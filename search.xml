<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[AIDL 原理分析]]></title>
      <url>http://www.timebridge.space/2017/10/30/AIDL-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[App 启动过程]]></title>
      <url>http://www.timebridge.space/2017/10/30/App-%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[PMS 解析]]></title>
      <url>http://www.timebridge.space/2017/10/29/PMS-%E8%A7%A3%E6%9E%90/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[WindowManagerService 解析]]></title>
      <url>http://www.timebridge.space/2017/10/29/WMS-%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>在另外一篇文章 <a href="http://timebridge.space/2016/09/21/Android-view-display/" target="_blank" rel="noopener">Android View 绘制过程</a> 中已经提到一个关于 Window 的概念了—— PhoneWindow，只不过这篇着重是从 PhoneWindow 往 View 方向讲，关于 PhoneWindow 本身关注的很少，这一篇就探究一下 Window 以及 WindowManagerService。</p>
<p>在 Android 里面，Window 是一个非常重要但其实平时开发又不常用的概念。大部分看到它时可能是我们要修改 Dialog 的样式的时候：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mDialog = <span class="keyword">new</span> Dialog(getActivity(), R.style.IsDelDialog);<span class="comment">//自定义的样式，没有贴出代码来</span></span><br><span class="line">mDialog.setContentView(view);</span><br><span class="line">mDialog.show();</span><br><span class="line">Window dialogWindow = mDialog.getWindow();</span><br><span class="line">WindowManager m = getActivity().getWindowManager();</span><br><span class="line">Display d = m.getDefaultDisplay(); <span class="comment">// 获取屏幕宽、高度</span></span><br><span class="line">WindowManager.LayoutParams p = dialogWindow.getAttributes(); <span class="comment">// 获取对话框当前的参数值</span></span><br><span class="line">        p.height = (<span class="keyword">int</span>) (d.getHeight() * <span class="number">0.8</span>); <span class="comment">// 高度设置为屏幕的0.6，根据实际情况调整</span></span><br><span class="line">p.width = (<span class="keyword">int</span>) (d.getWidth() * <span class="number">0.8</span>); <span class="comment">// 宽度设置为屏幕的0.65，根据实际情况调整</span></span><br><span class="line">dialogWindow.setAttributes(p);</span><br></pre></td></tr></table></figure>
<p>那么 Window 本质上到底是什么？为什么 Activity 的底层以及 Dialog 都与它相关？</p>
<h2 id="Window-概览"><a href="#Window-概览" class="headerlink" title="Window 概览"></a>Window 概览</h2><p>Window 的代码定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Abstract base class for a top-level window look and behavior policy.  An</span></span><br><span class="line"><span class="comment"> * instance of this class should be used as the top-level view added to the</span></span><br><span class="line"><span class="comment"> * window manager. It provides standard UI policies such as a background, title</span></span><br><span class="line"><span class="comment"> * area, default key processing, etc.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The only existing implementation of this abstract class is</span></span><br><span class="line"><span class="comment"> * android.view.PhoneWindow, which you should instantiate when needing a</span></span><br><span class="line"><span class="comment"> * Window.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从以上代码可以得出以下几个结论：</p>
<p>1）Window 负责一些标准的展示以及事件处理，最终的用法是添加到 WindowManager；</p>
<p>2）它是一个抽象类，并且只有一个实现类，就是 PhoneWindow；</p>
<p>关于 PhoneWindow 在做些啥，<a href="http://timebridge.space/2016/09/21/Android-view-display/" target="_blank" rel="noopener">Android View 绘制过程</a> 已经有讲述，我们去看看 WindowManager：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The interface that apps use to talk to the window manager.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Use &lt;code&gt;Context.getSystemService(Context.WINDOW_SERVICE)&lt;/code&gt; to get one of these.</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Each window manager instance is bound to a particular &#123;<span class="doctag">@link</span> Display&#125;.</span></span><br><span class="line"><span class="comment"> * To obtain a &#123;<span class="doctag">@link</span> WindowManager&#125; for a different display, use</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Context#createDisplayContext&#125; to obtain a &#123;<span class="doctag">@link</span> Context&#125; for that</span></span><br><span class="line"><span class="comment"> * display, then use &lt;code&gt;Context.getSystemService(Context.WINDOW_SERVICE)&lt;/code&gt;</span></span><br><span class="line"><span class="comment"> * to get the WindowManager.</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;&lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The simplest way to show a window on another display is to create a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Presentation&#125;.  The presentation will automatically obtain a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> WindowManager&#125; and &#123;<span class="doctag">@link</span> Context&#125; for that display.</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> android.content.Context#getSystemService</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> android.content.Context#WINDOW_SERVICE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WindowManager</span> <span class="keyword">extends</span> <span class="title">ViewManager</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WindowManager 可以通过 <code>getSystemService(Context.WINDOW_SERVICE)</code> 来获取，每一个 WindowMagaer 都被绑定到一个特性的 <code>Display</code> 实例。</p>
<blockquote>
<p>这里涉及到 Context 的解析，待补充。</p>
</blockquote>
<p><code>WindowManager</code>接口继承于<code>ViewManager</code>接口，这个接口只有三个简单的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateViewLayout</span><span class="params">(View view, ViewGroup.LayoutParams params)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeView</span><span class="params">(View view)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这三个方法代表了对 View 的基本操作，查看这个接口的实现，读者会发现除了 WindowManager，还有一个非常重要的实现类：ViewGroup。这似乎暗示了 WindowManager 和 ViewGroup 之间是有一些联系的。</p>
<h2 id="Dialog-与-Window"><a href="#Dialog-与-Window" class="headerlink" title="Dialog 与 Window"></a>Dialog 与 Window</h2><p>为了搞清楚 Window 相关概念的关系，我们选择从 Dialog 入手，看看 Window 是如何展示一个 Dialog 的。Dialog 的用法一般如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">AlertDialog ad = <span class="keyword">new</span> AlertDialog.Builder(MainActivity.<span class="keyword">this</span>).create();  </span><br><span class="line">ad.setTitle(<span class="string">"标题1"</span>);  </span><br><span class="line">ad.setIcon(R.drawable.ic_launcher);  </span><br><span class="line">ad.setMessage(<span class="string">"我是消息内容"</span>);  </span><br><span class="line">ad.setButton(<span class="string">"确定"</span>, <span class="keyword">new</span> DialogInterface.OnClickListener() &#123; </span><br><span class="line">	<span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123; </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);  </span><br><span class="line">ad.setButton2(<span class="string">"取消"</span>, <span class="keyword">new</span> DialogInterface.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;    </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);  </span><br><span class="line">ad.show();</span><br></pre></td></tr></table></figure>
<p>最关键的方法就是 <code>show()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mShowing) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mDecor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) &#123;</span><br><span class="line">                mWindow.invalidatePanelMenu(Window.FEATURE_ACTION_BAR);</span><br><span class="line">            &#125;</span><br><span class="line">            mDecor.setVisibility(View.VISIBLE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mCanceled = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!mCreated) &#123;</span><br><span class="line">        dispatchOnCreate(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onStart();</span><br><span class="line">    mDecor = mWindow.getDecorView(); <span class="comment">// mDecor 的来源</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mWindowManager.addView(mDecor, l);</span><br><span class="line">        mShowing = <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">        sendShowMessage();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终的展示是通过<code>mWindowManager.addView(mDecor, l);</code>来完成的，这一句到底做了啥呢？在这里我们可以看到一些熟悉的面孔：mWindow，mWindowManager，mDecor，首先我们来看看它们的来源。mDecor 是从 mWindow 中拿出来的，mWindow 呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Dialog(<span class="meta">@NonNull</span> Context context, <span class="meta">@StyleRes</span> <span class="keyword">int</span> themeResId, <span class="keyword">boolean</span> createContextThemeWrapper) &#123;</span><br><span class="line">    <span class="keyword">if</span> (createContextThemeWrapper) &#123;</span><br><span class="line">        <span class="keyword">if</span> (themeResId == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> TypedValue outValue = <span class="keyword">new</span> TypedValue();</span><br><span class="line">            context.getTheme().resolveAttribute(R.attr.dialogTheme, outValue, <span class="keyword">true</span>);</span><br><span class="line">            themeResId = outValue.resourceId;</span><br><span class="line">        &#125;</span><br><span class="line">        mContext = <span class="keyword">new</span> ContextThemeWrapper(context, themeResId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); <span class="comment">// mWindow </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Window w = <span class="keyword">new</span> PhoneWindow(mContext);</span><br><span class="line">    mWindow = w;</span><br><span class="line">    w.setCallback(<span class="keyword">this</span>);</span><br><span class="line">    w.setOnWindowDismissedCallback(<span class="keyword">this</span>);</span><br><span class="line">    w.setWindowManager(mWindowManager, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    w.setGravity(Gravity.CENTER);</span><br><span class="line"></span><br><span class="line">    mListenersHandler = <span class="keyword">new</span> ListenersHandler(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Dialog 的构造方法里面，这两个变量被实例化，首先是根据 context 获取 WindowManager，而 mWindow 实际就是 PhoneWindow 的实例。那么 <code>WindowManager</code> 又是如何添加 view 的呢，即 <code>mWindowManager.addView(mDecor, l);</code> 是如何运行的？</p>
<p>mWindowManager 的实现类是谁呢？它是通过 <code>context.getSystemService()</code>获取的，它的注册是在<code>android.app.SystemServiceRegistry#registerService</code>中进行的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">registerService(Context.WINDOW_SERVICE, WindowManager.class,</span><br><span class="line">                <span class="keyword">new</span> CachedServiceFetcher&lt;WindowManager&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> WindowManager <span class="title">createService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> WindowManagerImpl(ctx.getDisplay());</span><br><span class="line">&#125;&#125;);</span><br></pre></td></tr></table></figure>
<p>因此这里的实现类是<code>WindowManagerImpl</code>，并且在创建的时候是通过 context 获取到了 display。我们来看看类 <code>WindowManagerImpl</code> 的 <code>addView</code> 方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">     applyDefaultToken(params);</span><br><span class="line">     mGlobal.addView(view, params, mDisplay, mParentWindow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法被代理到了 <code>WindowManagerGlobal</code> 类里面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">            Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//... 参数检查 &amp; 调整</span></span><br><span class="line"></span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    View panelParentView = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// do this last because it fires off messages to start doing things</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        root.setView(view, wparams, panelParentView);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的核心方法被代理到了 <code>ViewRootImpl#setView()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * view 是前面 Window 的 decorView</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mView = view;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> res; <span class="comment">/* = WindowManagerImpl.ADD_OKAY; */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Schedule the first layout -before- adding to the window</span></span><br><span class="line">    <span class="comment">// manager, to make sure we do the relayout before receiving</span></span><br><span class="line">    <span class="comment">// any other events from the system.</span></span><br><span class="line">    requestLayout();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个方法用于添加展示，注意 mDisplay 就是 activity 的 display</span></span><br><span class="line">    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                            getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">                            mAttachInfo.mOutsets, mInputChannel);</span><br><span class="line">    ...                             </span><br><span class="line">    <span class="keyword">if</span> (res &lt; WindowManagerGlobal.ADD_OKAY) &#123;</span><br><span class="line">        mAttachInfo.mRootView = <span class="keyword">null</span>;</span><br><span class="line">        mAdded = <span class="keyword">false</span>;</span><br><span class="line">        mFallbackEventHandler.setView(<span class="keyword">null</span>);</span><br><span class="line">        unscheduleTraversals();</span><br><span class="line">        setAccessibilityFocus(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">switch</span> (res) &#123;</span><br><span class="line">            <span class="keyword">case</span> WindowManagerGlobal.ADD_BAD_APP_TOKEN:</span><br><span class="line">            <span class="keyword">case</span> WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> WindowManager.BadTokenException(</span><br><span class="line">                        <span class="string">"Unable to add window -- token "</span> + attrs.token</span><br><span class="line">                        + <span class="string">" is not valid; is your activity running?"</span>);</span><br><span class="line">            <span class="keyword">case</span> WindowManagerGlobal.ADD_NOT_APP_TOKEN:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> WindowManager.BadTokenException(</span><br><span class="line">                        <span class="string">"Unable to add window -- token "</span> + attrs.token</span><br><span class="line">                        + <span class="string">" is not for an application"</span>);   </span><br><span class="line">            .....</span><br><span class="line">          &#125;                          </span><br><span class="line">     ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再往下很重要的就是 mWindowSession 变量的来源了，它来自<code>WindowManagerGlobal#getWindowSession()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IWindowSession <span class="title">getWindowSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (WindowManagerGlobal.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sWindowSession == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                InputMethodManager imm = InputMethodManager.getInstance();</span><br><span class="line">                IWindowManager windowManager = getWindowManagerService();</span><br><span class="line">                sWindowSession = windowManager.openSession(</span><br><span class="line">                        <span class="keyword">new</span> IWindowSessionCallback.Stub() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimatorScaleChanged</span><span class="params">(<span class="keyword">float</span> scale)</span> </span>&#123;</span><br><span class="line">                                ValueAnimator.setDurationScale(scale);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        imm.getClient(), imm.getInputContext());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"Failed to open window session"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sWindowSession;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IWindowManager <span class="title">getWindowManagerService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (WindowManagerGlobal.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sWindowManagerService == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sWindowManagerService = IWindowManager.Stub.asInterface(</span><br><span class="line">                    ServiceManager.getService(<span class="string">"window"</span>));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sWindowManagerService = getWindowManagerService();</span><br><span class="line">                ValueAnimator.setDurationScale(sWindowManagerService.getCurrentAnimatorScale());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"Failed to get WindowManagerService, cannot set animator scale"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sWindowManagerService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再往下走就是<code>WindowManagerService</code> 相关的了。</p>
<h2 id="WindowManagerService"><a href="#WindowManagerService" class="headerlink" title="WindowManagerService"></a>WindowManagerService</h2>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[AMS 解析]]></title>
      <url>http://www.timebridge.space/2017/10/29/AMS-%E8%A7%A3%E6%9E%90/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[The-Good-Wife]]></title>
      <url>http://www.timebridge.space/2017/09/10/The-Good-Wife/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[黑帆]]></title>
      <url>http://www.timebridge.space/2017/09/10/Black-Sails/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://www.timebridge.space/2017/06/29/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[XCode 8.2.1 ClangFormat 插件安装]]></title>
      <url>http://www.timebridge.space/2017/03/23/XCode-8-2-1-ClangFormat-%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
      <content type="html"><![CDATA[<p>之前开发 Android ，Android Studio 有比较强大的 Format 工具，习惯性的写完代码顺手 Format 一下。然 XCode 本身并不支持 Format，需要手动调整，这让我痛苦无比而且觉得浪费时间，因此搜到了 <a href="https://github.com/travisjeffery/ClangFormat-Xcode" target="_blank" rel="noopener">ClangFormat-Xcode</a>。</p>
<p>本文主要记录安装过程，具体的使用教程可以参考：<a href="http://ios.jobbole.com/89104/" target="_blank" rel="noopener">超详细的Xcode代码格式化教程，可自定义样式</a>。</p>
<p>官网上提供了两种安装方式，一种是通过 Alcatraz 包管理工具，一种是 clone 代码下来到 XCode 中运行一下。这里使用第二种方法：<a id="more"></a></p>
<p>1）clone 项目，导入到 XCode 中运行；</p>
<p>2）之后可以在文件夹 <code>~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/</code> 下面发现一个文件 <strong>ClangFormat.xcplugin</strong>。这个文件夹下面存放的都是 XCode 上安装的插件，删除插件只要把这个目录下对应的插件文件删除即可；</p>
<p>3）在命令行执行命令：<code>sudo gem install update_xcode_plugins</code>；</p>
<p>4）在命令行执行命令：<code>update_xcode_plugins</code>，会看到如下的输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017</span>-<span class="number">03</span>-<span class="number">23</span> <span class="number">19</span>:<span class="number">49</span>:<span class="number">41.254</span> mdfind[<span class="number">15638</span>:<span class="number">271887</span>] Metadata.framework [Error]: couldn<span class="string">'t get the client port</span></span><br><span class="line"><span class="string">Found:</span></span><br><span class="line"><span class="string">- Xcode (8.2.1) [E0A62D1F-3C18-4D74-BFE5-A4167D643966]: /Applications/Xcode.app</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Plugins:</span></span><br><span class="line"><span class="string">- ClangFormat (1.0)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Updating...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Finished! 🎉</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">It seems that you have Xcode 8+ installed!</span></span><br><span class="line"><span class="string">Some plugins might not work on recent versions of Xcode because of library validation.</span></span><br><span class="line"><span class="string">See https://github.com/alcatraz/Alcatraz/issues/475</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Run `update_xcode_plugins --unsign` to fix this.</span></span><br></pre></td></tr></table></figure>
<p>这里会列出你安装的插件，并且提示你有些插件不能使用，建议执行命令：<code>update_xcode_plugins --unsign</code> 进行修复；</p>
<p>5）在命令行执行命令：<code>update_xcode_plugins --unsign</code>；</p>
<p>6）完全退出 XCode，重新打开，会有一个弹窗出现，警告你有 “Unexpected code bundles”，选择 <strong>Load Bundles</strong>。</p>
<p>之后在 Edit 菜单选项中就可以看到 Clang Format 选项了，安装完成！跟着前面推荐的文章配置吧。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SourceTree 分支图谱]]></title>
      <url>http://www.timebridge.space/2017/03/07/SourceTree-%E5%88%86%E6%94%AF%E5%9B%BE%E8%B0%B1/</url>
      <content type="html"><![CDATA[<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/sourcetree_rgb_blue.png" alt="分支查看" height="48"></div>

<p>用 <a href="https://www.sourcetreeapp.com/" target="_blank" rel="noopener">SourceTree</a> 一段时间了，一般用来做一下提交文件的 review，除此之外没怎么关注过其他功能。因为工作需要今天来看一下它的分支图谱功能：它用于展示一个 Git 仓库中分支的提交和操作情况。实际上 Git 本身就有这样的功能，执行命令<code>git log --graph --decorate --oneline --simplify-by-decoration --all</code>即可，或者使用 git 提供的图形化工具就好。那么 SourceTree 是怎么玩的呢？<a id="more"></a></p>
<p>初始分支情况如下：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/分支查看-1.png" alt="分支查看"></div>

<p>如上图，显示的是所有分支的提交情况，是经过以下提交记录之后的图谱：</p>
<p>1）新建仓库，在 <code>master</code> 上提交 <code>master_a</code>、<code>master_b</code>记录；</p>
<p>2）切出 <code>branchA</code> 分支，并提交 <code>branchA_c</code>记录；</p>
<p>3）切到 <code>master</code> 分支，提交 <code>master_d</code>记录；</p>
<p>4）切出 <code>branchB</code> 分支，提交 <code>branchB_e</code> 记录；</p>
<p>5）切到 <code>branchA</code> 分支，提交 <code>branchA_f</code> 记录；</p>
<p>6）切到 <code>master</code> 分支，提交 <code>master_g</code> 记录；</p>
<p>提交记录以 <strong>分支名 + 下划线 + 顺序字母</strong> 来表示，可以看出具体提交在哪个分支上以及提交的顺序。</p>
<p>把分支切到 <code>branchB</code>：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/分支查看-2.png" alt="分支查看"></div>

<p>可以看到整个图谱线条并没有变化，只是高亮点从原先 <code>master_g</code> 记录切换到了 <code>branchB_e</code> 记录。</p>
<p>把分支切换到分支 <code>branchB</code>，并提交记录 <code>branchB_g</code>：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/分支查看-3.png" alt="分支查看"></div>

<p>图谱变化，高亮点又回到最左边竖线的顶部。由此可见：<strong>整个图谱的点从下往上是按照提交记录的时间来排列的，最左边的线代表着最近有活动的分支</strong>。</p>
<p>在 <code>master</code> 分支上对 <code>branchA</code> 执行 merge 操作：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/分支查看-4.png" alt="分支查看"></div>

<p>这里有两点变化：</p>
<ol>
<li>因为是在 <code>master</code> 分支上执行的操作，因此最近有变化的分支就变成 <code>master</code>，最左边的线自然变成 <code>master</code> 分支，这也印证了前面的结论；</li>
<li>粉红色的线并入 <code>master</code> 分支，但是标记有 <code>branchA</code> 的粉红色色块并没有和标记有 <code>master</code> 的蓝色色块放到一块去；</li>
</ol>
<p>切到 <code>branchA</code> 分支，提交 <code>branchA_i</code> 记录：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/分支查看-5.png" alt="分支查看"></div>

<p>首先最左边变成了分支 <code>branchA</code>，其次 <code>branchA</code> 分支的线分叉了，一部分连接到最顶部的高亮点，一部分连接到表示 <code>master</code> 分支的粉色线，这也符合我们之前的操作记录。</p>
<p>切到 <code>master</code> 分支，并提交 <code>master_j</code> 操作：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/分支查看-7.png" alt="分支查看"></div>

<p><code>master</code> 分支又跑到了最左边，能清晰的看到如下变化：<code>branchA</code> （粉色线）在记录 <code>branchA_f</code> 之后合并了一次到 <code>master</code> 分支，之后继续提交了 <code>branchA_i</code> 记录。</p>
<p>切到 <code>branchB</code>，对 <code>master</code> 分支执行 rebase 操作：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/分支查看-8.png" alt="分支查看"></div>

<p>可以看到此时黄色的线消失了，似乎只有两个分支了，但实际不是。注意看最左边的线，此时变成了 <code>branchB</code>，<code>master</code> 分支也在这条线上，注意看灰色那行。</p>
<p>切到 <code>master</code>  分支，切出新的分支 <code>branchC</code>、<code>branchD</code>：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/分支查看-9.png" alt="分支查看"></div>

<p>可以看到灰色那行，原先代表 <code>master</code> 分支的最新节点，右边只有一个标有 <code>master</code> 的蓝色色块，现在有三个色块了，加了 <code>branchC</code>、<code>branchD</code> 两个。</p>
<p>针对 <strong>全部分支</strong> 总结一下：</p>
<ol>
<li>每一条线代表一个分支，分支上的点代表着一次提交，最新的提交记录右侧会带有一个色块，标记这条线代表哪个分支，有时候一个点会代表多个分支，因此会有多个色块；</li>
<li>整个图谱的点从下往上是按照提交记录的时间来排列的，最左边的线代表着最近有活动的分支；</li>
<li>线交汇代表分支合并，分叉代表切出新分支；</li>
</ol>
<p>以上基本就是看懂分支图谱所需要的知识。除了”全部分支” 视图，还可以任意切换到某个分支，查看这个分支的视图，两种视图唯一的不同就是分支视图下最左边的线代表选中的分支（其实也是最近有活动的分支，只不过上下文不一样）。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS 网络学习（一）—— URLConnection]]></title>
      <url>http://www.timebridge.space/2017/02/15/iOS-%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<blockquote>
<p>关于 Http 相关知识，推荐书籍：《HTTP : The Definitive Guide》。</p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://developer.apple.com/reference/foundation/nsurlconnection" target="_blank" rel="noopener"><code>NSURLConnection</code></a> 用于向服务端发起网络请求，它暴露的接口非常少，只能控制发起和取消请求，大部分的配置是在 <code>NSURLRequest</code> 上进行。我们平时所说的 NSURLConnection 更多的是指以 <code>NSURLConnection</code> 类为核心的一套网络请求解决方案，它包括：</p>
<ol>
<li><a href="https://developer.apple.com/reference/foundation/nsurl" target="_blank" rel="noopener">NSURL</a>：请求地址；</li>
<li><a href="https://developer.apple.com/reference/foundation/nsurlrequest" target="_blank" rel="noopener">NSURLRequest</a>：封装一个请求，保存发给服务器的全部数据，包括一个NSURL对象，请求方法、请求头、请求体等；</li>
<li><a href="https://developer.apple.com/reference/foundation/NSMutableURLRequest" target="_blank" rel="noopener">NSMutableURLRequest</a>：NSURLRequest的子类；</li>
<li><a href="https://developer.apple.com/reference/foundation/nsurlconnection" target="_blank" rel="noopener">NSURLConnection</a>：负责发送请求，建立客户端和服务器的连接。发送NSURLRequest的数据给服务器，并收集来自服务器的响应数据；</li>
</ol>
<a id="more"></a>NSURLConnection 的学习比较简单，核心包括两块：<br><br>1. 同步 / 异步请求；<br>2. 使用 Block / Delegate 接收返回数据；<br><br>下面围绕这两个点进行学习，并补充一些常见的设置和相关知识。<br><br>&gt; 这里推荐一个网站，用于快速实验网络功能：<a href="http://httpbin.org/。这个网站列举了很多开放的接口，开发者可以通过调用这些接口来测试自己的网络请求，非常方便。比如请求接口" target="_blank" rel="noopener">http://httpbin.org/。这个网站列举了很多开放的接口，开发者可以通过调用这些接口来测试自己的网络请求，非常方便。比如请求接口</a> <a href="http://httpbin.org/ip，返回的数据就是：" target="_blank" rel="noopener">http://httpbin.org/ip，返回的数据就是：</a><br>&gt;<br>&gt; <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123;</span><br><span class="line">&gt;   "origin": "103.39.140.10"</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<h2 id="同步-异步请求"><a href="#同步-异步请求" class="headerlink" title="同步 / 异步请求"></a>同步 / 异步请求</h2><p>NSURLConnection 同时支持同步和异步请求的发送，但实际使用中，我们大部分情况下都是使用异步请求，因此下面的例子先从异步请求开始。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">NSURL *url = [NSURL URLWithString:@&quot;协议://主机地址/路径?参数&amp;参数&quot;];</span><br><span class="line">NSURLRequest *request = [NSURLRequest requestWithURL:url cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:15.0];</span><br><span class="line">// 告诉服务器数据为json类型</span><br><span class="line">[request setValue:@&quot;application/json&quot; forHTTPHeaderField:@&quot;Content-Type&quot;]; </span><br><span class="line">// 设置请求体(json类型)</span><br><span class="line">NSData *jsonData = [NSJSONSerialization dataWithJSONObject:@&#123;@&quot;userid&quot;:@&quot;123456&quot;&#125; options:NSJSONWritingPrettyPrinted error:nil];</span><br><span class="line">request.HTTPBody = jsonData; </span><br><span class="line">[NSURLConnection sendAsynchronousRequest:request queue:[[NSOperationQueue alloc] init] completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) &#123;</span><br><span class="line">    // 有的时候，服务器访问正常，但是会没有数据！</span><br><span class="line">    // 以下的 if 是比较标准的错误 处理代码！</span><br><span class="line">    if (connectionError != nil || data == nil) &#123;</span><br><span class="line">        //给用户的提示信息</span><br><span class="line">        NSLog(@&quot;网络不给力&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p><code>NSURL</code> 用于指向一个资源地址，在这里我们指向的是服务器端的资源。关于代码中给出的格式，如有不懂可以直接参考<a href="https://developer.apple.com/reference/foundation/nsurl" target="_blank" rel="noopener">开发文档</a> 或者翻阅本文开头推荐的书籍。它的常见用法就是通过一个表达 url 的 <code>NSString</code> 生成 <code>NSURL</code> 对象，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSURL *url = [NSURL URLWithString:@&quot;http://httpbin.org/ip&quot;];</span><br></pre></td></tr></table></figure>
<p>接着，可以使用 <code>NSURL</code> 生成基本的 <code>NSURLRequest</code> 对象，<code>NSURL</code> 定义的是资源的地址，<code>NSURLRequest</code> 顾名思义，定义的就是一个完整的网络请求。<code>NSURLRequest</code> 的实例化基本分为两种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ requestWithURL:</span><br><span class="line">+ requestWithURL:cachePolicy:timeoutInterval:</span><br></pre></td></tr></table></figure>
<p>一种是只需要提供 <code>NSURL</code> 即可，其余的配置全部默认。另外一种是可以配置缓存策略以及超时时间。但是无论哪种方式，我们可以发现能配置的项实在太少，至少我们有一些常见的需求这样是无法满足的，比如更改请求方法为 POST 请求，添加请求 Header 等。因此很自然地就出现了 <code>NSMutableURLRequest</code> 类，该类提供了较为丰富的配置选项。就像例子中看到的一样，还可以设置消息体。</p>
<p>这里我们重点提一下缓存策略，即<code>cachePolicy</code>参数。这个参数是一个枚举类型——<a href="https://developer.apple.com/reference/foundation/NSURLRequestCachePolicy" target="_blank" rel="noopener"><code>NSURLRequestCachePolicy</code></a>，它的取值是根据 Http 定义的缓存协议来的，具体可以查询本文开头推荐的书籍，或者翻看 <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13" target="_blank" rel="noopener">RFC2616</a>，因为这个点可以专门开一篇文章进行描述，这里就不展开了。Http 缓存机制可以满足以下的逻辑路径：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/http_caching.png" height="420" alt="One Piece"></div>

<p>该枚举有以下值可以选择：</p>
<ol>
<li><code>NSURLRequestUseProtocolCachePolicy</code> 表示使用协议定义的标准缓存逻辑，它是请求默认使用的缓存协议。</li>
<li><code>[NSURLRequestReloadIgnoringLocalCacheData]</code> 表示忽略本地缓存，从源地址加载资源。如果使用的是 Http/Https 协议并请求的是资源的部分数据，务必使用该选项；</li>
<li><code>NSURLRequestReloadIgnoringLocalAndRemoteCacheData</code> 表示不仅忽略本地缓存，也要忽略任何中间节点的缓存，必须从源地址加载数据；</li>
<li><code>NSURLRequestReloadRevalidatingCacheData</code> 表示在使用缓存之前必须由服务端验证缓存是否过期，如果没有过期则使用缓存，否则从服务端拉取最新数据（对应到上图中，走的是 <strong>Issue a HEAD request</strong> 路径）；</li>
</ol>
<p>请求定义好之后，就可以通过<code>NSURLConnection</code>来发送请求了。发送请求有两个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ sendSynchronousRequest:returningResponse:error:  // 发送同步请求</span><br><span class="line">+ sendAsynchronousRequest:queue:completionHandler:  // 发送异步请求</span><br></pre></td></tr></table></figure>
<p>读者如果这个时候去查看<a href="https://developer.apple.com/reference/foundation/nsurlconnection?language=objc" target="_blank" rel="noopener">开发文档</a>，会发现这两个方法已经被废弃了，这是因为 Apple 发布了更为优秀的请求工具 <code>NSURLSession</code>，不再推荐使用<code>NSURLConnection</code>，然而因为某些库或者遗留代码还在使用 <code>NSURLConnection</code>，所以我们在这里学习一下。</p>
<p>例子中使用的是异步方法，异步方法需要设置回调来进行监听数据的接收处理，iOS 一般使用 Block 或者 Delegate 来实现回调，<code>NSURLConnection</code>两种都支持，例子中使用的是 Block。两者的区别下面再说。</p>
<p>使用同步方法的例子如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 发送同步请求, data 就是返回的数据</span><br><span class="line">NSError *error = nil;</span><br><span class="line">NSData *data = [NSURLConnection sendSynchronousRequest:request returningResponse:nil error:&amp;error];</span><br></pre></td></tr></table></figure>
<p>如果返回值为 nil，则表示连接创建失败，或者数据加载失败，简而言之，请求失败。使用同步请求会阻塞当前调用线程，所以不建议在 UI 线程调用。</p>
<h2 id="使用-Block-Delegate-接收返回数据"><a href="#使用-Block-Delegate-接收返回数据" class="headerlink" title="使用 Block / Delegate 接收返回数据"></a>使用 Block / Delegate 接收返回数据</h2><p>上一节的例子中已经展示如何使用 Block 接收数据，Block 作为回调的缺陷是只能在请求结束后对返回数据进行操作，如果遇到像 <a href="http://timebridge.space/2017/02/10/SDWebImage-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">SDWebImage</a> 库那样的需求，需要在数据加载开始和加载中进行处理，Block 就不能胜任，此时需要使用 Delegate。使用 Delegate 需要实现协议 <code>NSURLConnectionDataDelegate</code>，这个协议继承于<code>NSURLConnectionDelegate</code>协议并添加了七个新的接口，涉及到数据加载不同阶段、重定向、缓存等方面，其中四个比较常用的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark- NSURLConnectionDataDelegate代理方法</span><br><span class="line"></span><br><span class="line">//当接收到服务器的响应（连通了服务器）时会调用</span><br><span class="line">-(void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response</span><br><span class="line"></span><br><span class="line">//当接收到服务器的数据时会调用（可能会被调用多次，每次只传递部分数据）</span><br><span class="line">-(void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data</span><br><span class="line"></span><br><span class="line">//当服务器的数据加载完毕时就会调用</span><br><span class="line">-(void)connectionDidFinishLoading:(NSURLConnection *)connection</span><br><span class="line"></span><br><span class="line">//请求错误（失败）的时候调用（请求超时\断网\没有网\，一般指客户端错误）</span><br><span class="line">-(void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error</span><br></pre></td></tr></table></figure>
<p>实现之后，代理的设置和请求发送用法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSURLConnection *conn = [NSURLConnection connectionWithRequest:request delegate:self];</span><br><span class="line">[conn start];</span><br></pre></td></tr></table></figure>
<p>下面是一个使用 Delegate 下载文件的例子，以供读者参考：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">-(void)sendAFNetworingRequest:(id)button&#123;</span><br><span class="line">    NSURL *url = [NSURL URLWithString:@&quot;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1487163449810&amp;di=c69d81b7530c246d5d3ab7c157f5463c&amp;imgtype=0&amp;src=http%3A%2F%2Fimg2.78dm.net%2Fforum%2F201409%2F14%2F144254ed19ejda61z5aw5n.jpg&quot;];</span><br><span class="line">    NSURLRequest *request = [NSURLRequest requestWithURL:url cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:15.0];</span><br><span class="line">    NSURLConnection *conn = [NSURLConnection connectionWithRequest:request delegate:self];</span><br><span class="line">    [conn start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(NSString *)getDownloadFilePath &#123;</span><br><span class="line">    NSString *path = NSTemporaryDirectory();</span><br><span class="line">    return [path stringByAppendingString:@&quot;onepiece.jpeg&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response &#123;</span><br><span class="line">    NSLog(@&quot;下载开始&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data &#123;</span><br><span class="line">    NSFileHandle *fileHandle = [NSFileHandle fileHandleForWritingAtPath:self.downloadFilePath];</span><br><span class="line">    fileSize += (unsigned long)data.length;</span><br><span class="line">    NSLog(@&quot;数据下载中，新接收数据量：%lu&quot;, (unsigned long)data.length);</span><br><span class="line">    if (fileHandle) &#123;</span><br><span class="line">        [fileHandle seekToEndOfFile];</span><br><span class="line">        [fileHandle writeData:data];</span><br><span class="line">        [fileHandle closeFile];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [data writeToFile:self.downloadFilePath atomically:YES];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)connectionDidFinishLoading:(NSURLConnection *)connection &#123;</span><br><span class="line">    NSLog(@&quot;下载完成，总数据量：%lu&quot;, fileSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下载的资源是百度上的一张图片，大小显示为 158 KB，下面是控制台输出：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">2017-02-15 18:14:47.632 MyP[47339:12735852] 下载开始</span><br><span class="line">2017-02-15 18:14:47.633 MyP[47339:12735852] 数据下载中，新接收数据量：18413</span><br><span class="line">2017-02-15 18:14:47.944 MyP[47339:12735852] 数据下载中，新接收数据量：1336</span><br><span class="line">2017-02-15 18:14:47.944 MyP[47339:12735852] 数据下载中，新接收数据量：6856</span><br><span class="line">2017-02-15 18:14:48.246 MyP[47339:12735852] 数据下载中，新接收数据量：9624</span><br><span class="line">2017-02-15 18:14:48.246 MyP[47339:12735852] 数据下载中，新接收数据量：36864</span><br><span class="line">2017-02-15 18:14:48.400 MyP[47339:12735852] 数据下载中，新接收数据量：1328</span><br><span class="line">2017-02-15 18:14:48.401 MyP[47339:12735852] 数据下载中，新接收数据量：13624</span><br><span class="line">2017-02-15 18:14:48.453 MyP[47339:12735852] 数据下载中，新接收数据量：1336</span><br><span class="line">2017-02-15 18:14:48.459 MyP[47339:12735852] 数据下载中，新接收数据量：96</span><br><span class="line">2017-02-15 18:14:48.463 MyP[47339:12735852] 数据下载中，新接收数据量：23144</span><br><span class="line">2017-02-15 18:14:48.473 MyP[47339:12735852] 数据下载中，新接收数据量：1336</span><br><span class="line">2017-02-15 18:14:48.474 MyP[47339:12735852] 数据下载中，新接收数据量：96</span><br><span class="line">2017-02-15 18:14:48.476 MyP[47339:12735852] 数据下载中，新接收数据量：2664</span><br><span class="line">2017-02-15 18:14:48.790 MyP[47339:12735852] 数据下载中，新接收数据量：1432</span><br><span class="line">2017-02-15 18:14:49.355 MyP[47339:12735852] 数据下载中，新接收数据量：23144</span><br><span class="line">2017-02-15 18:14:49.589 MyP[47339:12735852] 数据下载中，新接收数据量：1432</span><br><span class="line">2017-02-15 18:14:49.609 MyP[47339:12735852] 数据下载中，新接收数据量：1328</span><br><span class="line">2017-02-15 18:14:49.609 MyP[47339:12735852] 数据下载中，新接收数据量：13528</span><br><span class="line">2017-02-15 18:14:49.610 MyP[47339:12735852] 下载完成，总数据量：157581</span><br></pre></td></tr></table></figure>
<p>从这个例子还可以看出使用 Delegate 的另外一个好处：因为可以持续处理数据而不用等到数据全部加载完成后再处理，因此可以避免将加载的资源全部保存在内存中，可以将数据持续同步到磁盘上，这是 Block 无法做到的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是关于 NSURLConnction 的一些基本知识。</p>
<p>在 2013 年苹果全球开发者大会（WWDC 2013）上 Apple 发布了新的网络请求类 NSURLSession，从 iOS9.0 开始，NSURLConnection 发送请求的两个方法以及初始化网络连接的方法都被置为过期，Apple 推荐使用 NSURLSession 类来替代 NSURLConnection，这意味着 NSURLConnection 即将推出历史舞台。</p>
<p>下一篇我们将学习 NSURLSession。</p>
<p>【参考文章】</p>
<p>1）<a href="http://www.cnblogs.com/wendingding/p/3813572.html" target="_blank" rel="noopener">iOS开发网络篇—NSURLConnection基本使用</a></p>
<p>2）<a href="http://www.cnblogs.com/mddblog/p/5134783.html" target="_blank" rel="noopener">iOS网络1——NSURLConnection使用详解</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS 网络学习（二）—— NSURLSession]]></title>
      <url>http://www.timebridge.space/2017/02/15/iOS-%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>2013 年 WWDC 上，Apple 发布了 NSURLConnection 的继任者 <a href="https://developer.apple.com/reference/foundation/urlsession" target="_blank" rel="noopener">NSURLSession</a>，支持 iOS7.0+，而 NSURLCOnnection 在 iOS9 被宣布弃用。</p>
<h2 id="URL-加载系统"><a href="#URL-加载系统" class="headerlink" title="URL 加载系统"></a>URL 加载系统</h2><p>在学习 NSURLSession 之前，有必要先了解一下 URL 加载系统（URL Loading System）。</p>
<blockquote>
<p>这个系统本来应该在 <a href="http://timebridge.space/2017/02/15/iOS-%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="noopener">iOS 网络学习（一）—— URLConnection</a> 提及，但 NSURLConnection 本身比较简单，而且已经被废弃，NSURLSession 将会是后面网络请求的核心，因此在这里系统了解一下。</p>
</blockquote>
<p>URL 加载系统，顾名思义就是根据 URL 从某个地方加载资源，这个“加载”是广义的，既包括从服务端下载资源，也包括上传资源。它支持 http、https、ftp、file、data 资源传输协议以及自定义扩充协议，由一组辅助类以及 Protocol 组成，主要分为五个部分：<a id="more"></a></p>
<ol>
<li>配置管理</li>
<li>缓存管理</li>
<li>cookie 存储</li>
<li>认证和证书</li>
<li>自定义协议支持</li>
</ol>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/NSURLSession-Family.png" height="320" alt="One Piece"></div>

<p>实际上我们平时所说的 NSURLSession 指的就是上面一组类，而并不单单是指 NSURLSession 类本身，下面我们通过对 NSURLSession 用法的学习来了解一下这五个部分。</p>
<blockquote>
<p>图中将 NSURLConnection 也列在其中，它也属于 URL 加载系统的一部分。</p>
</blockquote>
<h2 id="使用-NSURLSession"><a href="#使用-NSURLSession" class="headerlink" title="使用 NSURLSession"></a>使用 NSURLSession</h2><p>NSURLSession 以及相关类为 Http 请求提供了相关接口，为了使用 NSURLSession，需要我们创建一组 session 对象，每一个 session 对象负责执行一组数据传输任务。举个栗子，如果你在开发一个网页浏览器，你可能会为每一个 Tab 或者 Window 创建一个 session，每个 session 会负责一组传输任务，每个任务代表着对一个特定 URL 指向的资源的请求。</p>
<p>和 NSURLConnection 一样，NSURLSession 可以通过 Block 或者 Delegate 来接收处理请求返回的结果数据。Block 被设计为 Delegate 的替换选择，如果一个任务设置了 Block，那么 Delegate 就不会被回调。除此之外，NSURLSession 还提供了取消、暂停、唤醒任务的接口。</p>
<h3 id="URL-Session-相关概念"><a href="#URL-Session-相关概念" class="headerlink" title="URL Session 相关概念"></a>URL Session 相关概念</h3><p>session 中任务的行为取决于三个因素：1）session 的类型（取决于创建时候的配置）；2）任务的类型；3）任务创建的时候应用是否处于前台。</p>
<h4 id="session-类型"><a href="#session-类型" class="headerlink" title="session 类型"></a>session 类型</h4><p>NSURLSession 支持三种类型的 session，由创建时候的配置决定：</p>
<ul>
<li><strong>Default Session</strong> 默认 session 与 Foundation 中其他下载 URL 资源的方法类似，使用基于磁盘的缓存，并将证书存储在 keychain 中；</li>
<li><strong>Ephemeral Session</strong> 这种类型的 session 不会在磁盘上存储任何类型的数据，所有的缓存、证书存储以及其他数据都会被保存在内存中，仅限于当前 session 可用，因此当你的应用关闭这个 session，相关数据会自动被清除；</li>
<li><strong>Background Session</strong> 和 Default Session 类似，但是它是在独立的进程中进行数据传输的，并且还有一些额外的限制，后面会细说。</li>
</ul>
<h4 id="任务类型"><a href="#任务类型" class="headerlink" title="任务类型"></a>任务类型</h4><p>在一个 session 里面，NSURLSession 支持三种类型的任务：数据任务，下载任务和上传任务。</p>
<ul>
<li><strong>数据任务</strong> 使用 NSData 发送和接受数据，适用于比较信息量较少的服务端请求，数据任务可以将服务端返回的数据分批交给应用，又或者在全部接收完成之后通过 Block 一次性返回；</li>
<li><strong>下载任务</strong> 以文件形式接收数据，并且支持当 App 不运行的时候后台下载；</li>
<li><strong>上传任务</strong> 以文件形式发送数据，并且支持当 App 不运行的时候后台上传；</li>
</ul>
<h4 id="后台数据传输考量"><a href="#后台数据传输考量" class="headerlink" title="后台数据传输考量"></a>后台数据传输考量</h4><p>NSURLSession 支持当应用挂起的时候在后台进行数据传输，后台传输仅在使用 Background Session 配置的时候起作用。由于使用 Background Session 的时候下载任务是在独立的进程中进行的，且重启你的 App 有比较大的代价，因此使用这种模式有一些限制：</p>
<p>// TODO</p>
<h4 id="生命周期和-Delegate-交互"><a href="#生命周期和-Delegate-交互" class="headerlink" title="生命周期和 Delegate 交互"></a>生命周期和 Delegate 交互</h4><p>理解这个点取决于你使用 NSURLSession 类来干什么，有可能需要理解 session 生命周期，包括 session 如何与delegate 交互， delegate 接口的调用顺序，服务端重定向资源后会发生什么，当 App 重启一个失败的下载后会发生什么，等等。后面会详述。</p>
<h4 id="NSCoping-行为"><a href="#NSCoping-行为" class="headerlink" title="NSCoping 行为"></a>NSCoping 行为</h4><p>Session 和任务对象遵从 NSCopying 协议，并有如下实现：</p>
<ul>
<li>拷贝 session 和任务对象，会得到相同的对象；</li>
<li>拷贝配置对象，会得到新的对象，可以独立修改；</li>
</ul>
<h3 id="创建并配置-Session"><a href="#创建并配置-Session" class="headerlink" title="创建并配置 Session"></a>创建并配置 Session</h3><p>NSURLSession 提供了丰富的配置项：</p>
<ul>
<li>单个 session 特有的存储配置，包括缓存、cookie、证书，以及协议；</li>
<li>绑定到单个任务或者 session 的身份认证信息；</li>
<li>上传和下载任务，并支持分离数据（文件内容）和元数据（URL 和 设置）；</li>
<li>配置到每个 Host 的最大连接数；</li>
<li>如果整个资源不能在某个时间内被下载下来，那么每个组成资源都会被处罚超时；</li>
<li>支持的 TLS 版本范围设置；</li>
<li>自定义代理字典；</li>
<li>缓存策略；</li>
<li>Http 管道行为控制；</li>
</ul>
<p>因为大部分的配置项都包含在一个单独的配置配置项中，开发者可以重用通用的设置，当一个 session 对象被初始化之后，需要完成：</p>
<ul>
<li>一个控制 session 和 session 内任务行为的配置独享；</li>
<li>一个用于处理加载数据和事件的 delegate，进行服务端身份认证，决定一个资源加载是否需要被转化为下载等工作，这是可选的；</li>
</ul>
<p>如果开发者不提供自定义 delegate， NSURLSession 会使用系统提供的 delegate。但是如果你要进行后台数据传输任务，就必须提供一个自定义的 delegate。</p>
<p>当一个 session 初始化完毕之后，开发者就无法再更改配置对象或者代理了，除非创建一个新的 session。</p>
<p>下面代码展示了如何三种类型的 session：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// Creating session configurations</span><br><span class="line">NSURLSessionConfiguration *defaultConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration];</span><br><span class="line">NSURLSessionConfiguration *ephemeralConfiguration = [NSURLSessionConfiguration ephemeralSessionConfiguration];</span><br><span class="line">NSURLSessionConfiguration *backgroundConfiguration = [NSURLSessionConfiguration backgroundSessionConfigurationWithIdentifier: @&quot;com.myapp.networking.background&quot;];</span><br><span class="line"> </span><br><span class="line">// Configuring caching behavior for the default session</span><br><span class="line">NSString *cachesDirectory = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES).firstObject;</span><br><span class="line">NSString *cachePath = [cachesDirectory stringByAppendingPathComponent:@&quot;MyCache&quot;];</span><br><span class="line"> </span><br><span class="line">/* Note:</span><br><span class="line"> iOS requires the cache path to be</span><br><span class="line"> a path relative to the ~/Library/Caches directory,</span><br><span class="line"> but OS X expects an absolute path.</span><br><span class="line"> */</span><br><span class="line">#if TARGET_OS_OSX</span><br><span class="line">cachePath = [cachePath stringByStandardizingPath];</span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">NSURLCache *cache = [[NSURLCache alloc] initWithMemoryCapacity:16384 diskCapacity:268435456 diskPath:cachePath];</span><br><span class="line">defaultConfiguration.URLCache = cache;</span><br><span class="line">defaultConfiguration.requestCachePolicy = NSURLRequestUseProtocolCachePolicy;</span><br><span class="line"> </span><br><span class="line">// Creating sessions</span><br><span class="line">id &lt;NSURLSessionDelegate&gt; delegate = [[MySessionDelegate alloc] init];</span><br><span class="line">NSOperationQueue *operationQueue = [NSOperationQueue mainQueue];</span><br><span class="line"> </span><br><span class="line">NSURLSession *defaultSession = [NSURLSession sessionWithConfiguration:defaultConfiguration delegate:delegate operationQueue:operationQueue];</span><br><span class="line">NSURLSession *ephemeralSession = [NSURLSession sessionWithConfiguration:ephemeralConfiguration delegate:delegate delegateQueue:operationQueue];</span><br><span class="line">NSURLSession *backgroundSession = [NSURLSession sessionWithConfiguration:backgroundConfiguration delegate:delegate delegateQueue:operationQueue];</span><br></pre></td></tr></table></figure>
<p>除了 Background Session 的配置，开发者可以复用配置对象创建任意的 session（Background session 的配置对象之所以不能复用，是因为如果两个 Background Session 的 identifier 一样，会发生不可预知的行为）。</p>
<p>开发者介意在任何时候修改配置，因为当你创建一个 session 的时候，配置对象就会被深度拷贝，因此修改配置不会影响已经创建的 session。举个栗子，你或许会创建新的 session，并要求只能在链接 wifi 的情况下下载资源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ephemeralConfiguration.allowsCellularAccess = NO;</span><br><span class="line">NSURLSession *ephemeralSessionWiFiOnly = [NSURLSession sessionWithConfiguration:ephemeralConfiguration delegate:delegate delegateQueue:operationQueue];</span><br></pre></td></tr></table></figure>
<h3 id="使用系统提供的-Delegate-拉取资源"><a href="#使用系统提供的-Delegate-拉取资源" class="headerlink" title="使用系统提供的 Delegate 拉取资源"></a>使用系统提供的 Delegate 拉取资源</h3><p>使用 NSURLSession 最直接的方法就是使用系统提供的 Delegate 来请求资源，开发者只需要提供两段代码来实现这种方式的使用：</p>
<ul>
<li>一段代码创建配置对象以及基于配置对象的 session；</li>
<li>在数据全部接收完成后处理数据的 Block；</li>
</ul>
<p>使用系统提供的 Delegate，每个资源请求只需要一行代码就可以搞定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSURLSession *sessionWithoutADelegate = [NSURLSession sessionWithConfiguration:defaultConfiguration];</span><br><span class="line">NSURL *url = [NSURL URLWithString:@&quot;https://www.example.com/&quot;];</span><br><span class="line"> </span><br><span class="line">[[sessionWithoutADelegate dataTaskWithURL:url completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) &#123;</span><br><span class="line">    NSLog(@&quot;Got response %@ with error %@.\n&quot;, response, error);</span><br><span class="line">    NSLog(@&quot;DATA:\n%@\nEND DATA\n&quot;, [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];</span><br><span class="line">&#125;] resume];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>系统提供的 delegate 只定义了有限的网络行为，如果 App 有特殊的需要，比如自定义的认证或者后台下载，这种方式是不合适的。</p>
</blockquote>
<h3 id="使用自定义的-Delegate-拉取数据"><a href="#使用自定义的-Delegate-拉取数据" class="headerlink" title="使用自定义的 Delegate 拉取数据"></a>使用自定义的 Delegate 拉取数据</h3><p>如果你使用自定义的 Delegate 拉取数据，Delegate 必须实现至少如下两个方法：</p>
<ul>
<li><code>URLSession:dataTask:didReceiveData:</code> 会分批吐出服务端返回的数据。</li>
<li><code>URLSession:task:didCompleteWithError:</code> 会告诉 App 数据全部接收完毕。</li>
</ul>
<p>这种情况下，如果 App 需要使用完整的数据，就需要自己存储数据。举个栗子，网页浏览器可能需要渲染当前接收到的数据和之前接收到的数据，因此，它可能需要 <code>appendData:</code> 来不停的将新收到的数据保存下来。</p>
<p>下面的代码展示了如何创建和启动一个数据任务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSURL *url = [NSURL URLWithString: @&quot;https://www.example.com/&quot;];</span><br><span class="line">NSURLSessionDataTask *dataTask = [defaultSession dataTaskWithURL:url];</span><br><span class="line">[dataTask resume];</span><br></pre></td></tr></table></figure>
<h3 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h3><p>文件下载其实和拉取数据类似，使用的时候应该要实现以下 deleggate 方法：</p>
<ul>
<li><p><code>URLSession:downloadTask:didFinishDownloadingToURL:</code> 告知 App 指向下载内容临时存储文件的 URL；</p>
<blockquote>
<p>这个方法返回之前，它必须打开文件读取其中的数据或者将文件移动到一个永久的地址，因为当这个方法返回后，临时文件就会被删除。</p>
</blockquote>
</li>
<li><p><code>URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:</code> 告知 App 下载进度；</p>
</li>
<li><p><code>URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:</code> 告知 App 它成功重启了一个失败的下载；</p>
</li>
<li><p><code>URLSession:task:didCompleteWithError:</code> 告知 App 下载失败了；</p>
</li>
</ul>
<p>如果你在一个 Background Session 中调度下载任务，即使 App 不运行了，下载任务依然会运行；如果是在 Default / Ephemeral Session 中调度下载任务，应用重启之后必须重新开启下载任务。</p>
<p>当从服务端拉取数据的时候，如果用户选择暂停下载，App 可以通过调用<code>cancelByProducingResumeData:</code> 方法来取消任务，之后，App 可以通过将已经下载的数据传递给<code>downloadTaskWithResumeData:</code> 或者 <code>downloadTaskWithResumeData:</code> 方法来创建一个新的下载任务继续下载。</p>
<p>如果数据传输失败，delegate 的 <code>URLSession:task:didCompleteWithError:</code> 方法会被调用。</p>
<p>下面的代码展示了下载一个中等大小文件的过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSURL *url = [NSURL URLWithString:@&quot;https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/ObjC_classic/FoundationObjC.pdf&quot;];</span><br><span class="line">NSURLSessionDownloadTask *downloadTask = [backgroundSession downloadTaskWithURL:url];</span><br><span class="line">[downloadTask resume];</span><br></pre></td></tr></table></figure>
<p>下面是 delegate 实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">      downloadTask:(NSURLSessionDownloadTask *)downloadTask</span><br><span class="line">      didWriteData:(int64_t)bytesWritten</span><br><span class="line"> totalBytesWritten:(int64_t)totalBytesWritten</span><br><span class="line">totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;Session %@ download task %@ wrote an additional %lld bytes (total %lld bytes) out of an expected %lld bytes.\n&quot;, session, downloadTask, bytesWritten, totalBytesWritten, totalBytesExpectedToWrite);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">      downloadTask:(NSURLSessionDownloadTask *)downloadTask</span><br><span class="line"> didResumeAtOffset:(int64_t)fileOffset</span><br><span class="line">expectedTotalBytes:(int64_t)expectedTotalBytes</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;Session %@ download task %@ resumed at offset %lld bytes out of an expected %lld bytes.\n&quot;, session, downloadTask, fileOffset, expectedTotalBytes);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">      downloadTask:(NSURLSessionDownloadTask *)downloadTask</span><br><span class="line">didFinishDownloadingToURL:(NSURL *)location</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;Session %@ download task %@ finished downloading to URL %@\n&quot;, session, downloadTask, location);</span><br><span class="line"> </span><br><span class="line">    // Perform the completion handler for the current session</span><br><span class="line">    self.completionHandlers[session.configuration.identifier]();</span><br><span class="line"> </span><br><span class="line">   // Open the downloaded file for reading</span><br><span class="line">    NSError *readError = nil;</span><br><span class="line">    NSFileHandle *fileHandle = [NSFileHandle fileHandleForReadingFromURL:location error:readError];</span><br><span class="line">    // ...</span><br><span class="line"> </span><br><span class="line">   // Move the file to a new URL</span><br><span class="line">    NSFileManager *fileManager = [NSFileManager defaultManager];</span><br><span class="line">    NSURL *cacheDirectory = [[fileManager URLsForDirectory:NSCachesDirectory inDomains:NSUserDomainMask] firstObject];</span><br><span class="line">    NSError *moveError = nil;</span><br><span class="line">    if ([fileManager moveItemAtURL:location toURL:cacheDirectory error:moveError]) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="上传消息体内容"><a href="#上传消息体内容" class="headerlink" title="上传消息体内容"></a>上传消息体内容</h3><p>App 可以通过三种方式为 HTTP POST 消息提供消息体：NSData、文件或者流。总的来说，你的 App 应该：</p>
<ul>
<li>如果内存中已经存在一个 NSData 对象并且没有理由废弃它（比如内存问题），那么可以直接使用它；</li>
<li>如果上传内容是以文件的形式存在于磁盘上的，或者你是在进行后台传输任务，又或者 App 有必要将数据写到磁盘上来释放那部分数据占用的内存空间，那么使用文件即可；</li>
<li>如果你是从网络上接收数据，那么使用流；</li>
</ul>
<p>不管你选择何种方式上传，如果你的 App 自定义了 session delegate，它都应该实现 <code>URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:</code> 方法来获取上传进度信息；</p>
<p>另外，如果你的 App 是通过流的形式提供消息体的，它必须提供自定义的 session delegate 并实现 <code>URLSession:task:needNewBodyStream:</code> 方法，下面会详细解释。</p>
<h4 id="使用-NSData-上传数据"><a href="#使用-NSData-上传数据" class="headerlink" title="使用 NSData 上传数据"></a>使用 NSData 上传数据</h4><p>使用 NSData 进行上传，App 必须通过调用 <code>uploadTaskWithRequest:fromData:</code> 或者 <code>uploadTaskWithRequest:fromData:completionHandler:</code> 方法来创建上传任务，并在 <code>fromData:</code> 参数中传入数据对象。session 对象会根据 NSData 对象计算 <code>Content-Length</code> Header 的值，服务器需要的其余参数需要开发者手动提供，比如 <code>Content-Type</code>。</p>
<p>下面的代码展示了如何通过 NSData 进行数据上传：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NSURL *textFileURL = [NSURL fileURLWithPath:@&quot;/path/to/file.txt&quot;];</span><br><span class="line">NSData *data = [NSData dataWithContentsOfURL:textFileURL];</span><br><span class="line"> </span><br><span class="line">NSURL *url = [NSURL URLWithString:@&quot;https://www.example.com/&quot;];</span><br><span class="line">NSMutableURLRequest *mutableRequest = [NSMutableURLRequest requestWithURL:url];</span><br><span class="line">mutableRequest.HTTPMethod = @&quot;POST&quot;;</span><br><span class="line">[mutableRequest setValue:[NSString stringWithFormat:@&quot;%lld&quot;, data.length] forHTTPHeaderField:@&quot;Content-Length&quot;];</span><br><span class="line">[mutableRequest setValue:@&quot;text/plain&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];</span><br><span class="line"> </span><br><span class="line">NSURLSessionUploadTask *uploadTask = [defaultSession uploadTaskWithRequest:mutableRequest fromData:data];</span><br><span class="line">[uploadTask resume];</span><br></pre></td></tr></table></figure>
<h4 id="使用文件上传数据"><a href="#使用文件上传数据" class="headerlink" title="使用文件上传数据"></a>使用文件上传数据</h4><p>使用文件上传数据，App 必须通过调用 <code>uploadTaskWithRequest:fromFile:</code> 或者 <code>uploadTaskWithRequest:fromFile:completionHandler:</code> 方法来创建上传任务，并且提供文件的 URL 以供任务读取上传数据。session 对象会根据文件对象计算 <code>Content-Length</code> Header 的值，如果 App 没有设置 <code>Content-Type</code>  Header，session 也会提供一个。</p>
<p>下面的代码展示了如何通过文件进行数据上传：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSURL *textFileURL = [NSURL fileURLWithPath:@&quot;/path/to/file.txt&quot;];</span><br><span class="line"> </span><br><span class="line">NSURL *url = [NSURL URLWithString:@&quot;https://www.example.com/&quot;];</span><br><span class="line">NSMutableURLRequest *mutableRequest = [NSMutableURLRequest requestWithURL:url];</span><br><span class="line">mutableRequest.HTTPMethod = @&quot;POST&quot;;</span><br><span class="line"> </span><br><span class="line">NSURLSessionUploadTask *uploadTask = [defaultSession uploadTaskWithRequest:mutableRequest fromFile:textFileURL];</span><br><span class="line">[uploadTask resume];</span><br></pre></td></tr></table></figure>
<h4 id="使用流上传数据"><a href="#使用流上传数据" class="headerlink" title="使用流上传数据"></a>使用流上传数据</h4><p>使用流上传数据，必须通过调用 <code>uploadTaskWithStreamedRequest:</code> 方法来创建一个上传任务，App 必须为这个方法提供一个上传数据对象的关联流。App 同时必须提供一些服务器需要的 Header 字段，比如 <code>Content-Type</code> 和 <code>Content-Length</code>。</p>
<p>另外，session 如果遇到必须重新尝试一个请求的情况，比如如果身份验证失败，就必须重新读取流，但是流不一定能够倒回去重新读取，这个时候 App 就必须负责重新提供一个新的流。因此，App 需要实现 <code>URLSession:task:needNewBodyStream:</code> 方法，当这个方法被调用的时候，App 应该尽量提供一个新的流，然后以 新的流为参数调用 completion handler block。</p>
<blockquote>
<p>这种技术不能和系统提供的 delegate 兼容。</p>
</blockquote>
<p>下面的代码展示了如何通过流进行数据上传：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NSURL *textFileURL = [NSURL fileURLWithPath:@&quot;/path/to/file.txt&quot;];</span><br><span class="line"> </span><br><span class="line">NSURL *url = [NSURL URLWithString:@&quot;https://www.example.com/&quot;];</span><br><span class="line">NSMutableURLRequest *mutableRequest = [NSMutableURLRequest requestWithURL:url];</span><br><span class="line">mutableRequest.HTTPMethod = @&quot;POST&quot;;</span><br><span class="line">mutableRequest.HTTPBodyStream = [NSInputStream inputStreamWithFileAtPath:textFileURL.path];</span><br><span class="line">[mutableRequest setValue:@&quot;text/plain&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];</span><br><span class="line">[mutableRequest setValue:[NSString stringWithFormat:@&quot;%lld&quot;, data.length] forHTTPHeaderField:@&quot;Content-Type&quot;];</span><br><span class="line"> </span><br><span class="line">NSURLSessionUploadTask *uploadTask = [defaultSession uploadTaskWithStreamedRequest:mutableRequest];</span><br><span class="line">[uploadTask resume];</span><br></pre></td></tr></table></figure>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>URL 加载系统为请求和响应提供了磁盘缓存和内存缓存，这个设计让应用介绍了对网络的依赖，提高了性能。</p>
<h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><p>NSURLRequest 通过设置缓存策略来指定如何使用本地缓存，缓存策略的值是由枚举 <code>NSURLRequestCachePolicy</code> 指定的，包括：<code>NSURLRequestUseProtocolCachePolicy</code>, <code>NSURLRequestReloadIgnoringCacheData</code>, <code>NSURLRequestReturnCacheDataElseLoad</code>, 和 <code>NSURLRequestReturnCacheDataDontLoad</code>。<code>NSURLRequestUseProtocolCachePolicy</code> 是默认的缓存策略，它是根据协议规范实现的； <code>NSURLRequestReloadIgnoringCacheData</code> 表示完全忽略本地缓存；<code>NSURLRequestReturnCacheDataElseLoad</code> 表示只要有缓存，不论是否过期直接使用，没有缓存才从远端加载；<code>NSURLRequestReturnCacheDataDontLoad</code> 表示只从缓存加载数据，也就是离线模式。</p>
<blockquote>
<p>Http 的标准缓存机制可见：<a href="[http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13](http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13">RFC 2616, Section 13</a>)。</p>
</blockquote>
<h3 id="缓存控制"><a href="#缓存控制" class="headerlink" title="缓存控制"></a>缓存控制</h3><p>一般来说，请求会基于缓存策略进行缓存。如果开发者需要更加精细的控制，可以通过实现 delegate 方法来决定每个请求的响应如何进行缓存。对于 NSURLSession 的数据任务和上传任务，需要实现 <code>URLSession:dataTask:willCacheResponse:completionHandler:</code> 方法，这个方法只有在执行数据任务和上传任务的时候才会被调用。下载任务的缓存只能由设置的缓存策略控制。</p>
<p>delegate 方法通过调用 completion handler 来告知 session 应该如何做缓存，通常有以下三种情况：</p>
<ul>
<li>直接返回提供的响应；</li>
<li>修改提供的响应并返回一个新的响应；</li>
<li>返回 nil 拒绝缓存；</li>
</ul>
<p>delegate 方法也可以向 NSCacheURLResponse 对象的 <code>userInfo</code> 字典中插入对象，这些对象也会随着响应一起被缓存。</p>
<p>以下的例子就是拒绝在磁盘上缓存 HTTPS 响应，并且在 userInfo 字典中添加了当前日期：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line"> willCacheResponse:(NSCachedURLResponse *)proposedResponse</span><br><span class="line"> completionHandler:(void (^)(NSCachedURLResponse * __nullable cachedResponse))completionHandler &#123;</span><br><span class="line">    NSCachedURLResponse *newCachedResponse = proposedResponse;</span><br><span class="line">    NSDictionary *newUserInfo;</span><br><span class="line">    newUserInfo = [NSDictionary dictionaryWithObject:[NSDate date]</span><br><span class="line">                                              forKey:@&quot;Cached Date&quot;];</span><br><span class="line">    if ([proposedResponse.response.URL.scheme isEqualToString:@&quot;https&quot;]) &#123;</span><br><span class="line">#if ALLOW_IN_MEMORY_CACHING</span><br><span class="line">        newCachedResponse = [[NSCachedURLResponse alloc]</span><br><span class="line">                             initWithResponse:proposedResponse.response</span><br><span class="line">                             data:proposedResponse.data</span><br><span class="line">                             userInfo:newUserInfo</span><br><span class="line">                             storagePolicy:NSURLCacheStorageAllowedInMemoryOnly];</span><br><span class="line">#else // !ALLOW_IN_MEMORY_CACHING</span><br><span class="line">        newCachedResponse = nil;</span><br><span class="line">#endif // ALLOW_IN_MEMORY_CACHING</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        newCachedResponse = [[NSCachedURLResponse alloc]</span><br><span class="line">                             initWithResponse:[proposedResponse response]</span><br><span class="line">                             data:[proposedResponse data]</span><br><span class="line">                             userInfo:newUserInfo</span><br><span class="line">                             storagePolicy:[proposedResponse storagePolicy]];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    completionHandler(newCachedResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Cookie-存储"><a href="#Cookie-存储" class="headerlink" title="Cookie 存储"></a>Cookie 存储</h2><p>由于 Http 协议无状态的天然特性，客户端通常使用 cookie 来维护状态。URL 加载系统为创建和管理 cookie 提供了接口，并将 cookie 作为请求的一部分发送，会在服务器响应返回的时候接收 cookie。</p>
<p>NSHTTPCookie 类封装了一个 cookie 并对很多的常见 cookie 属性提供了读写方法。NSHTTPCookieStorage 类则提供了所有 App 共享的 NSHTTPCookie 对象的接口。</p>
<blockquote>
<p>注意：iOS 上的应用之间不共享 Cookie。</p>
</blockquote>
<p>NSHTTPCookieStorage 允许 App 指定 Cookie 设置策略，可以设置 Cookie 永久可设置，永久不可设置或者只有来自相同域名的请求才可以设置。</p>
<h2 id="处理身份认证和-TLS-链认证"><a href="#处理身份认证和-TLS-链认证" class="headerlink" title="处理身份认证和 TLS 链认证"></a>处理身份认证和 TLS 链认证</h2><p>如果远程服务返回的状态码要求进行身份认证，又或者认证需要在连接建立的时候进行（比如需要一个 SSL 客户端证书），NSURLSession 会调用一个 delegate 方法：</p>
<p>// TODO</p>
<h2 id="协议支持"><a href="#协议支持" class="headerlink" title="协议支持"></a>协议支持</h2><p>URL 加载系统允许应用扩展协议来支持数据传输。开发者可以继承 NSURLProtocol 协议实现自己的协议类，通过 NSURLProtocol 的类方法 <code>registerClass:</code> 进行注册，当 NSURLSession 对象为一个 NSURLRequest 初始化链接的时候，URL 加载系统会通过 NSURLProtocol 类来倒叙遍历所有的注册协议类，第一个在方法 <code>canInitWithRequest:</code> 中返回 <code>YES</code> 的协议类被用于处请求。</p>
<p>如果你自定义的协议需要在请求或者响应中添加新的属性，可以通过 Caterogry 在 NSURLRequest、NSMutableURLRequest 和 NSURLResponse 类中为这些属性提供读写方法。</p>
<p>URL 加载系统负责在连接建立的时候创建 NSURLProtocol 实例，在请求完成之后释放实例，因此开发者永远不应该自己去创建 NSURLProtocol 的实例。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="处理重定向和其他请求变化"><a href="#处理重定向和其他请求变化" class="headerlink" title="处理重定向和其他请求变化"></a>处理重定向和其他请求变化</h3><p>重定向发生在服务端告诉客户端需要对一个新的  URL 发起请求才能获取资源的时候， NSURLSession 遇到这种情况会通过 delegate 告知 App。为了处理这种情况，delegate 必须实现 <code>URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:</code> 方法，在这个方法里面可以获取到引起重定向的 response，并通过 comletionHandler 返回一个新的请求。delegate 可以做以下事情：</p>
<ul>
<li>简单的返回获取的 request 以允许重定向；</li>
<li>创建一个新的 request 指向一个不同的 URL，并返回 request；</li>
<li>通过返回 nil，拒绝重定向；</li>
</ul>
<p>另外，delegate 可以同时取消重定向和连接，只需要调用 task 对象的 <code>cancel</code> 方法即可。</p>
<p>如果处理请求的 NSURLProtocol 的子类为了标准化请求的格式，更改了 NSRequest 的内容，比如把请求 URL 的地址从 <a href="http://www.apple.com" target="_blank" rel="noopener">http://www.apple.com</a> 改为 <a href="http://www.apple.com/" target="_blank" rel="noopener">http://www.apple.com/</a> ，delegate 也会收到 <code>URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:</code>  消息，在这种特殊的情况下，response 参数会为 nil，delegate 应该直接返回收到的 request 对象。</p>
<p>下面的代码展现了<code>URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:</code> 的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">        task:(NSURLSessionTask *)task</span><br><span class="line">        willPerformHTTPRedirection:(NSHTTPURLResponse *)redirectResponse</span><br><span class="line">        newRequest:(NSURLRequest *)request</span><br><span class="line">        completionHandler:(void (^)(NSURLRequest *))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    NSURLRequest *newRequest = request;</span><br><span class="line">    if (redirectResponse) &#123;</span><br><span class="line">        newRequest = nil;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    completionHandler(newRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码允许请求上因为标准化而发生的任何变化，拒绝了所有服务端的重定向要求。</p>
<h3 id="处理-iOS-后台活动"><a href="#处理-iOS-后台活动" class="headerlink" title="处理 iOS 后台活动"></a>处理 iOS 后台活动</h3><p>如果你使用 NSURLSession，你的 App 会在下载任务完成后自动重新启动，App 的<code>application:handleEventsForBackgroundURLSession:completionHandler:</code> delegate 方法负责重新创建合适的 session，提供 completion handler，并在 session 调用 delegate 的 <code>URLSessionDidFinishEventsForBackgroundURLSession:</code> 方法的时候调用这个 handler。</p>
<p>下面的代码展示了如何在后台创建下载任务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SURL *url = [NSURL URLWithString:@&quot;https://www.example.com/&quot;];</span><br><span class="line"> </span><br><span class="line">NSURLSessionDownloadTask *backgroundDownloadTask = [backgroundSession downloadTaskWithURL:url];</span><br><span class="line">[backgroundDownloadTask resume];</span><br></pre></td></tr></table></figure>
<p>下面的代码展示了 session 的代理方法实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session &#123;</span><br><span class="line">    AppDelegate *appDelegate = (AppDelegate *)[[[UIApplication sharedApplication] delegate];</span><br><span class="line">    if (appDelegate.backgroundSessionCompletionHandler) &#123;</span><br><span class="line">        CompletionHandler completionHandler = appDelegate.backgroundSessionCompletionHandler;</span><br><span class="line">        appDelegate.backgroundSessionCompletionHandler = nil;</span><br><span class="line">        completionHandler();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    NSLog(@&quot;All tasks are finished&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的代码展示了 AppDelegate 的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@interface AppDelegate : UIResponder &lt;UIApplicationDelegate&gt;</span><br><span class="line">@property (strong, nonatomic) UIWindow *window;</span><br><span class="line">@property (copy) CompletionHandler backgroundSessionCompletionHandler;</span><br><span class="line"> </span><br><span class="line">@end</span><br><span class="line"> </span><br><span class="line">@implementation AppDelegate</span><br><span class="line"> </span><br><span class="line">- (void)application:(UIApplication *)application</span><br><span class="line">handleEventsForBackgroundURLSession:(NSString *)identifier</span><br><span class="line">  completionHandler:(void (^)())completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    self.backgroundSessionCompletionHandler = completionHandler;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>【参考资料】</p>
<p>1）<a href="https://objccn.io/issue-5-4/" target="_blank" rel="noopener">从 NSURLConnection 到 NSURLSession</a></p>
<p>2）<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html#//apple_ref/doc/uid/10000165i" target="_blank" rel="noopener">URL Session Programming Guide</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SDWebImage 源码解析]]></title>
      <url>http://www.timebridge.space/2017/02/10/SDWebImage-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<blockquote>
<p>分析版本：3.7.4</p>
</blockquote>
<p><a href="https://github.com/rs/SDWebImage" target="_blank" rel="noopener">SDWebImage</a> 是 iOS 上使用范围最广的网络图片加载库，在 Github 上有高达近 17K 的 Star 数量。它提供的功能主要如下：</p>
<ol>
<li>加载普通图片，包括 png、jpeg、gif、WebP等，支持的组件有 UIImageView、UIButton 和 MKAnnotationView；</li>
<li>为 UIImageVew 加载多帧图片；</li>
<li>预加载图片；</li>
</ol>
<p>使用示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[imageView sd_setImageWithURL:[NSURL URLWithString:@&quot;http://www.domain.com/path/to/image.jpg&quot;]</span><br><span class="line">             placeholderImage:[UIImage imageNamed:@&quot;placeholder.png&quot;]];</span><br></pre></td></tr></table></figure>
<p>简单的情况下只需要告诉它图片的 URL 以及占位图片就可以轻松完成网络图片的加载。知其然更要知其所以然，下面从源码角度分析一下 SDWebImage 是如何完成图片加载的。</p>
<a id="more"></a>
<h2 id="加载流程"><a href="#加载流程" class="headerlink" title="加载流程"></a>加载流程</h2><p>在详细看代码之前，先来看看图片加载的流程（来自项目的 Wiki）：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/SDWebImageSequenceDiagram.png" alt="SDWebImage 图片加载流程图"></div>

<p>文字描述如下：</p>
<ol>
<li>发起图片加载请求；</li>
<li>尝试从缓存中读取图片；</li>
<li>缓存读取成功则返回图片，读取失败则从网络下载；</li>
<li>下载成功后添加到缓存并返回图片；</li>
</ol>
<p>图片加载的流程并不复杂，大部分图片加载库的流程都大同小异，只不过每个库在实现的时候在策略控制以及细节实现上有所差别。在理解大致流程的基础上，下面分析每一步的实现。</p>
<h2 id="任务创建与调度"><a href="#任务创建与调度" class="headerlink" title="任务创建与调度"></a>任务创建与调度</h2><h3 id="任务创建"><a href="#任务创建" class="headerlink" title="任务创建"></a>任务创建</h3><p>我们从上面的示例代码切入，即方法<code>- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder;</code>。这个方法来自于<code>UIImageView+WebCache.h</code>，有很多的重载方法，最终调用到的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionBlock)completedBlock &#123;</span><br><span class="line">    // 1. 取消任务</span><br><span class="line">    [self sd_cancelCurrentImageLoad];</span><br><span class="line">    // 2. 记录要加载的 URL</span><br><span class="line">    objc_setAssociatedObject(self, &amp;imageURLKey, url, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line"></span><br><span class="line">    // 3. 设置占位图</span><br><span class="line">    if (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">            self.image = placeholder;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 4. 如果 URL 存在，则加载图片，否则报错，直接回调</span><br><span class="line">    if (url) &#123;</span><br><span class="line">        // 5. 显示加载菊花</span><br><span class="line">        // check if activityView is enabled or not</span><br><span class="line">        if ([self showActivityIndicatorView]) &#123;</span><br><span class="line">            [self addActivityIndicator];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 6. 创建加载任务</span><br><span class="line">        __weak __typeof(self)wself = self;</span><br><span class="line">        id &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager downloadImageWithURL:url options:options progress:progressBlock completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123;</span><br><span class="line">            [wself removeActivityIndicator];</span><br><span class="line">            if (!wself) return;</span><br><span class="line">            dispatch_main_sync_safe(^&#123;// 调度到主线程</span><br><span class="line">                if (!wself) return;</span><br><span class="line">                // 如果加载选项设置为不自动设置图片，并且有回调 Block，则调用回调 Block</span><br><span class="line">                if (image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage) &amp;&amp; completedBlock)</span><br><span class="line">                &#123;</span><br><span class="line">                    completedBlock(image, error, cacheType, url);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (image) &#123;// 否则直接设置图片</span><br><span class="line">                    wself.image = image;</span><br><span class="line">                    [wself setNeedsLayout];</span><br><span class="line">                &#125; else &#123;// 如果加载失败，在此处设置为占位符（关于 SDWebImageDelayPlaceholder 可以查看该枚举的说明）</span><br><span class="line">                    if ((options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">                        wself.image = placeholder;</span><br><span class="line">                        [wself setNeedsLayout];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // 回调</span><br><span class="line">                if (completedBlock &amp;&amp; finished) &#123;</span><br><span class="line">                    completedBlock(image, error, cacheType, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;];</span><br><span class="line">        // 7. 将该任务记录为 &quot;UIImageViewImageLoad&quot; 对应的任务。一个组件有两种任务，另外一种是 &quot;UIImageViewAnimationImages&quot;</span><br><span class="line">        // 加载的是 Gif 动态图，每种类型的任务同时只能存在一个，该方法调用是会默认检测并取消旧有的任务</span><br><span class="line">        [self sd_setImageLoadOperation:operation forKey:@&quot;UIImageViewImageLoad&quot;];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // URL 非法，直接报错回调</span><br><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">            [self removeActivityIndicator];</span><br><span class="line">            NSError *error = [NSError errorWithDomain:SDWebImageErrorDomain code:-1 userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Trying to load a nil url&quot;&#125;];</span><br><span class="line">            if (completedBlock) &#123;</span><br><span class="line">                completedBlock(nil, error, SDImageCacheTypeNone, url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的主要作用是准备加载环境，创建加载任务。相关注释都已经标记在代码上，下面说一些细节。</p>
<p>首先是<code>dispatch_main_async_safe</code>和<code>dispatch_main_sync_safe</code>两个宏，它们的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#define dispatch_main_sync_safe(block)\</span><br><span class="line">    if ([NSThread isMainThread]) &#123;\</span><br><span class="line">        block();\</span><br><span class="line">    &#125; else &#123;\</span><br><span class="line">        dispatch_sync(dispatch_get_main_queue(), block);\</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#define dispatch_main_async_safe(block)\</span><br><span class="line">    if ([NSThread isMainThread]) &#123;\</span><br><span class="line">        block();\</span><br><span class="line">    &#125; else &#123;\</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), block);\</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这两个宏虽然简化了一些写法，但是定义很糟糕：</p>
<ol>
<li>所谓<code>safe</code>，并不能很明显的看出来，唯一加强安全的地方就是<code>dispatch_main_sync_safe</code>防止了在主线程上调用<code>dispatch_sync(dispatch_get_main_queue(), block)</code>产生死锁，而<code>async</code>完全看不出来；</li>
<li><code>dispatch_main_async_safe</code>如果执行在主线程上，实际是同步的，并不与名字所反映的一样，使用的时候务必要注意；</li>
</ol>
<p>其次是任务的取消。在方法的一开始即 1 处就调用了取消任务的方法，图片加载任务创建的最后，也就是 7 处将任务记录为一个变量，后期会通过这个变量操作任务。<code>sd_setImageLoadOperation</code>方法的调用链如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 来自 UIImageView+WebCache.h</span><br><span class="line">- (void)sd_cancelCurrentImageLoad &#123;</span><br><span class="line">    [self sd_cancelImageLoadOperationWithKey:@&quot;UIImageViewImageLoad&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 来自 UIView+WebCacheOperation.h</span><br><span class="line">- (void)sd_setImageLoadOperation:(id)operation forKey:(NSString *)key &#123;</span><br><span class="line">    [self sd_cancelImageLoadOperationWithKey:key];</span><br><span class="line">    NSMutableDictionary *operationDictionary = [self operationDictionary];</span><br><span class="line">    [operationDictionary setObject:operation forKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 来自 UIView+WebCacheOperation.h</span><br><span class="line">- (void)sd_cancelImageLoadOperationWithKey:(NSString *)key &#123;</span><br><span class="line">    // Cancel in progress downloader from queue</span><br><span class="line">    NSMutableDictionary *operationDictionary = [self operationDictionary];</span><br><span class="line">    id operations = [operationDictionary objectForKey:key];</span><br><span class="line">    if (operations) &#123;</span><br><span class="line">        if ([operations isKindOfClass:[NSArray class]]) &#123;</span><br><span class="line">            for (id &lt;SDWebImageOperation&gt; operation in operations) &#123;</span><br><span class="line">                if (operation) &#123;</span><br><span class="line">                    [operation cancel];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if ([operations conformsToProtocol:@protocol(SDWebImageOperation)])&#123;</span><br><span class="line">            [(id&lt;SDWebImageOperation&gt;) operations cancel];</span><br><span class="line">        &#125;</span><br><span class="line">        [operationDictionary removeObjectForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 UIView 内部，通过 Category 创建了一个 Dictionary，用于记录当前在该 View 上正在执行的所有任务，在注释 7 处我说了这个 Dictionary 中记录的任务有两种 key：</p>
<ol>
<li><strong>“UIImageViewImageLoad”</strong>对应的是单个<code>SDWebImageOperation</code>，用于下载单张普通图片；</li>
<li><strong>“UIImageViewAnimationImages”</strong>对应的是<code>SDWebImageOperation</code>数组，用于下载一组图片展现帧动画。</li>
</ol>
<p><code>SDWebImageOperation</code>是一个接口，只有一个<code>cancel()</code>方法，取消任务调用它即可。</p>
<blockquote>
<p>要注意的是，在加载任务执行完成之后，并没有主动从字典中删除对应任务。</p>
</blockquote>
<p>最后有一个疑问没有得到解答：下载完成的回调 Block 中为什么要<code>dispatch_main_sync_safe</code>方法进行图片最后的显示处理？这里使用<code>dispatch_main_async_safe</code>明显可以更快地释放加载线程，而且实现效果一致。</p>
<h3 id="加载任务的执行"><a href="#加载任务的执行" class="headerlink" title="加载任务的执行"></a>加载任务的执行</h3><p>注释 6 处已经创建了加载任务，我们来仔细看看加载任务到底做了什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line">// 来自 SDWebImageManager.h</span><br><span class="line">- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url</span><br><span class="line">                                         options:(SDWebImageOptions)options</span><br><span class="line">                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                       completed:(SDWebImageCompletionWithFinishedBlock)completedBlock &#123;</span><br><span class="line">    // 1. 参数检测</span><br><span class="line">    // Invoking this method without a completedBlock is pointless</span><br><span class="line">    NSAssert(completedBlock != nil, @&quot;If you mean to prefetch the image, use -[SDWebImagePrefetcher prefetchURLs] instead&quot;);</span><br><span class="line"></span><br><span class="line">    // Very common mistake is to send the URL using NSString object instead of NSURL. For some strange reason, XCode won&apos;t</span><br><span class="line">    // throw any warning for this type mismatch. Here we failsafe this error by allowing URLs to be passed as NSString.</span><br><span class="line">    if ([url isKindOfClass:NSString.class]) &#123;</span><br><span class="line">        url = [NSURL URLWithString:(NSString *)url];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Prevents app crashing on argument type error like sending NSNull instead of NSURL</span><br><span class="line">    if (![url isKindOfClass:NSURL.class]) &#123;</span><br><span class="line">        url = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2. 创建真正的 Operation</span><br><span class="line">    __block SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new];</span><br><span class="line">    __weak SDWebImageCombinedOperation *weakOperation = operation;</span><br><span class="line"></span><br><span class="line">    // 3. 判断这个 URL 之前有没有加载失败过</span><br><span class="line">    BOOL isFailedUrl = NO;</span><br><span class="line">    @synchronized (self.failedURLs) &#123;</span><br><span class="line">        isFailedUrl = [self.failedURLs containsObject:url];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果 URL 为空，或者这个 URL 加载失败过但是开发者不要求重试失败的 URL，则直接回调</span><br><span class="line">    if (url.absoluteString.length == 0 || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) &#123;</span><br><span class="line">        dispatch_main_sync_safe(^&#123;</span><br><span class="line">            NSError *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];</span><br><span class="line">            completedBlock(nil, error, SDImageCacheTypeNone, YES, url);</span><br><span class="line">        &#125;);</span><br><span class="line">        return operation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 4. 记录这个 Operation</span><br><span class="line">    @synchronized (self.runningOperations) &#123;</span><br><span class="line">        [self.runningOperations addObject:operation];</span><br><span class="line">    &#125;</span><br><span class="line">    NSString *key = [self cacheKeyForURL:url];</span><br><span class="line"></span><br><span class="line">    // 5. &amp;&amp;&amp; 为任务创建缓存任务，先从磁盘读取任务，根据读取的结果进行操作，根据后面的分析，这个 Block 的执行是在主线程进行的</span><br><span class="line">    operation.cacheOperation = [self.imageCache queryDiskCacheForKey:key done:^(UIImage *image, SDImageCacheType cacheType) &#123;</span><br><span class="line">        if (operation.isCancelled) &#123;</span><br><span class="line">            @synchronized (self.runningOperations) &#123;</span><br><span class="line">                [self.runningOperations removeObject:operation];</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 6. @@@ 如果图片没有从缓存获取到/开发者要求刷新缓存图片（换句话说，获取到的图片不能用，需要下载），并且代理反馈需要根据 URL 下载图片</span><br><span class="line">        if ((!image || options &amp; SDWebImageRefreshCached) &amp;&amp; (![self.delegate respondsToSelector:@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self shouldDownloadImageForURL:url])) &#123;</span><br><span class="line">            // 如果从缓存中获取了图片，但是开发者设置为必须刷新缓存</span><br><span class="line">            if (image &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</span><br><span class="line">                dispatch_main_sync_safe(^&#123;</span><br><span class="line">                    // If image was found in the cache but SDWebImageRefreshCached is provided, notify about the cached image</span><br><span class="line">                    // AND try to re-download it in order to let a chance to NSURLCache to refresh it from server.</span><br><span class="line">                    // 先回调再重新下载</span><br><span class="line">                    completedBlock(image, nil, cacheType, YES, url);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // download if no image or requested to refresh anyway, and download allowed by delegate</span><br><span class="line">            SDWebImageDownloaderOptions downloaderOptions = 0;</span><br><span class="line">            if (options &amp; SDWebImageLowPriority) downloaderOptions |= SDWebImageDownloaderLowPriority;</span><br><span class="line">            if (options &amp; SDWebImageProgressiveDownload) downloaderOptions |= SDWebImageDownloaderProgressiveDownload;</span><br><span class="line">            if (options &amp; SDWebImageRefreshCached) downloaderOptions |= SDWebImageDownloaderUseNSURLCache;</span><br><span class="line">            if (options &amp; SDWebImageContinueInBackground) downloaderOptions |= SDWebImageDownloaderContinueInBackground;</span><br><span class="line">            if (options &amp; SDWebImageHandleCookies) downloaderOptions |= SDWebImageDownloaderHandleCookies;</span><br><span class="line">            if (options &amp; SDWebImageAllowInvalidSSLCertificates) downloaderOptions |= SDWebImageDownloaderAllowInvalidSSLCertificates;</span><br><span class="line">            if (options &amp; SDWebImageHighPriority) downloaderOptions |= SDWebImageDownloaderHighPriority;</span><br><span class="line">            // 如果是设置为刷新缓存并且获取到了图片，则取消渐进式加载，并添加忽略缓存响应选项</span><br><span class="line">            if (image &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</span><br><span class="line">                // force progressive off if image already cached but forced refreshing</span><br><span class="line">                downloaderOptions &amp;= ~SDWebImageDownloaderProgressiveDownload;</span><br><span class="line">                // ignore image read from NSURLCache if image if cached but force refreshing</span><br><span class="line">                downloaderOptions |= SDWebImageDownloaderIgnoreCachedResponse;</span><br><span class="line">            &#125;</span><br><span class="line">            // 7. 创建下载任务</span><br><span class="line">            id &lt;SDWebImageOperation&gt; subOperation = [self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage *downloadedImage, NSData *data, NSError *error, BOOL finished) &#123;</span><br><span class="line">                __strong __typeof(weakOperation) strongOperation = weakOperation;</span><br><span class="line">                if (!strongOperation || strongOperation.isCancelled) &#123; // 如果任务取消</span><br><span class="line">                    // Do nothing if the operation was cancelled</span><br><span class="line">                    // See #699 for more details</span><br><span class="line">                    // if we would call the completedBlock, there could be a race condition between this block and another completedBlock for the same object, so if this one is called second, we will overwrite the new data</span><br><span class="line">                &#125;</span><br><span class="line">                else if (error) &#123; // 如果下载失败</span><br><span class="line">                    dispatch_main_sync_safe(^&#123; </span><br><span class="line">                        if (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</span><br><span class="line">                            completedBlock(nil, error, SDImageCacheTypeNone, finished, url);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    // 如果不是因为以下原因下载失败，则记录为失败的 URL</span><br><span class="line">                    if (   error.code != NSURLErrorNotConnectedToInternet</span><br><span class="line">                        &amp;&amp; error.code != NSURLErrorCancelled</span><br><span class="line">                        &amp;&amp; error.code != NSURLErrorTimedOut</span><br><span class="line">                        &amp;&amp; error.code != NSURLErrorInternationalRoamingOff</span><br><span class="line">                        &amp;&amp; error.code != NSURLErrorDataNotAllowed</span><br><span class="line">                        &amp;&amp; error.code != NSURLErrorCannotFindHost</span><br><span class="line">                        &amp;&amp; error.code != NSURLErrorCannotConnectToHost) &#123;</span><br><span class="line">                        @synchronized (self.failedURLs) &#123;</span><br><span class="line">                            [self.failedURLs addObject:url];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123; // 如果下载成功</span><br><span class="line">                    if ((options &amp; SDWebImageRetryFailed)) &#123;</span><br><span class="line">                        @synchronized (self.failedURLs) &#123;</span><br><span class="line">                            [self.failedURLs removeObject:url];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    // 判断是否要缓存到磁盘上</span><br><span class="line">                    BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);</span><br><span class="line"></span><br><span class="line">                    // 如果要求刷新缓存但是下载图片不存在</span><br><span class="line">                    if (options &amp; SDWebImageRefreshCached &amp;&amp; image &amp;&amp; !downloadedImage) &#123;</span><br><span class="line">                        // Image refresh hit the NSURLCache cache, do not call the completion block</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 如果下载的是多图，进行转换</span><br><span class="line">                    else if (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)]) &#123;</span><br><span class="line">                        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">                            UIImage *transformedImage = [self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url];</span><br><span class="line"></span><br><span class="line">                            if (transformedImage &amp;&amp; finished) &#123;</span><br><span class="line">                                BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage];</span><br><span class="line">                                // 存储图片</span><br><span class="line">                                [self.imageCache storeImage:transformedImage recalculateFromImage:imageWasTransformed imageData:(imageWasTransformed ? nil : data) forKey:key toDisk:cacheOnDisk];</span><br><span class="line">                            &#125;</span><br><span class="line">                            // 回调</span><br><span class="line">                            dispatch_main_sync_safe(^&#123;</span><br><span class="line">                                if (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</span><br><span class="line">                                    completedBlock(transformedImage, nil, SDImageCacheTypeNone, finished, url);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    else &#123; // 如果下载的是普通图片</span><br><span class="line">                        if (downloadedImage &amp;&amp; finished) &#123;</span><br><span class="line">                            // 存储图片</span><br><span class="line">                            [self.imageCache storeImage:downloadedImage recalculateFromImage:NO imageData:data forKey:key toDisk:cacheOnDisk];</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        // 回调</span><br><span class="line">                        dispatch_main_sync_safe(^&#123;</span><br><span class="line">                            if (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</span><br><span class="line">                                completedBlock(downloadedImage, nil, SDImageCacheTypeNone, finished, url);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (finished) &#123;</span><br><span class="line">                    @synchronized (self.runningOperations) &#123;</span><br><span class="line">                        if (strongOperation) &#123;</span><br><span class="line">                            [self.runningOperations removeObject:strongOperation];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">            </span><br><span class="line">            // 取消回调</span><br><span class="line">            operation.cancelBlock = ^&#123;</span><br><span class="line">                [subOperation cancel];</span><br><span class="line">                </span><br><span class="line">                @synchronized (self.runningOperations) &#123;</span><br><span class="line">                    __strong __typeof(weakOperation) strongOperation = weakOperation;</span><br><span class="line">                    if (strongOperation) &#123;</span><br><span class="line">                        [self.runningOperations removeObject:strongOperation];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (image) &#123; // 获取缓存成功</span><br><span class="line">            dispatch_main_sync_safe(^&#123;</span><br><span class="line">                __strong __typeof(weakOperation) strongOperation = weakOperation;</span><br><span class="line">                if (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</span><br><span class="line">                    completedBlock(image, nil, cacheType, YES, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            @synchronized (self.runningOperations) &#123;</span><br><span class="line">                [self.runningOperations removeObject:operation];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123; // 开发者想 “只从缓存获取图片” 失败</span><br><span class="line">            // Image not in cache and download disallowed by delegate</span><br><span class="line">            dispatch_main_sync_safe(^&#123;</span><br><span class="line">                __strong __typeof(weakOperation) strongOperation = weakOperation;</span><br><span class="line">                if (strongOperation &amp;&amp; !weakOperation.isCancelled) &#123;</span><br><span class="line">                    completedBlock(nil, nil, SDImageCacheTypeNone, YES, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            @synchronized (self.runningOperations) &#123;</span><br><span class="line">                [self.runningOperations removeObject:operation];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相关流程关键点都标记在代码中，这边有些地方不能解释的很清楚，比如下载任务回调 Block 中的 finished 参数（7 处）到底指什么？这个参数是从最终的下载任务中传递出来的，后面再解释。要注意的是这个方法包含着图片加载的核心流程：<strong>先尝试从缓存获取（5 处），根据获取结果再决定是否要从网络获取（6 处）。</strong>根据缓存获取结果以及开发者设置的选项，分为三种情况：</p>
<ol>
<li>如果从缓存获取图片失败，或者开发者要求刷新缓存图片，并且根据设置的 delegate 开发者要求重新下载图片（没有设置 delegate 则默认下载），则重新从网络加载图片；</li>
<li>如果从缓存获取图片成功，则直接回调 Block，回传图片；</li>
<li>如果从缓存获取失败，并且根据设置的代理，开发者禁止从网络下载，则直接调用回调 Block；</li>
</ol>
<p>接下来就来详细看看缓存获取和下载流程。</p>
<h4 id="缓存获取"><a href="#缓存获取" class="headerlink" title="缓存获取"></a>缓存获取</h4><p>从缓存获取图片是通过下面方法进行的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// 来自 SDImageCache.h</span><br><span class="line">- (NSOperation *)queryDiskCacheForKey:(NSString *)key done:(SDWebImageQueryCompletedBlock)doneBlock &#123;</span><br><span class="line">    //1. 参数检测</span><br><span class="line">    if (!doneBlock) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!key) &#123;</span><br><span class="line">        doneBlock(nil, SDImageCacheTypeNone);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2. 首先从内存换取读取</span><br><span class="line">    // First check the in-memory cache...</span><br><span class="line">    UIImage *image = [self imageFromMemoryCacheForKey:key];</span><br><span class="line">    if (image) &#123;</span><br><span class="line">        doneBlock(image, SDImageCacheTypeMemory);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3. 调度到 IO 线程，从磁盘读取</span><br><span class="line">    NSOperation *operation = [NSOperation new];</span><br><span class="line">    dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">        if (operation.isCancelled) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @autoreleasepool &#123;</span><br><span class="line">            UIImage *diskImage = [self diskImageForKey:key];</span><br><span class="line">            if (diskImage &amp;&amp; self.shouldCacheImagesInMemory) &#123;</span><br><span class="line">                NSUInteger cost = SDCacheCostForImage(diskImage);</span><br><span class="line">                [self.memCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                doneBlock(diskImage, SDImageCacheTypeDisk);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SDImageCache 专门负责进行图片缓存，并依赖 AutoPurgeCache 进行内存缓存，它是<strong>单例</strong>的。这里的策略是：</p>
<ol>
<li>首先从内存缓存中读取，读取到则回调返回；</li>
<li>读取不到调度到异步线程从磁盘读取，读取到了则尝试添加到内存缓存；</li>
<li>调度到主线程执行回调 block；</li>
</ol>
<p>AutoPurgeCache 继承于 NSCache，添加了内存回收相关功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@interface AutoPurgeCache : NSCache</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation AutoPurgeCache</span><br><span class="line"></span><br><span class="line">- (id)init</span><br><span class="line">&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(removeAllObjects) name:UIApplicationDidReceiveMemoryWarningNotification object:nil];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    [[NSNotificationCenter defaultCenter] removeObserver:self name:UIApplicationDidReceiveMemoryWarningNotification object:nil];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以在收到 App 内存警告以及被销毁的时候自动释放所有内存缓存的图片。NSCache 本身提供通过数据数量以及数据体积来限制缓存的功能，这部分功能也通过接口暴露给了外部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)setMaxMemoryCost:(NSUInteger)maxMemoryCost &#123;</span><br><span class="line">    self.memCache.totalCostLimit = maxMemoryCost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setMaxMemoryCountLimit:(NSUInteger)maxCountLimit &#123;</span><br><span class="line">    self.memCache.countLimit = maxCountLimit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说我们可以在外部根据 App 实际情况设置内存缓存大小。磁盘缓存的控制清理需要手动调用如下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)cleanDisk &#123;</span><br><span class="line">    [self cleanDiskWithCompletionBlock:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)cleanDiskWithCompletionBlock:(SDWebImageNoParamsBlock)completionBlock &#123;</span><br><span class="line">	// 实际清理操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据代码，实际的清理操作流程与时间和缓存文件大小相关，策略如下：</p>
<ol>
<li>遍历缓存文件夹，先删除过期的文件，期限时长默认设置为一周，即默认删除一周前的文件，时长可设置；</li>
<li>遍历过程中会顺便计算经过 步骤 1 清理之后总的缓存文件大小；</li>
<li>如果开发者设置了缓存文件大小上限，检测剩余缓存文件是否超限，上限值默认为 0，表示未设限制；</li>
<li>如果超限，总体积为 M，则将理想尺寸设置为 M/2，将剩余文件根据修改时间排序，从最旧的文件开始删除，直到体积小于 M/2；</li>
</ol>
<p>相似的还有一个 clear 操作，它会清除所有缓存。</p>
<p>以上就是 SDWebImage 实现的两级缓存，既保证了图片的加载速度，又保证了不会占用太多的设备资源。</p>
<p>回到缓存获取返回处，即前面注释的代码 5 处（读者可以直接搜 “&amp;&amp;&amp;” 跳转）。从缓存返回之后，有两种情况：1）返回的图片对象可用；2）返回的图片对象不可用。不可用的情况同样分为两种：1）缓存未命中，没有获取到缓存图片；2）开发者要求刷新缓存，从缓存中获取的图片必须经过服务端验证。不可用的情况必须向服务端发送请求，这就是注释 7 处（用户可以直接搜 “@@@” 跳转）的目的。</p>
<h4 id="图片下载"><a href="#图片下载" class="headerlink" title="图片下载"></a>图片下载</h4><p>如果从缓存获取的图片不可用，那么就需要从网络进行下载，它调用的是<code>SDWebImageDownloader</code>的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url options:(SDWebImageDownloaderOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageDownloaderCompletedBlock)completedBlock &#123;</span><br><span class="line">    // SDWebImageDownloaderOperation 真正的任务下载类，继承自 NSOperation</span><br><span class="line">    __block SDWebImageDownloaderOperation *operation;</span><br><span class="line">    __weak __typeof(self)wself = self;</span><br><span class="line"></span><br><span class="line">    // 该方法将创建任务下载类实例 &amp; 执行请求</span><br><span class="line">    [self addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^&#123;</span><br><span class="line">        // 执行请求</span><br><span class="line">        ...</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法会调用以下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (void)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock forURL:(NSURL *)url createCallback:(SDWebImageNoParamsBlock)createCallback &#123;</span><br><span class="line">    // The URL will be used as the key to the callbacks dictionary so it cannot be nil. If it is nil immediately call the completed block with no image or data.</span><br><span class="line">    if (url == nil) &#123;</span><br><span class="line">        if (completedBlock != nil) &#123;</span><br><span class="line">            completedBlock(nil, nil, nil, NO);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">	// 经典用法</span><br><span class="line">    dispatch_barrier_sync(self.barrierQueue, ^&#123;</span><br><span class="line">        BOOL first = NO;</span><br><span class="line">        if (!self.URLCallbacks[url]) &#123;</span><br><span class="line">            self.URLCallbacks[url] = [NSMutableArray new];</span><br><span class="line">            first = YES;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Handle single download of simultaneous download request for the same URL</span><br><span class="line">        NSMutableArray *callbacksForURL = self.URLCallbacks[url];</span><br><span class="line">        NSMutableDictionary *callbacks = [NSMutableDictionary new];</span><br><span class="line">        if (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock copy];</span><br><span class="line">        if (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock copy];</span><br><span class="line">        [callbacksForURL addObject:callbacks];</span><br><span class="line">        self.URLCallbacks[url] = callbacksForURL;</span><br><span class="line"></span><br><span class="line">        if (first) &#123;</span><br><span class="line">            createCallback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码比较有趣，首先来了解一下设计场景，SDWebImage 考虑到一个 App 可能同时发起对一张图片的多个请求这种场景，因此当一个图片网络请求执行前，它会先去检测是否已经有一个同样的请求在执行了，如果有，则只是在对应的请求流程上添加回调，而不是直接发起请求。</p>
<p>在<code>SDWebImageDownloader</code>内部，维护着一个称为<code>URLCallbacks</code>的字典，这个字典的 key 就是请求的 URL，value 是一个数组，每一个数组又包含一个字典，这个字段存储着两个 Block，一个是下载进度回调 Block，一个是下载完成回调 Block，数组里面可能有多个元素，每一个元素代表着一组这样的回调。</p>
<p>如果以该 URL 为 key 的回调组不存在，则说明没有它的下载任务存在，这时候这个方法就会回调<code>createCallback</code> Block。这部分代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">// 该方法将创建任务下载类实例 &amp; 执行请求</span><br><span class="line">[self addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^&#123;</span><br><span class="line">    NSTimeInterval timeoutInterval = wself.downloadTimeout;</span><br><span class="line">    if (timeoutInterval == 0.0) &#123;</span><br><span class="line">        timeoutInterval = 15.0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 1. 创建请求 &amp; 设置参数</span><br><span class="line">    // In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise</span><br><span class="line">    NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url cachePolicy:(options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData) timeoutInterval:timeoutInterval];</span><br><span class="line">    request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);</span><br><span class="line">    request.HTTPShouldUsePipelining = YES;</span><br><span class="line">    if (wself.headersFilter) &#123;</span><br><span class="line">        request.allHTTPHeaderFields = wself.headersFilter(url, [wself.HTTPHeaders copy]);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        request.allHTTPHeaderFields = wself.HTTPHeaders;</span><br><span class="line">    &#125;</span><br><span class="line">    // 2. 初始化任务，添加 Block 回调监听</span><br><span class="line">    operation = [[wself.operationClass alloc] initWithRequest:request</span><br><span class="line">                                                      options:options</span><br><span class="line">                                                     progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123;</span><br><span class="line">                                                         SDWebImageDownloader *sself = wself;</span><br><span class="line">                                                         if (!sself) return;</span><br><span class="line">                                                         __block NSArray *callbacksForURL;</span><br><span class="line">                                                         // 回调所有的下载进度监听</span><br><span class="line">                                                         dispatch_sync(sself.barrierQueue, ^&#123;</span><br><span class="line">                                                             callbacksForURL = [sself.URLCallbacks[url] copy];</span><br><span class="line">                                                         &#125;);</span><br><span class="line">                                                         for (NSDictionary *callbacks in callbacksForURL) &#123;</span><br><span class="line">                                                             dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                                                                 SDWebImageDownloaderProgressBlock callback = callbacks[kProgressCallbackKey];</span><br><span class="line">                                                                 if (callback) callback(receivedSize, expectedSize);</span><br><span class="line">                                                             &#125;);</span><br><span class="line">                                                             &#125;</span><br><span class="line">                                                     &#125;</span><br><span class="line">                                                    completed:^(UIImage *image, NSData *data, NSError *error, BOOL finished) &#123;</span><br><span class="line">                                                        SDWebImageDownloader *sself = wself;</span><br><span class="line">                                                        if (!sself) return;</span><br><span class="line">                                                        __block NSArray *callbacksForURL;</span><br><span class="line">                                                        // 回调所有的下载完成监听</span><br><span class="line">                                                        dispatch_barrier_sync(sself.barrierQueue, ^&#123;</span><br><span class="line">                                                            callbacksForURL = [sself.URLCallbacks[url] copy];</span><br><span class="line">                                                            if (finished) &#123;</span><br><span class="line">                                                                [sself.URLCallbacks removeObjectForKey:url]; // 要移除回调监听</span><br><span class="line">                                                            &#125;</span><br><span class="line">                                                        &#125;);</span><br><span class="line">                                                        for (NSDictionary *callbacks in callbacksForURL) &#123;</span><br><span class="line">                                                            SDWebImageDownloaderCompletedBlock callback = callbacks[kCompletedCallbackKey];</span><br><span class="line">                                                            if (callback) callback(image, data, error, finished);</span><br><span class="line">                                                        &#125;</span><br><span class="line">                                                    &#125;</span><br><span class="line">                                                    cancelled:^&#123;</span><br><span class="line">                                                        // 被取消则移除所有的监听</span><br><span class="line">                                                        SDWebImageDownloader *sself = wself;</span><br><span class="line">                                                        if (!sself) return;</span><br><span class="line">                                                        dispatch_barrier_async(sself.barrierQueue, ^&#123;</span><br><span class="line">                                                            [sself.URLCallbacks removeObjectForKey:url];</span><br><span class="line">                                                        &#125;);</span><br><span class="line">                                                    &#125;];</span><br><span class="line">    operation.shouldDecompressImages = wself.shouldDecompressImages;</span><br><span class="line">    </span><br><span class="line">    // 设置认证信息(具体可看 Http StatusCode - 401)</span><br><span class="line">    if (wself.urlCredential) &#123;</span><br><span class="line">        operation.credential = wself.urlCredential;</span><br><span class="line">    &#125; else if (wself.username &amp;&amp; wself.password) &#123;</span><br><span class="line">        operation.credential = [NSURLCredential credentialWithUser:wself.username password:wself.password persistence:NSURLCredentialPersistenceForSession];</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    // 设置优先级</span><br><span class="line">    if (options &amp; SDWebImageDownloaderHighPriority) &#123;</span><br><span class="line">        operation.queuePriority = NSOperationQueuePriorityHigh;</span><br><span class="line">    &#125; else if (options &amp; SDWebImageDownloaderLowPriority) &#123;</span><br><span class="line">        operation.queuePriority = NSOperationQueuePriorityLow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3. 添加并执行任务</span><br><span class="line">    [wself.downloadQueue addOperation:operation];</span><br><span class="line">    // 模仿实现 LIFO 任务</span><br><span class="line">    if (wself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</span><br><span class="line">        // Emulate LIFO execution order by systematically adding new operations as last operation&apos;s dependency</span><br><span class="line">        [wself.lastAddedOperation addDependency:operation];</span><br><span class="line">        wself.lastAddedOperation = operation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>代码中同样在关键点进行了标注，这里实际只能看到一个发起请求的过程和请求结果的回调，而实际的下载操作在<code>SDWebImageDownloaderOperation</code>类中，这个类是使用 URLConnection  发送请求的，下面一个主题将进行分析。</p>
<p>这里解释一下前面提到的一个参数，即加载完成回调 Block 中的 finish 参数：SDWebImage 可以选择采用渐进式图片加载方式，也就是下载多少显示多少，只需要在下载的时候设置参数 <code>SDWebImageDownloaderProgressiveDownload</code>即可，finish 参数是用于表示下载是否已经完全结束。</p>
<p>另外再关注一下<code>downloadQueue</code>的初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_downloadQueue = [NSOperationQueue new];</span><br><span class="line">_downloadQueue.maxConcurrentOperationCount = 6;</span><br></pre></td></tr></table></figure>
<p>最大线程数设置为 6。也就是最多可以同时进行 6 个下载任务。</p>
<h2 id="下载-amp-解码"><a href="#下载-amp-解码" class="headerlink" title="下载 &amp; 解码"></a>下载 &amp; 解码</h2><p>SDWebImage 下载的真正实现类是<code>SDWebImageDownloaderOperation</code>，这个类继承自<strong>NSOperation</strong>，实现<code>NSURLConnectionDataDelegate</code>协议，将网络下载相关操作和下载图片解码操作封装在内部。</p>
<blockquote>
<p>阅读代码之前最好了解一下如何自定义 NSOperation 和 RunLoop 相关知识。</p>
<p>RunLoop 知识可以参考：<a href="http://blog.ibireme.com/2015/05/18/runloop/#base" target="_blank" rel="noopener">深入理解RunLoop</a></p>
</blockquote>
<h3 id="关键方法start"><a href="#关键方法start" class="headerlink" title="关键方法start"></a>关键方法<code>start</code></h3><p><code>SDWebImageDownloaderOperation</code>的<code>start</code>方法实现大致如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">- (void)start &#123;</span><br><span class="line">    @synchronized (self) &#123;</span><br><span class="line">        if (self.isCancelled) &#123;</span><br><span class="line">            self.finished = YES;</span><br><span class="line">            [self reset];</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ....</span><br><span class="line"></span><br><span class="line">        self.executing = YES;</span><br><span class="line">        self.connection = [[NSURLConnection alloc] initWithRequest:self.request delegate:self startImmediately:NO];</span><br><span class="line">        self.thread = [NSThread currentThread];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [self.connection start];</span><br><span class="line"></span><br><span class="line">    if (self.connection) &#123;// 1. connection 初始化成功</span><br><span class="line">        if (self.progressBlock) &#123;</span><br><span class="line">            self.progressBlock(0, NSURLResponseUnknownLength);</span><br><span class="line">        &#125;</span><br><span class="line">        // 2. 发送通知</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:self];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        // 3. 启动 RunLoop</span><br><span class="line">        if (floor(NSFoundationVersionNumber) &lt;= NSFoundationVersionNumber_iOS_5_1) &#123;</span><br><span class="line">            // Make sure to run the runloop in our background thread so it can process downloaded data</span><br><span class="line">            // Note: we use a timeout to work around an issue with NSURLConnection cancel under iOS 5</span><br><span class="line">            //       not waking up the runloop, leading to dead threads (see https://github.com/rs/SDWebImage/issues/466)</span><br><span class="line">            CFRunLoopRunInMode(kCFRunLoopDefaultMode, 10, false);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            CFRunLoopRun();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 4. 执行取消清理工作</span><br><span class="line">        if (!self.isFinished) &#123;</span><br><span class="line">            [self.connection cancel];</span><br><span class="line">            [self connection:self.connection didFailWithError:[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorTimedOut userInfo:@&#123;NSURLErrorFailingURLErrorKey : self.request.URL&#125;]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123; // 5. connnection 初始化失败</span><br><span class="line">        if (self.completedBlock) &#123;</span><br><span class="line">            self.completedBlock(nil, nil, [NSError errorWithDomain:NSURLErrorDomain code:0 userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Connection can&apos;t be initialized&quot;&#125;], YES);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较难理解的是 RunLoop 的启动。在网上查了一些资料，有的人认为这里启动 RunLoop 是为了保证数据加载的流畅性，在滑动的时候不去加载数据。</p>
<p>但我的理解并不是这样，这个下载任务执行是在异步线程里面，与主线程毫无关系，不存在页面流畅不流畅的问题，如果要做到流畅，也应该是在最后调度到主线程的时候控制。再看注释里面有一句 “Make sure to run the runloop in our background thread so it can process downloaded data”，这句话的意思是说必须要启动 RunLoop 以保证它能够处理下载的数据，而下载的的数据是在 delegate 中进行回调处理的。所以我认为：<strong><code>SDWebImageDownloaderOperation</code>实现了<code>NSURLConnectionDataDelegate</code>协议并把自己设置为 connection 的 delegate，这里之所以启动 RunLoop，是为了保证<code>SDWebImageDownloaderOperation</code>运行在<code>start</code>方法中不退出，从而该对象不会被回收，否则一旦<code>start</code>方法执行完成，connection 就失去代理无法处理数据了。</strong></p>
<h3 id="代理实现"><a href="#代理实现" class="headerlink" title="代理实现"></a>代理实现</h3><p>再来看代理，代理有三个关键时间节点：</p>
<ol>
<li>初次获得响应，也就是连通服务器的时候；</li>
<li>接收数据的过程；</li>
<li>数据接收完成；</li>
</ol>
<p>这部分主要是网络相关的内容，在数据接收上没有什么大问题，关键是看数据的处理。下面一一分析。</p>
<h4 id="连接打通"><a href="#连接打通" class="headerlink" title="连接打通"></a>连接打通</h4><p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response &#123;</span><br><span class="line">    //&apos;304 Not Modified&apos; is an exceptional one</span><br><span class="line">    if (![response respondsToSelector:@selector(statusCode)] || ([((NSHTTPURLResponse *)response) statusCode] &lt; 400 &amp;&amp; [((NSHTTPURLResponse *)response) statusCode] != 304)) &#123;</span><br><span class="line">        NSInteger expected = response.expectedContentLength &gt; 0 ? (NSInteger)response.expectedContentLength : 0;</span><br><span class="line">        self.expectedSize = expected;</span><br><span class="line">        if (self.progressBlock) &#123;</span><br><span class="line">            self.progressBlock(0, expected);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        self.imageData = [[NSMutableData alloc] initWithCapacity:expected];</span><br><span class="line">        self.response = response;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadReceiveResponseNotification object:self];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        NSUInteger code = [((NSHTTPURLResponse *)response) statusCode];</span><br><span class="line">        //This is the case when server returns &apos;304 Not Modified&apos;. It means that remote image is not changed.</span><br><span class="line">        //In case of 304 we need just cancel the operation and return cached image from the cache.</span><br><span class="line">        if (code == 304) &#123;</span><br><span class="line">            [self cancelInternal];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            [self.connection cancel];</span><br><span class="line">        &#125;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:self];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        if (self.completedBlock) &#123;</span><br><span class="line">            self.completedBlock(nil, nil, [NSError errorWithDomain:NSURLErrorDomain code:[((NSHTTPURLResponse *)response) statusCode] userInfo:nil], YES);</span><br><span class="line">        &#125;</span><br><span class="line">        CFRunLoopStop(CFRunLoopGetCurrent());</span><br><span class="line">        [self done];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果响应正常，即 statusCode &lt; 400，并且不是 304，那么正常接收数据，否则 cancel 掉连接。关于 304 的实现，其实并没看太明白。在<code>SDWebImageDownloader.m</code>中初始化下载 request 的时候，有如下注释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise</span><br><span class="line">NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url cachePolicy:(options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData) timeoutInterval:timeoutInterval];</span><br><span class="line">request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);</span><br><span class="line">request.HTTPShouldUsePipelining = YES;</span><br></pre></td></tr></table></figure>
<p>除非开发者手动设置<code>SDWebImageDownloaderUseNSURLCache</code>选项，否则不会使用<code>NSURLRequestUseProtocolCachePolicy</code>缓存策略，否则会直接从服务端加载，系统是不会帮忙做缓存的，而在代码里面是没有看到手动解析保存请求的 Header 的地方的，因此如果不用系统缓存信息，并使用<code>NSURLRequestReloadRevalidatingCacheData</code>缓存策略，那 304 就不可能出现，所以这里 304 到底是什么效果，需要实际调试一把才能弄清楚。</p>
<blockquote>
<p>iOS 缓存可以参考：<a href="http://nshipster.cn/nsurlcache/" target="_blank" rel="noopener">NSURLCache</a></p>
<p>PS：一般图片变化后 URL 都会随之变化，请求图片要求服务端进行缓存验证的情况并不多见。</p>
</blockquote>
<h4 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h4><p>调用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码就不贴出来了，重点在于接收数据的过程中使用 ImageIO 实现渐进式图片加载，关于 ImageIO，可以参考文档 <a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/ImageIOGuide/imageio_basics/ikpg_basics.html" target="_blank" rel="noopener">Image I/O Programming Guide</a>。代码注释作者表明代码是来自网站 <a href="http://www.cocoaintheshell.com/" target="_blank" rel="noopener">http://www.cocoaintheshell.com/</a> 的，但貌似这个网站不存在了。</p>
<p>这段代码有一个小小的细节点需要注意，就是下载下来的图片会通过下面的方法进行拉伸变化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// SDWebImageCompat.m</span><br><span class="line">inline UIImage *SDScaledImageForKey(NSString *key, UIImage *image) &#123;</span><br><span class="line">    if (!image) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if ([image.images count] &gt; 0) &#123;</span><br><span class="line">        NSMutableArray *scaledImages = [NSMutableArray array];</span><br><span class="line"></span><br><span class="line">        for (UIImage *tempImage in image.images) &#123;</span><br><span class="line">            [scaledImages addObject:SDScaledImageForKey(key, tempImage)];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return [UIImage animatedImageWithImages:scaledImages duration:image.duration];</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        if ([[UIScreen mainScreen] respondsToSelector:@selector(scale)]) &#123;</span><br><span class="line">            CGFloat scale = [UIScreen mainScreen].scale;</span><br><span class="line">            if (key.length &gt;= 8) &#123;</span><br><span class="line">                NSRange range = [key rangeOfString:@&quot;@2x.&quot;];</span><br><span class="line">                if (range.location != NSNotFound) &#123;</span><br><span class="line">                    scale = 2.0;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                range = [key rangeOfString:@&quot;@3x.&quot;];</span><br><span class="line">                if (range.location != NSNotFound) &#123;</span><br><span class="line">                    scale = 3.0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            UIImage *scaledImage = [[UIImage alloc] initWithCGImage:image.CGImage scale:scale orientation:image.imageOrientation];</span><br><span class="line">            image = scaledImage;</span><br><span class="line">        &#125;</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即会根据屏幕分辨率以及图片 URL 中的特定字符”@2x.”和”@3x.”来进行图片的比例缩放。</p>
<h4 id="接收完成"><a href="#接收完成" class="headerlink" title="接收完成"></a>接收完成</h4><p>调用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">- (void)connectionDidFinishLoading:(NSURLConnection *)aConnection &#123;</span><br><span class="line">    SDWebImageDownloaderCompletedBlock completionBlock = self.completedBlock;</span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">        // 停掉 Loop</span><br><span class="line">        CFRunLoopStop(CFRunLoopGetCurrent());</span><br><span class="line">        self.thread = nil;</span><br><span class="line">        self.connection = nil;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:self];</span><br><span class="line">            [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadFinishNotification object:self];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 判断响应是否来自缓存</span><br><span class="line">    if (![[NSURLCache sharedURLCache] cachedResponseForRequest:_request]) &#123;</span><br><span class="line">        responseFromCached = NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (completionBlock) &#123;</span><br><span class="line">        // 如果响应是来自缓存，但是开发者又设置了忽略缓存响应的选项，则回调无图片</span><br><span class="line">        if (self.options &amp; SDWebImageDownloaderIgnoreCachedResponse &amp;&amp; responseFromCached) &#123;</span><br><span class="line">            completionBlock(nil, nil, nil, YES);</span><br><span class="line">        &#125; else if (self.imageData) &#123;</span><br><span class="line">            UIImage *image = [UIImage sd_imageWithData:self.imageData];</span><br><span class="line">            NSString *key = [[SDWebImageManager sharedManager] cacheKeyForURL:self.request.URL];</span><br><span class="line">            image = [self scaledImageForKey:key image:image];</span><br><span class="line">            </span><br><span class="line">            // 解码图片</span><br><span class="line">            // Do not force decoding animated GIFs</span><br><span class="line">            if (!image.images) &#123;</span><br><span class="line">                if (self.shouldDecompressImages) &#123;</span><br><span class="line">                    image = [UIImage decodedImageWithImage:image];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (CGSizeEqualToSize(image.size, CGSizeZero)) &#123;</span><br><span class="line">                completionBlock(nil, nil, [NSError errorWithDomain:SDWebImageErrorDomain code:0 userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Downloaded image has 0 pixels&quot;&#125;], YES);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                completionBlock(image, self.imageData, nil, YES);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            completionBlock(nil, nil, [NSError errorWithDomain:SDWebImageErrorDomain code:0 userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Image data is nil&quot;&#125;], YES);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    self.completionBlock = nil;</span><br><span class="line">    [self done];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码本身没有什么难懂的地方，但这里面涉及到一个有用的基本知识——<strong>图片类型判断</strong>，记录如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+ (NSString *)sd_contentTypeForImageData:(NSData *)data &#123;</span><br><span class="line">    uint8_t c;</span><br><span class="line">    [data getBytes:&amp;c length:1];</span><br><span class="line">    switch (c) &#123;</span><br><span class="line">        case 0xFF:</span><br><span class="line">            return @&quot;image/jpeg&quot;;</span><br><span class="line">        case 0x89:</span><br><span class="line">            return @&quot;image/png&quot;;</span><br><span class="line">        case 0x47:</span><br><span class="line">            return @&quot;image/gif&quot;;</span><br><span class="line">        case 0x49:</span><br><span class="line">        case 0x4D:</span><br><span class="line">            return @&quot;image/tiff&quot;;</span><br><span class="line">        case 0x52:</span><br><span class="line">            // R as RIFF for WEBP</span><br><span class="line">            if ([data length] &lt; 12) &#123;</span><br><span class="line">                return nil;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            NSString *testString = [[NSString alloc] initWithData:[data subdataWithRange:NSMakeRange(0, 12)] encoding:NSASCIIStringEncoding];</span><br><span class="line">            if ([testString hasPrefix:@&quot;RIFF&quot;] &amp;&amp; [testString hasSuffix:@&quot;WEBP&quot;]) &#123;</span><br><span class="line">                return @&quot;image/webp&quot;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以前虽然看过一些图片加载库并对比过不同格式的图片的参数，但没有整理过每种图片格式开头的魔法数字，这个函数表达的很清晰，以后如果有相关需求可以拿来直接使用。</p>
<blockquote>
<p>在 SDWebImage 库中，是需要根据不同的类型使用不同的解码方式生成图片的，读者有兴趣也可以看一下这部分代码。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上内容对 SDWebImage 加载图片的细节做了简单的分析描述。下面通过类图来大致整理一下前面提到的函数和功能实现位置（同样来自项目 Wiki）：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/SDWebImage 类关系图.png" alt="SDWebImage SDWebImage 类关系图"></div>

<p>经过前面的分析，可以系统看一下 SDWebImage 的核心模块：</p>
<ol>
<li><strong>UIView 模块</strong> 处于上图的左上角部分，通过 Category 为 UIView、UIImageView 和 UIButton 添加方法，衔接 SDWebImage 的功能；</li>
<li><strong>SDWebImageManager</strong> 处于上图的中心，它是获取图片流程的制定者，负责调度缓存获取和网络下载两种图片获取方式；</li>
<li><strong>SDImageCache</strong> 处于上图左下角，负责图片的内存缓存和磁盘缓存；</li>
<li><strong>下载模块</strong> 处于上图的右边部分，负责图片的下载；</li>
</ol>
<p>以上四个模块配合前面所说的流程，完成图片的加载、解码以及显示。</p>
<p>最后，SDWebImage 是我学习 iOS 以来分析的第一个流行开源库，因为之前研究过 Andorid 上的一些图片加载库，比如 UIL，Picasso 等，因此觉得分析这样一个库会比较得心应手，也相对有个参考，是一个比较好的学习机会，分析完成之后，对于 GCD，NSOperation，Block，RunLoop 等这样的基础概念有了更多的认识，也算达到了我的目的😁。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【译】ReactiveCocoa 入门教程（下半部分）]]></title>
      <url>http://www.timebridge.space/2017/01/17/RAC%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>翻译自：<a href="https://www.raywenderlich.com/62796/reactivecocoa-tutorial-pt2" target="_blank" rel="noopener">ReactiveCocoa Tutorial – The Definitive Introduction: Part 2/2</a></p>
<p>RAC 是 iOS 上一个函数响应式编程框架。通过本教程的上半部分学习，你应该知道如何将应用中的标准 Action 以及事件处理逻辑替换成可以发送事件的信号，也学会了如何转换、分割、组合这些信号。在下半部分教程中，我们将学习一些 RAC 的高级主题，包括：</p>
<ul>
<li>另外两种事件类型：error 和 completed</li>
<li>Throttling</li>
<li>Threading</li>
<li>Continuations</li>
<li>更多其他的…</li>
</ul>
<p>Let’s go!</p>
<h2 id="Twitter-Instant"><a href="#Twitter-Instant" class="headerlink" title="Twitter Instant"></a>Twitter Instant</h2><p>在下半部分教程中，你要开发的是一个叫做 Twitter Instant（来自 Google Instant 概念）的应用：一个 Twitter 即时搜索应用。<a id="more"></a></p>
<p><a href="https://koenig-media.raywenderlich.com/uploads/2014/01/TwitterInstant-Starter2.zip" target="_blank" rel="noopener">初始项目</a>中包含了一些基础的 UI 界面以及一些必须的代码。在教程的上班部分中，需要使用 CocoaPods 来获取 RAC 框架并集成进项目，这个初始项目已经包含必须的 Podfile，所以可以直接打开命令行执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod install</span><br></pre></td></tr></table></figure>
<blockquote>
<p>【译者注】这里编译打开初始项目的过程略去不译。</p>
</blockquote>
<p>编译运行后可以看到如下界面：</p>
<div align="center"><img src="https://koenig-media.raywenderlich.com/uploads/2014/01/TwitterInstantStarter.png" alt="ReactivePlayground应用示例图"></div>

<p>你可以花一点时间熟悉一下应用代码。这是一个非常简单的基于 UISplitViewController 的应用，左边是 <strong>RWSearchFormViewController</strong>，添加了少量的 UIControls，包括一个搜索框；右边是 <strong>RWSearchResultsViewController</strong>，继承于 <strong>UITableViewController</strong>。</p>
<p>打开 <strong>RWSearchResultsViewController.h</strong> 文件，你会看到<code>viewDidLoad</code>方法将右边展示搜索结果的 ViewController 赋值给了私有属性 <strong>resultsViewController</strong>，应用的大部分逻辑都在 <strong>RWSearchResultsViewController</strong> 中，这个属性会将搜索结果传递给 <strong>RWSearchResultsViewController</strong> 。</p>
<h2 id="Validating-the-Search-Text"><a href="#Validating-the-Search-Text" class="headerlink" title="Validating the Search Text"></a>Validating the Search Text</h2><p>我们要做的第一件事情就是验证搜索输入框的内容确保输入的内容长度大于 2，这对于上半部分的学习是一个很好的复习。在<strong>RWSearchFormViewController.m</strong> 的<code>viewDidLoad</code>方法之后添加如下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)isValidSearchText:(NSString *)text &#123;</span><br><span class="line">  return text.length &gt; 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在<code>viewDidLoad</code>方法的最后添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[self.searchText.rac_textSignal</span><br><span class="line">  map:^id(NSString *text) &#123;</span><br><span class="line">    return [self isValidSearchText:text] ?</span><br><span class="line">      [UIColor whiteColor] : [UIColor yellowColor];</span><br><span class="line">  &#125;]</span><br><span class="line">  subscribeNext:^(UIColor *color) &#123;</span><br><span class="line">    self.searchText.backgroundColor = color;</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
<p>来想想这段代码在做什么？</p>
<ul>
<li>获取输入框的内容信号</li>
<li>根据内容是否合法将这个信号对应的背景颜色值</li>
<li>将背景颜色值通过<code>subscribeNext:</code>的 block 设置为搜索输入框的背景；</li>
</ul>
<p>编译运行代码，就可以看到当输入过短的时候，输入框的颜色是黄色的：</p>
<div align="center"><img src="https://koenig-media.raywenderlich.com/uploads/2014/01/ValidatedTextField.png" alt="ReactivePlayground应用示例图"></div>

<p>以上逻辑用图片表达为：</p>
<div align="center"><img src="https://koenig-media.raywenderlich.com/uploads/2014/01/TextValidationPipeline.png" alt="ReactivePlayground应用示例图"></div>

<p><code>rac_textSignal</code>信号在每次输入框内容变化的时候释放携带当前搜索输入框输入内容的 next 事件，<code>map</code>则将输入内容转换为颜色，最终由<code>subscribeNext:</code>方法将颜色值设置为输入框的背景颜色。</p>
<p>当然，看过上半部分教程之后你肯定还记得这些，如果不记得了，最好回过头去好好看看上半部分教程。</p>
<p>在添加 Twitter 搜索逻辑之前，我们先讨论一些有意思的主题。</p>
<h2 id="Formatting-of-Pipelines"><a href="#Formatting-of-Pipelines" class="headerlink" title="Formatting of Pipelines"></a>Formatting of Pipelines</h2><p>当我们想要格式化 RAC 代码的时候，普遍的约定是每一个操作都新起一行，然后每一步都垂直对齐，下面就是之前示例的一个格式化展示：</p>
<div align="center"><img src="https://koenig-media.raywenderlich.com/uploads/2014/01/PipelineFormatting.png" alt="ReactivePlayground应用示例图"></div>

<p>这样这个管道是由哪些步骤组成的就一目了然。同时也要注意，每个 block 中的代码都要尽量少，超过一定行数之后最好使用一个私有的方法去表达。</p>
<blockquote>
<p>【译者注】如果 block 内容过长，会导致 RAC 代码的可阅读性大大降低。</p>
</blockquote>
<p>不幸的是 Xcode 并不支持这种风格的格式化，所以得开发者自己维护这样的缩进。</p>
<h2 id="Memory-Management"><a href="#Memory-Management" class="headerlink" title="Memory Management"></a>Memory Management</h2><p>回过头来看看我们添加到 <strong>TwitterInstant</strong> 应用中的代码，你是否会好奇你刚刚创建的管道是如何被维持在内存中的呢？它既没有被赋值给一个本地变量，也没有赋值给一个属性，是不是它的引用计数不会被增加，一定会被回收掉？</p>
<p>实际上 RAC 的设计目标之一就是允许创建匿名管道这样的编码方式，在前面我们写过的所有 RAC 代码中，这个特性显得自然直观。</p>
<p>为了支持这个模型，RAC 维护这自己的信号全局集合。如果一个信号有一个或者多个订阅者，则信号是激活状态，如果没有订阅者，则信号会被回收掉。这就引起了另外一个问题：我们如何取消订阅一个信号？在信号发送 error/completed 事件之后，订阅关系会被自动移除掉（后面会马上说到），而手动的取消订阅则可以通过<code>RACDisposable</code>来进行。</p>
<p>订阅<code>RACSignal</code>的时候都会返回一个<code>RACDisposable</code>实例，这个实例就允许开发者手动解除订阅关系，下面是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *backgroundColorSignal =</span><br><span class="line">  [self.searchText.rac_textSignal</span><br><span class="line">    map:^id(NSString *text) &#123;</span><br><span class="line">      return [self isValidSearchText:text] ?</span><br><span class="line">        [UIColor whiteColor] : [UIColor yellowColor];</span><br><span class="line">    &#125;];</span><br><span class="line"> </span><br><span class="line">RACDisposable *subscription =</span><br><span class="line">  [backgroundColorSignal</span><br><span class="line">    subscribeNext:^(UIColor *color) &#123;</span><br><span class="line">      self.searchText.backgroundColor = color;</span><br><span class="line">    &#125;];</span><br><span class="line"> </span><br><span class="line">// at some point in the future ...</span><br><span class="line">[subscription dispose];</span><br></pre></td></tr></table></figure>
<p>你会发现你很少去做这件事情，但是应该要知道这种操作的存在。</p>
<blockquote>
<p><strong>注意：</strong>由此推出，如果你创建了一个管道但是不去订阅它，那这个管道就永远不会执行，包括<code>doNext:</code>这样的 side-effect block。</p>
</blockquote>
<h2 id="Avoiding-Retain-Cycles"><a href="#Avoiding-Retain-Cycles" class="headerlink" title="Avoiding Retain Cycles"></a>Avoiding Retain Cycles</h2><p>RAC 虽然为此做了很多幕后工作，让开发者不必担心有关信号的内存管理，但是仍然有一种情况需要开发者注意。我们来看看前面添加的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[self.searchText.rac_textSignal</span><br><span class="line">  map:^id(NSString *text) &#123;</span><br><span class="line">    return [self isValidSearchText:text] ?</span><br><span class="line">      [UIColor whiteColor] : [UIColor yellowColor];</span><br><span class="line">  &#125;]</span><br><span class="line">  subscribeNext:^(UIColor *color) &#123;</span><br><span class="line">    self.searchText.backgroundColor = color;</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
<p><code>subscribeNext:</code> block 在内部使用了 self 来引用外部的输入框，block 持有对 self 的强引用，因此如果 self 对 block 也有强引用，那么就会形成一个循环引用。这个是否会引起问题取决于 self 对象本身，如果 self 贯穿应用的生命周期，就如上面的例子所示，那么这个问题就没那么严重，但是在更为复杂的情况下，恐怕就不是这样的了。</p>
<p>为了避免潜在的循环引用，苹果官方的文档 <a href="https://developer.apple.com/library/ios/documentation/cocoa/conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html#//apple_ref/doc/uid/TP40011210-CH8-SW16" target="_blank" rel="noopener">Working With Blocks</a> 建议在 block 中引用 self 的弱引用，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">__weak RWSearchFormViewController *bself = self; // Capture the weak reference</span><br><span class="line"> </span><br><span class="line">[[self.searchText.rac_textSignal</span><br><span class="line">  map:^id(NSString *text) &#123;</span><br><span class="line">    return [self isValidSearchText:text] ?</span><br><span class="line">      [UIColor whiteColor] : [UIColor yellowColor];</span><br><span class="line">  &#125;]</span><br><span class="line">  subscribeNext:^(UIColor *color) &#123;</span><br><span class="line">    bself.searchText.backgroundColor = color;</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
<p>bself 是指向 self 的使用 __weak 修饰的变量，也就是指向 self 的弱引用，而在<code>subscribeNext:</code> block 块中，我们把 self 替换成 bself，这样就打破了循环引用。不过这看上去并不那么优雅。</p>
<p>RAC 框架在这里玩了一点小把戏，我们可以导入以下头文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;RACEXTScope.h&quot;</span><br></pre></td></tr></table></figure>
<p>然后用下面的代码实现等同的效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@weakify(self)</span><br><span class="line">[[self.searchText.rac_textSignal</span><br><span class="line">  map:^id(NSString *text) &#123;</span><br><span class="line">    return [self isValidSearchText:text] ?</span><br><span class="line">      [UIColor whiteColor] : [UIColor yellowColor];</span><br><span class="line">  &#125;]</span><br><span class="line">  subscribeNext:^(UIColor *color) &#123;</span><br><span class="line">    @strongify(self)</span><br><span class="line">    self.searchText.backgroundColor = color;</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
<p><code>@weakify</code>和<code>@strongify</code>语句是定义在 <a href="https://github.com/jspahrsummers/libextobjc" target="_blank" rel="noopener">Extended Objective-C </a>中的宏，它们也被包含在了 RAC 框架中，<code>@weakify</code>宏允许你创建弱引用变量（如果有需要，还可以传入多个变量作为参数），<code>@strongify</code>宏则允许你根据之前传入<code>@weakify</code>的参数创建强引用。</p>
<blockquote>
<p><strong>注意：</strong>如果你对这两个宏的具体实现感兴趣，可以在 Xcode 中选择 <strong>Product-&gt;Perform Action-&gt;Preprocess “RWSearchForViewController”.</strong> 这会预处理一遍当前的 view controller，展开所有的宏，开发者将可以看到最终的输出。</p>
</blockquote>
<p>最后需要注意的是：在 block 内部使用实例变量也会造成 block 持有对 self 的强引用，你可以打开编译器的告警开关，在代码出现这种问题的时候警告你，在项目的 build settings 中搜索 retain 就可以看到这个选项：</p>
<div align="center"><img src="https://koenig-media.raywenderlich.com/uploads/2014/01/AvoidRetainSelf.png" alt="ReactivePlayground应用示例图"></div>

<p>好了，你应该已经掌握这个要点了，恭喜！现在你可以继续学习剩下的有趣部分了：为你的应用添加一些真正的功能。</p>
<blockquote>
<p>眼尖的读者肯定注意到这里实际不必使用<code>subscribeNext:</code>方法，使用 RAC 替代即可，如果你发现了这点，请改掉它，并奖励给自己一个亮闪闪的✨。</p>
</blockquote>
<h2 id="Requesting-Access-to-Twitter"><a href="#Requesting-Access-to-Twitter" class="headerlink" title="Requesting Access to Twitter"></a>Requesting Access to Twitter</h2><p>接下来你将要使用 <strong>Social Framework</strong> 让 TwitterInstant 应用搜索 Tweets，使用 <strong>Accounts Framework</strong> 来授权访问 Twitter。为了更好的了解 <strong>Social Framework</strong>，可以查看专门为此准备的章节：<a href="https://www.raywenderlich.com/?page_id=19968" target="_blank" rel="noopener">iOS 6 by Tutorials</a>。</p>
<p>在你添加这段代码之前，你需要将 Twitter 认证信息添加到模拟器或者运行应用的设备上。打开<strong>设置</strong>应用然后选择<strong>Twitter</strong>菜单选项，添加你的身份信息：</p>
<div align="center"><img src="https://koenig-media.raywenderlich.com/uploads/2014/01/TwitterCredentials.png" alt="ReactivePlayground应用示例图"></div>

<p>初始项目已经包含所需要的 Framework，所以你只需要导入 header 就好。在<code>RWSearchFormViewController.m</code>文件中，添加以下语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Accounts/Accounts.h&gt;</span><br><span class="line">#import &lt;Social/Social.h&gt;</span><br></pre></td></tr></table></figure>
<p>在<code>import</code>语句下面添加如下枚举类型和常量值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, RWTwitterInstantError) &#123;</span><br><span class="line">    RWTwitterInstantErrorAccessDenied,</span><br><span class="line">    RWTwitterInstantErrorNoTwitterAccounts,</span><br><span class="line">    RWTwitterInstantErrorInvalidResponse</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">static NSString * const RWTwitterInstantDomain = @&quot;TwitterInstant&quot;;</span><br></pre></td></tr></table></figure>
<p>接下去你会用这些枚举类型来定义一些错误。接着添加如下属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@property (strong, nonatomic) ACAccountStore *accountStore;</span><br><span class="line">@property (strong, nonatomic) ACAccountType *twitterAccountType;</span><br></pre></td></tr></table></figure>
<p><code>ACAccountStore</code>类可以帮助链接各种社交媒体账号，<code>ACAccountType</code>类代表一种特定类型的账号。</p>
<p>接着在<code>viewDidLoad</code>方法末尾添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.accountStore = [[ACAccountStore alloc] init];</span><br><span class="line">self.twitterAccountType = [self.accountStore </span><br><span class="line">  accountTypeWithAccountTypeIdentifier:ACAccountTypeIdentifierTwitter];</span><br></pre></td></tr></table></figure>
<p>这段代码创建了 account store 以及 Twitter 账号标记。</p>
<p>当一个 App 想要访问一个社交媒体账号，用户会看到一个弹窗，这是一个异步操作，因此将它包裹在信号中，是它变成响应式是很好的选择。我们在代码中添加如下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)requestAccessToTwitterSignal &#123;</span><br><span class="line"> </span><br><span class="line">  // 1 - define an error</span><br><span class="line">  NSError *accessError = [NSError errorWithDomain:RWTwitterInstantDomain</span><br><span class="line">                                             code:RWTwitterInstantErrorAccessDenied</span><br><span class="line">                                         userInfo:nil];</span><br><span class="line"> </span><br><span class="line">  // 2 - create the signal</span><br><span class="line">  @weakify(self)</span><br><span class="line">  return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    // 3 - request access to twitter</span><br><span class="line">    @strongify(self)</span><br><span class="line">    [self.accountStore</span><br><span class="line">       requestAccessToAccountsWithType:self.twitterAccountType</span><br><span class="line">         options:nil</span><br><span class="line">      completion:^(BOOL granted, NSError *error) &#123;</span><br><span class="line">          // 4 - handle the response</span><br><span class="line">          if (!granted) &#123;</span><br><span class="line">            [subscriber sendError:accessError];</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            [subscriber sendNext:nil];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    return nil;</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法做了以下事情：</p>
<ol>
<li>定义了一个 error，如果用户拒绝 App 访问账号，这个错误会被返回；</li>
<li>和上半部分教程一样，方法<code>createSignal</code>返回了<code>RACSignal</code>类的一个实例；</li>
<li>访问 Twitter 的请求是通过 account store 发出的，用户会看到一个弹窗来请求用户授予权限；</li>
<li>当用户授予 / 拒绝访问权限之后，信号就会被发送。如果授予了权限，next 事件之后会发送 completed 事件，如果请求被拒绝，error 事件会被发送；</li>
</ol>
<p>如果你还记得上半部分教程，其中提到过信号可以发送三种类型的事件：next、completed 和 error。在一个信号的生命周期中，它可以不发送任何事件，发送一个或者多个 next 事件并以一个 completed / error 事件结束。</p>
<p>最后，为了使用这个信号，将以下代码添加到<code>viewDidLoad</code>方法后面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[[self requestAccessToTwitterSignal]</span><br><span class="line">  subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;Access granted&quot;);</span><br><span class="line">  &#125; error:^(NSError *error) &#123;</span><br><span class="line">    NSLog(@&quot;An error occurred: %@&quot;, error);</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
<p>编译运行代码，将会看到以下弹窗：</p>
<div align="center"><img src="https://koenig-media.raywenderlich.com/uploads/2014/01/RequestAccessToTwitter.png" alt="ReactivePlayground应用示例图"></div>

<p>如果你点击 <strong>OK</strong>，控制台会输出：Access granted；点击 <strong>Don’t Allow</strong>，控制台会输出：An error occurred:xxx。</p>
<p>Accounts Framework 会记住你的选择，因此如果需要测试两种情况，需要重置 <strong>iOS Simulator -&gt; Reset Contents and Settings</strong> 菜单选项，这会有点麻烦，因为你必须再输入一遍你的 Twitter 账号。</p>
<h2 id="Chaining-Signals"><a href="#Chaining-Signals" class="headerlink" title="Chaining Signals"></a>Chaining Signals</h2><p>一旦用户授予 Twitter 账号权限，应用就需要持续的监听搜索输入框的变化，及时搜索 Twitter。在 <code>viewDidLoad</code>方法最后添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[[[self requestAccessToTwitterSignal]</span><br><span class="line">  then:^RACSignal *&#123;</span><br><span class="line">    @strongify(self)</span><br><span class="line">    return self.searchText.rac_textSignal;</span><br><span class="line">  &#125;]</span><br><span class="line">  subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">  &#125; error:^(NSError *error) &#123;</span><br><span class="line">    NSLog(@&quot;An error occurred: %@&quot;, error);</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
<p><code>then</code>方法会在收到 completed 事件之后，立刻订阅由<code>then</code>返回的信号，用于高效的从订阅一个信号转移到订阅另外一个。</p>
<blockquote>
<p><strong>注意：</strong>前面已经声明了一个@weakify(self)，这里不用重复声明。</p>
</blockquote>
<p>error 事件会穿过<code>then</code>方法，因此后面的<code>subscribeNext:error:</code>  block 依然能够接收到前面权限请求所发出的 error 事件。</p>
<p>编译运行代码，然后授予权限。在输入搜索内容的同时，可以看到控制台的如下输出：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2014-01-04 08:16:11.444 TwitterInstant[39118:a0b] m</span><br><span class="line">2014-01-04 08:16:12.276 TwitterInstant[39118:a0b] ma</span><br><span class="line">2014-01-04 08:16:12.413 TwitterInstant[39118:a0b] mag</span><br><span class="line">2014-01-04 08:16:12.548 TwitterInstant[39118:a0b] magi</span><br><span class="line">2014-01-04 08:16:12.628 TwitterInstant[39118:a0b] magic</span><br><span class="line">2014-01-04 08:16:13.172 TwitterInstant[39118:a0b] magic!</span><br></pre></td></tr></table></figure>
<p>接着，可以为管道添加过滤器，过滤非法的搜索关键字，在这里我们定义搜索字符数少于3个即为非法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[[[[self requestAccessToTwitterSignal]</span><br><span class="line">  then:^RACSignal *&#123;</span><br><span class="line">    @strongify(self)</span><br><span class="line">    return self.searchText.rac_textSignal;</span><br><span class="line">  &#125;]</span><br><span class="line">  filter:^BOOL(NSString *text) &#123;</span><br><span class="line">    @strongify(self)</span><br><span class="line">    return [self isValidSearchText:text];</span><br><span class="line">  &#125;]</span><br><span class="line">  subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">  &#125; error:^(NSError *error) &#123;</span><br><span class="line">    NSLog(@&quot;An error occurred: %@&quot;, error);</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
<p>下图展示了当前的管道逻辑：</p>
<div align="center"><img src="https://koenig-media.raywenderlich.com/uploads/2014/01/PipelineWithThen.png" alt="ReactivePlayground应用示例图"></div>

<p>应用程序管道由<code>requestAccessToTwitterSignal</code>开始，然后切换到<code>rac_textSignal</code>信号，同时，next 类型事件经过<code>filter</code>方法过滤，最终到达订阅 block，你可以看到第一步触发的 error 事件还是会被最后的<code>subscribeNext:error:</code> block 消费。</p>
<blockquote>
<p>【译者注】error 事件的这种特性使得管道可以在一个统一的地方处理错误。</p>
</blockquote>
<p>既然已经有了一个信号用于通知搜索内容的变化，那接下来是时候用它来搜索 Twitter 了！你觉得有趣吗？我觉得应该是觉得有趣的，因为你已经真正了解一些东西了。</p>
<h2 id="Searching-Twitter"><a href="#Searching-Twitter" class="headerlink" title="Searching Twitter"></a>Searching Twitter</h2><p><strong>Social Framework</strong> 是获取 Twitter 搜索 API 的一种渠道。然而 <strong>Social Framework</strong> 并不是响应式的，我们要做的就是用信号去包裹这些 API。你现在应该去掌握这样做的窍门了！</p>
<p>在<code>RWSearchFormViewController.m</code>内部，添加如下的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (SLRequest *)requestforTwitterSearchWithText:(NSString *)text &#123;</span><br><span class="line">  NSURL *url = [NSURL URLWithString:@&quot;https://api.twitter.com/1.1/search/tweets.json&quot;];</span><br><span class="line">  NSDictionary *params = @&#123;@&quot;q&quot; : text&#125;;</span><br><span class="line"> </span><br><span class="line">  SLRequest *request =  [SLRequest requestForServiceType:SLServiceTypeTwitter</span><br><span class="line">                                           requestMethod:SLRequestMethodGET</span><br><span class="line">                                                     URL:url</span><br><span class="line">                                              parameters:params];</span><br><span class="line">  return request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用 <a href="https://dev.twitter.com/docs/api/1.1" target="_blank" rel="noopener">v1.1 REST API</a> 创建了一个搜索 Twitter 的请求，以上代码使用 <strong>q</strong> 关键字来搜索包含输入内容的 Twitter，你可以从  <a href="https://dev.twitter.com/docs/api/1.1/get/search/tweets" target="_blank" rel="noopener">Twitter API docs</a> 中了解更多关于搜索 API 的细节。</p>
<p>下面一步就是基于这个请求创建一个信号，添加如下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)signalForSearchWithText:(NSString *)text &#123;</span><br><span class="line"> </span><br><span class="line">  // 1 - define the errors</span><br><span class="line">  NSError *noAccountsError = [NSError errorWithDomain:RWTwitterInstantDomain</span><br><span class="line">                                                 code:RWTwitterInstantErrorNoTwitterAccounts</span><br><span class="line">                                             userInfo:nil];</span><br><span class="line"> </span><br><span class="line">  NSError *invalidResponseError = [NSError errorWithDomain:RWTwitterInstantDomain</span><br><span class="line">                                                      code:RWTwitterInstantErrorInvalidResponse</span><br><span class="line">                                                  userInfo:nil];</span><br><span class="line"> </span><br><span class="line">  // 2 - create the signal block</span><br><span class="line">  @weakify(self)</span><br><span class="line">  return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    @strongify(self);</span><br><span class="line"> </span><br><span class="line">    // 3 - create the request</span><br><span class="line">    SLRequest *request = [self requestforTwitterSearchWithText:text];</span><br><span class="line"> </span><br><span class="line">    // 4 - supply a twitter account</span><br><span class="line">    NSArray *twitterAccounts = [self.accountStore</span><br><span class="line">      accountsWithAccountType:self.twitterAccountType];</span><br><span class="line">    if (twitterAccounts.count == 0) &#123;</span><br><span class="line">      [subscriber sendError:noAccountsError];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      [request setAccount:[twitterAccounts lastObject]];</span><br><span class="line"> </span><br><span class="line">      // 5 - perform the request</span><br><span class="line">      [request performRequestWithHandler: ^(NSData *responseData,</span><br><span class="line">                                          NSHTTPURLResponse *urlResponse, NSError *error) &#123;</span><br><span class="line">        if (urlResponse.statusCode == 200) &#123;</span><br><span class="line"> </span><br><span class="line">          // 6 - on success, parse the response</span><br><span class="line">          NSDictionary *timelineData =</span><br><span class="line">             [NSJSONSerialization JSONObjectWithData:responseData</span><br><span class="line">                                             options:NSJSONReadingAllowFragments</span><br><span class="line">                                               error:nil];</span><br><span class="line">          [subscriber sendNext:timelineData];</span><br><span class="line">          [subscriber sendCompleted];</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">          // 7 - send an error on failure</span><br><span class="line">          [subscriber sendError:invalidResponseError];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return nil;</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码执行的功能步骤如下：</p>
<ol>
<li>首先定义了一些不同的 error，一个用于表示用户没有添加任何的 Twitter 账号，一个用于表示查询出错；</li>
<li>创建信号；</li>
<li>利用前面添加的方法创建一个请求；</li>
<li>查询 account store 的第一个账号，如果没有任何账号可查询，报错；</li>
<li>执行请求；</li>
<li>如果请求正确返回（Http Status Code 为 200），解析返回的 JSON 数据，发送 next 事件和 completed 事件；</li>
<li>如果请求失败，发送 error 事件；</li>
</ol>
<p>现在我们来使用这个新创建的信号。在本教程的上半部分，你学会了使用<code>flattenMap</code>方法来”扁平化”信号，现在又到了这个方法施展身手的时候，在<code>viewDidLoad</code>方法的结尾，添加<code>flattenMap</code>方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[[[[[self requestAccessToTwitterSignal]</span><br><span class="line">  then:^RACSignal *&#123;</span><br><span class="line">    @strongify(self)</span><br><span class="line">    return self.searchText.rac_textSignal;</span><br><span class="line">  &#125;]</span><br><span class="line">  filter:^BOOL(NSString *text) &#123;</span><br><span class="line">    @strongify(self)</span><br><span class="line">    return [self isValidSearchText:text];</span><br><span class="line">  &#125;]</span><br><span class="line">  flattenMap:^RACStream *(NSString *text) &#123;</span><br><span class="line">    @strongify(self)</span><br><span class="line">    return [self signalForSearchWithText:text];</span><br><span class="line">  &#125;]</span><br><span class="line">  subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">  &#125; error:^(NSError *error) &#123;</span><br><span class="line">    NSLog(@&quot;An error occurred: %@&quot;, error);</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
<p>编译运行代码，在搜索框中输入搜索内容，一旦字符长度大于等于 3 个，你就可以在控制台看到 Twitter 的搜索返回结果：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">2014-01-05 07:42:27.697 TwitterInstant[40308:5403] &#123;</span><br><span class="line">    "search_metadata" =     &#123;</span><br><span class="line">        "completed_in" = "0.019";</span><br><span class="line">        count = 15;</span><br><span class="line">        "max_id" = 419735546840117248;</span><br><span class="line">        "max_id_str" = 419735546840117248;</span><br><span class="line">        "next_results" = "?max_id=419734921599787007&amp;q=asd&amp;include_entities=1";</span><br><span class="line">        query = asd;</span><br><span class="line">        "refresh_url" = "?since_id=419735546840117248&amp;q=asd&amp;include_entities=1";</span><br><span class="line">        "since_id" = 0;</span><br><span class="line">        "since_id_str" = 0;</span><br><span class="line">    &#125;;</span><br><span class="line">    statuses =     (</span><br><span class="line">                &#123;</span><br><span class="line">            contributors = "<span class="tag">&lt;<span class="name">null</span>&gt;</span>";</span><br><span class="line">            coordinates = "<span class="tag">&lt;<span class="name">null</span>&gt;</span>";</span><br><span class="line">            "created_at" = "Sun Jan 05 07:42:07 +0000 2014";</span><br><span class="line">            entities =             &#123;</span><br><span class="line">                hashtags = ...</span><br></pre></td></tr></table></figure>
<h2 id="Threading"><a href="#Threading" class="headerlink" title="Threading"></a>Threading</h2><p>我想你一定非常迫切的想要在 UI 上展示搜搜得到的数据，但是在此之前你还有一件事情要做，想知道要做什么，我们得做点小实验。</p>
<p>在<code>subscribeNext:error:</code>的 block 中添加断点，如下图所示：</p>
<div align="center"><img src="https://koenig-media.raywenderlich.com/uploads/2014/01/BreakpointLocation.png" alt="ReactivePlayground应用示例图"></div>

<p>重新运行程序，如果有必要重新输入 Twitter 的认证信息，输入一些搜索内容，然后就运行到断电处了，类似下面：</p>
<div align="center"><img src="https://koenig-media.raywenderlich.com/uploads/2014/01/BreakpointResult.png" alt="ReactivePlayground应用示例图"></div>

<p>我们观察到这段代码并没有运行在主线程（Thread 1）上，而我们首先应当记住的就是只能在主线程更新 UI，因此如果你要展示数据，就必须切换线程。</p>
<p>这里引出了 RAC 框架的一个关键点：以上的代码运行在事件发送的线程上。可以尝试在管道的其余步骤上议案家断点：你会发现它们运行在不止一条线程上。</p>
<p>所以你该如何更新 UI 呢？经典做法就是使用 Operation Queue（参见教程 <a href="https://www.raywenderlich.com/?p=19788" target="_blank" rel="noopener">How To Use NSOperations and NSOperationQueues</a>），但是 RAC 本身提供了更为简单的方法 —— <code>deliverOn:</code>，更新代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[[[[[[self requestAccessToTwitterSignal]</span><br><span class="line">  then:^RACSignal *&#123;</span><br><span class="line">    @strongify(self)</span><br><span class="line">    return self.searchText.rac_textSignal;</span><br><span class="line">  &#125;]</span><br><span class="line">  filter:^BOOL(NSString *text) &#123;</span><br><span class="line">    @strongify(self)</span><br><span class="line">    return [self isValidSearchText:text];</span><br><span class="line">  &#125;]</span><br><span class="line">  flattenMap:^RACStream *(NSString *text) &#123;</span><br><span class="line">    @strongify(self)</span><br><span class="line">    return [self signalForSearchWithText:text];</span><br><span class="line">  &#125;]</span><br><span class="line">  deliverOn:[RACScheduler mainThreadScheduler]]</span><br><span class="line">  subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">  &#125; error:^(NSError *error) &#123;</span><br><span class="line">    NSLog(@&quot;An error occurred: %@&quot;, error);</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
<p>现在再运行程序，就可以看到断点处是在主线程上执行了：</p>
<div align="center"><img src="https://koenig-media.raywenderlich.com/uploads/2014/01/BreakpointNowOnUIThread.png" alt="ReactivePlayground应用示例图"></div>

<p>纳尼？调度到另外一个线程处理事件流就这么简单？不可思议！现在你可以放心的刷新你的 UI 了！</p>
<blockquote>
<p><strong>注意：</strong>读者可以去详细了解一下 RACScheduler 类。</p>
</blockquote>
<p>现在是时候展示 tweets 了。</p>
<h2 id="Updating-the-UI"><a href="#Updating-the-UI" class="headerlink" title="Updating  the UI"></a>Updating  the UI</h2><p>打开<code>RWSearchResultsViewController.h</code>文件你会发现这里已经有一个<code>displayTweets:</code>方法了，它会让右边的 View Controller 去显示相应的 tweet 数组。实现非常简单，只是填充一个 UITableView 的数据源。该方法期望的参数是一个<code>RWTweet</code>数组，这个类也已经在项目中提供好了。</p>
<p>现在到达<code>subscibeNext:error:</code>这一步的数据是一个 NSDictionary，所以你要怎么解析它的内容呢？</p>
<p>如果你去看 <a href="https://dev.twitter.com/docs/api/1.1/get/search/tweets" target="_blank" rel="noopener">Twitter API documentation</a>，你会看到一个结果响应示例：它就展示了 NSDictionary 的结构，所以你可以发现它有一个 key 叫做 statuses，其中包含着 tweet 数组，数组的内容也是一个个 NSDictionary 实例。而 <code>RWTweet</code>类已经包含解析这个 NSDictionary 的过程了，因此你要做的就是写一个循环，将返回消息里面的 statuses 数组转换为 RWTweet 数组。</p>
<p>但是你甚至连这个都不用做，我们还有更好的解决方案。本教程是有关 RAC 以及 函数式编程的，通过函数式 API 将数据从一种类型转化为另外一种类型会更加优雅，我们将使用 <a href="https://github.com/ColinEberhardt/LinqToObjectiveC" target="_blank" rel="noopener">LinqToObjectiveC</a> 来完成这个任务。</p>
<blockquote>
<p>【译者注】具体怎么引入这个库这里就略过不译了。</p>
</blockquote>
<p>在<code>RWSearchFormViewController.m</code>文件中添加如下文件引入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;RWTweet.h&quot;</span><br><span class="line">#import &quot;NSArray+LinqExtensions.h&quot;</span><br></pre></td></tr></table></figure>
<p><code>NSArray+LinqExtensions.h</code>头文件来自 <strong>LinqToObjectiveC</strong>，它往 NSArray 中添加了一些方法让你可以变换、排序、分析、过滤数组中的数据，并且也是链式的！现在我们就来使用这个 API，更换<code>viewDidLoad</code>方法最后的管道代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[[[[[[self requestAccessToTwitterSignal]</span><br><span class="line">  then:^RACSignal *&#123;</span><br><span class="line">    @strongify(self)</span><br><span class="line">    return self.searchText.rac_textSignal;</span><br><span class="line">  &#125;]</span><br><span class="line">  filter:^BOOL(NSString *text) &#123;</span><br><span class="line">    @strongify(self)</span><br><span class="line">    return [self isValidSearchText:text];</span><br><span class="line">  &#125;]</span><br><span class="line">  flattenMap:^RACStream *(NSString *text) &#123;</span><br><span class="line">    @strongify(self)</span><br><span class="line">    return [self signalForSearchWithText:text];</span><br><span class="line">  &#125;]</span><br><span class="line">  deliverOn:[RACScheduler mainThreadScheduler]]</span><br><span class="line">  subscribeNext:^(NSDictionary *jsonSearchResult) &#123;</span><br><span class="line">    NSArray *statuses = jsonSearchResult[@&quot;statuses&quot;];</span><br><span class="line">    NSArray *tweets = [statuses linq_select:^id(id tweet) &#123;</span><br><span class="line">      return [RWTweet tweetWithStatus:tweet];</span><br><span class="line">    &#125;];</span><br><span class="line">    [self.resultsViewController displayTweets:tweets];</span><br><span class="line">  &#125; error:^(NSError *error) &#123;</span><br><span class="line">    NSLog(@&quot;An error occurred: %@&quot;, error);</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
<p>如上面的代码所示，我们优雅地将原始的 NSDictionary 数据转换成了 RWTweet 对象。一旦转变完成，我们就可以在 result view controller 上展示对应的数据了。</p>
<p>编译运行代码，搜索之后就可以看到类似的 UI：</p>
<div align="center"><img src="https://koenig-media.raywenderlich.com/uploads/2014/01/FinallyWeSeeTweets.png" alt="ReactivePlayground应用示例图"></div>

<blockquote>
<p><strong>注意：</strong> RAC 和 LinqToObjectiveC 有着相似的思想。</p>
</blockquote>
<h2 id="Asynchronous-Loading-of-Images"><a href="#Asynchronous-Loading-of-Images" class="headerlink" title="Asynchronous Loading of Images"></a>Asynchronous Loading of Images</h2><p>你或许已经发现每一调 tweet 的左侧有一块很大的空白，这块地方实际是用于展示 Twitter 的用户头像的。RWTweet 类中实际已经有一个<code>profileImageUrl</code>属性用于记录获取头像的 URL 了，为了能够让 UITableView 流畅的滚动，我们需要保证头像获取的代码不在主线程上执行，这可以使用 GCD 或者 NSOperationQueue 来达到目的，但是为什么不使用 RAC 呢？</p>
<p>打开 <strong>RWSearchResultsViewController.m</strong> 文件，在最后添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-(RACSignal *)signalForLoadingImage:(NSString *)imageUrl &#123;</span><br><span class="line"> </span><br><span class="line">  RACScheduler *scheduler = [RACScheduler</span><br><span class="line">                         schedulerWithPriority:RACSchedulerPriorityBackground];</span><br><span class="line"> </span><br><span class="line">  return [[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:imageUrl]];</span><br><span class="line">    UIImage *image = [UIImage imageWithData:data];</span><br><span class="line">    [subscriber sendNext:image];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    return nil;</span><br><span class="line">  &#125;] subscribeOn:scheduler];</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对这种模式，你应该非常熟悉了。以上代码获取到了一个后台调度器用于调度信号执行的线程，让它不要在主线程上执行，接着它创建了一个信号用于下载图像数据并创建 UIImage，最后是调用<code>subscribeOn:</code>方法，用于保证信号是执行在指定的调度器上的。</p>
<p>现在在同一个文件中，更新<code>tableView:cellForRowAtIndex:</code>方法，在<code>return</code>语句之前添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cell.twitterAvatarView.image = nil;</span><br><span class="line"> </span><br><span class="line">[[[self signalForLoadingImage:tweet.profileImageUrl]</span><br><span class="line">  deliverOn:[RACScheduler mainThreadScheduler]]</span><br><span class="line">  subscribeNext:^(UIImage *image) &#123;</span><br><span class="line">   cell.twitterAvatarView.image = image;</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
<p>以上代码首先重置了 cell 的图片，因为 cell 会被重用，很有可能携带者过期的数据，然后它创建了对应的信号来获取数据，<code>deliverOn:</code>管道步骤用于将<code>subscriberNext:</code>的 block 调度到主线程进行。</p>
<p>编译运行代码，可以看到如下的展示：</p>
<div align="center"><img src="https://koenig-media.raywenderlich.com/uploads/2014/01/AvatarsAtAlast.png" alt="ReactivePlayground应用示例图"></div>

<h2 id="Throttling"><a href="#Throttling" class="headerlink" title="Throttling"></a>Throttling</h2><p>你或许已经发现每次输入一个新字符，应用都会理解发起一个 Twitter 搜索。如果你是一个快速输入者（或者只是长按着删除键），这会导致应用在短时间内发起大量请求，这并不是合理的：首先，这会对 Twitter 的搜索 API 造成压力，并且大部分的搜索结果都被丢弃了；其次，频繁的更新界面对于用户来说也是很烦人的一件事儿。</p>
<p>一个比较好的方案是在输入框的内容一段时间不变化之后再去发起搜索，比如，500ms。如你所想，RAC 又为此提供了简单的难以置信的解决方案！</p>
<p>打开<code>RWSearchFormViewController.m</code>，更新前面的管道代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[[[[[[[self requestAccessToTwitterSignal]</span><br><span class="line">  then:^RACSignal *&#123;</span><br><span class="line">    @strongify(self)</span><br><span class="line">    return self.searchText.rac_textSignal;</span><br><span class="line">  &#125;]</span><br><span class="line">  filter:^BOOL(NSString *text) &#123;</span><br><span class="line">    @strongify(self)</span><br><span class="line">    return [self isValidSearchText:text];</span><br><span class="line">  &#125;]</span><br><span class="line">  throttle:0.5]</span><br><span class="line">  flattenMap:^RACStream *(NSString *text) &#123;</span><br><span class="line">    @strongify(self)</span><br><span class="line">    return [self signalForSearchWithText:text];</span><br><span class="line">  &#125;]</span><br><span class="line">  deliverOn:[RACScheduler mainThreadScheduler]]</span><br><span class="line">  subscribeNext:^(NSDictionary *jsonSearchResult) &#123;</span><br><span class="line">    NSArray *statuses = jsonSearchResult[@&quot;statuses&quot;];</span><br><span class="line">    NSArray *tweets = [statuses linq_select:^id(id tweet) &#123;</span><br><span class="line">      return [RWTweet tweetWithStatus:tweet];</span><br><span class="line">    &#125;];</span><br><span class="line">    [self.resultsViewController displayTweets:tweets];</span><br><span class="line">  &#125; error:^(NSError *error) &#123;</span><br><span class="line">    NSLog(@&quot;An error occurred: %@&quot;, error);</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
<p><code>throttle</code>操作在收到一个 next 事件之后，如果一定时间内还没有收到下一个 next 事件，才会发送当前这个 next 事件。这真的非常简单。</p>
<p>编译运行代码，我们就可以看到效果，体验好多了是不是？</p>
<p>然后…到这里我们就完成了 Tweet Instant 应用的开发，回顾一下然后尽情地享受吧！同样的，如果有哪款地方有所遗漏或者不明白的，可以下载最终的代码：<a href="https://koenig-media.raywenderlich.com/uploads/2014/01/TwitterInstant-Final.zip" target="_blank" rel="noopener">final project</a>（记得运行<code>pod install</code>命令），或者直接从 <a href="https://github.com/ColinEberhardt/RWTwitterInstant" target="_blank" rel="noopener">GitHub</a> clone，每一个 commit 都对应着上面的一个步骤。</p>
<h2 id="Wrap-Up"><a href="#Wrap-Up" class="headerlink" title="Wrap Up"></a>Wrap Up</h2><p>在离开之前，我们有必要看一下最终整个应用的管道：</p>
<div align="center"><img src="https://koenig-media.raywenderlich.com/uploads/2014/01/CompletePipeline.png" alt="ReactivePlayground应用示例图"></div>

<p>这个流程非常的复杂，但是我们使用一根响应式管道就表达清楚了，看起来非常漂亮，不是吗？你能想象不用 RAC 这个应用会变得多么复杂么，它的流程又会变得多么难以理清？你现在再也不用经历这些了！</p>
<p>现在你应该知道 RAC 是多么的令人惊讶了！</p>
<p>最后一点，RAC 使得 MVVM（更好的分离应用逻辑和视图逻辑）的应用更为简单了，如果有人希望能看到如何使用 RAC 来实现 MVVM，请在评论里让我知道，我很希望听到你们的想法以及经历！</p>
<h2 id="译者总结"><a href="#译者总结" class="headerlink" title="译者总结"></a>译者总结</h2><p>这两篇文章虽然没有讲太多的理论，也没有对某个函数做深入的探讨，但是确实改变了我对响应式编程的看法。</p>
<p>如果你写过 Android，为 Button 添加监听的代码一般如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 点击事件发生</span></span><br><span class="line">		<span class="comment">// BLABLA...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这种方法称为 <strong>Callback</strong>。如果你写过 iOS 代码，那么为 UIButton 添加监听事件的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[button addTarget:self action:@selector(buttonClicked:) forControlEvents:UIControlEventTouchUpInside];</span><br></pre></td></tr></table></figure>
<p>当然还要为此声明并实现一个<code>buttonClicked:</code>私有方法用于处理点击事件，这种方法称为 <strong>Target-Action</strong>。</p>
<p>这两种机制虽然叫法不一样，但我认为两者本质上都是一样的（且不讨论方法调用和消息发送），响应式编程也是使用的同样的机制 —— 就是 <strong>观察者模式</strong>。不觉得<code>subscribe</code>的过程就是<code>addListener</code>的过程么？</p>
<blockquote>
<p>PS：这里忽略所谓的观察者模式和监听回调模式的区别，个人认为做这种区分毫无意义。</p>
</blockquote>
<p>这种典型的做法已经可以满足大部分的需求了，但是又存在什么问题呢？</p>
<ul>
<li>相比较于 Android，iOS 的这种方式我是比较反感的，每次写这行代码我都得先去声明一个方法，查看代码的时候得跳转到方法体中查看方法逻辑然后再回来继续往下查看，Android 将绑定过程和绑定的内容放在一块儿，阅读起来更加方便；</li>
<li>即使 Android 能够为 “为 View 添加监听事件” 这样的事情提供比较优雅的方案，但是在 Android 上仍然存在一些恶心的长流程，当你想要去了解这个流程的时候，需要到处跳转代码查看；</li>
</ul>
<p>总结一下：<strong>非响应式代码的逻辑分散，不易阅读</strong>。这就是响应式编码所要解决的问题！<strong>响应式编码的价值在于：</strong></p>
<p>1）通过定义 next、error、complete 三种类型的事件规范了事件的表达；</p>
<p>2）建立事件流概念；</p>
<p>3）在事件流基础上建立了一系列的函数用于操作事件和事件流；</p>
<p>响应式编码会定义一个事件源，或者称之为 Signal；事件除了类型之外，还会携带任意类型的数据。当事件被触发之后（比如按钮被点击），事件源就会通过发送事件来告诉订阅者，这一点和前面 Andorid 的示例并无区别，甚至实现起来代码形式都差不多。但是关键在于：<strong>响应式编码定义的操作是可以将一个信号源转换为另外一种信号源，换言之，它可以发送完全不同的事件出来，也可以将事件的数据处理成另外一种格式的数据再进行传送。</strong>回顾一张<a href="http://timebridge.space/2017/01/16/RAC/" target="_blank" rel="noopener">【译】ReactiveCocoa 入门教程（上半部分）</a>中的图：</p>
<div align="center"><img src="https://koenig-media.raywenderlich.com/uploads/2014/01/CombinePipeline.png" alt="RAC 数据流图"></div>

<p>如图，ran_textSignal 就是事件源，它发送的事件携带的数据是 NSString 类型的，经过<code>map</code>操作之后会变成 BOOL 类型，再经过一次<code>map</code>操作之后就会变成 UIColor 类型。从图中还可以看出：username 和 password 这两个信号源发出的时事件经过<code>combineLatest:reduce</code>操作之后会被合并为一个携带 BOOL 类型数据的事件。这种<strong>事件/事件流的变换操作正是响应式编程的核心能力</strong>！通过这种能力是可以比较优雅的解决掉前面提到的问题的（之所以说“比较优雅”，是因为要理解响应式编程定义的各种操作并不是一件容易的事情）。</p>
<p>以上，是我理解的响应式编程的精髓。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【译】ReactiveCocoa 入门教程（上半部分）]]></title>
      <url>http://www.timebridge.space/2017/01/16/RAC/</url>
      <content type="html"><![CDATA[<p>翻译自：<a href="https://www.raywenderlich.com/62699/reactivecocoa-tutorial-pt1" target="_blank" rel="noopener">ReactiveCocoa Tutorial – The Definitive Introduction: Part 1/2</a></p>
<blockquote>
<p>在网上看了很多的文章，大部分都是例子堆砌或者理论堆砌，只有这篇文章，虽然没有理论描述，但是通过两个 App 的改造和开发过程，详细的展示了 RAC 的优点以及使用场景，娓娓道来，理解起来比较容易。</p>
</blockquote>
<p>作为一个 iOS 开发者，你写的每行代码几乎都是用于响应某个时间：一个按钮点击事件、一个网络回复的消息、一个属性变化事件（KVO）或者是因为位置变化而收到的系统通知，这些都是很好的例子。然而，这些事件的通知都被包装秤不同的方式进行：Action、delegate、KVO 以及 callback 等等。<a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="noopener">ReactiveCocoa </a>为事件的响应定义了一套标准的接口，这样处理/过滤/组合起事件来会变得更加简单。</p>
<p>听起来是不是有点费解？还是有点好奇，有点激动？那就继续往下读吧:-D。</p>
<p>ReactiveCocoa 组合了一些编码风格：</p>
<ul>
<li><strong><a href="http://en.wikipedia.org/wiki/Functional_programming" target="_blank" rel="noopener">Functional Programming</a></strong> 使用了其中的高阶函数，也就是以函数作为函数的参数</li>
<li><strong><a href="http://en.wikipedia.org/wiki/Reactive_programming" target="_blank" rel="noopener">Reactive Programming</a></strong> 关注数据流以及变化的通知<a id="more"></a></li>
</ul>
<blockquote>
<p>【译者注】实际上远不止这些，要理解好 RAC，可以多看看函数式编程和响应式编程这两种编码思想，这里作者简化了理论描述。</p>
</blockquote>
<p>因为融合了两种编码风格的思想，因此 ReactiveCocoa 又被描述为<strong>函数响应式编程（Functional Reactive Programming，简称 FRP）</strong>框架。</p>
<p>好了，相关理论到此为止，虽然编程范式是一个非常有吸引力的主题，但是接下去本教程主要关注实践部分，会以一个贯穿始终的例子为核心进行讲述。</p>
<h2 id="The-Reactive-Playground"><a href="#The-Reactive-Playground" class="headerlink" title="The Reactive Playground"></a>The Reactive Playground</h2><p>在这个教程中，我们会从一个简单的应用程序 —— ReactivePlayground 入手来了解响应式编程。开始之前可以先下载这个<a href="https://koenig-media.raywenderlich.com/uploads/2014/01/ReactivePlayground-Starter.zip" target="_blank" rel="noopener">项目</a>并编译运行以确保一切就绪。</p>
<p>ReactivePlayground 非常简单，只会在屏幕上展示一个登陆页面，提供正确的身份信息：用户名和密码就可以看到一张可爱的小猫咪图片：</p>
<div align="center"><img src="https://koenig-media.raywenderlich.com/uploads/2014/01/ReactivePlaygroundStarter.jpg" width="320" alt="ReactivePlayground应用示例图"></div>

<p>看呐，多么可爱！</p>
<p>现在是时候花点时间来浏览一下项目的代码了，它非常简单，花不了多长时间。</p>
<p>打开 <strong>RWViewController.m</strong> 扫一眼，你需要花多久时间才能看出来 <strong>Sign In</strong> 按钮被激活的条件？展现/隐藏 <strong>signInFailure</strong> 标签的规则又是什么？在这个相对简单的例子中，你可能需要花一两分钟的时间来回答这些问题，在一个更为复杂的应用中，这样的分析无疑会花费很长的时间。</p>
<blockquote>
<p>【译者注】主要原因是逻辑四下分散，要回答这些问题需要来回切换代码。</p>
</blockquote>
<p>如果开发者使用 ReactiveCocoa，应用的逻辑就会变得清晰很多，So，让我们开始吧！</p>
<blockquote>
<p>【译者注】这里省略一段如何添加 ReactiveCocoa 框架的章节不作翻译，了解 CocoaPods 的童鞋并不难。建议读者直接去看 Github Readme指导。</p>
</blockquote>
<h2 id="Time-To-Play"><a href="#Time-To-Play" class="headerlink" title="Time To Play"></a>Time To Play</h2><p>正如前面介绍的，ReactiveCocoa 为处理应用中发生的各种不同的事件流提供了一套标准的接口，在 ReactiveCocoa 框架中，这些事件被称为<strong>信号(signal)</strong>，由类 RACSignal 表示。</p>
<blockquote>
<p>【译者注】后面 ReactiveCocoa 简称 RAC。</p>
</blockquote>
<p>打开应用的初始 ViewController —— RWViewController，添加以下语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;ReactiveCocoa/ReactiveCocoa.h&gt;</span><br></pre></td></tr></table></figure>
<p>就可以导入 RAC 的头文件。你现在要做的事情不是去替换任何的代码，而是先玩玩它，在<code>viewDidLoad</code>方法的末尾添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[self.usernameTextField.rac_textSignal subscribeNext:^(id x) &#123;</span><br><span class="line">  NSLog(@&quot;%@&quot;, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>编译并运行程序，在用户名输入框中输入一些文字，并注意观察控制台的输出，会有类似下面的 Log 打印出来：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">2013-12-24 14:48:50.359 RWReactivePlayground[9193:a0b] i</span><br><span class="line">2013-12-24 14:48:50.436 RWReactivePlayground[9193:a0b] is</span><br><span class="line">2013-12-24 14:48:50.541 RWReactivePlayground[9193:a0b] is </span><br><span class="line">2013-12-24 14:48:50.695 RWReactivePlayground[9193:a0b] is t</span><br><span class="line">2013-12-24 14:48:50.831 RWReactivePlayground[9193:a0b] is th</span><br><span class="line">2013-12-24 14:48:50.878 RWReactivePlayground[9193:a0b] is thi</span><br><span class="line">2013-12-24 14:48:50.901 RWReactivePlayground[9193:a0b] is this</span><br><span class="line">2013-12-24 14:48:51.009 RWReactivePlayground[9193:a0b] is this </span><br><span class="line">2013-12-24 14:48:51.142 RWReactivePlayground[9193:a0b] is this m</span><br><span class="line">2013-12-24 14:48:51.236 RWReactivePlayground[9193:a0b] is this ma</span><br><span class="line">2013-12-24 14:48:51.335 RWReactivePlayground[9193:a0b] is this mag</span><br><span class="line">2013-12-24 14:48:51.439 RWReactivePlayground[9193:a0b] is this magi</span><br><span class="line">2013-12-24 14:48:51.535 RWReactivePlayground[9193:a0b] is this magic</span><br><span class="line">2013-12-24 14:48:51.774 RWReactivePlayground[9193:a0b] is this magic?</span><br></pre></td></tr></table></figure>
<p>你可以看到，每次输入框中的文字变化，block 中的代码就会被执行，然而我们并没有使用 Target-Action、Delegate 等机制，只有信号和 block，多么令人兴奋啊！</p>
<p>RAC 信号（由 RACSignal 类表示）会向它的订阅者发送事件流，<strong>事件分为三种类型：next、error 和 completed</strong>。在信号发送 error 或者 complete 事件结束自己之前，它可以发送任意数量的 next 事件。在本教程中我们主要关注 next 事件，其余两种事件会在第二部分详细描述。</p>
<blockquote>
<p>【译者注】经过前面的介绍，如果读者对 <a href="http://reactivex.io/" target="_blank" rel="noopener">ReactiveX</a> 熟悉的话，应该已经明白这个框架到底要做什么了，不过融合了响应式编程之后，RAC 更为强大。</p>
</blockquote>
<p>RACSignal 类有一系列方法用于注册监听不同的事件类型。每一个方法会要求传入一个或者多个 block 参数，用于在事件发生时执行。在上面的例子中，你已经看到使用 <code>subscribeNext</code>方法来为每一个 next 事件添加 block 用于执行的过程了。</p>
<blockquote>
<p>【译者注】RAC 将事件源抽象成 RACSignal，比如一个 Button，一个属性；将原先的事件抽象成事件，不过事件没有在 RAC 中有明确表示（起码前面还没提到）；一个完整的事件流（比如 Button 的点击事件）由若干个 next 事件和一个 error/complete 类型事件组成。</p>
</blockquote>
<p>RAC 框架使用 Category 为标准的 UIKit Control 类添加了很多的信号，以便于开发者可以订阅这些事件，这就是前面例子中<code>rac_textSignal</code>属性的由来。</p>
<p>接下来我们要让 RAC 为我们做点儿实际的工作。</p>
<p>RAC 定义了很多的操作用于处理事件流。举个例子，假设你只对超过字符长度超过 3 的用户名感兴趣，你可以使用 <code>filter</code>操作符，更新前面的例子代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[self.usernameTextField.rac_textSignal</span><br><span class="line">  filter:^BOOL(id value) &#123;</span><br><span class="line">    NSString *text = value;</span><br><span class="line">    return text.length &gt; 3;</span><br><span class="line">  &#125;]</span><br><span class="line">  subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
<p>如果你编译运行并在输入框中输入一些字符，就会发现只有在用户名长度大于3的情况下才会有 Log 输出：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2013-12-26 08:17:51.335 RWReactivePlayground[9654:a0b] is t</span><br><span class="line">2013-12-26 08:17:51.478 RWReactivePlayground[9654:a0b] is th</span><br><span class="line">2013-12-26 08:17:51.526 RWReactivePlayground[9654:a0b] is thi</span><br><span class="line">2013-12-26 08:17:51.548 RWReactivePlayground[9654:a0b] is this</span><br><span class="line">2013-12-26 08:17:51.676 RWReactivePlayground[9654:a0b] is this </span><br><span class="line">2013-12-26 08:17:51.798 RWReactivePlayground[9654:a0b] is this m</span><br><span class="line">2013-12-26 08:17:51.926 RWReactivePlayground[9654:a0b] is this ma</span><br><span class="line">2013-12-26 08:17:51.987 RWReactivePlayground[9654:a0b] is this mag</span><br><span class="line">2013-12-26 08:17:52.141 RWReactivePlayground[9654:a0b] is this magi</span><br><span class="line">2013-12-26 08:17:52.229 RWReactivePlayground[9654:a0b] is this magic</span><br><span class="line">2013-12-26 08:17:52.486 RWReactivePlayground[9654:a0b] is this magic?</span><br></pre></td></tr></table></figure>
<p>你在这里创建的是一个非常简单的<strong>管道</strong>——这个概念对于响应式编程来说至关重要：将 App 的功能表达成数据流形式。下面的图可以帮你理清楚这个流：</p>
<div align="center"><img src="https://koenig-media.raywenderlich.com/uploads/2014/01/FilterPipeline.png" alt="ReactivePlayground应用示例图"></div>

<p>在上面的图示中，你可以看到<code>rac_textSignal</code>就是事件源，数据流（其中包含事件）流经<code>fliter</code>，只有输入字符串长度大于 3 的事件才会穿过去，管道的最后一步是<code>subscribeNext:</code>函数——也就是打印事件值的地方。</p>
<p>这里值得注意的是<code>filter</code>操作的输出也是一个 RACSingal，你可以使用以下的代码方式来分离管道的处理步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *usernameSourceSignal = </span><br><span class="line">    self.usernameTextField.rac_textSignal;</span><br><span class="line"> </span><br><span class="line">RACSignal *filteredUsername = [usernameSourceSignal  </span><br><span class="line">  filter:^BOOL(id value) &#123;</span><br><span class="line">    NSString *text = value;</span><br><span class="line">    return text.length &gt; 3;</span><br><span class="line">  &#125;];</span><br><span class="line"> </span><br><span class="line">[filteredUsername subscribeNext:^(id x) &#123;</span><br><span class="line">  NSLog(@&quot;%@&quot;, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>因为 RACSignal 上的每一个步骤都会返回一个 RACSignal，所以整体形成了一个链式接口，这个特性使得开发者不用为每一个中间操作生成一个局部变量。</p>
<blockquote>
<p><strong>注意：</strong>ReactiveCocoa 重度依赖 block。如果你是 block 新手，你应该尝试读一下苹果的 <a href="https://developer.apple.com/library/ios/documentation/cocoa/Conceptual/Blocks/Articles/00_Introduction.html" target="_blank" rel="noopener">Blocks Programming Topics </a>。如果你很熟悉 block，但是觉得这样的语法难以理解，不容易记住，那 <a href="http://fuckingblocksyntax.com/" target="_blank" rel="noopener">f<strong>*</strong>gblocksyntax.com</a> 网站对你或许很有用！（部分字符用 * 隐藏以保护纯洁的童鞋，但是链接是有效的。）</p>
</blockquote>
<h2 id="小小的转换"><a href="#小小的转换" class="headerlink" title="小小的转换"></a>小小的转换</h2><p>如果你把你的代码更新成多个 RACSignal 组件对象，现在是时候将它还原成链式调用了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[self.usernameTextField.rac_textSignal</span><br><span class="line">  filter:^BOOL(id value) &#123;</span><br><span class="line">    NSString *text = value; // implicit cast</span><br><span class="line">    return text.length &gt; 3;</span><br><span class="line">  &#125;]</span><br><span class="line">  subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
<p>这里有个显式地从<code>id</code>类型转换为 <code>NSString</code>的过程，这行代码看上去不怎么优雅。幸运的是，由于发送给这个 Block 的数据始终都会是<code>NSString</code>类型，因此开发者可以自行更改参数类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[[self.usernameTextField.rac_textSignal</span><br><span class="line">  filter:^BOOL(NSString *text) &#123;</span><br><span class="line">    return text.length &gt; 3;</span><br><span class="line">  &#125;]</span><br><span class="line">  subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
<p>编译并运行，确认结果如预期。</p>
<h2 id="什么是事件（Event）？"><a href="#什么是事件（Event）？" class="headerlink" title="什么是事件（Event）？"></a>什么是事件（Event）？</h2><p>迄今为止本教程已经描述了不同的事件类型，但是我们还没有去详述这些事件的结构，有趣的是事件可以包含任何东西！</p>
<p>为了弄清楚这点，我们将在管道中再添加一个操作，更新代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[[[self.usernameTextField.rac_textSignal</span><br><span class="line">  map:^id(NSString *text) &#123;</span><br><span class="line">    return @(text.length);</span><br><span class="line">  &#125;]</span><br><span class="line">  filter:^BOOL(NSNumber *length) &#123;</span><br><span class="line">    return [length integerValue] &gt; 3;</span><br><span class="line">  &#125;]</span><br><span class="line">  subscribeNext:^(id x) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
<p>编译运行这段代码就会发现控制台输出的不再是输入框中的内容，而是它的长度：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2013-12-26 12:06:54.566 RWReactivePlayground[10079:a0b] 4</span><br><span class="line">2013-12-26 12:06:54.725 RWReactivePlayground[10079:a0b] 5</span><br><span class="line">2013-12-26 12:06:54.853 RWReactivePlayground[10079:a0b] 6</span><br><span class="line">2013-12-26 12:06:55.061 RWReactivePlayground[10079:a0b] 7</span><br><span class="line">2013-12-26 12:06:55.197 RWReactivePlayground[10079:a0b] 8</span><br><span class="line">2013-12-26 12:06:55.300 RWReactivePlayground[10079:a0b] 9</span><br><span class="line">2013-12-26 12:06:55.462 RWReactivePlayground[10079:a0b] 10</span><br><span class="line">2013-12-26 12:06:55.558 RWReactivePlayground[10079:a0b] 11</span><br><span class="line">2013-12-26 12:06:55.646 RWReactivePlayground[10079:a0b] 12</span><br></pre></td></tr></table></figure>
<p>新加的 map 操作使用提供的 block 来变换事件的数据。对于每一个它接收到的 next 事件，RAC 都会运行提供的 block，将返回值作为一个新的 next 事件放出。在上面的代码中，map 操作以 NSString 为输入，转换成内容长度后返回。下面的图更形象的展示了这个过程：</p>
<div align="center"><img src="https://koenig-media.raywenderlich.com/uploads/2014/01/FilterAndMapPipeline.png" alt="RAC 数据流图"></div>

<p>如读者缩减，map 操作后的所有步骤接收到的都是一个 NSNumber 实例。你可以使用 map 操作将传入的数据转换成任意你喜欢的东西，只要它是一个对象即可。</p>
<blockquote>
<p><strong>注意：</strong>在上面的例子中，<code>text.length</code>属性返回的是 NSUInteger，是一个原始类型，为了将它用作事件的数据内容，它必须被装箱。庆幸的是，在 OC 里面使用字面量语法可以很优雅的进行转换。</p>
</blockquote>
<p>现在是时候用前面学到的概念来更新一下 ReactivePlayground 应用了，你可以将前面添加的嗲吗全部移除掉。</p>
<h2 id="Creating-Valid-State-Signals"><a href="#Creating-Valid-State-Signals" class="headerlink" title="Creating Valid State Signals"></a>Creating Valid State Signals</h2><p>第一件要做的事情就是创建一些信号来反映输入的用户名和密码是否是有效的 —— 在<strong>RMViewController.m</strong>的<code>viewDidLoad</code>方法最后添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *validUsernameSignal =</span><br><span class="line">  [self.usernameTextField.rac_textSignal</span><br><span class="line">    map:^id(NSString *text) &#123;</span><br><span class="line">      return @([self isValidUsername:text]);</span><br><span class="line">    &#125;];</span><br><span class="line"> </span><br><span class="line">RACSignal *validPasswordSignal =</span><br><span class="line">  [self.passwordTextField.rac_textSignal</span><br><span class="line">    map:^id(NSString *text) &#123;</span><br><span class="line">      return @([self isValidPassword:text]);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<p>以上代码通过 map 操作将输入转换成 boolean 输出，同时装箱为 NSNumber 类型。下一步就是进一步转换这两个信号，以便于能为输入框提供合适的背景颜色，一般来说就是订阅信号并使用输出数据来更新背景颜色即可，其中一种实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[[validPasswordSignal</span><br><span class="line">  map:^id(NSNumber *passwordValid) &#123;</span><br><span class="line">    return [passwordValid boolValue] ? [UIColor clearColor] : [UIColor yellowColor];</span><br><span class="line">  &#125;]</span><br><span class="line">  subscribeNext:^(UIColor *color) &#123;</span><br><span class="line">    self.passwordTextField.backgroundColor = color;</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
<p>这段代码看上去非常落后 &amp; 不优雅。</p>
<blockquote>
<p>为了实现一个简单的功能，拆分出了很多的操作，阅读起来很累赘。</p>
</blockquote>
<p>RAC 为这种需求提供了宏，可以优雅的实现它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RAC(self.passwordTextField, backgroundColor) =</span><br><span class="line">  [validPasswordSignal</span><br><span class="line">    map:^id(NSNumber *passwordValid) &#123;</span><br><span class="line">      return [passwordValid boolValue] ? [UIColor clearColor] : [UIColor yellowColor];</span><br><span class="line">    &#125;];</span><br><span class="line"> </span><br><span class="line">RAC(self.usernameTextField, backgroundColor) =</span><br><span class="line">  [validUsernameSignal</span><br><span class="line">    map:^id(NSNumber *passwordValid) &#123;</span><br><span class="line">     return [passwordValid boolValue] ? [UIColor clearColor] : [UIColor yellowColor];</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<p><strong><code>RAC</code></strong>宏允许将信号的输出赋值给对象的属性。它需要两个参数：第一个是属性设置的对象，第二个是属性名。每次信号释放一个事件，事件的值都会被赋值给属性。</p>
<p>这个实现非常优雅，你觉得呢？</p>
<p>在编译运行前，还需要找到<code>upadteUIState</code>方法，移除下面两行代码来清楚非响应式代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.usernameTextField.backgroundColor = self.usernameIsValid ? [UIColor clearColor] : [UIColor yellowColor];</span><br><span class="line">self.passwordTextField.backgroundColor = self.passwordIsValid ? [UIColor clearColor] : [UIColor yellowColor];</span><br></pre></td></tr></table></figure>
<p>编译运行代码，你会发现输入框在输入非法的时候高亮了，输入合法的时候高亮消失。</p>
<p>下面这幅图展现了当前的逻辑：</p>
<div align="center"><img src="https://koenig-media.raywenderlich.com/uploads/2014/01/TextFieldValidPipeline.png" alt="RAC 数据流图"></div>

<p>你是不是很好奇为什么这里要创建两个的<code>validPasswordSignal</code>和<code>validUsernameSignal</code>信号变量，这与我们之前提到的链式管道相违背呀？保持耐心，后面会越来越清晰。</p>
<h2 id="Combining-signals"><a href="#Combining-signals" class="headerlink" title="Combining signals"></a>Combining signals</h2><p>现在 App 里面的<code>Sign In</code>按钮只有在用户名和密码输入框都有合法输入的情况下才会可点击，又到了使用响应式编程风格的时候了！</p>
<p>现有的代码已经通过信号来发送一个布尔值反映用户名和密码是不是有效的了。你的任务就是将这两个信号组合起来来确定是否激活登陆按钮。</p>
<p>在<code>viewDidLoad</code>方法的最后，添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signUpActiveSignal =</span><br><span class="line">  [RACSignal combineLatest:@[validUsernameSignal, validPasswordSignal]</span><br><span class="line">                    reduce:^id(NSNumber *usernameValid, NSNumber *passwordValid) &#123;</span><br><span class="line">                      return @([usernameValid boolValue] &amp;&amp; [passwordValid boolValue]);</span><br><span class="line">                    &#125;];</span><br></pre></td></tr></table></figure>
<p>以上代码使用<strong><code>combineLatest:reduce:</code> </strong>方法来组合由<code>validUsernameSignal</code>和<code>validPasswordSignal</code>信号发出的最新值，并生成一个新的信号。每次这两个信号中的任何一个发出新的值，都会导致<code>reduce</code> block 执行。</p>
<blockquote>
<p><strong>注意：</strong>RACSignal 组合方法可以组合任意数量的信号，reduce block 的参数则对应着每一个源信号的输出值。RAC 在底层做了很多的事情，查看它的实现是很有价值的。</p>
</blockquote>
<p>既然已经生成了一个合适的信号，可以把下面的代码添加到<code>viewDidLoad</code>方法的末尾，它会去更新按钮的 enabled 属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[signUpActiveSignal subscribeNext:^(NSNumber *signupActive) &#123;</span><br><span class="line">   self.signInButton.enabled = [signupActive boolValue];</span><br><span class="line"> &#125;];</span><br></pre></td></tr></table></figure>
<p>同样的，移除下面的非响应实现代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic) BOOL passwordIsValid;</span><br><span class="line">@property (nonatomic) BOOL usernameIsValid;</span><br></pre></td></tr></table></figure>
<p>以及<code>viewDidLoad</code>方法中的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// handle text changes for both text fields</span><br><span class="line">[self.usernameTextField addTarget:self</span><br><span class="line">                           action:@selector(usernameTextFieldChanged)</span><br><span class="line">                 forControlEvents:UIControlEventEditingChanged];</span><br><span class="line">[self.passwordTextField addTarget:self </span><br><span class="line">                           action:@selector(passwordTextFieldChanged)</span><br><span class="line">                 forControlEvents:UIControlEventEditingChanged];</span><br></pre></td></tr></table></figure>
<p>然后移除<code>updateUIState</code>、<code>usernameTextFieldChanged</code>和<code>passwordTextFieldChanged</code>方法，移除调用它们的代码。然后编译运行，<strong>Sign In</strong> 按钮就会在用户名密码合法的情况下被激活，逻辑展示如下图：</p>
<div align="center"><img src="https://koenig-media.raywenderlich.com/uploads/2014/01/CombinePipeline.png" alt="RAC 数据流图"></div>

<p>上图展现了一些重要的概念，理解这些概念有助于你使用 RAC 实现一些强大的功能：</p>
<ul>
<li><strong>分割</strong>  信号可以有多个订阅者，可以成为多个管道的信号源。在上图中，反映用户名密码是否合法的 boolean 信号就被两个管道接收用于不同的目的。</li>
<li><strong>组合</strong>  多个信号可以被组合生成新的信号，在上面的例子中，两个 boolean 信号就被组合了起来。组合起来的信号可以生成包含任何类型值的新信号。</li>
</ul>
<p>使用 RAC 的结果就是现在应用里面再也没有反映两个输入框输入内容是否合法的变量。<strong>这将是你采用响应式编程风格的一个关键原因——不再需要使用实例变量来跟踪可变状态。</strong></p>
<blockquote>
<p>【译者注】这或许是一个原因，但是这个例子中并不明显，因为即使不用 RAC，也可以不用变量保存状态就实现上面的功能。</p>
</blockquote>
<h2 id="Reactive-Sign-in"><a href="#Reactive-Sign-in" class="headerlink" title="Reactive Sign-in"></a>Reactive Sign-in</h2><p>示例应用现在使用响应式管道来管理输入框和按钮的状态。然而按钮的点击处理使用的还是 action，所以下一步就是将这块也改造成响应式的！</p>
<p><strong>Sign In</strong> 按钮上的 <strong>Touch Up Inside</strong> 事件会触发<code>signInButtonTouched</code>事件。我们首先移除掉这个关系。</p>
<blockquote>
<p>【译者注】原文中这个 Action 的是通过 Storyboard 添加的，这里移除的过程就不作翻译了。</p>
</blockquote>
<p>前面已经展示了如何利用 RAC 框架给标准的 UIKit Control 添加属性和方法了，到目前为止我们已经使用过<code>rac_textSignal</code> —— 在文本变化的时候触发事件。为了能够处理事件，我们需要使用另外一个添加进去的方法：<code>rac_signalForControlEvents</code>。</p>
<p>回到<code>RWViewController.m</code>，将下面的代码添加到<code>viewDidLoad</code>方法末尾：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[self.signInButton</span><br><span class="line">   rac_signalForControlEvents:UIControlEventTouchUpInside]</span><br><span class="line">   subscribeNext:^(id x) &#123;</span><br><span class="line">     NSLog(@&quot;button clicked&quot;);</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure>
<p>以上代码从按钮的<code>UIControlEventTouchUpInside</code>事件中创造出了一个信号，并添加了一个订阅上去：每次在事件发生的时候，都打印一次日志。</p>
<p>编译并运行以确认日志实际会打印。记住按钮只有在用户名和密码都合法的情况下才可点击，所以请在两个输入框中输入合法的内容，点击之后就可以看到控制台的输出如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2013-12-28 08:05:10.816 RWReactivePlayground[18203:a0b] button clicked</span><br><span class="line">2013-12-28 08:05:11.675 RWReactivePlayground[18203:a0b] button clicked</span><br><span class="line">2013-12-28 08:05:12.605 RWReactivePlayground[18203:a0b] button clicked</span><br><span class="line">2013-12-28 08:05:12.766 RWReactivePlayground[18203:a0b] button clicked</span><br><span class="line">2013-12-28 08:05:12.917 RWReactivePlayground[18203:a0b] button clicked</span><br></pre></td></tr></table></figure>
<p>既然这个按钮有一个为 Touch 事件而生的信号，那么下一步就是将信号绑定到登陆处理上。打开<code>RMDummySignInService.h</code>看一下接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef void (^RWSignInResponse)(BOOL);</span><br><span class="line"> </span><br><span class="line">@interface RWDummySignInService : NSObject</span><br><span class="line"> </span><br><span class="line">- (void)signInWithUsername:(NSString *)username</span><br><span class="line">                  password:(NSString *)password </span><br><span class="line">                  complete:(RWSignInResponse)completeBlock;</span><br><span class="line"> </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>这个服务以用户名、密码以及一个 completion block 作为参数，这个 block 在登陆成功或者失败只会被调用，我们可以直接在前面打印 log 的地方替换上对这个接口的调用。</p>
<blockquote>
<p><strong>注意：</strong>为了实现简单，这个服务是 Mock 的，那样就不用依赖其余的外部 API 了。</p>
<p>现在我们遇到了一个真正的问题，我们如何去利用没有用信号形式表达过的 API？</p>
</blockquote>
<h2 id="Creating-Signals"><a href="#Creating-Signals" class="headerlink" title="Creating Signals"></a>Creating Signals</h2><p>实际上使用信号来适配一个异步接口是非常简单的。首先，从<code>RWViewController.m</code>中移除<code>signInButtonToouched</code>方法，后面会用响应式的代码替代它。在<code>RWViewController.m</code>中添加如下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-(RACSignal *)signInSignal &#123;</span><br><span class="line">  return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    [self.signInService</span><br><span class="line">     signInWithUsername:self.usernameTextField.text</span><br><span class="line">     password:self.passwordTextField.text</span><br><span class="line">     complete:^(BOOL success) &#123;</span><br><span class="line">       [subscriber sendNext:@(success)];</span><br><span class="line">       [subscriber sendCompleted];</span><br><span class="line">     &#125;];</span><br><span class="line">    return nil;</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上方法调用了<code>RACSignal</code>类的<code>createSignal:</code>方法创建了一个以当前输入的用户名和密码登陆的信号。创建信号只需要一个 block 作为参数，当有订阅者订阅这个信号之后，block 里面的代码就会执行。block 本身也只需要一个参数：<code>subscriber</code>，它实现了<code>RACSubscriber</code>协议， 这个协议有一些方法用于发送事件：你可以发送任意数量的 next 类型事件，最后再发送一个 error/complete 类型的事件作为结束。在上面的例子中，它发送了一个 next 事件来反映登陆是否成功，然后发送一个 complete 类型事件。</p>
<p>block 的返回值类型是一个<code>RACDisposable</code>对象，它允许使用者在一段订阅关系需要取消或者删除的时候进行一些清理工作。这个信号没有任何的清理需求，因此返回 nil。</p>
<p>如你所见，将一个异步接口包裹在信号中是多么的简单！</p>
<p>现在我们来利用一下这个新的信号，更新之前添加到<code>viewDidLoad</code>方法中的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[[self.signInButton</span><br><span class="line">   rac_signalForControlEvents:UIControlEventTouchUpInside]</span><br><span class="line">   map:^id(id x) &#123;</span><br><span class="line">     return [self signInSignal];</span><br><span class="line">   &#125;]</span><br><span class="line">   subscribeNext:^(id x) &#123;</span><br><span class="line">     NSLog(@&quot;Sign in result: %@&quot;, x);</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure>
<p>上面的代码使用了前面提到的<code>map</code>方法将按钮点击信号转换为登陆信号，订阅者只是简单的打印结果。</p>
<p>现在编译运行代码，然后点击 <strong>Sign In</strong> 按钮，就可以看到控制台输出如下 Log：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2014-01-08 21:00:25.919 RWReactivePlayground[33818:a0b] Sign in result:</span><br><span class="line">                                   <span class="tag">&lt;<span class="name">RACDynamicSignal:</span> <span class="attr">0xa068a00</span>&gt;</span> name: +createSignal:</span><br></pre></td></tr></table></figure>
<p><code>subscribeNext:</code> block接收到的是一个信号，即登陆信号本身，而不是登陆信号的结果。下面的图展示了前面代码的逻辑：</p>
<div align="center"><img src="https://koenig-media.raywenderlich.com/uploads/2014/01/SignalOfSignals.png" alt="RAC 数据流图"></div>

<p>当点击按钮的时候<code>rac_signalForControlEvents</code>会触发一个 next 事件（事件数据就是 UIButton），map 则把这个 next 事件转化成了一个登陆信号，也就是说后续的处理步骤中将接收到一个 RACSignal，这就是我们在<code>subscribeNext:</code>方法中观察的对象。</p>
<p>订阅登陆信号本身当然不是我们期望的，解决办法称为<strong>信号的信号（signal of signals）</strong>，换句话说也就是外部信号包含着一个内部信号。如果你确实有需要，是可以通过调用外部信号的<code>subscribeNext:</code>方法来订阅内部信号的。然而这样会造成嵌套混乱，但庆幸的是这是一个很普遍的问题，RAC 已经为此准备好了解决方案。</p>
<h2 id="Signal-of-Signals"><a href="#Signal-of-Signals" class="headerlink" title="Signal of Signals"></a>Signal of Signals</h2><p>问题的解决方案非常直接，只需要将<code>map</code>函数换成<code>flattenMap</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[[self.signInButton</span><br><span class="line">   rac_signalForControlEvents:UIControlEventTouchUpInside]</span><br><span class="line">   flattenMap:^id(id x) &#123;</span><br><span class="line">     return [self signInSignal];</span><br><span class="line">   &#125;]</span><br><span class="line">   subscribeNext:^(id x) &#123;</span><br><span class="line">     NSLog(@&quot;Sign in result: %@&quot;, x);</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure>
<p>这样同样会把按钮的点击事件转换为登陆信号，但是也会把内部信号的事件透传到外部信号，从而转化为外部信号量的事件，这就是<strong><code>flatten</code>(扁平化)</strong>。</p>
<p>编译并运行代码，控制台的输出就会变成如下样子：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2013-12-28 18:20:08.156 RWReactivePlayground[22993:a0b] Sign in result: 0</span><br><span class="line">2013-12-28 18:25:50.927 RWReactivePlayground[22993:a0b] Sign in result: 1</span><br></pre></td></tr></table></figure>
<p>现在整个管道就像我们期望的那样运行，最后一步就是把登陆成功/失败后的逻辑添加到<code>subscribeNext</code>的 block 中去：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[[[self.signInButton</span><br><span class="line">  rac_signalForControlEvents:UIControlEventTouchUpInside]</span><br><span class="line">  flattenMap:^id(id x) &#123;</span><br><span class="line">    return [self signInSignal];</span><br><span class="line">  &#125;]</span><br><span class="line">  subscribeNext:^(NSNumber *signedIn) &#123;</span><br><span class="line">    BOOL success = [signedIn boolValue];</span><br><span class="line">    self.signInFailureText.hidden = success;</span><br><span class="line">    if (success) &#123;</span><br><span class="line">      [self performSegueWithIdentifier:@&quot;signInSuccess&quot; sender:self];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>
<p>这个 block 现在根据登陆信号量发送的事件更新<code>signFailureText</code>的可见性，并进行相应的导航。</p>
<p>编译并运行代码，我们就可以看到猫咪啦：</p>
<div align="center"><img src="https://koenig-media.raywenderlich.com/uploads/2014/01/ReactivePlaygroundStarter.jpg" width="320" alt="ReactivePlayground应用示例图"></div>

<p>不知道你有没有注意到当前的应用有一个很小的用户体验问题：当在登陆验证的过程中，是否应该禁掉 <strong>Sign In</strong> 按钮的点击？这可以防止用户重复点击登陆，另外，如果登陆失败，用户再次登陆的时候应该隐藏掉错误信息。</p>
<p>但是这个逻辑怎么添加到当前的管道中去呢？更改按钮的可点击状态并不是一个转换、过滤或者前面提到的任何一个操作概念。它被认为是一个 <em>side effect</em> ，或者更准确一点说，是一个 next 事件发生时要做的一点额外工作，但是又不会改变事件的本身。</p>
<h2 id="Adding-side-effect"><a href="#Adding-side-effect" class="headerlink" title="Adding side-effect"></a>Adding side-effect</h2><p>替换前面的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[[[[self.signInButton</span><br><span class="line">   rac_signalForControlEvents:UIControlEventTouchUpInside]</span><br><span class="line">   doNext:^(id x) &#123;</span><br><span class="line">     self.signInButton.enabled = NO;</span><br><span class="line">     self.signInFailureText.hidden = YES;</span><br><span class="line">   &#125;]</span><br><span class="line">   flattenMap:^id(id x) &#123;</span><br><span class="line">     return [self signInSignal];</span><br><span class="line">   &#125;]</span><br><span class="line">   subscribeNext:^(NSNumber *signedIn) &#123;</span><br><span class="line">     self.signInButton.enabled = YES;</span><br><span class="line">     BOOL success = [signedIn boolValue];</span><br><span class="line">     self.signInFailureText.hidden = success;</span><br><span class="line">     if (success) &#123;</span><br><span class="line">       [self performSegueWithIdentifier:@&quot;signInSuccess&quot; sender:self];</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure>
<p>这里展示了如何在管道中 Button 的点击事件发生之后添加一个<code>doNext:</code>步骤。<code>doNext:</code>步骤不反悔任何的值，因为它只是一个 side-effect，它不会改变事件。</p>
<blockquote>
<p>【译者注】doNext 所做的事情这里就不解释了。</p>
</blockquote>
<p>所以整个流程又变成下图所示：</p>
<div align="center"><img src="https://koenig-media.raywenderlich.com/uploads/2014/01/SideEffects.png" alt="RAC 数据流图"></div>

<p>编译并运行代码，确认 <strong>Sign In</strong> 按钮的可点击状态如预期那样变化。</p>
<p>到这里，所有的工作都完成了，现在整个 App 完全变成响应式的了。Nice！</p>
<p>如果前面有什么不明白的地方，可以下载最终的代码：<strong><a href="https://koenig-media.raywenderlich.com/uploads/2014/01/ReactivePlayground-Final.zip" target="_blank" rel="noopener">final project</a></strong>，或者直接从 <a href="https://github.com/ColinEberhardt/RWReactivePlayground" target="_blank" rel="noopener">GitHub</a> 拉取，每一个 commit 都对应着前面的一个步骤。</p>
<blockquote>
<p><strong>注意：</strong>当某些异步任务进行时禁掉 button 的点击是一个普遍功能，RAC 提供了 RACCommand 来解决这个问题，有兴趣可以研究一下。</p>
</blockquote>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>希望这篇教程为你在自己的应用中使用 RAC 打下了一个良好的基础。熟悉这些概念需要一定的联系，但是和学习语言或者编程一样，一旦你适应了，一切就变得很简单。RAC 的核心就是信号，即事件流，还有什么比这更简单的呢？</p>
<p>使用 RAC 让我觉得有趣的一点是解决同一个问题有无数种解决方案，你可以着用这个示例应用进行更多的探索，让信号和管道以别的方式进行分割和组合。</p>
<p>使用 RAC 的目的是让代码更加整洁，更易理解，记住这个非常有必要。个人观点是将应用的逻辑使用链式语法表达为清晰的管道确实让理解变得更为简单。</p>
<p>在本教程的第二部分，你会学习到诸如错误处理、如何管理不同的线程等高级主题，玩的愉快！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UIResponder 和 UIControl]]></title>
      <url>http://www.timebridge.space/2017/01/11/UIResponder-%E5%92%8C-UIControl/</url>
      <content type="html"><![CDATA[<p>先来看一幅图：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/view_class_tree.png" width="480" alt="View 类继承树"></div>

<p>这幅图展示了 iOS View 类的继承关系，可以看到 UIResponder 和 UIControl 之间的关系。为什么要比对这两个类呢？从继承关系中可以看出：</p>
<ol>
<li>UIResponder 的直接子类覆盖了我们平时用到的几大重要类：UIApplication，UIView 和 UIViewController，也就是说所有的 UIView 的子类 —— 我们平时用的 View 组件都是 UIResponder 的子类；</li>
<li>UIView 的子类分为两组，一类是直接子类，一类则是 UIControl 的子类；</li>
</ol>
<p>所以从继承树上看，研究这两个类对于理解 iOS 的 View 结构有很重要的意义。<a id="more"></a></p>
<h2 id="UIResponder"><a href="#UIResponder" class="headerlink" title="UIResponder"></a>UIResponder</h2><p>官网描述：</p>
<blockquote>
<p>The <code>UIResponder</code> class defines an interface for objects that respond to and handle events. It is the superclass of <code>UIApplication</code>, <code>UIView</code> and its subclasses (which include <code>UIWindow</code>). Instances of these classes are sometimes referred to as responder objects or, simply, responders.</p>
</blockquote>
<p>也就是说，这个类为 <strong>响应和处理事件</strong> 定义了相关接口，通常继承这个类的子类被称为 <strong>响应者</strong>。UIResponder 的 <a href="https://developer.apple.com/reference/uikit/uiresponder" target="_blank" rel="noopener">API</a> 大致分为以下几类：</p>
<ol>
<li>关于 FirstResponder；</li>
<li>touch 事件；</li>
<li>press 事件；</li>
<li>motion 事件；</li>
<li>remote 事件；</li>
</ol>
<p>touch 事件即触摸事件，press 事件是由物理键触发的，比如手机遥控器，motion 事件简单翻译过来是手势事件，比如摇动设备，remote 事件是远程控制事件，比如耳机。</p>
<blockquote>
<p>关于事件，可以阅读：<a href="https://developer.apple.com/library/content/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009541" target="_blank" rel="noopener">Event Handling Guide for iOS</a>。</p>
</blockquote>
<h2 id="UIControl"><a href="#UIControl" class="headerlink" title="UIControl"></a>UIControl</h2><p>官网描述：</p>
<blockquote>
<p>The <code>UIControl</code> class implements common behavior for visual elements that convey a specific action or intention in response to user interactions. Controls implement elements such as buttons and sliders, which your app might use to facilitate navigation, gather user input, or manipulate content. Controls use the <a href="https://developer.apple.com/library/content/documentation/General/Conceptual/Devpedia-CocoaApp/TargetAction.html#//apple_ref/doc/uid/TP40009071-CH3" target="_blank" rel="noopener">Target-Action</a> mechanism to report user interactions to your app.</p>
</blockquote>
<p>UIControl 使用 Target-Action 机制来告知 App 用户的交互，并把这种交互抽象成一些通用的行为，比如<code>UIControlEventTouchUpInside</code>。为 UIButton 添加过监听的童鞋应该很容易理解。</p>
<blockquote>
<p>Target-Action 机制可参考文章<a href="http://www.cocoachina.com/ios/20160111/14932.html" target="_blank" rel="noopener">UIControl 的基本使用方法和 Target-Action 机制</a>。</p>
<p>在我看来和 Java 中的回调监听一样，只不过 Java 中并没有 SEL 这样的概念，而 iOS 中需要 Target 和 Action 才能指定执行某个实例的某个方法，两者理念上应该没有什么不同。</p>
</blockquote>
<p>简单查看一下 UIControl 的属性和方法，可以看出 UIControl 是在事件的基础上封装出来一些高级概念，以便于开发者更容易的相应用户的交互行为，比如：通过添加 Target 来相应 <code>UIControlEventTouchUpInside</code> 动作，而这个动作在 iOS 上的典型代表就是一次 UIButton 的点击过程，拆分成事件就是 TouchBegin -&gt; TouchMove -&gt;…-&gt; TouchMove -&gt; TouchEnd，还有对 selected、highlighted 等属性的定义，都是根据实际使用场景定义一些通用的用户行为模式，然后在 UIControl 为这些模式提供相应入口。</p>
<p>另外一个值得注意的点是下面两组接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// UIResponder</span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</span><br><span class="line">- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</span><br><span class="line">- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</span><br><span class="line">- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</span><br><span class="line"></span><br><span class="line">// UIControl</span><br><span class="line">- (BOOL)beginTrackingWithTouch:(UITouch *)touch withEvent:(nullable UIEvent *)event;</span><br><span class="line">- (BOOL)continueTrackingWithTouch:(UITouch *)touch withEvent:(nullable UIEvent *)event;</span><br><span class="line">- (void)endTrackingWithTouch:(nullable UITouch *)touch withEvent:(nullable UIEvent *)event; // touch is sometimes nil if cancelTracking calls through to this.</span><br><span class="line">- (void)cancelTrackingWithEvent:(nullable UIEvent *)event;   // event may be nil if cancelled for non-event reasons, e.g. removed from window</span><br></pre></td></tr></table></figure>
<p>这两组接口非常相似，但是参数上却又略微的不同：UIResponder 组得到的是一个 UITouch 集合，而 UIControl 得到的却是单个的 UITouch，简单猜测是因为判断用户行为模式并不需要同时监控多个 UITouch 变量，大多数的 UIControlEvents 定义的用户行为模式只需要一个 UITouch 即可判断。</p>
<blockquote>
<p>这个猜测受 Android 系统影响，可见文章<a href="http://timebridge.space/2016/09/04/Android-touchevent-process/" target="_blank" rel="noopener">Android View事件处理</a>。</p>
<p>关于这两组 API 的详细情况，可以参考 <a href="http://www.cnblogs.com/machao/p/5471094.html" target="_blank" rel="noopener">史上最详细的iOS之事件的传递和响应机制</a>。</p>
</blockquote>
<h2 id="两者的区别和联系"><a href="#两者的区别和联系" class="headerlink" title="两者的区别和联系"></a>两者的区别和联系</h2><p>区别前面已有论述，总结来说：<strong>UIResponder 类表明一个组件是可以接受事件的，它定义的方法可以获得一个组件最原始的事件信息，包括多点触控等等；UIControl 则通过这些事件抽象出用户的行为，比如点击事件，拖曳事件，并通过 Target-Action 机制让开发者可以方便的监听这些行为的发生。</strong></p>
<p>而为了研究两者之间的联系，我重载了上面提到的两组方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">@interface XYButton ()</span><br><span class="line">-(void)printTouchInfo:(UITouch *)touch withTag:(NSString *)tag;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation XYButton</span><br><span class="line"></span><br><span class="line">// UIControl</span><br><span class="line">- (BOOL)beginTrackingWithTouch:(UITouch *)touch withEvent:(nullable UIEvent *)event &#123;</span><br><span class="line">    [self printTouchInfo:touch withTag:@&quot;UIControl-Begin&quot;];</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)continueTrackingWithTouch:(UITouch *)touch withEvent:(nullable UIEvent *)event &#123;</span><br><span class="line">    [self printTouchInfo:touch withTag:@&quot;UIControl-Move&quot;];</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)endTrackingWithTouch:(nullable UITouch *)touch withEvent:(nullable UIEvent *)event &#123;</span><br><span class="line">    [self printTouchInfo:touch withTag:@&quot;UIControl-End&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)cancelTrackingWithEvent:(nullable UIEvent *)event &#123;</span><br><span class="line">    [self printTouchInfo:[[event.allTouches allObjects] objectAtIndex:0] withTag:@&quot;UIControl-End&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// UIResponder</span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event &#123;</span><br><span class="line">    [self printTouchInfo:[[touches allObjects] objectAtIndex:0] withTag:@&quot;UIResponder-Begin&quot;];</span><br><span class="line">    [super touchesBegan:touches withEvent:event];</span><br><span class="line">&#125;</span><br><span class="line">- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event &#123;</span><br><span class="line">    [self printTouchInfo:[[touches allObjects] objectAtIndex:0] withTag:@&quot;UIResponder-Move&quot;];</span><br><span class="line">    [super touchesMoved:touches withEvent:event];</span><br><span class="line">&#125;</span><br><span class="line">- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event &#123;</span><br><span class="line">    [self printTouchInfo:[[touches allObjects] objectAtIndex:0] withTag:@&quot;UIResponder-End&quot;];</span><br><span class="line">    [super touchesEnded:touches withEvent:event];</span><br><span class="line">&#125;</span><br><span class="line">- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event &#123;</span><br><span class="line">    [self printTouchInfo:[[touches allObjects] objectAtIndex:0] withTag:@&quot;UIResponder-Cancel&quot;];</span><br><span class="line">    [super touchesCancelled:touches withEvent:event];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)printTouchInfo:(UITouch *)touch withTag:(NSString *)tag &#123;</span><br><span class="line">    CGPoint point = [touch locationInView:self];</span><br><span class="line">    NSLog(@&quot;【%@】%f, %f&quot;, tag, point.x, point.y);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>当这个 UIButton 显示在界面上的时候，我在 Button 上拖动鼠标（点击位置），输出的 Log 如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">2017-01-11 17:55:25.079 MyP[37537:3413743] 【UIResponder-Begin】119.000000, 121.000000</span><br><span class="line">2017-01-11 17:55:25.080 MyP[37537:3413743] 【UIControl-Begin】119.000000, 121.000000</span><br><span class="line">2017-01-11 17:55:25.123 MyP[37537:3413743] 【UIResponder-Move】119.000000, 123.666656</span><br><span class="line">2017-01-11 17:55:25.123 MyP[37537:3413743] 【UIControl-Move】119.000000, 123.666656</span><br><span class="line">2017-01-11 17:55:25.142 MyP[37537:3413743] 【UIResponder-Move】121.000000, 135.333328</span><br><span class="line">2017-01-11 17:55:25.143 MyP[37537:3413743] 【UIControl-Move】121.000000, 135.333328</span><br><span class="line">2017-01-11 17:55:25.175 MyP[37537:3413743] 【UIResponder-Move】136.000000, 221.333328</span><br><span class="line">2017-01-11 17:55:25.176 MyP[37537:3413743] 【UIControl-Move】136.000000, 221.333328</span><br><span class="line">2017-01-11 17:55:25.192 MyP[37537:3413743] 【UIResponder-Move】147.666656, 291.666656</span><br><span class="line">2017-01-11 17:55:25.193 MyP[37537:3413743] 【UIControl-Move】147.666656, 291.666656</span><br><span class="line">2017-01-11 17:55:25.209 MyP[37537:3413743] 【UIResponder-Move】159.666656, 352.666656</span><br><span class="line">2017-01-11 17:55:25.210 MyP[37537:3413743] 【UIControl-Move】159.666656, 352.666656</span><br><span class="line">2017-01-11 17:55:25.226 MyP[37537:3413743] 【UIResponder-Move】164.666656, 392.333328</span><br><span class="line">2017-01-11 17:55:25.226 MyP[37537:3413743] 【UIControl-Move】164.666656, 392.333328</span><br><span class="line">2017-01-11 17:55:25.243 MyP[37537:3413743] 【UIResponder-Move】168.666656, 424.000000</span><br><span class="line">2017-01-11 17:55:25.244 MyP[37537:3413743] 【UIControl-Move】168.666656, 424.000000</span><br><span class="line">2017-01-11 17:55:25.260 MyP[37537:3413743] 【UIResponder-Move】170.666656, 445.666656</span><br><span class="line">2017-01-11 17:55:25.260 MyP[37537:3413743] 【UIControl-Move】170.666656, 445.666656</span><br><span class="line">2017-01-11 17:55:25.277 MyP[37537:3413743] 【UIResponder-Move】170.666656, 455.666656</span><br><span class="line">2017-01-11 17:55:25.277 MyP[37537:3413743] 【UIControl-Move】170.666656, 455.666656</span><br><span class="line">2017-01-11 17:55:25.294 MyP[37537:3413743] 【UIResponder-Move】170.666656, 460.666656</span><br><span class="line">2017-01-11 17:55:25.294 MyP[37537:3413743] 【UIControl-Move】170.666656, 460.666656</span><br><span class="line">2017-01-11 17:55:25.348 MyP[37537:3413743] 【UIResponder-End】170.666656, 460.666656</span><br><span class="line">2017-01-11 17:55:25.348 MyP[37537:3413743] 【UIControl-End】170.666656, 460.666656</span><br><span class="line">2017-01-11 17:55:26.431 MyP[37537:3413743] 【UIResponder-Begin】128.000000, 154.666656</span><br><span class="line">2017-01-11 17:55:26.431 MyP[37537:3413743] 【UIControl-Begin】128.000000, 154.666656</span><br><span class="line">2017-01-11 17:55:26.450 MyP[37537:3413743] 【UIResponder-Move】128.000000, 157.666656</span><br><span class="line">2017-01-11 17:55:26.450 MyP[37537:3413743] 【UIControl-Move】128.000000, 157.666656</span><br><span class="line">2017-01-11 17:55:26.467 MyP[37537:3413743] 【UIResponder-Move】128.000000, 163.333328</span><br><span class="line">2017-01-11 17:55:26.468 MyP[37537:3413743] 【UIControl-Move】128.000000, 163.333328</span><br><span class="line">2017-01-11 17:55:26.484 MyP[37537:3413743] 【UIResponder-Move】129.000000, 174.333328</span><br><span class="line">2017-01-11 17:55:26.484 MyP[37537:3413743] 【UIControl-Move】129.000000, 174.333328</span><br><span class="line">2017-01-11 17:55:26.501 MyP[37537:3413743] 【UIResponder-Move】131.000000, 200.000000</span><br><span class="line">2017-01-11 17:55:26.501 MyP[37537:3413743] 【UIControl-Move】131.000000, 200.000000</span><br><span class="line">2017-01-11 17:55:26.518 MyP[37537:3413743] 【UIResponder-Move】135.000000, 235.666656</span><br><span class="line">2017-01-11 17:55:26.518 MyP[37537:3413743] 【UIControl-Move】135.000000, 235.666656</span><br><span class="line">2017-01-11 17:55:26.534 MyP[37537:3413743] 【UIResponder-Move】139.000000, 277.000000</span><br><span class="line">2017-01-11 17:55:26.535 MyP[37537:3413743] 【UIControl-Move】139.000000, 277.000000</span><br><span class="line">2017-01-11 17:55:26.551 MyP[37537:3413743] 【UIResponder-Move】141.000000, 300.666656</span><br><span class="line">2017-01-11 17:55:26.551 MyP[37537:3413743] 【UIControl-Move】141.000000, 300.666656</span><br><span class="line">2017-01-11 17:55:26.568 MyP[37537:3413743] 【UIResponder-Move】141.000000, 325.333328</span><br><span class="line">2017-01-11 17:55:26.709 MyP[37537:3413743] 【UIResponder-End】141.000000, 346.333328</span><br><span class="line">2017-01-11 17:55:26.710 MyP[37537:3413743] 【UIControl-End】141.000000, 346.333328</span><br></pre></td></tr></table></figure>
<p>在单指情况下，可以看到 UIResponder 方法的 UITouch 集合的第一个 UITouch 对象记录的信息和 UIControl 方法的 UITouch 对象记录的信息完全一致，且事件类型也一一对应，基本印证了前面的猜测。</p>
<blockquote>
<p>多指情况下待验证。</p>
</blockquote>
<p>这一点设计和 Android 很不一样，Android 的触摸以及事件监听是 View 提供的特性，所有 View 都有一致的事件监听添加方法，并不像 iOS 这样做了划分，以至像 UILabel 这样的组件无法像 UIButton 一样添加点击事件监听。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java 注释]]></title>
      <url>http://www.timebridge.space/2016/12/22/Java-%E6%B3%A8%E9%87%8A/</url>
      <content type="html"><![CDATA[<p>算起来自己正儿八经写 Java 代码也有两年多了，每每看到 Android Framework 和成熟开源项目的代码，都有一种高大上的气息油然而生。这些代码除了本身写的好，注释通常也非常完善。而平日里接触到的公司代码以及自己写的代码都不是非常注意注释这块儿，写的非常随意甚至不写。</p>
<blockquote>
<p>因此往往通过注释就能区别代码是来自开源项目还是公司内部自己写的。T T</p>
</blockquote>
<p>其实 Java 在关于代码注释的写法这块，是有比较完善的规范的：<a href="http://www.oracle.com/technetwork/articles/java/index-137868.html" target="_blank" rel="noopener">How to Write Doc Comments for the Javadoc Tool</a>。<a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>通常我们在学习一个 系统/SDK 的时候会遇到两类文档：API文档 &amp; 开发指导文档，有的 系统/SDK 会把两类文档混成一个，但是官方并不建议这么做。</p>
<p>API 文档通常是由 Javadoc 从代码注释生成，它所应该标注的应当是与平台无关、实现无关的关于这个方法/类/属性的声明，以达到 Java 的 “write once, run anywhere” 的目标；应当是调用者和实现者之间的一个协议。</p>
<p>开发指导文档一般包括示例、开发术语定义、概念解释和存在的Bug、使用环境。毫无疑问这些描述也有助于开发者理解和使用 系统/SDK，但它并不是接口声明，而是根据接口声明进行的具体实现，在接口文档中不是必须的。Java 本身就将 API 文档和开发指导文档分开维护——JDK 文档包中包含 API 文档以及示例代码和开发指导文档，通过链接来关联两者。</p>
<h2 id="标准写法"><a href="#标准写法" class="headerlink" title="标准写法"></a>标准写法</h2><p>文档注释必须在类/属性/方法前面使用 HTML 格式书写（代码的任何地方都可以写注释，但是只有这些地方的注释会被生成到 API 文档中），标准格式包括两块：描述块 + 标记块。比如下面这个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns an Image object that can then be painted on the screen. </span></span><br><span class="line"><span class="comment"> * The url argument must specify an absolute &#123;<span class="doctag">@link</span> URL&#125;. The name</span></span><br><span class="line"><span class="comment"> * argument is a specifier that is relative to the url argument. </span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * This method always returns immediately, whether or not the </span></span><br><span class="line"><span class="comment"> * image exists. When this applet attempts to draw the image on</span></span><br><span class="line"><span class="comment"> * the screen, the data will be loaded. The graphics primitives </span></span><br><span class="line"><span class="comment"> * that draw the image will incrementally paint on the screen. </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  url  an absolute URL giving the base location of the image</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  name the location of the image, relative to the url argument</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>      the image at the specified URL</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>         Image</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Image <span class="title">getImage</span><span class="params">(URL url, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getImage(<span class="keyword">new</span> URL(url, name));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>前面的两段文字就是描述块，后面四行以<code>@</code>开头的就称为标记块。生成的 API 文档如下：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/API文档示例.png" alt="API文档示例"></div>

<h3 id="基本规范"><a href="#基本规范" class="headerlink" title="基本规范"></a>基本规范</h3><p>比照上面的例子，文档注释的基本规范如下：</p>
<ol>
<li>使用<code>/** */</code>包裹；</li>
<li>从 Javadoc 1.4 开始，每一行的开头 <strong>*</strong> 可选（但是现在的 IDE 在格式化的时候都保持了这个习惯，注释因此看上去也更加整齐）；</li>
<li>第一句话应该是方法的总结，Javadoc 在生成文档的时候会把这句话作为方法总结呈现在方法概要列表里面；</li>
<li>如果注释描述不止一段，每一段之间需要加上<code>&lt;p&gt;</code>标记符；</li>
<li>当遇到第一个以<code>@</code>字符开头的行的时候，就意味着描述块的结束；</li>
</ol>
<h3 id="细节技巧"><a href="#细节技巧" class="headerlink" title="细节技巧"></a>细节技巧</h3><h4 id="第一句描述"><a href="#第一句描述" class="headerlink" title="第一句描述"></a>第一句描述</h4><p>第一句描述会被作为总结呈现在 API 文档适当的地方，例子中展示的是方法，但对于类、属性、接口以及包都是适用的。第一句话通常以 blank，tab，换行符或者是第一个标记块结束。</p>
<blockquote>
<p>99%的情况都是一个正常的英文句子，在中文中，以句号可以达到同样的效果。养成习惯，第一句写一个总结句即可。</p>
</blockquote>
<h4 id="实现无关"><a href="#实现无关" class="headerlink" title="实现无关"></a>实现无关</h4><p>写 API 注释的时候，官方家建议应当尽量与实现无关。实际生产中，像 Android 确实有部分代码是和 J2EE 服务端公用的，也有代码会有多份实现，因此这一点需要多加注意：<strong>注释必须确保有足够的信息保证实现的一致，保证能够写出一致的测试 case，包括边界条件，参数范围，边界 case 等，说明清楚哪些细节可以自由实现</strong>。</p>
<blockquote>
<p>这一点很像 Java 虚拟机规范，列出了实现的很多参数和要求，也有很多方面未有涉及，由实现者自行决定。</p>
</blockquote>
<p>如果必须写明一些实现相关的行为，建议可以另开一个段落，并以清晰的开头表明接下去的描述是实现相关的，下面是一个例子：</p>
<blockquote>
<p>On Windows systems, the path search behavior of the <code>loadLibrary</code> method is identical to that of the Windows API’s <code>LoadLibrary</code> procedure.</p>
</blockquote>
<p>这段注释就清晰的表明它描述的是 Windows 平台相关的内容。</p>
<h4 id="方法注释的自动复用"><a href="#方法注释的自动复用" class="headerlink" title="方法注释的自动复用"></a>方法注释的自动复用</h4><p>有三种情况，方法的注释可以自动从别的地方复用：</p>
<ol>
<li>子类覆写父类的方法；</li>
<li>子接口覆写父接口的方法；</li>
<li>子类实现接口的方法；</li>
</ol>
<p>这三种情况下，都会自动复用被覆写/实现方法的注释（如果你自己写了注释，那就不会复制了，但使用<a href="http://docs.oracle.com/javase/7/docs/technotes/tools/windows/javadoc.html#inheritDoc" target="_blank" rel="noopener"><code>{@inheritDoc}</code></a>可以做到）。</p>
<h4 id="对于关键字以及名字，使用-lt-code-gt"><a href="#对于关键字以及名字，使用-lt-code-gt" class="headerlink" title="对于关键字以及名字，使用&lt;code&gt;"></a>对于关键字以及名字，使用<code>&lt;code&gt;</code></h4><p>对于以下在注释中引用到的字符串，建议使用<code>&lt;code&gt;</code>包裹：</p>
<ol>
<li>Java 关键字；</li>
<li>包、类、方法、接口、属性、参数名字；</li>
<li>代码示例；</li>
</ol>
<p>还有一种更加优雅的写法：<a href="http://docs.oracle.com/javase/7/docs/technotes/tools/windows/javadoc.html#code" target="_blank" rel="noopener"><code>{@code}</code></a>。</p>
<blockquote>
<p>实际使用时发现生成的文档上并没有明显的标记，对于长串的代码也没有格式化，不过在阅读注释的时候显得更加清晰。</p>
</blockquote>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p>除了上述提到的，还有一些注意点：</p>
<ol>
<li>如果一个方法有很多重载形式，那么当需要表达一个通用形式的时候，一定不要再方法名后面加上括号，比如<code>add()</code>和<code>add(int, Object)</code>，直接用<code>add</code>代表这两种形式即可；</li>
<li>使用第三人称而不是第二人称；</li>
<li>通常方法是用来实现一个行为的，因此建议使用动词开头（看方法而异吧）；</li>
<li>使用 this 而不是 the 来代替当前对象；</li>
<li>注释不要只是复述方法名，要添加一些额外的描述（有时候这个很艰难）；</li>
</ol>
<h3 id="Tag（标记）"><a href="#Tag（标记）" class="headerlink" title="Tag（标记）"></a>Tag（标记）</h3><p>Tag，就是前面例子中看到的<code>@param</code>、<code>@return</code>、<code>@see</code>这样的标记，它是大小写铭感的，必须写在某一行的开头（前面可以有空格或者可选的星号），否则就会被当做普通文本处理。</p>
<p><strong>Tag 分为两类，块 Tag (Block Tag)和行内 Tag(Inline Tag)。</strong>前者只能出现在描述后面的 Tag 部分，形式是<code>@tag</code>；后者可以出现在描述块或者块 Tag 后面的描述中，形式是<code>{@tag}</code>。目前 Tag 包括：<code>@author</code>，<code>{@code}</code>，<code>{@docRoot}</code>，<code>@deprecated</code>，<code>@exception</code>，<code>{@inheritDoc}</code>，<code>{@link}</code>，<code>@{linkplain}</code>，<code>{@literal}</code>，<code>@param</code>，<code>@return</code>，<code>@see</code>，<code>serial</code>，<code>@serialData</code>，<code>@serialField</code>，<code>@since</code>，<code>@throws</code>，<code>{@value}</code>，<code>@version</code>。</p>
<p>下面简单介绍下用法，详细可见 <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/windows/javadoc.html#link" target="_blank" rel="noopener">JAVADOC TAGS</a>。</p>
<h4 id="autohor-name-text"><a href="#autohor-name-text" class="headerlink" title="@autohor name-text"></a>@autohor name-text</h4><p>可以使用多个<code>@author</code>表示多个作者，也可以使用<code>,</code>在一个<code>@author</code>中分隔多个作者。</p>
<h4 id="deprecated-deprecated-text"><a href="#deprecated-deprecated-text" class="headerlink" title="@deprecated deprecated-text"></a>@deprecated deprecated-text</h4><p>deprecated-text 会被移到描述块前面，使用斜体表示并前缀一个加粗的告警提示 “Deprecated”。</p>
<p>这个 Tag 可以用在所有的可注释元素上，使用这个 Tag 的时候，至少在第一句话要说明 API 是什么时候被废弃，替代方案是什么，后续描述可以阐述为什么废弃这个 API。示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@deprecated</span>  As of JDK 1.1, replaced by &#123;<span class="doctag">@link</span> #setBounds(int,int,int,int)&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h4 id="docRoot"><a href="#docRoot" class="headerlink" title="{@docRoot}"></a>{@docRoot}</h4><p>表示到当前生成文档根目录的相对的路径，一般用于指向存在于根目录下的指定文件，比如 Logo 或者版权声明。它不但可以在所有的可注释元素中使用，也可以用在命令行中。</p>
<p>命令行使用示例：<code>javadoc -bottom &#39;&lt;a href=&quot;{@docRoot}/copyright.html&quot;&gt;Copyright&lt;/a&gt;&#39;</code>。在注释中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * See the &lt;a href="&#123;<span class="doctag">@docRoot</span>&#125;/copyright.html"&gt;Copyright&lt;/a&gt;.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h4 id="inheritDoc"><a href="#inheritDoc" class="headerlink" title="{@inheritDoc}"></a>{@inheritDoc}</h4><p>这个标记会从继承树中最近的位置复制注释，从而允许在继承树的高层中进行一些通用的注释，在低层中进行更为详细的描述。这个标记可以在下面两个地方使用：</p>
<ol>
<li>在方法的描述块中。这种情况下，会从父类/接口中拷贝描述；</li>
<li>在@return，@param和@throws标记的文本参数中。这种情况下，会从父方法的对应标记中进行拷贝；</li>
</ol>
<blockquote>
<p>详细的寻找过程如下：</p>
<p><strong>Algorithm for Inheriting Method Comments</strong> - If a method does not have a doc comment, or has an {@inheritDoc} tag, the Javadoc tool searches for an applicable comment using the following algorithm, which is designed to find the most specific applicable doc comment, giving preference to interfaces over superclasses:</p>
<ol>
<li>Look in each directly implemented (or extended) interface in the order they appear following the word implements (or extends) in the method declaration. Use the first doc comment found for this method.</li>
<li>If step 1 failed to find a doc comment, recursively apply this entire algorithm to each directly implemented (or extended) interface, in the same order they were examined in step 1.</li>
<li>If step 2 failed to find a doc comment and this is a class other than Object (not an interface):</li>
<li><ol>
<li>If the superclass has a doc comment for this method, use it.</li>
<li>If step 3a failed to find a doc comment, recursively apply this entire algorithm to the superclass.</li>
</ol>
</li>
</ol>
<p>简而言之：会一直往继承树高层找，直到找到对应的注释或者到达 Object 类。</p>
</blockquote>
<h4 id="link-package-class-member-label"><a href="#link-package-class-member-label" class="headerlink" title="{@link  package.class#member  label}"></a><strong>{@link</strong>  package.class#member  label}</h4><p>一个非常强大的标记，可以链接到源码中的任何一个包、类、方法或者属性，从而使得注释可以点击跳转：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Use the &#123;@link #getComponentAt(int, int) getComponentAt&#125; method.</span><br></pre></td></tr></table></figure>
<p>上面的注释会产生如下效果：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Use the <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"Component.html#getComponentAt(int, int)"</span>&gt;</span>getComponentAt<span class="tag">&lt;/<span class="name">a</span>&gt;</span> method.</span><br></pre></td></tr></table></figure>
<p>它可以使用在注释的任何地方。如果 label 不是代码（不是一个方法、类名或者属性名等，与代码无关），可以使用 <code>{@linkplain  package.class#member  label}</code>代替。</p>
<h4 id="literal-text"><a href="#literal-text" class="headerlink" title="{@literal text}"></a>{@literal text}</h4><p>可以避免一段文字被当做 HTML 标记或者 Javadoc 解析，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="meta">@literal</span> A&lt;B&gt;C&#125;</span><br></pre></td></tr></table></figure>
<p><code>&lt;B&gt;</code>就不会被当做加粗来解析，实际上，<code>{@code text}</code>就等于<code>&lt;code&gt;{literal text}&lt;/code&gt;</code>。</p>
<h4 id="param"><a href="#param" class="headerlink" title="@param"></a>@param</h4><p>在方法的注释上很常见，但实际上也可以用来标注类，因为它可以用于标记泛型。</p>
<h4 id="see"><a href="#see" class="headerlink" title="@see"></a>@see</h4><p>这个标记会生成 “See Also” （中文：另请参阅）的注释用于指向一个引用，可以再任何可注释的对象上。它有三种用法：</p>
<ol>
<li><code>@see &quot;string&quot;</code>。例如<code>@see &quot;The Java Programming Language&quot;</code>，string 代表的是一本书或者无法通过 URL 获取的资料，必须要加上双引号才行；</li>
<li><code>@see &lt;a herf=&quot;URL#valie&gt;label&lt;/a&gt;&quot;&gt;</code>。这里给出的是一个 URL；</li>
<li><code>@see package.class#member label</code>。这个用法和<code>{@link}</code>很像，可以链接到源码中的任何包/类/方法/属性。label 是可选的，具体显示可以参见<a href="http://docs.oracle.com/javase/7/docs/technotes/tools/windows/javadoc.html#shortened" target="_blank" rel="noopener">How a name is displayed</a>。</li>
</ol>
<p>具体写法可以参见下面的表格：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/@see写法.png" height="360" alt="API文档示例"></div>

<h4 id="since-since-text"><a href="#since-since-text" class="headerlink" title="@since since-text"></a>@since since-text</h4><p>可以用于标记某个 API /特性是在哪个版本被加上的，可以用在所有可注释的元素上，比如<code>@since 1.5</code>。</p>
<h4 id="throws"><a href="#throws" class="headerlink" title="@throws"></a>@throws</h4><p>和<code>@exception</code>一样，用于表示一个方法可能会抛出的异常，用法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException  If an input or output </span></span><br><span class="line"><span class="comment"> *                      exception occurred</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>实际上如果方法签名（注意：不是方法体）throw 了一个异常，而没有使用 @throws 标记，Javadoc 工具会自动生成一个没有描述的 HTML 插入到文档中。</p>
<h4 id="value-package-class-field"><a href="#value-package-class-field" class="headerlink" title="@{value package.class#field}"></a>@{value package.class#field}</h4><p>如果<code>{@value}</code>用于修饰一个静态的 final 变量，那么就会展示这个变量的值，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The value of this constant is &#123;<span class="doctag">@value</span>&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SCRIPT_START = <span class="string">"&lt;script&gt;"</span></span><br></pre></td></tr></table></figure>
<p>否则它就可以用来表示某个类的常量值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Evaluates the script starting with &#123;<span class="doctag">@value</span> #SCRIPT_START&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">evalScript</span><span class="params">(String script)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：变量必须是静态的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>文章提到的两篇文档中还有很多注释相关的整理，尤其是关于生成文档的命令选项，如果真的需要生成 API 文档，可以仔细研究一下。这里整理的目的主要是为了日常开发所用，一般只限于代码注释而不用生成 API 文档，因此这里就不再继续研究了。</p>
<p>希望这篇文章能够提高一下自己和读者写注释的规范性，让注释能更好的帮助别人理解我们的代码。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[OC Runtime（二）]]></title>
      <url>http://www.timebridge.space/2016/12/10/OC-Runtime%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>在前一篇文章<a href="http://timebridge.space/2016/12/10/OC-Runtime/" target="_blank" rel="noopener">OC Runtime（一）</a>（以下简称”前文”）里面，通过对<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048-CH1-SW1" target="_blank" rel="noopener">《ObjC Runtime Guide》</a>文档的阅读，基本了解了 Runtime 的概念和能力。本文在此基础上进一步深入探索，为什么 Runtime 具备这样的能力，OC 又是基于怎样的结构实现当前的特性的。</p>
<blockquote>
<p>在 Apple 的<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">Source Browser</a>网站上可以下载到 Runtime 的源代码，代码下载下来解压后可以导入到 XCode 中查看。</p>
</blockquote>
<h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><p>前文提到，开发者在 OC 中的消息发送最终会被转化为 <code>objc_msgSend(receiver, selector, arg1, arg2, ...)</code>这样的调用格式，<code>objc_msgSend</code>方法定义在 message.h 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id objc_msgSend(id self, SEL op, ...)</span><br></pre></td></tr></table></figure>
<p>第一个和第二个参数在前文中有相应解释，这里它们的类型分别是 id 和 SEL，并且函数的返回值类型也是 id。那么这两个类型代表什么呢？我们就从这里入手。<a id="more"></a></p>
<h2 id="SEL-和-id"><a href="#SEL-和-id" class="headerlink" title="SEL 和 id"></a>SEL 和 id</h2><p>在项目中简单搜索，很快就能发现两者的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_selector *SEL;</span><br><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure>
<p>SEL 是一个指向 objc_selector 的指针，id 是一个指向 objc_object 的指针。</p>
<h3 id="objc-selector"><a href="#objc-selector" class="headerlink" title="objc_selector"></a>objc_selector</h3><p>关于 objc_selector 这个结构体的定义，runtime 库中并没有给出，但是可以参考以下两份资料：</p>
<ul>
<li><a href="https://sourceware.org/svn/gcc/tags/stack-last-merge/libobjc/objc/objc.h" target="_blank" rel="noopener">objc.h</a></li>
<li><a href="https://books.google.com.hk/books?id=onyzCAAAQBAJ&amp;pg=PA237&amp;lpg=PA237&amp;dq=the+definition+of+objc_selector&amp;source=bl&amp;ots=p2rIQX9Wjb&amp;sig=MxfZ9CPPzWSlAKqyz1xMZJt_10k&amp;hl=zh-CN&amp;sa=X&amp;ved=0ahUKEwj7vbD-4enQAhXFLhoKHa__Cz0Q6AEIVDAI#v=onepage&amp;q=the%20definition%20of%20objc_selector&amp;f=false" target="_blank" rel="noopener">Professional Swift</a></li>
</ul>
<p>其中第二份资料提到：</p>
<blockquote>
<p>However, on OS X and iOS, a struct objc_selector is simply a C string internally.</p>
</blockquote>
<p>结合我们对 SEL 的使用看，可以认为 SEL 等于一个字符串。比如下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method method = class_getInstanceMethod([MsgTest class], @selector(realMethod));</span><br><span class="line">NSLog(@&quot;%@&quot;, NSStringFromSelector(method_getName(method)));</span><br></pre></td></tr></table></figure>
<p>就会输出：realMethod。</p>
<p>读者可以去看看<code>method_getName</code>这个方法的返回值类型，就是 SEL，也就是说 SEL 是用来表示方法名的。</p>
<h3 id="objc-object"><a href="#objc-object" class="headerlink" title="objc_object"></a>objc_object</h3><p>这个结构体定义在 object-private.h 中，只有一个属性：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">isa_t</span> isa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//各种方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个属性是 isa_t 类型，它是一个联合体：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="keyword">isa_t</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="keyword">isa_t</span>(<span class="keyword">uintptr_t</span> value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;</span><br><span class="line">  	<span class="comment">//下面是三个结构体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中核心部分是一个 Class 属性，Class 是什么呢？定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_class *Class;</span><br></pre></td></tr></table></figure>
<p>是一个指向 objc_class 的指针，也就是说，<strong>每一个对象内部都存储着指向自己所属类型的指针</strong>。</p>
<p>objc_class 的定义则如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">uint32_t</span> version;</span><br><span class="line">    <span class="keyword">uint32_t</span> info;</span><br><span class="line">    <span class="keyword">uint32_t</span> instance_size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">old_ivar_list</span> *<span class="title">ivars</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">old_method_list</span> **<span class="title">methodLists</span>;</span></span><br><span class="line">    Cache cache;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">old_protocol_list</span> *<span class="title">protocols</span>;</span></span><br><span class="line">  	<span class="comment">// CLS_EXT only</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> *ivar_layout;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">old_class_ext</span> *<span class="title">ext</span>;</span></span><br><span class="line">    <span class="comment">//各种方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里就很有意思了，虽然这些代码注释不多，但根据名字，依然能够看出一些端倪。</p>
<ul>
<li>首先这个结构体是继承 objc_object 的，这表明类也是一个对象，同时也会有一个 isa 属性；</li>
<li>其次这个结构体包含一个 superclass 的 Class 属性，这应该是指向它的父类；</li>
<li>接着，这个结构体包含三个结构体，从名字看，应该是依次包含所有变量、方法和实现的协议；</li>
<li>还有一个 Cache 变量，这个应该是前文提到的用于缓存被调用方法的；</li>
<li>最后，有一个 old_class_ext 扩展结构体属性；</li>
</ul>
<h4 id="变量、方法、协议和属性"><a href="#变量、方法、协议和属性" class="headerlink" title="变量、方法、协议和属性"></a>变量、方法、协议和属性</h4><p>变量列表的结构定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">old_ivar</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *ivar_name;</span><br><span class="line">    <span class="keyword">char</span> *ivar_type;</span><br><span class="line">    <span class="keyword">int</span> ivar_offset;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">old_ivar_list</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ivar_count;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* variable length structure */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">old_ivar</span> <span class="title">ivar_list</span>[1];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看上去很简单，这个列表里面存储着的元素是 old_var，而这个结构体中有两个很重要的成员：变量名和变量类型。方法列表大致相同：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">old_method</span> &#123;</span></span><br><span class="line">    SEL method_name;</span><br><span class="line">    <span class="keyword">char</span> *method_types;</span><br><span class="line">    IMP method_imp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">old_method_list</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *obsolete;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> method_count;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* variable length structure */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">old_method</span> <span class="title">method_list</span>[1];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是方法列表的元素结构体有些特殊，首先方法名是 SEL 类型的，这个前面已经有分析。method_types 是什么？IMP 是又什么东西呢？</p>
<p>如果读者阅读了前文提到的<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1" target="_blank" rel="noopener">Type Encodings</a>小节，其实不是很难理解 method_types，我们可以使用如下的代码打印出它的案例，还是以前文的 MsgTest 类为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method method = class_getInstanceMethod([MsgTest class], @selector(realMethod));</span><br><span class="line">NSLog(@&quot;%s&quot;, method_getTypeEncoding(method));</span><br></pre></td></tr></table></figure>
<p>这段代码会输出：v16@0:8。</p>
<blockquote>
<p>v 表示 void，即返回值为 void，16 表示 整个方法参数占位的总长度，@0 表示在参数区域偏移为 0 的位置有一个 OC 对象，还记得前面说到的方法在被编译之后，第一个参数是 id 类型，即 self 么？:8 表示在参数列表偏移为 8 字节的地方有一个 SEL 对象，也就是前面分析的第二个参数 _cmd。</p>
<p>这里由于内存对齐的原因，会导致很多类型都站 4 个字节或者 8 个字节，读者可以自己实验。</p>
</blockquote>
<p>IMP 的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A pointer to the function of a method implementation. </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !OBJC_OLD_DISPATCH_PROTOTYPES</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*IMP)</span><span class="params">(<span class="keyword">void</span> <span class="comment">/* id, SEL, ... */</span> )</span></span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">id</span> <span class="params">(*IMP)</span><span class="params">(id, SEL, ...)</span></span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>注释说的很明白：指向方法实现的函数指针。其实在前文中提到 class_addMethod 的时候，已经遇到并使用过它了。</p>
<p>协议部分的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">old_protocol</span> &#123;</span></span><br><span class="line">    Class isa;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *protocol_name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">old_protocol_list</span> *<span class="title">protocol_list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_method_description_list</span> *<span class="title">instance_methods</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_method_description_list</span> *<span class="title">class_methods</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">old_protocol_list</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">old_protocol_list</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">long</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">old_protocol</span> *<span class="title">list</span>[1];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>协议元素 old_protocol 包含两个结构体，分别描述实例方法和类方法。最终都指向以下元素的一个集合：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Defines a method</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_method_description</span> &#123;</span></span><br><span class="line">	SEL name;               <span class="comment">/**&lt; The name of the method */</span></span><br><span class="line">	<span class="keyword">char</span> *types;            <span class="comment">/**&lt; The types of the method arguments */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里倒是很清楚的指出了<strong>SEL 代表的就是方法名</strong>，而 types 指向的是参数类型。只不过协议是没有方法实现的，因此这里没有 IMP 指针。其余的部分就不过多探究了。</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>乍一看，objc_class 结构体中并没有属性相关的内容，那是因为属性藏到了 old_class_ext 结构体中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">old_class_ext</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> size;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> *weak_ivar_layout;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">old_property_list</span> **<span class="title">propertyLists</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>old_property_list 结构体的内容如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">old_property</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *attributes;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">old_property_list</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> entsize;</span><br><span class="line">    <span class="keyword">uint32_t</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">old_property</span> <span class="title">first</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>到这边会看到一些熟悉的东西，这个列表里的元素是 old_property 结构体，还记得前文中打印属性的 name 和attributes 的例子么？这就是那两个值存储的地方。</p>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>Cache 的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_cache</span> *<span class="title">Cache</span></span></span><br></pre></td></tr></table></figure>
<p>它是一个指向 objc_cache 的指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_cache</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask <span class="comment">/* total = mask + 1 */</span>                 OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> occupied                                    OBJC2_UNAVAILABLE;</span><br><span class="line">    Method buckets[<span class="number">1</span>]                                        OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Method 又是啥？其实前面的例子中已经用到，它的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">old_method</span> *<span class="title">Method</span>;</span></span><br></pre></td></tr></table></figure>
<p>就是一个指向 old_method 结构体的指针，这个结构体前面已经展示过了，因此 Cache 可以简单的认为就是一个存储着方法列表的结构体。这和我们之前了解到的和猜测的也相符合。</p>
<h4 id="类和元类"><a href="#类和元类" class="headerlink" title="类和元类"></a>类和元类</h4><p>虽然前面对 objc_class 结构体的展示省略了所有的方法，但是其中有一个方法还是比较重要的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NOT identical to this-&gt;ISA() when this is a metaclass</span></span><br><span class="line"><span class="function">Class <span class="title">getMeta</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (isMetaClass()) <span class="keyword">return</span> (Class)<span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">this</span>-&gt;ISA();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里涉及到一个元类的概念，当调用<code>getMeta()</code>方法的时候，如果当前类就是一个元类，返回自身就好，否则返回的是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> Class objc_object::ISA() </span><br><span class="line">&#123;</span><br><span class="line">    assert(!isTaggedPointer()); </span><br><span class="line">    <span class="keyword">return</span> isa.cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是个内联函数，最终值为 isa.cls —— 指向的是一个 Class 对象。那么究竟什么是 Meta Class 呢？读者可以参考这篇文章：<a href="https://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html" target="_blank" rel="noopener">What is a meta-class in Objective-C?</a> 它的主要结论如下：</p>
<ol>
<li>任何包含指向 Class 结构体指针的结构体都可以被认为是 objc_object，这也是为什么 OC 中可以向对象发送消息的原因：因为 Class 中包含了方法列表，这个在前文以及前面的分析中都已经提到；</li>
<li>Class 也是一个对象，根据前面的分析，objc_class 是继承 objc_object 的，也就是说，Class 也可以接收消息，比如<code>[NSObject alloc]</code>；</li>
<li>既然 Class 也是一个对象，那就必然有一个指针指针一个类型，以符合结论 1 中定义的 objc_object 的结构体特性，Class 指向的这个类型也必须包含一个 Method 列表以表明我们可以在 Class 上执行哪些方法；</li>
<li>Meta-Class，即元类，就是为这个需求存在的：当向一个 Class 对象发送消息的时候，就会在元类中寻找消息的处理者，也就是说，元类存储着类方法，每一个类都必须有自己独特的元类，因为每个类的类方法都可能不一样；</li>
<li>既然元类也有消息处理能力，即表明元类也和 Class 一样，也是一个对象，那它也必须有一个 Class。所有的元类都以继承树中的最基类的元类作为它们的 Class，也就是 NSObject 的所有子类的元类都以 NSObject 的元类作为自己的 Class。</li>
<li>Class 通过 superclass 指向指向自己的父类，meta-class 则通过自己的 superclass 指向父类的元类。</li>
</ol>
<p>总结下来就是下面这幅图（来源不明）：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/类与元类.jpg" height="360" alt="Android调优工具汇总"></div>

<p><strong>最基类（NSObject）是所有子类的基类，最基类的元类是最基类所有子类的元类的最基类，最基类的元类是所有子类以及自身元类的元类。</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，Runtime 中比较重要的数据结构分析完毕，结合前文，我们也基本知道了 OC 下面是怎样的一套数据结构在支撑它的特性。</p>
<p>Runtime 库中有部分实现代码在其中，在了解了基本的数据结构之后，接着就是探索 OC 特性与这些数据结构之间的关系，比如 Category 的实现原理、Method Swizzling等。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[OC Runtime（一）]]></title>
      <url>http://www.timebridge.space/2016/12/10/OC-Runtime/</url>
      <content type="html"><![CDATA[<blockquote>
<p>参考资料：<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048-CH1-SW1" target="_blank" rel="noopener">《ObjC Runtime Guide》</a>。</p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>简单来说，<strong>Runtime 是 OC 语言的运行环境</strong>。</p>
<p>OC 会尽量将决议延迟到运行时做出而非在编译和连接期间，比如方法调用具体是执行哪段代码。这意味着 OC 不仅需要一个特定的编译器，而且需要一个运行系统来执行编译后的代码从而实现决议延迟，这有点像 JVM 和 Java的关系。因此研究 Runtime 有助于了解 OC 的运行，帮助认识 OC 的本质。</p>
<p>Runtime 分为两个版本，“modern”和“legacy”。modern 版本从 OC2.0 开始引入，在<a href="https://developer.apple.com/reference/objectivec/1657527-objective_c_runtime" target="_blank" rel="noopener">Objective-C Runtime Reference</a>中有详细的开发接口描述。modern 版本相比于 legacy 版本的最大亮点在于：在 legacy 版本的 Runtime 中，如果你改变了实例变量的布局，就必须重新编译所有的子类，在 modern 版本的 Runtime 中则不需要。另外， modern 版本 Runtime 支持从声明的 property 综合推理（synthesis）出实例变量。</p>
<p>iPhone 应用和 OS X v10.5以及之后版本的 64-bit 程序使用的是 modern 版本，其余的应用使用的是 legacy 版本。<a id="more"></a></p>
<blockquote>
<p>legacy 版本开发接口在 Objective-C 1 Runtime Reference 中有描述，但基本不需要去关心了。</p>
</blockquote>
<h3 id="调用-Runtime-的方式"><a href="#调用-Runtime-的方式" class="headerlink" title="调用 Runtime 的方式"></a>调用 Runtime 的方式</h3><p>OC 语言和 Runtime 有三种层次的交互：</p>
<ul>
<li><strong>通过 OC 源码交互。</strong> 这种交互并不是说通过 OC 方法去调用 runtime ，而是指编译器会通过创建合适的数据结构和方法调用来实现语言的动态特征，比如用于描述类、Category、协议以及 selector。最主要的一个 runtime 函数就是用于发送消息的，后面会有描述，它就是通过 OC 层面的消息发送表达式来调用的。</li>
<li><strong>使用 Foundation 中定义的 NSObject 类交互。 </strong> Cocoa 中大部分的对象都是 NSObject 的子类，所以它们也继承了 NSobject 的方法，其中有部分方法是用于内省的，比如<code>class</code>方法——用于询问一个对象它的类是什么；用于判断继承关系的方法<code>isKindOfClass:</code>和<code>isMemberOfClass:</code>；判断一个对象是否能接受某个消息的方法<code>respondsToSelector:</code>；判断一个对象是否实现了某个协议的方法<code>conformsToProtocol:</code>；查询方法实现地址的方法<code>methodForSelector:</code>。这些方法赋予了对象内省的能力。</li>
<li><strong>直接调用 runtime 函数。</strong> Runtime 系统是一个动态链接库，由一组函数和数据结构组成的，它位于系统的 /usr/include/objc 目录下面。这里的很多函数允许开发者在开发应用的时候使用纯 C 语言来复制编译器的行为。其中一些就是前面提到的 NSObject 内省函数的基础。所有的这些函数都可以在文档 <a href="https://developer.apple.com/reference/objectivec/1657527-objective_c_runtime" target="_blank" rel="noopener">Objective-C Runtime Reference</a> 中查阅。</li>
</ul>
<h3 id="Runtime的内容"><a href="#Runtime的内容" class="headerlink" title="Runtime的内容"></a>Runtime的内容</h3><p>Runtime总共包含三个方面的内容：</p>
<ul>
<li>类的动态加载</li>
<li>消息发送</li>
<li>属性内省</li>
</ul>
<p>下面一一阐述。</p>
<h2 id="类的动态加载"><a href="#类的动态加载" class="headerlink" title="类的动态加载"></a>类的动态加载</h2><p>OC 可以在运行时加载和链接新的类和 Category，加载完成后和程序中原始的类以及 Category 并无二致。我们有两种方式可以进行类动态加载：</p>
<ol>
<li>objc/objc-load.h 文件中定义的 runtime 函数；</li>
<li>Cocoa 的 NSBundle 类；</li>
</ol>
<p>具体操作因为文档没有描述，本文也不打算拓展，计划后面补充。</p>
<h2 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h2><p>在 OC 代码中我们通过<code>[]</code>来表达一个消息的发送，比如<code>[self class]</code>，这个调用最终会被转化为<code>objc_msgSend</code>函数调用。</p>
<h3 id="objc-msgSend函数"><a href="#objc-msgSend函数" class="headerlink" title="objc_msgSend函数"></a><code>objc_msgSend</code>函数</h3><p><code>objc_msgSend</code>函数的转换如下：如果 OC 中的调用是<code>[receiver message]</code>，那么会被转化为<code>objc_msgSend(receiver, selector)</code>，其中 selector 代表的就是 message，如果有参数，就会转化为<code>objc_msgSend(receiver, selector, arg1, arg2, ...)</code>调用样式，通过这个函数就可以实现动态绑定：</p>
<ol>
<li>它首先会找到 selector 指向的方法实现。由于不同的类可能会实现同样的方法（指的是方法名字一样），因此这个寻找过程是依赖于 receiver 的，简单来说，就是找到 receiver 上的这个方法的实现；</li>
<li>之后调用这个方法实现，将对象实例以及参数传递给方法（传递对象实例是为了引用对象的实例变量）；</li>
<li>最终它会返回方法返回的值；</li>
</ol>
<blockquote>
<p>苹果建议永远不要自己去调用这个函数。</p>
</blockquote>
<p>发送消息的关键在于编译器为每一个类和对象创建的数据结构。每一个类都包含两个关键的元素：</p>
<ul>
<li>指向父类的指针；</li>
<li>类分发表。这张表定义了 selector 到类定义方法的映射。</li>
</ul>
<p>每一个对象实例创建之后，都会携带有一个指向类结构的指针变量——<code>isa</code>。这个指针可以让对象知道自己的类型以及自己的所有父类。</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/消息发送框架.png" width="280" alt="消息发送框架"></div>

<p>如图，当一个对象接收到一个消息时，<code>objc_msgSend</code>函数会根据对象的<code>isa</code>指针找到类结构体，从而找到类的分发表，查询是否有 selector 对应的方法体，如果没有，则根据 superclass 找到父类的分发表，周而复始直到找到对应的方法体。<strong>这就是运行时动态绑定方法的流程</strong>。</p>
<blockquote>
<p>找不到的处理后面会提到。</p>
</blockquote>
<p>这种实现的缺点很明显：如果每次都去一层层找，肯定比直接进行方法调用要慢很多，这种差别就像在链表和数组中定位一个元素一样，一个通过下标定位，一个通过遍历定位，差距不言而喻。因此在每个类中会有额外的缓存结构来存储这个类经常使用到的方法——包括自身和父类的方法。对象每次收到一个消息的时候都会首先搜寻缓存结构，搜寻不到才会去搜寻分发表。通过这种方式，可以缩小消息发送和方法调用之间的速度差距。后面还会提到别的手段用于缩小这种差距。</p>
<blockquote>
<p>缓存基于局部性原理。</p>
</blockquote>
<h3 id="隐藏的参数"><a href="#隐藏的参数" class="headerlink" title="隐藏的参数"></a>隐藏的参数</h3><p>当使用<code>objc_msgSend</code>函数传递消息的时候，它不仅会传递原来消息的所有参数，还会默认传递两个额外的参数：</p>
<ol>
<li>接受对象 receiver；</li>
<li>表示方法的 selector；</li>
</ol>
<p>这两个参数在编译器编译时被“偷偷”插入，从而使得<code>objc_msgSend</code>可以还原出完整的消息发送信息：</p>
<ol>
<li>消息是什么（selector）；</li>
<li>消息是发送给谁的（receiver）；</li>
<li>参数是什么；</li>
</ol>
<p>虽然参数是隐形的，但是在代码里面却可以使用它们，它们分别是<code>self</code>和<code>_cmd</code>。比如下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)strange &#123;</span><br><span class="line">    id  target = getTheReceiver();</span><br><span class="line">    SEL method = getTheMethod();</span><br><span class="line">    if ( target == self || method == _cmd )</span><br><span class="line">        return nil;</span><br><span class="line">    return [target performSelector:method];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 self 就代表消息 strange 所在的对象，_cmd 就表示代表 strange 的 selector。<strong>self 就是方法为什么可以操作对象实例变量的关键所在：通过self，可以引用到对象本身，从而可以引用对象的变量</strong>。</p>
<h3 id="获取方法地址"><a href="#获取方法地址" class="headerlink" title="获取方法地址"></a>获取方法地址</h3><p>动态绑定处理消息方法的过程比较耗时，除了可以使用缓存加快查询速度，还可以通过获取方法地址直接调用方法的方式来避免动态绑定。这种方法并不常见，除非你在短时间内需要高频次的调用某个方法，并且直接调用已经造成性能问题。</p>
<p>NSObject 中有一个方法是用于获取方法地址的：<code>methodForSelector</code>，通过这个方法可以获得一个函数指针，用法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void (*setter)(id, SEL, BOOL);</span><br><span class="line">int i;</span><br><span class="line">setter = (void (*)(id, SEL, BOOL))[target</span><br><span class="line">    methodForSelector:@selector(setFilled:)];</span><br><span class="line">for ( i = 0 ; i &lt; 1000 ; i++ )</span><br><span class="line">    setter(targetList[i], @selector(setFilled:), YES);</span><br></pre></td></tr></table></figure>
<p>声明的函数指针中也标记除了隐形参数，在调用的时候需要把对应的值设置进去。</p>
<h3 id="方法动态解析"><a href="#方法动态解析" class="headerlink" title="方法动态解析"></a>方法动态解析</h3><p>OC 除了可以通过 <code>objc_msgSend</code>函数动态绑定已有的方法，还可以通过实现方法<code>resolveInstanceMethod:</code>和<code>resolveInstanceMethod:</code>动态提供类方法和实例方法实现。<strong>OC 方法本质上来说就是至少接受 self 和 _cmd 两个参数的 C 函数</strong>。通过调用方法<code>class_addMethod</code>可以为类添加一个函数，举例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void dynamicMethodIMP(id self, SEL _cmd) &#123;</span><br><span class="line">    // implementation ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@implementation MyClass</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)aSEL &#123;</span><br><span class="line">	if (aSEL == @selector(resolveThisMethodDynamically)) &#123;</span><br><span class="line">		class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &quot;v@:&quot;);</span><br><span class="line">		return YES;</span><br><span class="line">	&#125;</span><br><span class="line">	return [super resolveInstanceMethod:aSEL];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>消息转发（后面会提）和方法动态解析绝大部分情况下是正交的，方法动态解析会在消息转发之前进行。如果<code>respondsToSelector:</code>或者<code>instancesRespondToSelector:</code>被调用，方法动态解析是有机会为 selector 提供一个 IMP（可以认为是函数指针）的。但如果想在动态解析之后进行消息转发，这里可以返回 NO。</p>
<h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><p>前面提到，<code>objc_msgSend</code>函数会在分发表中寻找 selector 对应的方法体，如果找到 NSObject 还是找不到怎么办呢？一种情况就是动态方法解析，如果返回 YES，就表示对于的方法体已经添加到了类中，NO 则相反。那么如果是返回是 NO，那是不是程序就出错，直接 crash 了呢？OC 在这个时候还提供了最后一道关卡：在报错之前，runtime 会向消息的原本发送对象发送一个<code>forwardInvocation:</code>消息，并携带一个 NSInvocation 参数，这个参数包装了原始的消息和参数。我们可以在这个地方对一个消息进行最后的处理。</p>
<p>首先顾名思义，这个方法一般用于将消息转发给别的对象。通过实现这个方法，我们可以给消息一个默认的响应，或者通过别的手段来防止出错。如果我们不去重载这个方法，那么就会执行 NSObject 的默认实现，即调用<code>doesNotRecognizeSelector:</code>方法，从而报错。举例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation</span><br><span class="line">&#123;</span><br><span class="line">    if ([someOtherObject respondsToSelector:[anInvocation selector]])</span><br><span class="line">        [anInvocation invokeWithTarget:someOtherObject];</span><br><span class="line">    else</span><br><span class="line">    	[super forwardInvocation:anInvocation];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这方法可以扮演不能识别的消息的转发中心，或者作为一个中转站，将所有的消息转发到一个特定的对象；也可以将一个消息转换为别的消息，甚至直接吞没一些消息，以避免错误发生。简而言之，未被识别的消息以及未能动态解析的消息都会被转到这里进行处理，因此这里可以有很多玩法，比如多继承模拟，比如实现代理。</p>
<blockquote>
<p>注意：想要这个方法被调用，还需要重载另外一个方法<code>methodSignatureForSelector:</code>，详细见下面例子。</p>
</blockquote>
<p>除了<code>forwardInvocation</code>这个方法之外，还有一个方法也可以扮演这个角色——<code>forwardingTargetForSelector:</code>。这个方法通过返回一个消息的接收者来完成对消息的转发，后面示例会给出用法。</p>
<h4 id="消息转发模拟多继承"><a href="#消息转发模拟多继承" class="headerlink" title="消息转发模拟多继承"></a>消息转发模拟多继承</h4><p>消息转发是可以模拟出多继承的。如下图：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/消息转发.png" width="320" alt="消息转发"></div>

<p>Warrior 通过把 negotiate 方法转发给 Diplomat，看上去就像是继承了 Diplomat，另外一方面 Warrior 本身就继承了 NSObject，从而就具备了两条继承线。</p>
<blockquote>
<p>这种多继承的“模拟”其实就是组合的一个变种，只不过实现起来更加方便。</p>
</blockquote>
<p>实际上要完全模拟多继承并没有这么简单，我们需要修改很多默认的内省函数来进一步完善这种模拟，比如:</p>
<ul>
<li><code>respondsToSelector:</code></li>
<li><code>isKindOfClass:</code></li>
<li><code>nstancesRespondToSelector:</code></li>
<li><code>methodSignatureForSelector:</code></li>
<li><code>methodSignatureForSelector:</code></li>
</ul>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)respondsToSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    if ( [super respondsToSelector:aSelector] )</span><br><span class="line">        return YES;</span><br><span class="line">    else &#123;</span><br><span class="line">        /* Here, test whether the aSelector message can     *</span><br><span class="line">         * be forwarded to another object and whether that  *</span><br><span class="line">         * object can respond to it. Return YES if it can.  */</span><br><span class="line">    &#125;</span><br><span class="line">	return NO; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>前面描述了消息处理的过程，总共包括三种方式：</p>
<ol>
<li>分发表；</li>
<li>动态解析；</li>
<li>消息转发；</li>
</ol>
<p>下面给一个例子实践一下，为了节省篇幅和方便阅读，h 和 m 就写在一个代码块里面了。首先声明 MsgTest 类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">@interface MsgTest : NSObject</span><br><span class="line">-(void)realMethod;</span><br><span class="line">@end</span><br><span class="line">  </span><br><span class="line">void dynamicMethodIMP(id self, SEL _cmd) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, @&quot;Dynamic Resolving.&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@interface MsgTest ()</span><br><span class="line">@property(nonatomic, strong) MsgResovler *msgResolver;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MsgTest</span><br><span class="line">@synthesize msgResolver;</span><br><span class="line"></span><br><span class="line">-(instancetype)init&#123;</span><br><span class="line">    if(self = [super init])&#123;</span><br><span class="line">        msgResolver = [[MsgResovler alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)realMethod&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, @&quot;Real Method&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)aSEL &#123;</span><br><span class="line">    if (aSEL == @selector(resolveThisMethodDynamically)) &#123;</span><br><span class="line">        class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &quot;v@:&quot;);</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:aSEL];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    if (aSelector == @selector(forwardTarget)) &#123;</span><br><span class="line">        return msgResolver; // 返回实际处理对象</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation</span><br><span class="line">&#123;</span><br><span class="line">    if ([msgResolver respondsToSelector:[anInvocation selector]])</span><br><span class="line">        [anInvocation invokeWithTarget:msgResolver];</span><br><span class="line">    else</span><br><span class="line">        [super forwardInvocation:anInvocation];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 消息转发的时候，不要忘了实现这个方法</span><br><span class="line">- (NSMethodSignature*)methodSignatureForSelector:(SEL)selector</span><br><span class="line">&#123;</span><br><span class="line">    NSMethodSignature* signature = [super methodSignatureForSelector:selector];</span><br><span class="line">    if (!signature) &#123;</span><br><span class="line">        signature = [msgResolver methodSignatureForSelector:selector];</span><br><span class="line">    &#125;</span><br><span class="line">    return signature;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>这是核心类，会根据前面提到的消息处理方式分别接受四种消息，接着为消息转发声明消息接受类 MsgResovler：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@interface MsgResovler : NSObject</span><br><span class="line">-(void)forwardMsg;</span><br><span class="line">-(void)forwardTarget;</span><br><span class="line">@end</span><br><span class="line">  </span><br><span class="line">@implementation MsgResovler</span><br><span class="line">-(void)forwardMsg &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, @&quot;Forwarded Msg&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)forwardTarget&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, @&quot;Forwarding Target&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>最后尝试调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        MsgTest *msgTest = [[MsgTest alloc] init];</span><br><span class="line">        NSLog(@&quot;%@&quot;, @&quot;============= 真实方法 =============&quot;);</span><br><span class="line">        [msgTest realMethod];</span><br><span class="line">        NSLog(@&quot;%@&quot;, @&quot;============= 动态解析 =============&quot;);</span><br><span class="line">        [msgTest performSelector:@selector(resolveThisMethodDynamically)];</span><br><span class="line">        NSLog(@&quot;%@&quot;, @&quot;============= 消息转发 =============&quot;);</span><br><span class="line">        [msgTest performSelector:@selector(forwardMsg)];</span><br><span class="line">      	NSLog(@&quot;%@&quot;, @&quot;============= 消息转发 =============&quot;);</span><br><span class="line">        [msgTest performSelector:@selector(forwardTarget)];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就可以看到控制台输出：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">============= 真实方法 =============</span><br><span class="line">Real Method</span><br><span class="line">============= 动态解析 =============</span><br><span class="line">Dynamic Resolving.</span><br><span class="line">============= 消息转发 =============</span><br><span class="line">Forwarded Msg</span><br><span class="line">============= 消息转发 =============</span><br><span class="line">Forwarding Target</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>
<p>四个方法都顺利完成调用，没有报错。那么这几种方法的调用顺序是什么样子的呢？借用网上一幅图：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/消息发送路线.png" width="360" alt="消息转发路线"></div>

<p>一目了然。</p>
<h2 id="属性内省"><a href="#属性内省" class="headerlink" title="属性内省"></a>属性内省</h2><h3 id="Type-Encoding"><a href="#Type-Encoding" class="headerlink" title="Type Encoding"></a>Type Encoding</h3><p>在说属性内省之前，需要先说一个概念——Type Encoding。Type Encoding 实际是用于表达方法返回值和参数的简洁表达式，开发者可以通过<code>@encode()</code>编译命令对某一个特定类型进行转化，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char *buf1 = @encode(int **);//^^i</span><br><span class="line">char *buf2 = @encode(struct key);//要看key内容</span><br><span class="line">char *buf3 = @encode(Rectangle);//要看Rectangle类</span><br></pre></td></tr></table></figure>
<p>具体对应列表如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Code</th>
<th style="text-align:center">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">c</td>
<td style="text-align:center">A char</td>
</tr>
<tr>
<td style="text-align:center">i</td>
<td style="text-align:center">An int</td>
</tr>
<tr>
<td style="text-align:center">s</td>
<td style="text-align:center">A short</td>
</tr>
<tr>
<td style="text-align:center">l</td>
<td style="text-align:center">A long</td>
</tr>
<tr>
<td style="text-align:center">q</td>
<td style="text-align:center">A long long</td>
</tr>
<tr>
<td style="text-align:center">C</td>
<td style="text-align:center">An unsigned char</td>
</tr>
<tr>
<td style="text-align:center">I</td>
<td style="text-align:center">An unsigned int</td>
</tr>
<tr>
<td style="text-align:center">S</td>
<td style="text-align:center">An unsigned short</td>
</tr>
<tr>
<td style="text-align:center">L</td>
<td style="text-align:center">An unsigned long</td>
</tr>
<tr>
<td style="text-align:center">Q</td>
<td style="text-align:center">An unsigned long long</td>
</tr>
<tr>
<td style="text-align:center">f</td>
<td style="text-align:center">A float</td>
</tr>
<tr>
<td style="text-align:center">d</td>
<td style="text-align:center">A double</td>
</tr>
<tr>
<td style="text-align:center">B</td>
<td style="text-align:center">A C++ bool or C99_Bool</td>
</tr>
<tr>
<td style="text-align:center">v</td>
<td style="text-align:center">A void</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">A character string(char *)</td>
</tr>
<tr>
<td style="text-align:center">@</td>
<td style="text-align:center">An object(whether statically typed or typed id)</td>
</tr>
<tr>
<td style="text-align:center">#</td>
<td style="text-align:center">A class object(Class)</td>
</tr>
<tr>
<td style="text-align:center">:</td>
<td style="text-align:center">A method selector(SEL)</td>
</tr>
<tr>
<td style="text-align:center">[array type]</td>
<td style="text-align:center">An array</td>
</tr>
<tr>
<td style="text-align:center">{name=type…}</td>
<td style="text-align:center">A structure</td>
</tr>
<tr>
<td style="text-align:center">(name=type…)</td>
<td style="text-align:center">A union</td>
</tr>
<tr>
<td style="text-align:center">bnum</td>
<td style="text-align:center">A bit bield of num bits</td>
</tr>
<tr>
<td style="text-align:center">^type</td>
<td style="text-align:center">A pointer</td>
</tr>
<tr>
<td style="text-align:center">?</td>
<td style="text-align:center">An unknown type(among other things, this code is used for function pointers)</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意：OC 不支持 long double 类型，@encode(long double) 会返回 d，也就是会被当做 double 执行。</p>
</blockquote>
<p>下面是一些例子：</p>
<table>
<thead>
<tr>
<th style="text-align:center">例子</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">[12^f]</td>
<td style="text-align:center">一个包含12个指向 float 元素的指针的数组</td>
</tr>
<tr>
<td style="text-align:center">{example=@*i}</td>
<td style="text-align:center">一个包含对象、char指针和int值的结构体，名为example</td>
</tr>
<tr>
<td style="text-align:center">^{example=@*i}</td>
<td style="text-align:center">上述结构体的指针</td>
</tr>
<tr>
<td style="text-align:center">^^{example}</td>
<td style="text-align:center">上述指针的指针，这时候可以忽略结构体内容</td>
</tr>
<tr>
<td style="text-align:center">{NSObject=# }</td>
<td style="text-align:center">对象会被当做结构体对待，@encode(NSObject)就会产生左边的表达式，NSObject 的对象实例只有一个 Class 类型的 isa 指针。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>关于@encode{NSObject}，输出的其实是NSObject这个类它的实例的表达式：包含一个 isa 指针以及属性。</p>
</blockquote>
<h3 id="Property-类型和函数"><a href="#Property-类型和函数" class="headerlink" title="Property 类型和函数"></a>Property 类型和函数</h3><p>当编译器在编译 property 的时候，它会产生一些与类、Category以及协议相关的描述元数据。OC 提供了一些函数可以通过名字搜索类或者协议上的 property，从而获取这些元数据。</p>
<p>Property 实际是一个 objc_property 指针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_property *Property;</span><br></pre></td></tr></table></figure>
<p>开发者可以通过<code>class_copyPropertyList</code>和<code>protocol_copyPropertyList</code>两个函数来获取类/协议的属性数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)</span><br><span class="line">objc_property_t *protocol_copyPropertyList(Protocol *proto, unsigned int *outCount)</span><br></pre></td></tr></table></figure>
<p>举个例子，声明如下一个类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface Lender : NSObject &#123;</span><br><span class="line">    float ins;</span><br><span class="line">&#125;</span><br><span class="line">@property float alone;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>通过如下方法可以获取属性列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id LenderClass = objc_getClass(&quot;Lender&quot;);</span><br><span class="line">unsigned int outCount;</span><br><span class="line">objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;outCount);</span><br></pre></td></tr></table></figure>
<p>获取属性之后，可以根据<code>property_getName</code>来获取属性名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const char *property_getName(objc_property_t property)</span><br></pre></td></tr></table></figure>
<p>通过指定某个类的某个属性名字，也可以获取到一个属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objc_property_t class_getProperty(Class cls, const char *name)</span><br><span class="line">objc_property_t protocol_getProperty(Protocol *proto, const char *name, BOOL</span><br><span class="line">isRequiredProperty, BOOL isInstanceProperty)</span><br></pre></td></tr></table></figure>
<p>接着调用<code>property_getAttributes</code>函数可以获取属性的名字以及 @encode 类型字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const char *property_getAttributes(objc_property_t property)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>@encode 类型字符串 可以参见<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html#//apple_ref/doc/uid/TP40008048-CH101-SW1" target="_blank" rel="noopener">Property Type String</a>和<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html#//apple_ref/doc/uid/TP40008048-CH101-SW1" target="_blank" rel="noopener">Property Attribute Description Examples</a>。</p>
</blockquote>
<p>把这些代码融合在一块儿，就可以获得一个类/协议的所有属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">id LenderClass = objc_getClass(&quot;Lender&quot;);</span><br><span class="line">unsigned int outCount, i;</span><br><span class="line">objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;outCount);</span><br><span class="line">for (i = 0; i &lt; outCount; i++) &#123;</span><br><span class="line">	objc_property_t property = properties[i];</span><br><span class="line">	fprintf(stdout, &quot;%s %s\n&quot;, property_getName(property), property_getAttributes(property));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alone Tf,V_alone</span><br></pre></td></tr></table></figure>
<blockquote>
<p>实践结果表明：Category 中的属性会被一并打印，而实例变量不会被打印。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048-CH1-SW1" target="_blank" rel="noopener">《ObjC Runtime Guide》</a>是学习 Runtime 的入门读物，本文是该文档的阅读笔记，主要目的是搞清楚两件事情：</p>
<ol>
<li>什么是 Runtime；</li>
<li>Runtime 能做什么；</li>
</ol>
<p>除此之外没有任何的探究拓展。在此基础上，后续会探索 Runtime 是如何实现的，也就是本文提到的函数和数据结构，进而发现 Runtime 更为本质的内在和更为强大的用法。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android卡顿监控方案以及局限性]]></title>
      <url>http://www.timebridge.space/2016/12/08/Android%E5%8D%A1%E9%A1%BF%E7%9B%91%E6%8E%A7%E6%96%B9%E6%A1%88%E4%BB%A5%E5%8F%8A%E5%B1%80%E9%99%90%E6%80%A7/</url>
      <content type="html"><![CDATA[<h2 id="方案介绍"><a href="#方案介绍" class="headerlink" title="方案介绍"></a>方案介绍</h2><p>最早在 QQ 空间团队的微信公众号上看到一篇文章：<a href="http://mp.weixin.qq.com/s/40br55yHjABd5RALf5BO0g" target="_blank" rel="noopener">Android卡慢监控组件简介</a>，介绍了一种监控Android应用卡顿的思路。原理非常简单：在<code>Looper.loop()</code>方法内，有一段这样的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line"><span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">	logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</span><br><span class="line">		msg.callback + <span class="string">": "</span> + msg.what);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msg.target.dispatchMessage(msg);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">	logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码就是消息循环机制中处理消息的核心代码，详细可以参考：<a href="http://muzileecoding.com/2015/11/23/Android-Handler/" target="_blank" rel="noopener">Handler源码分析</a>。<a id="more"></a>在处理消息前后，都调用了logging对象打印消息日志，并且Looper中的消息对象是可以设置的，因此思路就是我们自己开发一个logging对象，通过监控这两段日志打印来统计<code>dispatchMessage</code>方法的执行时间。主线程上如果能保证每一个消息的处理时间在16ms以内，就可以保证不卡顿。</p>
<blockquote>
<p>实际上应该设置的阈值应当远大于16ms，因为诸如Activity创建这样的动作，时间会比较长，而且这种情况下只要不出现黑屏之类的问题，用户不会觉得卡顿。</p>
</blockquote>
<p>后来发现已经有相关的实现库了，这就是<a href="https://github.com/markzhai/AndroidPerformanceMonitor" target="_blank" rel="noopener">BlockCanary</a>。它的核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!mPrintingStarted) &#123;</span><br><span class="line">		mStartTimestamp = System.currentTimeMillis();</span><br><span class="line">		mStartThreadTimestamp = SystemClock.currentThreadTimeMillis();</span><br><span class="line">		mPrintingStarted = <span class="keyword">true</span>;</span><br><span class="line">		startDump();</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">		mPrintingStarted = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (isBlock(endTime)) &#123;</span><br><span class="line">			notifyBlockEvent(endTime);</span><br><span class="line">		&#125;</span><br><span class="line">		stopDump();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过监控两次打印，判断事件是否超出阈值，超出则回调 Block 事件，并打印相关的 CPU 信息、栈信息以辅助解决问题。</p>
<p>以上方案可以说有一点投机取巧，它有局限性的。</p>
<h2 id="Logger变化怎么办？"><a href="#Logger变化怎么办？" class="headerlink" title="Logger变化怎么办？"></a>Logger变化怎么办？</h2><p>如果某天 Android 系统不再调用这段 Logger，或者在别的地方也打印 Logger，很容易看到 BlockCanary 的方案就会失效。除此之外，读者可能会忽略前面展示的 Looper 的那段代码的一个小注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br></pre></td></tr></table></figure>
<p>UI 时间可能也会设置这个 logger，因此依赖 Logger 并不靠谱，解决方案是使用 <a href="https://github.com/mmin18/SafeLooper" target="_blank" rel="noopener">SafeLooper</a>。</p>
<p>SafeLooper 通过在主线程队列中塞入一个可以托管主线程后续消息的阻塞消息，可以在应用内部执行：</p>
<p><code>h.dispatchMessage(msg);</code></p>
<p>这段代码，这样就可以完全不依赖Logger来统计时间。</p>
<h2 id="如果卡顿时间非常非常长怎么办？"><a href="#如果卡顿时间非常非常长怎么办？" class="headerlink" title="如果卡顿时间非常非常长怎么办？"></a>如果卡顿时间非常非常长怎么办？</h2><p>BlockCanary 是需要依赖两次 Logger 的调用才能完成监控日志的输出的，那如果 <code>dispatchMessage</code>方法永远不返回，比如黑屏了怎么监控呢？</p>
<p>这需要另外开启一个线程，在固定时间之后完成监控，简单实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mPrintingStarted) &#123;</span><br><span class="line">        mStartTimestamp = System.currentTimeMillis();</span><br><span class="line">        mStartThreadTimestamp = SystemClock.currentThreadTimeMillis();</span><br><span class="line">        mPrintingStarted = <span class="keyword">true</span>;</span><br><span class="line">        startDump();</span><br><span class="line">        monitorHandler.postDelayed(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">                notifyBlockEvent(endTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, mBlockThresholdMillis * <span class="number">3</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        monitorHandler.removeCallbacksAndMessages(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        mPrintingStarted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (isBlock(endTime)) &#123;</span><br><span class="line">            notifyBlockEvent(endTime);</span><br><span class="line">        &#125;</span><br><span class="line">        stopDump();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样即使完全卡死，也可以获取监控信息。</p>
<h2 id="Application如何监控"><a href="#Application如何监控" class="headerlink" title="Application如何监控"></a>Application如何监控</h2><blockquote>
<p>这个问题和前面一个问题可能最初不在这个方案的设计者的目标之内，但如果能进一步扩充，整个方案会更加健全。</p>
</blockquote>
<p>在实际实验过程中，我们发现，Application 的<code>onCreate()</code>方法是无法监控的，不论是在<code>onCreate()</code>的第一行，还是在 Application 的构造函数中调用都做不到。为什么呢？打印一下这两个方法的调用堆栈信息：</p>
<p>【构造函数】</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">12-07 20:51:41.547 I/System.out: *******************************************</span><br><span class="line">12-07 20:51:41.547 I/System.out: stacktrace len:16</span><br><span class="line">12-07 20:51:41.547 I/System.out: ----  the 0 element  ----</span><br><span class="line">12-07 20:51:41.547 I/System.out: toString: dalvik.system.VMStack.getThreadStackTrace(Native Method)</span><br><span class="line">12-07 20:51:41.547 I/System.out: ClassName: dalvik.system.VMStack</span><br><span class="line">12-07 20:51:41.547 I/System.out: FileName: VMStack.java</span><br><span class="line">12-07 20:51:41.547 I/System.out: LineNumber: -2</span><br><span class="line">12-07 20:51:41.547 I/System.out: MethodName: getThreadStackTrace</span><br><span class="line">12-07 20:51:41.547 I/System.out: ----  the 1 element  ----</span><br><span class="line">12-07 20:51:41.547 I/System.out: toString: java.lang.Thread.getStackTrace(Thread.java:580)</span><br><span class="line">12-07 20:51:41.547 I/System.out: ClassName: java.lang.Thread</span><br><span class="line">12-07 20:51:41.547 I/System.out: FileName: Thread.java</span><br><span class="line">12-07 20:51:41.547 I/System.out: LineNumber: 580</span><br><span class="line">12-07 20:51:41.547 I/System.out: MethodName: getStackTrace</span><br><span class="line">12-07 20:51:41.547 I/System.out: ----  the 2 element  ----</span><br><span class="line">12-07 20:51:41.547 I/System.out: toString: com.example.blockcanary.DemoApplication.<span class="tag">&lt;<span class="name">init</span>&gt;</span>(DemoApplication.java:31)</span><br><span class="line">12-07 20:51:41.547 I/System.out: ClassName: com.example.blockcanary.DemoApplication</span><br><span class="line">12-07 20:51:41.547 I/System.out: FileName: DemoApplication.java</span><br><span class="line">12-07 20:51:41.547 I/System.out: LineNumber: 31</span><br><span class="line">12-07 20:51:41.547 I/System.out: MethodName: <span class="tag">&lt;<span class="name">init</span>&gt;</span></span><br><span class="line">12-07 20:51:41.547 I/System.out: ----  the 3 element  ----</span><br><span class="line">12-07 20:51:41.547 I/System.out: toString: java.lang.Class.newInstance(Native Method)</span><br><span class="line">12-07 20:51:41.547 I/System.out: ClassName: java.lang.Class</span><br><span class="line">12-07 20:51:41.547 I/System.out: FileName: Class.java</span><br><span class="line">12-07 20:51:41.547 I/System.out: LineNumber: -2</span><br><span class="line">12-07 20:51:41.547 I/System.out: MethodName: newInstance</span><br><span class="line">12-07 20:51:41.547 I/System.out: ----  the 4 element  ----</span><br><span class="line">12-07 20:51:41.547 I/System.out: toString: android.app.Instrumentation.newApplication(Instrumentation.java:996)</span><br><span class="line">12-07 20:51:41.547 I/System.out: ClassName: android.app.Instrumentation</span><br><span class="line">12-07 20:51:41.547 I/System.out: FileName: Instrumentation.java</span><br><span class="line">12-07 20:51:41.547 I/System.out: LineNumber: 996</span><br><span class="line">12-07 20:51:41.547 I/System.out: MethodName: newApplication</span><br><span class="line">12-07 20:51:41.547 I/System.out: ----  the 5 element  ----</span><br><span class="line">12-07 20:51:41.547 I/System.out: toString: android.app.Instrumentation.newApplication(Instrumentation.java:981)</span><br><span class="line">12-07 20:51:41.547 I/System.out: ClassName: android.app.Instrumentation</span><br><span class="line">12-07 20:51:41.547 I/System.out: FileName: Instrumentation.java</span><br><span class="line">12-07 20:51:41.547 I/System.out: LineNumber: 981</span><br><span class="line">12-07 20:51:41.547 I/System.out: MethodName: newApplication</span><br><span class="line">12-07 20:51:41.547 I/System.out: ----  the 6 element  ----</span><br><span class="line">12-07 20:51:41.547 I/System.out: toString: android.app.LoadedApk.makeApplication(LoadedApk.java:573)</span><br><span class="line">12-07 20:51:41.547 I/System.out: ClassName: android.app.LoadedApk</span><br><span class="line">12-07 20:51:41.547 I/System.out: FileName: LoadedApk.java</span><br><span class="line">12-07 20:51:41.547 I/System.out: LineNumber: 573</span><br><span class="line">12-07 20:51:41.547 I/System.out: MethodName: makeApplication</span><br><span class="line">12-07 20:51:41.548 I/System.out: ----  the 7 element  ----</span><br><span class="line">12-07 20:51:41.548 I/System.out: toString: android.app.ActivityThread.handleBindApplication(ActivityThread.java:4680)</span><br><span class="line">12-07 20:51:41.548 I/System.out: ClassName: android.app.ActivityThread</span><br><span class="line">12-07 20:51:41.548 I/System.out: FileName: ActivityThread.java</span><br><span class="line">12-07 20:51:41.548 I/System.out: LineNumber: 4680</span><br><span class="line">12-07 20:51:41.548 I/System.out: MethodName: handleBindApplication</span><br><span class="line">12-07 20:51:41.548 I/System.out: ----  the 8 element  ----</span><br><span class="line">12-07 20:51:41.548 I/System.out: toString: android.app.ActivityThread.-wrap1(ActivityThread.java)</span><br><span class="line">12-07 20:51:41.548 I/System.out: ClassName: android.app.ActivityThread</span><br><span class="line">12-07 20:51:41.548 I/System.out: FileName: ActivityThread.java</span><br><span class="line">12-07 20:51:41.548 I/System.out: LineNumber: -1</span><br><span class="line">12-07 20:51:41.548 I/System.out: MethodName: -wrap1</span><br><span class="line">12-07 20:51:41.548 I/System.out: ----  the 9 element  ----</span><br><span class="line">12-07 20:51:41.548 I/System.out: toString: android.app.ActivityThread$H.handleMessage(ActivityThread.java:1405)</span><br><span class="line">12-07 20:51:41.548 I/System.out: ClassName: android.app.ActivityThread$H</span><br><span class="line">12-07 20:51:41.548 I/System.out: FileName: ActivityThread.java</span><br><span class="line">12-07 20:51:41.548 I/System.out: LineNumber: 1405</span><br><span class="line">12-07 20:51:41.548 I/System.out: MethodName: handleMessage</span><br><span class="line">12-07 20:51:41.548 I/System.out: ----  the 10 element  ----</span><br><span class="line">12-07 20:51:41.548 I/System.out: toString: android.os.Handler.dispatchMessage(Handler.java:102)</span><br><span class="line">12-07 20:51:41.548 I/System.out: ClassName: android.os.Handler</span><br><span class="line">12-07 20:51:41.548 I/System.out: FileName: Handler.java</span><br><span class="line">12-07 20:51:41.548 I/System.out: LineNumber: 102</span><br><span class="line">12-07 20:51:41.548 I/System.out: MethodName: dispatchMessage</span><br><span class="line">12-07 20:51:41.548 I/System.out: ----  the 11 element  ----</span><br><span class="line">12-07 20:51:41.548 I/System.out: toString: android.os.Looper.loop(Looper.java:148)</span><br><span class="line">12-07 20:51:41.548 I/System.out: ClassName: android.os.Looper</span><br><span class="line">12-07 20:51:41.548 I/System.out: FileName: Looper.java</span><br><span class="line">12-07 20:51:41.548 I/System.out: LineNumber: 148</span><br><span class="line">12-07 20:51:41.548 I/System.out: MethodName: loop</span><br><span class="line">12-07 20:51:41.548 I/System.out: ----  the 12 element  ----</span><br><span class="line">12-07 20:51:41.548 I/System.out: toString: android.app.ActivityThread.main(ActivityThread.java:5417)</span><br><span class="line">12-07 20:51:41.548 I/System.out: ClassName: android.app.ActivityThread</span><br><span class="line">12-07 20:51:41.548 I/System.out: FileName: ActivityThread.java</span><br><span class="line">12-07 20:51:41.548 I/System.out: LineNumber: 5417</span><br><span class="line">12-07 20:51:41.548 I/System.out: MethodName: main</span><br><span class="line">12-07 20:51:41.548 I/System.out: ----  the 13 element  ----</span><br><span class="line">12-07 20:51:41.548 I/System.out: toString: java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">12-07 20:51:41.548 I/System.out: ClassName: java.lang.reflect.Method</span><br><span class="line">12-07 20:51:41.548 I/System.out: FileName: Method.java</span><br><span class="line">12-07 20:51:41.548 I/System.out: LineNumber: -2</span><br><span class="line">12-07 20:51:41.548 I/System.out: MethodName: invoke</span><br><span class="line">12-07 20:51:41.548 I/System.out: ----  the 14 element  ----</span><br><span class="line">12-07 20:51:41.548 I/System.out: toString: com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:726)</span><br><span class="line">12-07 20:51:41.549 I/System.out: ClassName: com.android.internal.os.ZygoteInit$MethodAndArgsCaller</span><br><span class="line">12-07 20:51:41.549 I/System.out: FileName: ZygoteInit.java</span><br><span class="line">12-07 20:51:41.549 I/System.out: LineNumber: 726</span><br><span class="line">12-07 20:51:41.549 I/System.out: MethodName: run</span><br><span class="line">12-07 20:51:41.549 I/System.out: ----  the 15 element  ----</span><br><span class="line">12-07 20:51:41.549 I/System.out: toString: com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616)</span><br><span class="line">12-07 20:51:41.549 I/System.out: ClassName: com.android.internal.os.ZygoteInit</span><br><span class="line">12-07 20:51:41.549 I/System.out: FileName: ZygoteInit.java</span><br><span class="line">12-07 20:51:41.549 I/System.out: LineNumber: 616</span><br><span class="line">12-07 20:51:41.549 I/System.out: MethodName: main</span><br></pre></td></tr></table></figure>
<p>【<code>onCreate()</code>方法】</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">12-07 20:36:45.733 I/System.out: *******************************************</span><br><span class="line">12-07 20:36:45.733 I/System.out: stacktrace len:13</span><br><span class="line">12-07 20:36:45.733 I/System.out: ----  the 0 element  ----</span><br><span class="line">12-07 20:36:45.733 I/System.out: toString: dalvik.system.VMStack.getThreadStackTrace(Native Method)</span><br><span class="line">12-07 20:36:45.733 I/System.out: ClassName: dalvik.system.VMStack</span><br><span class="line">12-07 20:36:45.733 I/System.out: FileName: VMStack.java</span><br><span class="line">12-07 20:36:45.734 I/System.out: LineNumber: -2</span><br><span class="line">12-07 20:36:45.734 I/System.out: MethodName: getThreadStackTrace</span><br><span class="line">12-07 20:36:45.734 I/System.out: ----  the 1 element  ----</span><br><span class="line">12-07 20:36:45.734 I/System.out: toString: java.lang.Thread.getStackTrace(Thread.java:580)</span><br><span class="line">12-07 20:36:45.734 I/System.out: ClassName: java.lang.Thread</span><br><span class="line">12-07 20:36:45.734 I/System.out: FileName: Thread.java</span><br><span class="line">12-07 20:36:45.734 I/System.out: LineNumber: 580</span><br><span class="line">12-07 20:36:45.734 I/System.out: MethodName: getStackTrace</span><br><span class="line">12-07 20:36:45.734 I/System.out: ----  the 2 element  ----</span><br><span class="line">12-07 20:36:45.734 I/System.out: toString: com.example.blockcanary.DemoApplication.onCreate(DemoApplication.java:43)</span><br><span class="line">12-07 20:36:45.734 I/System.out: ClassName: com.example.blockcanary.DemoApplication</span><br><span class="line">12-07 20:36:45.734 I/System.out: FileName: DemoApplication.java</span><br><span class="line">12-07 20:36:45.734 I/System.out: LineNumber: 43</span><br><span class="line">12-07 20:36:45.734 I/System.out: MethodName: onCreate</span><br><span class="line">12-07 20:36:45.734 I/System.out: ----  the 3 element  ----</span><br><span class="line">12-07 20:36:45.734 I/System.out: toString: android.app.Instrumentation.callApplicationOnCreate(Instrumentation.java:1013)</span><br><span class="line">12-07 20:36:45.734 I/System.out: ClassName: android.app.Instrumentation</span><br><span class="line">12-07 20:36:45.734 I/System.out: FileName: Instrumentation.java</span><br><span class="line">12-07 20:36:45.734 I/System.out: LineNumber: 1013</span><br><span class="line">12-07 20:36:45.734 I/System.out: MethodName: callApplicationOnCreate</span><br><span class="line">12-07 20:36:45.734 I/System.out: ----  the 4 element  ----</span><br><span class="line">12-07 20:36:45.734 I/System.out: toString: android.app.ActivityThread.handleBindApplication(ActivityThread.java:4707)</span><br><span class="line">12-07 20:36:45.734 I/System.out: ClassName: android.app.ActivityThread</span><br><span class="line">12-07 20:36:45.734 I/System.out: FileName: ActivityThread.java</span><br><span class="line">12-07 20:36:45.734 I/System.out: LineNumber: 4707</span><br><span class="line">12-07 20:36:45.734 I/System.out: MethodName: handleBindApplication</span><br><span class="line">12-07 20:36:45.734 I/System.out: ----  the 5 element  ----</span><br><span class="line">12-07 20:36:45.734 I/System.out: toString: android.app.ActivityThread.-wrap1(ActivityThread.java)</span><br><span class="line">12-07 20:36:45.734 I/System.out: ClassName: android.app.ActivityThread</span><br><span class="line">12-07 20:36:45.734 I/System.out: FileName: ActivityThread.java</span><br><span class="line">12-07 20:36:45.734 I/System.out: LineNumber: -1</span><br><span class="line">12-07 20:36:45.734 I/System.out: MethodName: -wrap1</span><br><span class="line">12-07 20:36:45.734 I/System.out: ----  the 6 element  ----</span><br><span class="line">12-07 20:36:45.734 I/System.out: toString: android.app.ActivityThread$H.handleMessage(ActivityThread.java:1405)</span><br><span class="line">12-07 20:36:45.734 I/System.out: ClassName: android.app.ActivityThread$H</span><br><span class="line">12-07 20:36:45.734 I/System.out: FileName: ActivityThread.java</span><br><span class="line">12-07 20:36:45.734 I/System.out: LineNumber: 1405</span><br><span class="line">12-07 20:36:45.734 I/System.out: MethodName: handleMessage</span><br><span class="line">12-07 20:36:45.734 I/System.out: ----  the 7 element  ----</span><br><span class="line">12-07 20:36:45.734 I/System.out: toString: android.os.Handler.dispatchMessage(Handler.java:102)</span><br><span class="line">12-07 20:36:45.734 I/System.out: ClassName: android.os.Handler</span><br><span class="line">12-07 20:36:45.734 I/System.out: FileName: Handler.java</span><br><span class="line">12-07 20:36:45.734 I/System.out: LineNumber: 102</span><br><span class="line">12-07 20:36:45.734 I/System.out: MethodName: dispatchMessage</span><br><span class="line">12-07 20:36:45.734 I/System.out: ----  the 8 element  ----</span><br><span class="line">12-07 20:36:45.734 I/System.out: toString: android.os.Looper.loop(Looper.java:148)</span><br><span class="line">12-07 20:36:45.734 I/System.out: ClassName: android.os.Looper</span><br><span class="line">12-07 20:36:45.734 I/System.out: FileName: Looper.java</span><br><span class="line">12-07 20:36:45.734 I/System.out: LineNumber: 148</span><br><span class="line">12-07 20:36:45.734 I/System.out: MethodName: loop</span><br><span class="line">12-07 20:36:45.734 I/System.out: ----  the 9 element  ----</span><br><span class="line">12-07 20:36:45.734 I/System.out: toString: android.app.ActivityThread.main(ActivityThread.java:5417)</span><br><span class="line">12-07 20:36:45.734 I/System.out: ClassName: android.app.ActivityThread</span><br><span class="line">12-07 20:36:45.734 I/System.out: FileName: ActivityThread.java</span><br><span class="line">12-07 20:36:45.734 I/System.out: LineNumber: 5417</span><br><span class="line">12-07 20:36:45.734 I/System.out: MethodName: main</span><br><span class="line">12-07 20:36:45.734 I/System.out: ----  the 10 element  ----</span><br><span class="line">12-07 20:36:45.734 I/System.out: toString: java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">12-07 20:36:45.734 I/System.out: ClassName: java.lang.reflect.Method</span><br><span class="line">12-07 20:36:45.734 I/System.out: FileName: Method.java</span><br><span class="line">12-07 20:36:45.734 I/System.out: LineNumber: -2</span><br><span class="line">12-07 20:36:45.734 I/System.out: MethodName: invoke</span><br><span class="line">12-07 20:36:45.734 I/System.out: ----  the 11 element  ----</span><br><span class="line">12-07 20:36:45.734 I/System.out: toString: com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:726)</span><br><span class="line">12-07 20:36:45.734 I/System.out: ClassName: com.android.internal.os.ZygoteInit$MethodAndArgsCaller</span><br><span class="line">12-07 20:36:45.734 I/System.out: FileName: ZygoteInit.java</span><br><span class="line">12-07 20:36:45.734 I/System.out: LineNumber: 726</span><br><span class="line">12-07 20:36:45.734 I/System.out: MethodName: run</span><br><span class="line">12-07 20:36:45.734 I/System.out: ----  the 12 element  ----</span><br><span class="line">12-07 20:36:45.734 I/System.out: toString: com.android.internal.os.ZygoteInit.main(ZygoteInit.java:616)</span><br><span class="line">12-07 20:36:45.734 I/System.out: ClassName: com.android.internal.os.ZygoteInit</span><br><span class="line">12-07 20:36:45.734 I/System.out: FileName: ZygoteInit.java</span><br><span class="line">12-07 20:36:45.734 I/System.out: LineNumber: 616</span><br><span class="line">12-07 20:36:45.734 I/System.out: MethodName: main</span><br></pre></td></tr></table></figure>
<p>简单分析可以看到：</p>
<p>1）这两个函数的调用都是由<code>ActivityThread.main()</code>函数在5417行发起调用的；</p>
<p>2）最终通过消息分发（注意<code>handleMessage()</code>函数的调用）交付给<code>ActivityThread.handleBindApplication()</code>执行，在这个方法第 4680 行会调用<code>LoadedApk.makeApplication()</code>方法创建 Application 对象，在 4707 行会调用<code>Instrumentation.callApplicationOnCreate()</code>方法调用 Application 的<code>onCreate()</code>方法；</p>
<p><code>ActivityThread.handleBindApplication()</code>方法的局部实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// If the app is being launched for full backup or restore, bring it up in</span></span><br><span class="line">    <span class="comment">// a restricted environment with the base application class.</span></span><br><span class="line">    <span class="comment">// 创建 Application</span></span><br><span class="line">    Application app = data.info.makeApplication(data.restrictedBackupMode, <span class="keyword">null</span>);</span><br><span class="line">    mInitialApplication = app;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// don't bring up providers in restricted mode; they may depend on the</span></span><br><span class="line">    <span class="comment">// app's custom Application class</span></span><br><span class="line">    <span class="keyword">if</span> (!data.restrictedBackupMode) &#123;</span><br><span class="line">        List&lt;ProviderInfo&gt; providers = data.providers;</span><br><span class="line">        <span class="keyword">if</span> (providers != <span class="keyword">null</span>) &#123;</span><br><span class="line">            installContentProviders(app, providers);</span><br><span class="line">            <span class="comment">// For process that contains content providers, we want to</span></span><br><span class="line">            <span class="comment">// ensure that the JIT is enabled "at some point".</span></span><br><span class="line">            mH.sendEmptyMessageDelayed(H.ENABLE_JIT, <span class="number">10</span>*<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do this after providers, since instrumentation tests generally start their</span></span><br><span class="line">    <span class="comment">// test thread at this point, and we don't want that racing.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mInstrumentation.onCreate(data.instrumentationArgs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">"Exception thrown in onCreate() of "</span></span><br><span class="line">                + data.instrumentationName + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 onCreate 方法</span></span><br><span class="line">        mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mInstrumentation.onException(app, e)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"Unable to create application "</span> + app.getClass().getName()</span><br><span class="line">                    + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    StrictMode.setThreadPolicy(savedPolicy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简而言之：Application 的创建和 <code>onCreate()</code>是在一个消息中执行完成的。再看Application 的<code>onCreate()</code>方法的注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Called when the application is starting, before any activity, service,</span></span><br><span class="line"><span class="comment"> * or receiver objects (excluding content providers) have been created.</span></span><br><span class="line"><span class="comment"> * Implementations should be as quick as possible (for example using </span></span><br><span class="line"><span class="comment"> * lazy initialization of state) since the time spent in this function</span></span><br><span class="line"><span class="comment"> * directly impacts the performance of starting the first activity,</span></span><br><span class="line"><span class="comment"> * service, or receiver in a process.</span></span><br><span class="line"><span class="comment"> * If you override this method, be sure to call super.onCreate().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@CallSuper</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，这个方法会先于四大组件运行。综上可以得出结论：<strong>在Application的构造函数中，开发者可以获得App发出的第一个主线程消息并执行相关代码</strong>。</p>
<p>根据前面的卡顿原理分析，这种情况下是无法监控到这个消息本身的，也就是说通过 Logger 的打印不能监控到 Application 的<code>onCreate()</code>方法。</p>
<p>解决办法也不难，按照 BlockCanary 的实现，我只需要拿到 LooperMonitor 对象，手动插入 Logger 代码即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate();</span><br><span class="line">    monitor.println(<span class="string">"Application Create Start"</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//Application 初始化代码</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">        </span><br><span class="line">    monitor.println(<span class="string">"Application Create End"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样也能完成<code>onCreate()</code>方法的监控。</p>
<blockquote>
<p>但这种方案实际在 SafeLooper 中比较难操作，要实现和 SafeLooper 的结合需要对项目做比较大的重构。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这套方案利用系统暴露的接口和实现，巧妙地实现了监控卡顿的目的。</p>
<p>前面提到，方案的 Block 阈值是比较难设置的，比较理想的状况是把 Application 和四大组件的生命周期方法单独抽取出来做统计，这部分对 Block 的要求远远要比在页面上滚动一个列表页要来的低。</p>
<p>再进一步的，可以构建一个客户端卡顿监控系统，将 BlockCanary 融合 SafeLooper 之后作为监控系统消息的一种手段纳入其中，并提供接口可以让开发者手动监控某段代码的执行时间，从而构建一个比较全面的客户端代码运行监控系统。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hexo 高级玩法和坑]]></title>
      <url>http://www.timebridge.space/2016/12/03/Hexo%E9%AB%98%E7%BA%A7%E7%8E%A9%E6%B3%95%E5%92%8C%E5%9D%91/</url>
      <content type="html"><![CDATA[<p>Hexo 虽然已经有很多的主题实现了各种酷炫的功能和排版，但是依然有人不满足。本文就结合自己部署博客时所做改动介绍两个大家玩的比较溜的高级玩法，以及这两个玩法要注意的问题。</p>
<blockquote>
<p><a href="https://hexo.io/plugins/" target="_blank" rel="noopener">Hexo 插件官网</a>上有很多插件可以选择。Hexo的插件安装非常简单，在博客的根目录下面执行:<code>npm install -g 插件名</code>即可。</p>
</blockquote>
<h2 id="置顶功能"><a href="#置顶功能" class="headerlink" title="置顶功能"></a>置顶功能</h2><p>置顶功能相关的帖子最早出处应该是<a href="http://www.netcan666.com/2015/11/22/%E8%A7%A3%E5%86%B3Hexo%E7%BD%AE%E9%A1%B6%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">解决Hexo置顶问题</a>这篇文章。Hexo 在安装的时候就自带了生成 Index 的插件，也就是<code>/node_modules/hexo-generator-index</code>插件，这个插件的具体玩法在<a href="https://github.com/hexojs/hexo-generator-index" target="_blank" rel="noopener">这里</a>。可以有两个配置项，其中一个就表示根据 date 排序，也就是文章的创建日期。<a id="more"></a></p>
<p><a href="http://www.netcan666.com/2015/11/22/%E8%A7%A3%E5%86%B3Hexo%E7%BD%AE%E9%A1%B6%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">解决Hexo置顶问题</a>通过比较 top 来实现置顶问题，非常完美，但是要注意的是原来的排序代码是：</p>
<p><code>var posts = locals.posts.sort(config.index_generator.order_by);</code> </p>
<p>而新的代码却是：</p>
<p><code>posts.data = posts.data.sort(function(a, b)...</code></p>
<p>这里多了一个 data 属性，而不是直接对 posts 数组排序，如果不写这个，会出现乱序。</p>
<blockquote>
<p>所有文章也同样需要排序，它的修改位置在<code>/node_modules/hexo-generator-archive/lib/generator.js</code>中，搜索 sort 进行相同替换就可以了。</p>
</blockquote>
<p>另外这个 top 属性也可以拿来做别的事情，比如我们不仅希望博客可以指定，而且有明显的标识，像下面：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/博客置顶样式.png" alt="博客置顶样式" width="320"></div>

<p>在标题前面加上红色加粗”[置顶]”文案，那可以去修改对应主题<code>/layout/_partial/post/titls.ejs</code>文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (post.link)&#123; %&gt;</span><br><span class="line">  &lt;h1 itemprop=<span class="string">"name"</span>&gt;</span><br><span class="line">    &lt;a <span class="class"><span class="keyword">class</span></span>=<span class="string">"&lt;%= class_name %&gt;"</span> href=<span class="string">"&lt;%- url_for(post.link) %&gt;"</span> target=<span class="string">"_blank"</span> itemprop=<span class="string">"url"</span>&gt;</span><br><span class="line">      &lt;%<span class="keyword">if</span>(post.top)&#123;%&gt;&lt;span style="font-weight:bold;color:red"&gt;[置顶]&lt;/span&gt;&lt;% &#125; %&gt;&lt;%= post.title %&gt;</span><br><span class="line">    &lt;/a&gt;</span><br><span class="line">  &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">&lt;% &#125; else if (post.title)&#123; %&gt;</span></span><br><span class="line"><span class="regexp">  &lt;% if (index)&#123; %&gt;</span></span><br><span class="line"><span class="regexp">    &lt;h1 itemprop="name"&gt;</span></span><br><span class="line"><span class="regexp">      &lt;a class="&lt;%= class_name %&gt;" href="&lt;%- url_for(post.path) %&gt;"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;% if(post.top)&#123; %&gt;</span></span><br><span class="line"><span class="regexp">          &lt;% if(class_name !== 'archive-article-title')&#123; %&gt;</span></span><br><span class="line"><span class="regexp">            &lt;span style="font-weight:bold;color:red"&gt;[置顶]&lt;/</span>span&gt;</span><br><span class="line">          &lt;% &#125; <span class="keyword">else</span> &#123; %&gt;</span><br><span class="line">            &lt;span style=<span class="string">"font-weight:bold;color:red;display:inline"</span>&gt;[置顶]&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">          &lt;% &#125; %&gt;</span></span><br><span class="line"><span class="regexp">        &lt;% &#125; %&gt;</span></span><br><span class="line"><span class="regexp">        &lt;%= post.title %&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>a&gt;</span><br><span class="line">    &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">  &lt;% &#125; else &#123; %&gt;</span></span><br><span class="line"><span class="regexp">    &lt;h1 class="&lt;%= class_name %&gt;" itemprop="name"&gt;</span></span><br><span class="line"><span class="regexp">      &lt;%if(post.top)&#123;%&gt;&lt;span style="font-weight:bold;color:red"&gt;[置顶]&lt;/</span>span&gt;&lt;% &#125; %&gt;&lt;%= post.title %&gt;</span><br><span class="line">    &lt;/h1&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>
<p>在所有显示标题的地方判断文章是不是top的，如果是，则添加文案。</p>
<h2 id="浏览量统计功能"><a href="#浏览量统计功能" class="headerlink" title="浏览量统计功能"></a>浏览量统计功能</h2><p>这个功能对于博客写作者来说应该是蛮重要一个功能，我的视线方案使用的是<a href="https://link.zhihu.com/?target=http%3A//crescentmoon.info/2014/12/11/popular-widget/" target="_blank" rel="noopener">使用LeanCloud平台为Hexo博客添加文章浏览量统计组件</a>所介绍的基于 LeadCloud 的方案。详细方案原文已经阐述，但这个方案实际是作者根据自己的需求进行开发的，也就是显示在边栏上。因此建议读者看懂 JS 代码之后再修改一下，下面是我的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span>(!index)&#123; %&gt;</span><br><span class="line">    &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"post-meta"</span>&gt;总字数: &lt;%= wordcount(post.content) %&gt; | 阅读预计 &lt;%= min2read(post.content) %&gt; 分钟&lt;/span&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">    	addCount();</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;% &#125; %&gt;</span></span><br></pre></td></tr></table></figure>
<p>我这里还涉及一个字数统计的功能，后面再介绍。然后修改<code>head.ejs</code>文件，在最后 header 标签之前添加：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"https://cdn1.lncld.net/static/js/av-min-1.5.0.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> APP_ID = <span class="string">'XXXXXXXX'</span>;</span><br><span class="line">    <span class="keyword">var</span> APP_KEY = <span class="string">'XXXXXXXXXXX'</span>;</span><br><span class="line">    AV.init(&#123;</span><br><span class="line">        appId: APP_ID,</span><br><span class="line">        appKey: APP_KEY</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;!--page counter part--&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">    function addCount() &#123;</span></span><br><span class="line"><span class="regexp">        var Counter=AV.Object.extend("Counter");</span></span><br><span class="line"><span class="regexp">        url=$('.article-date').attr('href').trim();</span></span><br><span class="line"><span class="regexp">        title = $('.article-title').text().trim();</span></span><br><span class="line"><span class="regexp">        var query=new AV.Query(Counter);</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/use url as unique idnetfication</span></span><br><span class="line"><span class="regexp">        query.equalTo("url",url);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        query.find(&#123;</span></span><br><span class="line"><span class="regexp">            success: function(results)&#123;</span></span><br><span class="line"><span class="regexp">                if(results.length&gt;0) &#123;</span></span><br><span class="line"><span class="regexp">                    var counter=results[0];</span></span><br><span class="line"><span class="regexp">                    var times=counter.get('time')+1;</span></span><br><span class="line"><span class="regexp">                    $('.post-meta').append(" | PV: " + times);</span></span><br><span class="line"><span class="regexp">                    counter.set('time', times);</span></span><br><span class="line"><span class="regexp">                    counter.save();</span></span><br><span class="line"><span class="regexp">                &#125; else &#123;</span></span><br><span class="line"><span class="regexp">                    var newcounter=new Counter();</span></span><br><span class="line"><span class="regexp">                    newcounter.set("title",title);</span></span><br><span class="line"><span class="regexp">                    newcounter.set("url",url);</span></span><br><span class="line"><span class="regexp">                    newcounter.set("time",1);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">                    $('.post-meta').append(" | PV: 1");</span></span><br><span class="line"><span class="regexp">                    newcounter.save().then(function (counter) &#123;</span></span><br><span class="line"><span class="regexp">                        /</span><span class="regexp">/ 成功</span></span><br><span class="line"><span class="regexp">                    &#125;,function (error) &#123;</span></span><br><span class="line"><span class="regexp">                        /</span><span class="regexp">/ 失败</span></span><br><span class="line"><span class="regexp">                    &#125;);</span></span><br><span class="line"><span class="regexp">                &#125;</span></span><br><span class="line"><span class="regexp">            &#125;,</span></span><br><span class="line"><span class="regexp">            error: function(error)&#123;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">        &#125;);</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>
<p>这里 JS 文件的链接与原文的不同，原文提供的链接已经失效，这点原作者有提醒，另外初始化方法也不一样，这是升级所致，具体可见：<a href="https://leancloud.cn/docs/sdk_setup-js.html#初始化" target="_blank" rel="noopener"><a href="https://leancloud.cn/docs/sdk_setup-js.html#JavaScript_SDK_安装指南" target="_blank" rel="noopener">JavaScript SDK 安装指南</a></a>，下面是一个简单的存取，方法可见文档：[<a href="https://leancloud.cn/docs/leanstorage_guide-js.html#数据存储开发指南___JavaScript" target="_blank" rel="noopener">数据存储开发指南 · JavaScript</a>]</p>
<p>另外还有一个需要注意的点就是在 LeanCloud 上新建 Class 的时候，权限务必选择无限制，不然在更新数据的时候会被 Forbidden。</p>
<h2 id="博客统计功能"><a href="#博客统计功能" class="headerlink" title="博客统计功能"></a>博客统计功能</h2><p>这个功能使用的是插件<a href="https://www.npmjs.com/package/hexo-wordcount" target="_blank" rel="noopener">hexo-wordcount</a>，提供以下三个功能：</p>
<ol>
<li>博客总数量统计；</li>
<li>博客字数统计；</li>
<li>预计阅读时间统计；</li>
</ol>
<p>具体怎么用在官网上有明确的说明，而具体放置在什么位置，读者可以研究一下主题下面<code>/layout/_partial/article.ejs</code>文件，这个文件描述了在文章列表和详情页面文章如何显示，找一个合适的地方插入即可。</p>
<blockquote>
<p>注：可以通过 index 这个参数判断是不是在列表页面上。</p>
</blockquote>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>粗略感觉 Hexo 是一个结构非常好的项目，即使我这种菜鸟也能在短时间内照葫芦画瓢进行一些个性化定制，配置 Hexo 的过程极大的激发了我学前端的欲望。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Log4j]]></title>
      <url>http://www.timebridge.space/2016/11/30/log4j/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>简单来说，<a href="https://logging.apache.org/log4j/1.2/manual.html" target="_blank" rel="noopener">Log4j</a> 是一个专门的日志工具，可以可靠、快速的进行日志输出。</p>
<blockquote>
<p>Inserting log statements into code is a low-tech method for debugging it. It may also be the only way because debuggers are not always available or applicable. This is usually the case for multithreaded applications and distributed applications at large.</p>
</blockquote>
<p>按照官网的说法，日志在某些情况是唯一进行调试的手段，比如多线程状态下，或者是分布式应用中。按照我的理解，日志有以下好处：</p>
<p>1）我们可以选择输出我们关注的信息到文件或者我们任何想要的地方，靠谱快速；<br>2）日志系统可以做快照，在发生异常情况时，可以记录此时的上下文环境；</p>
<a id="more"></a>Log4j 主要包含三个方面的东西：Logger、Appender 和 Layout，这三个部分定义了 Log 的内容、格式、级别以及输出目标。开始学习前，先给一个例子直观感受一下：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Logger  logger = Logger.getLogger(<span class="string">"com.foo"</span>);<span class="comment">//为 Logger 取一个名字</span></span><br><span class="line">logger.setLevel(Level.INFO);<span class="comment">// 设置 Logger 的级别</span></span><br><span class="line">logger.warn(<span class="string">"Low fuel level."</span>); <span class="comment">// 打印一个warn级别的日志</span></span><br><span class="line">logger.debug(<span class="string">"Starting search for nearest gas station."</span>);<span class="comment">// 打印一个debug级别的日志，但是这里实际不会打印，下面会解释原因</span></span><br></pre></td></tr></table></figure>
<h2 id="Logger-的继承"><a href="#Logger-的继承" class="headerlink" title="Logger 的继承"></a>Logger 的继承</h2><h3 id="继承和级别"><a href="#继承和级别" class="headerlink" title="继承和级别"></a>继承和级别</h3><p>Logger 根据 <code>System.out.println</code>的设计，也对日志进行空间划分，也就是 Category 的概念，简单来说，日志的输出是分组，可以把某些日志分为一组，从而可以在组的层面上控制日志的输出。Category 的概念在 Log4j 1.2之后就被取代了，这就是 Logger 类。官网上关于分组的说法是：</p>
<blockquote>
<p>A logger is said to be an <em>ancestor</em> of another logger if its name followed by a dot is a prefix of the<em>descendant</em> logger name. A logger is said to be a <em>parent</em> of a <em>child</em> logger if there are no ancestors between itself and the descendant logger.</p>
</blockquote>
<p>这个和包以及子包的概念一样，名字叫做”java.util”的 Logger 是名字叫做”java”的 Logger 的子，是名字叫做”java.util.Vector”的 Logger 的父，是名字叫做”java.util.X.Y”的 Logger 的祖先。<strong>换句话说：Logger类通过名字（详见前面例子）来标记身份，名字之间如果按照规范有父子关系，则称作 Logger 之间有继承关系</strong>。</p>
<p>同时 Logger 也有一个 root logger，它比较特殊：</p>
<p>1）这个 Logger 总是存在的；</p>
<p>2）不能通过名字获取实例，只能通过方法<code>Logger.getRootLogger</code>获取；</p>
<p>下面是 Logger 常用的一些方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.log4j;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Creation &amp; retrieval methods:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title">getRootLogger</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title">getLogger</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printing methods:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trace</span><span class="params">(Object message)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">(Object message)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">(Object message)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">warn</span><span class="params">(Object message)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(Object message)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fatal</span><span class="params">(Object message)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// generic printing method:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(Level l, Object message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 API 就可以看出，日志是有级别的，官方的级别定义在 <a href="https://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/Level.html" target="_blank" rel="noopener">Level</a> 类中，如果一个 Logger 没有被赋予日志级别，那它就会从最近的祖先那里继承一个级别。</p>
<blockquote>
<p>这里可能有点模糊了，日志的级别是区分大小的，比如常见的几种级别的大小比较就是：DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL。</p>
<p>Logger 本身也是有日志级别的，它表示一个 Logger 可以输出什么级别的日志，比如 Logger A 定义的级别是 warn，那么使用这个 Logger 输出 warn 级别的日志就会被过来掉，而 warn 和更高级别的 error 日志就可以被输出。因此日志级别对于 Logger 来说相当于一个过滤器。</p>
</blockquote>
<p>为了保证所有的 Logger 都会有一个级别，root logger 总是会有一个默认级别。如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Logger name</th>
<th style="text-align:center">Assigned level</th>
<th style="text-align:center">Inherited level</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">root</td>
<td style="text-align:center">Proof</td>
<td style="text-align:center">Proof</td>
</tr>
<tr>
<td style="text-align:center">X</td>
<td style="text-align:center">none</td>
<td style="text-align:center">Proof</td>
</tr>
<tr>
<td style="text-align:center">X.Y</td>
<td style="text-align:center">Pxy</td>
<td style="text-align:center">Pxy</td>
</tr>
<tr>
<td style="text-align:center">X.Y.Z</td>
<td style="text-align:center">none</td>
<td style="text-align:center">Pxy</td>
</tr>
</tbody>
</table>
<p>Logger X 没有设置日志级别，则从 root logger 继承一个，因此也是 Proof，而 Logger X.Y 设置了日志级别为 Pxy，则最终的日志级别也为 Pxy，Logger X.Y.Z 没有设置日志级别，则默认从最近的祖先，也就是 Logger X.Y 里继承一个，即 Pxy。</p>
<p>通过同一个名字获取的 Logger 总是指向同一个 Logger 实例。通常在开发中我们会使用当前类的 class 来获取一个 Logger 。比如：</p>
<p><code>private static final Logger logger = Logger.getLogger(MonitorController.class);</code></p>
<p>这是一种简便有效的获取 Logger 的方法，当然 Logger4j 并不排斥你用别的方式为 Logger 命名。父 Logger 和子 Logger 可以以任意的顺序进行配置和初始化，并不影响它们的继承关系。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>通过前面的介绍，我们已经知道：</p>
<p>1）日志本身是有级别的，级别也是有序的；</p>
<p>2）Logger 也是有级别的，只有当打印的日志级别大于等于 Logger 的日志级别，才会输出日志；</p>
<p>3）Logger 的日志级别可以继承；</p>
<p>由此可以看出，日志的有序级别是 Log4j 控制日志输出的一个核心概念。</p>
<blockquote>
<p>Log4j建议只使用四个级别，优先级从高到低分别是ERROR、WARN、INFO、DEBUG。</p>
</blockquote>
<h2 id="Appenders和Layouts"><a href="#Appenders和Layouts" class="headerlink" title="Appenders和Layouts"></a>Appenders和Layouts</h2><p>在输出日志的时候，除了需要根据级别来控制日志输出，还需要控制日志输出的目的地和格式，这就是Appender和Layout的作用。</p>
<h3 id="Appender"><a href="#Appender" class="headerlink" title="Appender"></a>Appender</h3><p>一个 Logger 可以配置多个 Appender，简而言之，Logger 可以把同一份日志输出到多个地方，比如console、文件。一个有效的日志请求（指的是级别大于等于 Logger 的日志级别）不但会被当前 Logger 的所有 Appender 处理，而且会被 Logger 的祖先 Logger 所配置的所有 Appender 处理，比如 root logger 配置了一个 console Appender，则所有的 Appender 都至少会在控制台输出日志。也就是说 <strong>Appender 也具有继承性</strong>，但不同于日志级别的继承，Appender 的继承是可以控制的：只需要将 Logger 的 additivity 属性设置为false，该 Logger 将不会继承父 Logger 的 Appender。</p>
<h3 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h3><p>Logger 允许为 Appender 设置一个 Layout 来控制日志的输出格式。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Activity启动过程]]></title>
      <url>http://www.timebridge.space/2016/09/25/activity-launch-progress/</url>
      <content type="html"><![CDATA[<p>前面几篇文章讲述了 Binder 通信机制，另外两边文章 <a href="https://www.muzileecoding.com/android/Android-touchevent-process.html" target="_blank" rel="noopener">Android View事件处理</a> 和 <a href="https://www.muzileecoding.com/android/Android-view-display.html" target="_blank" rel="noopener">Android View绘制过程</a> 讲述了 Activity 上 View 相关的机制。那么剩下的就是如何组合这些机制实现我们开发、使用所看到的现象。</p>
<blockquote>
<p>在 <a href="https://www.muzileecoding.com/android/Android-view-display.html" target="_blank" rel="noopener">Android View绘制过程</a> 后面还留了一个点，即<code>ViewRootImpl.performTraversals()</code>是如何被触发调用的，本文就是弥合这样的裂缝。</p>
</blockquote>
<p><a id="more"></a>待续…</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android View绘制过程]]></title>
      <url>http://www.timebridge.space/2016/09/21/Android-view-display/</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>A View occupies a rectangular area on the screen and is responsible for drawing and event handling。</strong></p>
</blockquote>
<h2 id="View-绘制模型"><a href="#View-绘制模型" class="headerlink" title="View 绘制模型"></a>View 绘制模型</h2><p>撇开 Android 系统不谈，我们想象一下自己要画一幅画会首先做哪些事情？首先得构图，我们得规划一下要画哪些东西，画在什么地方以及画多大，然后我们就能下笔成画了：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/viewdraw-mnlsh.jpg" alt="蒙娜丽莎的微笑"></div>

<a id="more"></a>那么 Android 系统是不是也这么机智呢？确实如此。Android 的绘制过程由<code>ViewRootImpl.performTraversals()</code>方法触发，这个方法有800多行，它调用了三个方法：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">performMeasure()</span><br><span class="line">performLayout()</span><br><span class="line">performDraw()</span><br></pre></td></tr></table></figure>
<p>这三个方法分别代表着测量尺寸、放置位置、进行绘制三个步骤。</p>
<p>在详细看这三个方法之前，我们需要先了解两件事情: </p>
<ol>
<li>Activity 内的 View 组织方式；</li>
<li><code>setCotentView()</code>是如何工作的；</li>
</ol>
<h3 id="Activity-内的-View-组织方式"><a href="#Activity-内的-View-组织方式" class="headerlink" title="Activity 内的 View 组织方式"></a>Activity 内的 View 组织方式</h3><p>如下图: </p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/View层级.png" alt="View层级"></div>

<p>PhoneWindow 是 Window 的子类，根据注释，Window的作用是:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Abstract base class for a top-level window look and behavior policy.  An</span></span><br><span class="line"><span class="comment"> * instance of this class should be used as the top-level view added to the</span></span><br><span class="line"><span class="comment"> * window manager. It provides standard UI policies such as a background, title</span></span><br><span class="line"><span class="comment"> * area, default key processing, etc.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>它负责组织一组 View，并实现它们的绘制显示方式以及对应的行为，来为 window 的最终显示提供支持。</p>
<p><strong>图中绿色部分和 View 无关，它们是负责包装 View 显示和行为的，而从 DecorView 开始，就是真正显示在手机屏幕上的 View 的根节点。蓝色部分就是我们通常使用<code>setContentView()</code>方法进行布局的地方。</strong></p>
<h3 id="setCotentView-是如何工作的"><a href="#setCotentView-是如何工作的" class="headerlink" title="setCotentView()是如何工作的"></a><code>setCotentView()</code>是如何工作的</h3><p>我们从<code>Activity.attach()</code>这个方法开始分析:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context, ActivityThread aThread,</span></span></span><br><span class="line"><span class="function"><span class="params">            Instrumentation instr, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="function"><span class="params">            Application application, Intent intent, ActivityInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">            CharSequence title, Activity parent, String id,</span></span></span><br><span class="line"><span class="function"><span class="params">            NonConfigurationInstances lastNonConfigurationInstances,</span></span></span><br><span class="line"><span class="function"><span class="params">            Configuration config, String referrer, IVoiceInteractor voiceInteractor)</span> </span>&#123;</span><br><span class="line">        attachBaseContext(context);</span><br><span class="line"></span><br><span class="line">        mFragments.attachHost(<span class="keyword">null</span> <span class="comment">/*parent*/</span>);</span><br><span class="line"></span><br><span class="line">        mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>);</span><br><span class="line">        mWindow.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        mWindow.setOnWindowDismissedCallback(<span class="keyword">this</span>);</span><br><span class="line">        mWindow.getLayoutInflater().setPrivateFactory(<span class="keyword">this</span>);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里在 Activity 中<code>new</code>了一个<code>PhoneWindow</code>对象。而当我们<code>setContentView()</code>的时候，实际调用的是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Window <span class="title">getWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> mWindow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(@LayoutRes <span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">	getWindow().setContentView(layoutResID);</span><br><span class="line">	initWindowDecorActionBar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，这个 View/ID 最终被设置到了 mWindow 中去了，也就是 PhoneWindow，它的<code>setContentView()</code>方法是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        installDecor();</span><br><span class="line">    &#125; </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    mContentParent.addView(view, params);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mDecor = generateDecor(); <span class="comment">//方法1</span></span><br><span class="line">        mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</span><br><span class="line">        mDecor.setIsRootNamespace(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != <span class="number">0</span>) &#123;</span><br><span class="line">            mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mContentParent = generateLayout(mDecor); <span class="comment">//方法2</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法1实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> DecorView <span class="title">generateDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> DecorView(getContext(), -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ViewGroup <span class="title">generateLayout</span><span class="params">(DecorView decor)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> layoutResource;</span><br><span class="line">    <span class="keyword">int</span> features = getLocalFeatures();</span><br><span class="line">    <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != <span class="number">0</span>) &#123;</span><br><span class="line">        layoutResource = R.layout.screen_swipe_dismiss;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    mDecor.startChanging();</span><br><span class="line"></span><br><span class="line">    View in = mLayoutInflater.inflate(layoutResource, <span class="keyword">null</span>);</span><br><span class="line">    decor.addView(in, <span class="keyword">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">    mContentRoot = (ViewGroup) in;</span><br><span class="line"></span><br><span class="line">    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> contentParent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，我们往 decor 里面添加了一个 View，然后从 decor 中获取到了 contentParent, 办法是<code>findViewById(ID_ANDROID_CONTENT)</code>，那么这个 id 所代表的 View 是什么呢？这个要看到 layoutResource 所代表的资源，给这个变量赋值的时候会做很多的判断，值也有很多的可能性，其中一个值是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layoutResource = R.layout.screen_simple;</span><br></pre></td></tr></table></figure>
<p>而<code>R.layout.screen_simple</code>代表的资源如下:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fitsSystemWindows</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ViewStub</span> <span class="attr">android:id</span>=<span class="string">"@+id/action_mode_bar_stub"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:inflatedId</span>=<span class="string">"@+id/action_mode_bar"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout</span>=<span class="string">"@layout/action_mode_bar"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:theme</span>=<span class="string">"?attr/actionBarTheme"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:id</span>=<span class="string">"@android:id/content"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:foregroundInsidePadding</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:foregroundGravity</span>=<span class="string">"fill_horizontal|top"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:foreground</span>=<span class="string">"?android:attr/windowContentOverlay"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>是不是非常眼熟？我们经常会为 Activity 配置一些属性，比如无 ActionBar ，那就对应到不同的 Activity 模板，而这里的 FrameLayout 就是我们找到的 contentParent，我们通过<code>setContentView()</code>设置的 View 最终就是被添加到这个 View 中去了。</p>
<p>OK，下面我们来细细分析 View 的绘制三步骤。</p>
<h2 id="measure-过程"><a href="#measure-过程" class="headerlink" title="measure 过程"></a>measure 过程</h2><p>测量尺寸是使用方法<code>performMeasure()</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performMeasure</span><span class="params">(<span class="keyword">int</span> childWidthMeasureSpec, <span class="keyword">int</span> childHeightMeasureSpec)</span> </span>&#123;</span><br><span class="line">	Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"measure"</span>);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就看到这个方法其实是调用了 View 的<code>measure</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ||</span><br><span class="line">            widthMeasureSpec != mOldWidthMeasureSpec ||</span><br><span class="line">            heightMeasureSpec != mOldHeightMeasureSpec) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// first clears the measured dimension flag</span></span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET;</span><br><span class="line"></span><br><span class="line">        resolveRtlPropertiesIfNeeded();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cacheIndex = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ? -<span class="number">1</span> :</span><br><span class="line">                    mMeasureCache.indexOfKey(key);</span><br><span class="line">        <span class="keyword">if</span> (cacheIndex &lt; <span class="number">0</span> || sIgnoreMeasureCache) &#123;</span><br><span class="line">            <span class="comment">// measure ourselves, this should set the measured dimension flag back</span></span><br><span class="line">            onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    mMeasureCache.put(key, ((<span class="keyword">long</span>) mMeasuredWidth) &lt;&lt; <span class="number">32</span> |</span><br><span class="line">            (<span class="keyword">long</span>) mMeasuredHeight &amp; <span class="number">0xffffffffL</span>); <span class="comment">// suppress sign extension</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里首先判断有没有设置<code>PFLAG_FORCE_LAYOUT</code>标志位，或者父 View 的尺寸和上次的有没有变化，如果有，则继续判断是否是<code>PFLAG_FORCE_LAYOUT</code>引起的，如果是，则忽略缓存的内容，调用<code>onMeasure()</code>进行测量，在方法的最后，会更新缓存在 mMeasureCache 中的内容。而<code>onMeasure()</code>方法的默认实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">	setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">			getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里计算宽高的两组方法是对应的，看一组即可，我们看看宽度的计算相关的方法实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> result = size;</span><br><span class="line">	<span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">	<span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">		<span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">			result = size;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">		<span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">			result = specSize;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先看<code>getSuggestedMinimumWidth()</code>的计算，它得到的是 View 本身和它的背景允许的最小宽度的较大值。而至于<code>getDefaultSize()</code>方法，则是根据 sepcMode，决定是否采用前面的较大值，那么这几种 specMode 分别代表什么意思呢？<a href="https://developer.android.com/guide/topics/ui/how-android-draws.html" target="_blank" rel="noopener">官网</a>有详细的描述：</p>
<blockquote>
<p>A MeasureSpec can be in one of three modes:</p>
<p><strong>UNSPECIFIED</strong>: This is used by a parent to determine the desired dimension of a child View. For example, a LinearLayout may call measure() on its child with the height set to UNSPECIFIED and a width of EXACTLY 240 to find out how tall the child View wants to be given a width of 240 pixels.</p>
<p><strong>EXACTLY:</strong> This is used by the parent to impose an exact size on the child. The child must use this size, and guarantee that all of its descendants will fit within this size.</p>
<p><strong>AT MOST</strong>: This is used by the parent to impose a maximum size on the child. The child must guarantee that it and all of its descendants will fit within this size.</p>
</blockquote>
<p>简单来说，<strong>UNSPECIFIED</strong> 是父 View 用来查看子 View 自己想要的尺寸的一种 Mode，它并没有详细说明尺寸的限制，View 根据自身的条件自己去判断即可。<strong>EXACTLY</strong> 是父 View 用于对子 View 强制施加一个尺寸用的，子 View 必须保证使用这个尺寸，且所有的子 View 都能够适配于这个尺寸，<strong>AT MOST</strong>则是父 View 告诉子 View 一个最大可以使用的尺寸，子 View 必须保证不超过这个尺寸。</p>
<blockquote>
<p>EXACTLY 对应于match_parent和具体的数值这两种模式，而 AT_MOST 对应于 wrap_content。</p>
</blockquote>
<p>因此父 View 在告诉子 View 测量尺寸的时候，不仅会告诉它自己的尺寸是多少，还会告诉它自己对这个尺寸的一个要求，是要严格遵守，还是自行考量。在测量完尺寸之后，需要调用<code>setMeasuredDimension()</code>方法进行设置:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setMeasuredDimension</span><span class="params">(<span class="keyword">int</span> measuredWidth, <span class="keyword">int</span> measuredHeight)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> optical = isLayoutModeOptical(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (optical != isLayoutModeOptical(mParent)) &#123;</span><br><span class="line">        Insets insets = getOpticalInsets();</span><br><span class="line">        <span class="keyword">int</span> opticalWidth  = insets.left + insets.right;</span><br><span class="line">        <span class="keyword">int</span> opticalHeight = insets.top  + insets.bottom;</span><br><span class="line"></span><br><span class="line">        measuredWidth  += optical ? opticalWidth  : -opticalWidth;</span><br><span class="line">        measuredHeight += optical ? opticalHeight : -opticalHeight;</span><br><span class="line">    &#125;</span><br><span class="line">    setMeasuredDimensionRaw(measuredWidth, measuredHeight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setMeasuredDimensionRaw</span><span class="params">(<span class="keyword">int</span> measuredWidth, <span class="keyword">int</span> measuredHeight)</span> </span>&#123;</span><br><span class="line">    mMeasuredWidth = measuredWidth;</span><br><span class="line">    mMeasuredHeight = measuredHeight;</span><br><span class="line"></span><br><span class="line">    mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置的时候其实就是将值赋值给 mMeasuredWidth 和 mMeasuredHeight，而这两个值正是<code>getMeasuredWidth()</code>和<code>getMeasuredHeight()</code>这两个方法的返回值。因此只有在测量完毕之后，这两个方法才能返回正确的有效值。</p>
<p>以上是 View 的 measure 过程，下面看一下 ViewGroup 的。ViewGroup 的测量与三个方法相关：<code>measureChildren()</code>、<code>measureChild()</code>和<code>measureChildWithMargins()</code>。一个个来看:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildren</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = mChildrenCount;</span><br><span class="line">    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = children[i];</span><br><span class="line">        <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;</span><br><span class="line">            measureChild(child, widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法很简单：循环遍历所有的子 View ，只要可见性不是 GONE 的，就调用<code>measureChild()</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> parentHeightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> LayoutParams lp = child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">            mPaddingLeft + mPaddingRight, lp.width);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">            mPaddingTop + mPaddingBottom, lp.height);</span><br><span class="line"></span><br><span class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个会计算传递给子 View <code>measure()</code> 的宽高，调用的方法是<code>getChildMeasureSpec()</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(spec);</span><br><span class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(spec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = Math.max(<span class="number">0</span>, specSize - padding);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> resultSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> resultMode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">    <span class="comment">// Parent has imposed an exact size on us</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to be our size. So be it.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to determine its own size. It can't be</span></span><br><span class="line">            <span class="comment">// bigger than us.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parent has imposed a maximum size on us</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Child wants a specific size... so be it</span></span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to be our size, but our size is not fixed.</span></span><br><span class="line">            <span class="comment">// Constrain child to not be bigger than us.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to determine its own size. It can't be</span></span><br><span class="line">            <span class="comment">// bigger than us.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parent asked to see how big we want to be</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Child wants a specific size... let him have it</span></span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to be our size... find out how big it should</span></span><br><span class="line">            <span class="comment">// be</span></span><br><span class="line">            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</span><br><span class="line">            resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to determine its own size.... find out how</span></span><br><span class="line">            <span class="comment">// big it should be</span></span><br><span class="line">            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</span><br><span class="line">            resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法比较长，但是细看并不难，可以看到我们平时在添加子 View 的时候，使用的 LayoutParams 对布局的影响。<code>measureChildWithMargins()</code>方法就不分析了，它只是把 margin 也从 View 的空间中扣除了。</p>
<blockquote>
<p>由此可见，一个 View 的 MeasureSpec 由父布局 MeasureSpec 和自身的 LayoutParams 共同产生。</p>
</blockquote>
<p>虽然 ViewGroup 有这样一组与测量有关的方法，但是 framework 层面好像并没有去使用，像 FrameLayout、LinearLayout 等都是自己重载了<code>onMeasure()</code>，并在这个方法中按照自己的逻辑完成了子 View 的测量。</p>
<p>以上，就是 View 的测量过程。</p>
<h2 id="layout-过程"><a href="#layout-过程" class="headerlink" title="layout 过程"></a>layout 过程</h2><p>View 的 layout 过程起始于 ViewRootImpl 的 <code>performLayout</code>方法: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performLayout</span><span class="params">(WindowManager.LayoutParams lp, <span class="keyword">int</span> desiredWindowWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> desiredWindowHeight)</span> </span>&#123;</span><br><span class="line">    mLayoutRequested = <span class="keyword">false</span>;</span><br><span class="line">    mScrollMayChange = <span class="keyword">true</span>;</span><br><span class="line">    mInLayout = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> View host = mView;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    mInLayout = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法里面调用了一个很重要的方法，即 View 的<code>layout</code>方法: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="number">0</span>) &#123;</span><br><span class="line">        onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</span><br><span class="line">        mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> oldL = mLeft;</span><br><span class="line">    <span class="keyword">int</span> oldT = mTop;</span><br><span class="line">    <span class="keyword">int</span> oldB = mBottom;</span><br><span class="line">    <span class="keyword">int</span> oldR = mRight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</span><br><span class="line">            setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class="line">        onLayout(changed, l, t, r, b);</span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</span><br><span class="line"></span><br><span class="line">        ListenerInfo li = mListenerInfo;</span><br><span class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</span><br><span class="line">                    (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</span><br><span class="line">            <span class="keyword">int</span> numListeners = listenersCopy.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</span><br><span class="line">                listenersCopy.get(i).onLayoutChange(<span class="keyword">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</span><br><span class="line">    mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里首先通过<code>setOpticalFrame()</code>或者<code>setFrame()</code>方法判断边界有没有变化，这两个方法最终都调用到了<code>setFrame()</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Assign a size and position to this view.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is called from layout.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left Left position, relative to parent</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> top Top position, relative to parent</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right Right position, relative to parent</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bottom Bottom position, relative to parent</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if the new size and position are different than the</span></span><br><span class="line"><span class="comment"> *         previous ones</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@hide</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">setFrame</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果与之前的值不一致，就说明 View 的边界变化了</span></span><br><span class="line">    <span class="keyword">if</span> (mLeft != left || mRight != right || mTop != top || mBottom != bottom) &#123;</span><br><span class="line">        changed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Remember our drawn bit</span></span><br><span class="line">        <span class="keyword">int</span> drawn = mPrivateFlags &amp; PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> oldWidth = mRight - mLeft;</span><br><span class="line">        <span class="keyword">int</span> oldHeight = mBottom - mTop;</span><br><span class="line">        <span class="keyword">int</span> newWidth = right - left;</span><br><span class="line">        <span class="keyword">int</span> newHeight = bottom - top;</span><br><span class="line">        <span class="comment">// sizeChanged 表示大小有没有变化</span></span><br><span class="line">        <span class="keyword">boolean</span> sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Invalidate our old position</span></span><br><span class="line">        invalidate(sizeChanged);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新赋值</span></span><br><span class="line">        mLeft = left;</span><br><span class="line">        mTop = top;</span><br><span class="line">        mRight = right;</span><br><span class="line">        mBottom = bottom;</span><br><span class="line">        mRenderNode.setLeftTopRightBottom(mLeft, mTop, mRight, mBottom);</span><br><span class="line"></span><br><span class="line">        mPrivateFlags |= PFLAG_HAS_BOUNDS;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回调</span></span><br><span class="line">        <span class="keyword">if</span> (sizeChanged) &#123;</span><br><span class="line">            sizeChange(newWidth, newHeight, oldWidth, oldHeight);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || mGhostView != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If we are visible, force the DRAWN bit to on so that</span></span><br><span class="line">            <span class="comment">// this invalidate will go through (at least to our parent).</span></span><br><span class="line">            <span class="comment">// This is because someone may have invalidated this view</span></span><br><span class="line">            <span class="comment">// before this call to setFrame came in, thereby clearing</span></span><br><span class="line">            <span class="comment">// the DRAWN bit.</span></span><br><span class="line">            mPrivateFlags |= PFLAG_DRAWN;</span><br><span class="line">            invalidate(sizeChanged);</span><br><span class="line">            <span class="comment">// parent display list may need to be recreated based on a change in the bounds</span></span><br><span class="line">            <span class="comment">// of any child</span></span><br><span class="line">            invalidateParentCaches();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset drawn bit to original value (invalidate turns it off)</span></span><br><span class="line">        mPrivateFlags |= drawn;</span><br><span class="line"></span><br><span class="line">        mBackgroundSizeChanged = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (mForegroundInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mForegroundInfo.mBoundsChanged = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        notifySubtreeAccessibilityStateChangedIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> changed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点已经标注在代码里面了，判断的依据就是和原有的旧值相比较。如果变化了或者是设置了<code>PFLAG_LAYOUT_REQUIRED</code>标记，就调用<code>onLayout()</code>方法。因此 View 的<code>onLayout()</code>方法虽然会被调用，但是只要它的上下左右的位置不变，则<code>changed</code>参数就为 false。我们来看一下<code>onLayout()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个空方法，而在 ViewGroup 里面，方法则是:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure>
<p>它是一个抽象方法。那么到底 ViewGroup 会如何去使用这些参数呢？可以看一个简单的例子: FrameLayout。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    layoutChildren(left, top, right, bottom, <span class="keyword">false</span> <span class="comment">/* no force left gravity */</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutChildren</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">boolean</span> forceLeftGravity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = getChildCount();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 计算 FrameLayout 上下左右的边界位置</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> parentLeft = getPaddingLeftWithForeground();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> parentRight = right - left - getPaddingRightWithForeground();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> parentTop = getPaddingTopWithForeground();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> parentBottom = bottom - top - getPaddingBottomWithForeground();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 遍历所有的子 View </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = getChildAt(i);</span><br><span class="line">        <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">            <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取之前子 View 测量出来的尺寸</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> width = child.getMeasuredWidth();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> height = child.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> childLeft;</span><br><span class="line">            <span class="keyword">int</span> childTop;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> gravity = lp.gravity;</span><br><span class="line">            <span class="keyword">if</span> (gravity == -<span class="number">1</span>) &#123;</span><br><span class="line">                gravity = DEFAULT_CHILD_GRAVITY;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = getLayoutDirection();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> verticalGravity = gravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 根据 ViewGroup 设置的属性，比如 gravity，计算子 View 的上下左右边界位置</span></span><br><span class="line">            <span class="keyword">switch</span> (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class="line">                <span class="keyword">case</span> Gravity.CENTER_HORIZONTAL:</span><br><span class="line">                    childLeft = parentLeft + (parentRight - parentLeft - width) / <span class="number">2</span> +</span><br><span class="line">                    lp.leftMargin - lp.rightMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Gravity.RIGHT:</span><br><span class="line">                    <span class="keyword">if</span> (!forceLeftGravity) &#123;</span><br><span class="line">                        childLeft = parentRight - width - lp.rightMargin;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">case</span> Gravity.LEFT:</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    childLeft = parentLeft + lp.leftMargin;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (verticalGravity) &#123;</span><br><span class="line">                <span class="keyword">case</span> Gravity.TOP:</span><br><span class="line">                    childTop = parentTop + lp.topMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Gravity.CENTER_VERTICAL:</span><br><span class="line">                    childTop = parentTop + (parentBottom - parentTop - height) / <span class="number">2</span> +</span><br><span class="line">                    lp.topMargin - lp.bottomMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> Gravity.BOTTOM:</span><br><span class="line">                    childTop = parentBottom - height - lp.bottomMargin;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    childTop = parentTop + lp.topMargin;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 传递给子 View 它的位置</span></span><br><span class="line">            child.layout(childLeft, childTop, childLeft + width, childTop + height);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键的四步已经标注在代码中了，第 4 步之后，就回到我们前面分析的 View 的<code>setFrame()</code>方法，View 会记录下 mLeft/mTop/mRight/mBottom 四个值。</p>
<p>以上，就是 View 的 layout 过程。</p>
<h2 id="draw-过程"><a href="#draw-过程" class="headerlink" title="draw 过程"></a>draw 过程</h2><p>经过前面两个过程，我们已经知道了要在什么位置画多大的一个 View ，接下去就是要开始绘制了，起始当然是<code>performDraw()</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mIsDrawing = <span class="keyword">true</span>;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"draw"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        draw(fullRedrawNeeded);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mIsDrawing = <span class="keyword">false</span>;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里调用了<code>draw()</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">boolean</span> fullRedrawNeeded)</span> </span>&#123;</span><br><span class="line">    Surface surface = mSurface;</span><br><span class="line">    <span class="keyword">if</span> (!surface.isValid()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">if</span> (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mAttachInfo.mHardwareRenderer != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mHardwareRenderer.isEnabled()) &#123;</span><br><span class="line">            ...</span><br><span class="line">            mAttachInfo.mHardwareRenderer.draw(mView, mAttachInfo, <span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// If we get here with a disabled &amp; requested hardware renderer, something went</span></span><br><span class="line">            <span class="comment">// wrong (an invalidate posted right before we destroyed the hardware surface</span></span><br><span class="line">            <span class="comment">// for instance) so we should just bail out. Locking the surface with software</span></span><br><span class="line">            <span class="comment">// rendering at this point would lock it forever and prevent hardware renderer</span></span><br><span class="line">            <span class="comment">// from doing its job when it comes back.</span></span><br><span class="line">            <span class="comment">// Before we request a new frame we must however attempt to reinitiliaze the</span></span><br><span class="line">            <span class="comment">// hardware renderer if it's in requested state. This would happen after an</span></span><br><span class="line">            <span class="comment">// eglTerminate() for instance.</span></span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (animating) &#123;</span><br><span class="line">        mFullRedrawNeeded = <span class="keyword">true</span>;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会去判断是否是开启了硬件加速，如果没有，就调用<code>drawSoftware()</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">drawSoftware</span><span class="params">(Surface surface, AttachInfo attachInfo, <span class="keyword">int</span> xoff, <span class="keyword">int</span> yoff,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> scalingRequired, Rect dirty)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Draw with software renderer.</span></span><br><span class="line">    <span class="keyword">final</span> Canvas canvas;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> left = dirty.left;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> top = dirty.top;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> right = dirty.right;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> bottom = dirty.bottom;</span><br><span class="line"></span><br><span class="line">        canvas = mSurface.lockCanvas(dirty);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The dirty rectangle can be modified by Surface.lockCanvas()</span></span><br><span class="line">        <span class="comment">//noinspection ConstantConditions</span></span><br><span class="line">        <span class="keyword">if</span> (left != dirty.left || top != dirty.top || right != dirty.right</span><br><span class="line">                || bottom != dirty.bottom) &#123;</span><br><span class="line">            attachInfo.mIgnoreDirtyState = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Do this in native</span></span><br><span class="line">        canvas.setDensity(mDensity);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Surface.OutOfResourcesException e) &#123;</span><br><span class="line">        handleOutOfResourcesException(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// If this bitmap's format includes an alpha channel, we</span></span><br><span class="line">        <span class="comment">// need to clear it before drawing so that the child will</span></span><br><span class="line">        <span class="comment">// properly re-composite its drawing on a transparent</span></span><br><span class="line">        <span class="comment">// background. This automatically respects the clip/dirty region</span></span><br><span class="line">        <span class="comment">// or</span></span><br><span class="line">        <span class="comment">// If we are applying an offset, we need to clear the area</span></span><br><span class="line">        <span class="comment">// where the offset doesn't appear to avoid having garbage</span></span><br><span class="line">        <span class="comment">// left in the blank areas.</span></span><br><span class="line">        <span class="keyword">if</span> (!canvas.isOpaque() || yoff != <span class="number">0</span> || xoff != <span class="number">0</span>) &#123;</span><br><span class="line">            canvas.drawColor(<span class="number">0</span>, PorterDuff.Mode.CLEAR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dirty.setEmpty();</span><br><span class="line">        mIsAnimating = <span class="keyword">false</span>;</span><br><span class="line">        mView.mPrivateFlags |= View.PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">        canvas.translate(-xoff, -yoff);</span><br><span class="line">        <span class="keyword">if</span> (mTranslator != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mTranslator.translateCanvas(canvas);</span><br><span class="line">        &#125;</span><br><span class="line">        canvas.setScreenDensity(scalingRequired ? mNoncompatDensity : <span class="number">0</span>);</span><br><span class="line">        attachInfo.mSetIgnoreDirtyState = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// ！！！</span></span><br><span class="line">        mView.draw(canvas);</span><br><span class="line">        drawAccessibilityFocusedDrawableIfNeeded(canvas);    </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            surface.unlockCanvasAndPost(canvas);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法锁定了 Surface 上的一块 Canvas 区域，然后调用了 View 的<code>draw()</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> privateFlags = mPrivateFlags;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;</span><br><span class="line">            (mAttachInfo == <span class="keyword">null</span> || !mAttachInfo.mIgnoreDirtyState);</span><br><span class="line">    mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Draw traversal performs several drawing steps which must be executed</span></span><br><span class="line"><span class="comment">     * in the appropriate order:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. Draw the background</span></span><br><span class="line"><span class="comment">     * 2. If necessary, save the canvas' layers to prepare for fading</span></span><br><span class="line"><span class="comment">     * 3. Draw view's content</span></span><br><span class="line"><span class="comment">     * 4. Draw children</span></span><br><span class="line"><span class="comment">     * 5. If necessary, draw the fading edges and restore layers</span></span><br><span class="line"><span class="comment">     * 6. Draw decorations (scrollbars for instance)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 1, draw the background, if needed</span></span><br><span class="line">    <span class="keyword">int</span> saveCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dirtyOpaque) &#123;</span><br><span class="line">        drawBackground(canvas);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// skip step 2 &amp; 5 if possible (common case)</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</span><br><span class="line">    <span class="keyword">boolean</span> horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</span><br><span class="line">        <span class="comment">// Step 3, draw the content</span></span><br><span class="line">        <span class="keyword">if</span> (!dirtyOpaque) onDraw(canvas);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 4, draw the children</span></span><br><span class="line">        dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Overlay is part of the content and draws beneath Foreground</span></span><br><span class="line">        <span class="keyword">if</span> (mOverlay != <span class="keyword">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">            mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 6, draw decorations (foreground, scrollbars)</span></span><br><span class="line">        onDrawForeground(canvas);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// we're done...</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的注释非常清楚，绘制过程主要分为 6 个步骤:</p>
<ol>
<li>绘制背景；</li>
<li>判断是否要显示横向或者纵向的fading edge;</li>
<li>绘制自身的内容；</li>
<li>绘制子View；</li>
<li>如果需要绘制fading edge，则在这一步进行绘制；</li>
<li>绘制装饰品，比如滚动条等；</li>
</ol>
<p>2 和 5会尽可能的省略，因为不是所有的 View 都需要绘制。<code>draw()</code>方法会根据有没有fading edge 选择两条不同的逻辑进行绘制，代码片段中展示的是简单的一条，在这个过程中，step 3，也就是绘制自身内容这块，它调用了另外一个重要的方法，即<code>onDraw()</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 View 类中，这个方法是一个空方法，因此它不会绘制任何内容，读者可以去看一下 TextView 等子类关于该方法的实现。而 step 4调用的另外一个方法<code>dispatchDraw()</code>也是一个空方法，在 ViewGroup 中会有相应的实现。</p>
<p>以上，就是 View 的绘制过程。</p>
<h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><h3 id="ViewRootImpl-performTraversals-是如何被调用的？"><a href="#ViewRootImpl-performTraversals-是如何被调用的？" class="headerlink" title="ViewRootImpl.performTraversals()是如何被调用的？"></a><code>ViewRootImpl.performTraversals()</code>是如何被调用的？</h3><p>这个问题要到<a href="https://www.muzileecoding.com/framework/activity-launch-progress.html" target="_blank" rel="noopener">Activity启动过程</a>一文中解答。</p>
<h3 id="getWidth-getHeight-和getMeasuredWidth-getMeasuredHeight-两组方法有什么区别和联系？"><a href="#getWidth-getHeight-和getMeasuredWidth-getMeasuredHeight-两组方法有什么区别和联系？" class="headerlink" title="getWidth()/getHeight()和getMeasuredWidth()/getMeasuredHeight()两组方法有什么区别和联系？"></a><code>getWidth()/getHeight()</code>和<code>getMeasuredWidth()/getMeasuredHeight()</code>两组方法有什么区别和联系？</h3><p>两组方法的实现分别如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> mRight - mLeft;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> mBottom - mTop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getMeasuredWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> mMeasuredWidth &amp; MEASURED_SIZE_MASK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getMeasuredHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> mMeasuredHeight &amp; MEASURED_SIZE_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此我们只需要看看这些变量什么时候被赋值就好了，根据前面的分析： mRight/mLeft/mBottom/mTop 四个变量是在 layout 之后才被赋值（<code>setFrame()</code>方法体内），因此之后在 layout 之后，这组方法才会有效。而 mMeasuredWidth/mMeasuredHeight 是在<code>onMeasure()</code>方法中调用<code>setMeasuredDimension()</code>设置后才有值的，因此这组方法是在 measure 过程完成之后就有效了。</p>
<p>这两组值可能不一样，也可能一样，具体要看在实际 layout 的过程中有没有遵循 measure 过程中设置好的限制。</p>
<h3 id="invalidate-postInvalidate-requestLayout"><a href="#invalidate-postInvalidate-requestLayout" class="headerlink" title="invalidate()/postInvalidate()/requestLayout"></a><code>invalidate()</code>/<code>postInvalidate()</code>/<code>requestLayout</code></h3><p>这三个方法出现的背景是：一个页面已经绘制好了，如果因为一些原因它的位置、尺寸、外观需要发生变化，比如一个 View 正在执行一个动画，那就需要 View 自己能够主动请求重新计算、展现这些变化。</p>
<h4 id="invalidate-和postInvalidate"><a href="#invalidate-和postInvalidate" class="headerlink" title="invalidate()和postInvalidate()"></a><code>invalidate()</code>和<code>postInvalidate()</code></h4><p><code>postInvalidate()</code>方法的实现如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Cause an invalidate to happen on a subsequent cycle through the event loop.</span></span><br><span class="line"><span class="comment"> * Use this to invalidate the View from a non-UI thread.&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method can be invoked from outside of the UI thread</span></span><br><span class="line"><span class="comment"> * only when this View is attached to a window.&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #invalidate()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #postInvalidateDelayed(long)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postInvalidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    postInvalidateDelayed(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postInvalidateDelayed</span><span class="params">(<span class="keyword">long</span> delayMilliseconds)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// We try only with the AttachInfo because there's no point in invalidating</span></span><br><span class="line">    <span class="comment">// if we are not attached to our window</span></span><br><span class="line">    <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">    <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        attachInfo.mViewRootImpl.dispatchInvalidateDelayed(<span class="keyword">this</span>, delayMilliseconds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从注释看，这个方法是为了从非-UI 线程来刷新 View，最终调用到的是<code>ViewRootImpl.dispatchInvalidateDelayed()</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchInvalidateDelayed</span><span class="params">(View view, <span class="keyword">long</span> delayMilliseconds)</span> </span>&#123;</span><br><span class="line">	Message msg = mHandler.obtainMessage(MSG_INVALIDATE, view);</span><br><span class="line">	mHandler.sendMessageDelayed(msg, delayMilliseconds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里产生了一个<code>MSG_INVALIDATE</code>消息，它的处理如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewRootHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">        <span class="keyword">case</span> MSG_INVALIDATE:</span><br><span class="line">            ((View) msg.obj).invalidate();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很清楚，这里是通过主线程的 Handler 将 invalidate 消息调度到至主线程。因此，<strong><code>invalidate()</code>和<code>postInvalidate()</code>的区别就是前者是在主线程调用，后者可以从非主线程调度</strong>。</p>
<p>接着我们来看<code>invalidate()</code>和<code>requestLayout</code>各自所起的作用。</p>
<h4 id="requestLayout方法"><a href="#requestLayout方法" class="headerlink" title="requestLayout方法"></a><code>requestLayout</code>方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mMeasureCache != <span class="keyword">null</span>) mMeasureCache.clear();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 设置两个标志位</span></span><br><span class="line">    mPrivateFlags |= PFLAG_FORCE_LAYOUT;</span><br><span class="line">    mPrivateFlags |= PFLAG_INVALIDATED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用父 ViewGroup 的 requestLayout() 方法</span></span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="keyword">null</span> &amp;&amp; !mParent.isLayoutRequested()) &#123;</span><br><span class="line">        mParent.requestLayout();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mAttachInfo != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mViewRequestingLayout == <span class="keyword">this</span>) &#123;</span><br><span class="line">        mAttachInfo.mViewRequestingLayout = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它设置了两个标志位，之后调用父 View 的<code>requestLayout()</code>方法，根据我们前面分析的 Activity 的 View 结构，这个调用会层层向上，会到哪里呢？最终会调用到 ViewRootImpl 的<code>requestLayout()</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">        checkThread();</span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会设置 mLayoutRequested 标志位，并调用<code>scheduleTraversals()</code>，这个方法又会调用到我们前面分析的<code>performTraversals()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">boolean</span> layoutRequested = mLayoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line">    <span class="keyword">if</span> (layoutRequested) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// Ask host how big it wants to be</span></span><br><span class="line">        windowSizeMayChange |= measureHierarchy(host, lp, res,</span><br><span class="line">                desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 成立</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> didLayout = layoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line">    <span class="keyword">boolean</span> triggerGlobalLayoutListener = didLayout || mAttachInfo.mRecomputeGlobalAttributes;</span><br><span class="line">	<span class="keyword">if</span> (didLayout) &#123;</span><br><span class="line">		performLayout(lp, desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为前面将 mLayoutRequested 置为 true，因此一定会调用<code>measureHierarchy()</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">measureHierarchy</span><span class="params">(<span class="keyword">final</span> View host, <span class="keyword">final</span> WindowManager.LayoutParams lp,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> Resources res, <span class="keyword">final</span> <span class="keyword">int</span> desiredWindowWidth, <span class="keyword">final</span> <span class="keyword">int</span> desiredWindowHeight)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">boolean</span> goodMeasure = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">        ....</span><br><span class="line">        <span class="keyword">if</span> (baseSize != <span class="number">0</span> &amp;&amp; desiredWindowWidth &gt; baseSize) &#123;</span><br><span class="line">            ...</span><br><span class="line">            performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> ((host.getMeasuredWidthAndState()&amp;View.MEASURED_STATE_TOO_SMALL) == <span class="number">0</span>) &#123;</span><br><span class="line">                goodMeasure = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ...</span><br><span class="line">                performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">                <span class="keyword">if</span> ((host.getMeasuredWidthAndState()&amp;View.MEASURED_STATE_TOO_SMALL) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_DIALOG) Log.v(TAG, <span class="string">"Good!"</span>);</span><br><span class="line">                    goodMeasure = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!goodMeasure) &#123;</span><br><span class="line">        childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);</span><br><span class="line">        childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);</span><br><span class="line">        performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">        <span class="keyword">if</span> (mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) &#123;</span><br><span class="line">            windowSizeMayChange = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个代码片段中，肯定会调用<code>performMeasure()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ||</span><br><span class="line">        widthMeasureSpec != mOldWidthMeasureSpec ||</span><br><span class="line">        heightMeasureSpec != mOldHeightMeasureSpec) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// first clears the measured dimension flag</span></span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET;</span><br><span class="line"></span><br><span class="line">        resolveRtlPropertiesIfNeeded();</span><br><span class="line">        <span class="comment">// 设置了 PFLAG_FORCE_LAYOUT，cacheIndex 为 -1</span></span><br><span class="line">        <span class="keyword">int</span> cacheIndex = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ? -<span class="number">1</span> :</span><br><span class="line">                mMeasureCache.indexOfKey(key);</span><br><span class="line">        <span class="keyword">if</span> (cacheIndex &lt; <span class="number">0</span> || sIgnoreMeasureCache) &#123;</span><br><span class="line">            <span class="comment">// measure ourselves, this should set the measured dimension flag back</span></span><br><span class="line">            onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">            mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> value = mMeasureCache.valueAt(cacheIndex);</span><br><span class="line">            <span class="comment">// Casting a long to int drops the high 32 bits, no mask needed</span></span><br><span class="line">            setMeasuredDimensionRaw((<span class="keyword">int</span>) (value &gt;&gt; <span class="number">32</span>), (<span class="keyword">int</span>) value);</span><br><span class="line">            mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 设置标志位：PFLAG_LAYOUT_REQUIRED</span></span><br><span class="line">        mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mOldWidthMeasureSpec = widthMeasureSpec;</span><br><span class="line">    mOldHeightMeasureSpec = heightMeasureSpec;</span><br><span class="line"></span><br><span class="line">    mMeasureCache.put(key, ((<span class="keyword">long</span>) mMeasuredWidth) &lt;&lt; <span class="number">32</span> |</span><br><span class="line">            (<span class="keyword">long</span>) mMeasuredHeight &amp; <span class="number">0xffffffffL</span>); <span class="comment">// suppress sign extension</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面调用<code>requestLayout()</code>方法的时候，我们设置了<code>PFLAG_FORCE_LAYOUT</code>标志位，因此这里会执行到<code>onMeasure()</code>方法。也就是说会进行测量过程。</p>
<p>我们再回到<code>performTraversals()</code>方法，接下去会调用<code>performLayout()</code>方法，这个方法前面分析过了:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="number">0</span>) &#123;</span><br><span class="line">        onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</span><br><span class="line">        mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> oldL = mLeft;</span><br><span class="line">    <span class="keyword">int</span> oldT = mTop;</span><br><span class="line">    <span class="keyword">int</span> oldB = mBottom;</span><br><span class="line">    <span class="keyword">int</span> oldR = mRight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</span><br><span class="line">            setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line">    <span class="comment">// 如果设置了 PFLAG_LAYOUT_REQUIRED 标志位，则进行 onLayout</span></span><br><span class="line">    <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class="line">        onLayout(changed, l, t, r, b);</span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</span><br><span class="line"></span><br><span class="line">        ListenerInfo li = mListenerInfo;</span><br><span class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</span><br><span class="line">                    (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</span><br><span class="line">            <span class="keyword">int</span> numListeners = listenersCopy.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</span><br><span class="line">                listenersCopy.get(i).onLayoutChange(<span class="keyword">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</span><br><span class="line">    mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为在 measure 过程中设置了<code>PFLAG_LAYOUT_REQUIRED</code>标志位，所以这里会重新设置位置。而<code>performDraw()</code>方法虽然有触发条件，但是如果 View 的尺寸和位置变化了，一定会触发该方法的调用。</p>
<h4 id="invalidate-方法"><a href="#invalidate-方法" class="headerlink" title="invalidate()方法"></a><code>invalidate()</code>方法</h4><p>这个方法其实有一些重载方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    invalidate(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invalidate</span><span class="params">(<span class="keyword">boolean</span> invalidateCache)</span> </span>&#123;</span><br><span class="line">    invalidateInternal(<span class="number">0</span>, <span class="number">0</span>, mRight - mLeft, mBottom - mTop, invalidateCache, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invalidateInternal</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b, <span class="keyword">boolean</span> invalidateCache,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> fullInvalidate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mGhostView != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mGhostView.invalidate(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (skipInvalidate()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重绘执行的条件</span></span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags &amp; (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)</span><br><span class="line">            || (invalidateCache &amp;&amp; (mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID)</span><br><span class="line">            || (mPrivateFlags &amp; PFLAG_INVALIDATED) != PFLAG_INVALIDATED</span><br><span class="line">            || (fullInvalidate &amp;&amp; isOpaque() != mLastIsOpaque)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fullInvalidate) &#123;</span><br><span class="line">            mLastIsOpaque = isOpaque();</span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_DRAWN;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置标志位</span></span><br><span class="line">        mPrivateFlags |= PFLAG_DIRTY;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断成立</span></span><br><span class="line">        <span class="keyword">if</span> (invalidateCache) &#123;</span><br><span class="line">            mPrivateFlags |= PFLAG_INVALIDATED;</span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Propagate the damage rectangle to the parent view.</span></span><br><span class="line">        <span class="keyword">final</span> AttachInfo ai = mAttachInfo;</span><br><span class="line">        <span class="keyword">final</span> ViewParent p = mParent;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用父 View 的 invalidateChild 方法</span></span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; ai != <span class="keyword">null</span> &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123;</span><br><span class="line">            <span class="keyword">final</span> Rect damage = ai.mTmpInvalRect;</span><br><span class="line">            damage.set(l, t, r, b);</span><br><span class="line">            p.invalidateChild(<span class="keyword">this</span>, damage);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Damage the entire projection receiver, if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (mBackground != <span class="keyword">null</span> &amp;&amp; mBackground.isProjected()) &#123;</span><br><span class="line">            <span class="keyword">final</span> View receiver = getProjectionReceiver();</span><br><span class="line">            <span class="keyword">if</span> (receiver != <span class="keyword">null</span>) &#123;</span><br><span class="line">                receiver.damageInParent();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Damage the entire IsolatedZVolume receiving this view's shadow.</span></span><br><span class="line">        <span class="keyword">if</span> (isHardwareAccelerated() &amp;&amp; getZ() != <span class="number">0</span>) &#123;</span><br><span class="line">            damageShadowReceiver();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如注释所说，最终调用了父 ViewParent 的<code>invalidateChild()</code>方法，并把当前 View 的范围默认传递给了该方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Don't call or override this method. It is used for the implementation of</span></span><br><span class="line"><span class="comment"> * the view hierarchy.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invalidateChild</span><span class="params">(View child, <span class="keyword">final</span> Rect dirty)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 把自身赋值给 parent</span></span><br><span class="line">    ViewParent parent = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">    <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] location = attachInfo.mInvalidateChildLocation;</span><br><span class="line">        location[CHILD_LEFT_INDEX] = child.mLeft;</span><br><span class="line">        location[CHILD_TOP_INDEX] = child.mTop;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// while 循环</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            View view = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> View) &#123;</span><br><span class="line">                view = (View) parent;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            parent = parent.invalidateChildInParent(location, dirty);</span><br><span class="line">            <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Account for transform on current parent</span></span><br><span class="line">                Matrix m = view.getMatrix();</span><br><span class="line">                <span class="keyword">if</span> (!m.isIdentity()) &#123;</span><br><span class="line">                    RectF boundingRect = attachInfo.mTmpTransformRect;</span><br><span class="line">                    boundingRect.set(dirty);</span><br><span class="line">                    m.mapRect(boundingRect);</span><br><span class="line">                    dirty.set((<span class="keyword">int</span>) (boundingRect.left - <span class="number">0.5f</span>),</span><br><span class="line">                            (<span class="keyword">int</span>) (boundingRect.top - <span class="number">0.5f</span>),</span><br><span class="line">                            (<span class="keyword">int</span>) (boundingRect.right + <span class="number">0.5f</span>),</span><br><span class="line">                            (<span class="keyword">int</span>) (boundingRect.bottom + <span class="number">0.5f</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (parent != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会不停的调用 parent 的<code>invalidateChildInParent()</code>方法，这个方法一直调用，会调用到<code>ViewRootImpl.invalidateRectOnScreen()</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invalidateRectOnScreen</span><span class="params">(Rect dirty)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Rect localDirty = mDirty;</span><br><span class="line">    <span class="keyword">if</span> (!localDirty.isEmpty() &amp;&amp; !localDirty.contains(dirty)) &#123;</span><br><span class="line">        mAttachInfo.mSetIgnoreDirtyState = <span class="keyword">true</span>;</span><br><span class="line">        mAttachInfo.mIgnoreDirtyState = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the new dirty rect to the current one</span></span><br><span class="line">    localDirty.union(dirty.left, dirty.top, dirty.right, dirty.bottom);</span><br><span class="line">    <span class="comment">// Intersect with the bounds of the window to skip</span></span><br><span class="line">    <span class="comment">// updates that lie outside of the visible region</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> appScale = mAttachInfo.mApplicationScale;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> intersected = localDirty.intersect(<span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">            (<span class="keyword">int</span>) (mWidth * appScale + <span class="number">0.5f</span>), (<span class="keyword">int</span>) (mHeight * appScale + <span class="number">0.5f</span>));</span><br><span class="line">    <span class="keyword">if</span> (!intersected) &#123;</span><br><span class="line">        localDirty.setEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 成立</span></span><br><span class="line">    <span class="keyword">if</span> (!mWillDrawSoon &amp;&amp; (intersected || mIsAnimating)) &#123;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此这里还是去调用了<code>scheduleTraversals()</code>方法，不同的是，这次没有设置 mLayoutRequested 为 true，因此不会调用<code>performLayout()</code>方法，也不会去调用<code>measureHierarchy()</code>方法。</p>
<blockquote>
<p>关于这一点论断，读者可以去看这两个方法的调用处，都和 mLayoutRequested 相关。</p>
</blockquote>
<p>因此只会直接去调用<code>performDraw()</code>方法。</p>
<h4 id="方法总结"><a href="#方法总结" class="headerlink" title="方法总结"></a>方法总结</h4><p>下面这幅图出自 Google+ ：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/android-view-method.webp" height="400" alt="android-view-method"></div>

<p>它很好的总结了相关过程，指出了<code>invalidate()</code>和<code>requestLayout()</code>方法的区别。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>View 的绘制过程一如我们自己作画的过程一样，抽象出来无非是确认 View 的大小，设置 View 的位置，绘制 View 的内容三个步骤，前面的分析能够让读者对绘制的过程有一个粗略的了解。</p>
<p>结合<a href="https://www.muzileecoding.com/android/Android-touchevent-process.html" target="_blank" rel="noopener">Android View事件处理</a>，我们还能得出一个结论：<strong>View 的绘制过程无非是把我们想要的 View 界面绘制在 Surface 的 Canvas 上并最终显示到屏幕上，最终的显示和我们屏幕截图下来的图片本质上是没有区别的。它的奇特之处就在于它能接受事件并作出反应，而这是通过底层的View 对象来实现的。</strong></p>
<p>然而，贴出来分析的代码是经过删减的，读者如果自己去看方法体，会发现过程复杂的多，就比如我们最开始分析的<code>ViewRootImpl.performTraversals()</code>方法，它并不是简简单单的就调用了这三个方法，甚至也不是调用了一次。但这并不妨碍我们去了解这样一个过程，当我们以后遇到问题，至少可以有一个基本的概念去猜测一下问题点。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android View事件处理]]></title>
      <url>http://www.timebridge.space/2016/09/04/Android-touchevent-process/</url>
      <content type="html"><![CDATA[<h2 id="View-模型-amp-事件模型"><a href="#View-模型-amp-事件模型" class="headerlink" title="View 模型 &amp; 事件模型"></a>View 模型 &amp; 事件模型</h2><h3 id="View-模型"><a href="#View-模型" class="headerlink" title="View 模型"></a>View 模型</h3><p>如图所示，是我们日常开发布局所接触的 View 模型：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/Android-View模型.png" alt="Android-View模型"></div>

<p>简单来说，就是 View 和 ViewGroup 的嵌套组合。ViewGroup 是一种特殊的 View，特殊之处就在于它可以容纳并按照一定的规则排列View，此时的 View 被称为子 View，常见的 View 有 Button、ImageView 等，常见的 ViewGroup 有 LinearLayout、Relativelayout等，Android 开发者应该非常熟悉。<a id="more"></a></p>
<h3 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h3><p>本文要讨论的是这样一组 View 模型对事件的处理过程。什么是事件？我们触摸屏幕，从我们的手指开始接触屏幕到手指离开屏幕，手指与屏幕之间的交互都被抽象成连续的事件，用于描述一个触摸过程。事件主要分为三类：</p>
<ol>
<li>ACTION_DOWN：Down事件，也就是我们落下手指的事件，它是一个事件流的开始；</li>
<li>ACTION_MOVE：Move事件，我们手指按在屏幕上，不会一直不动，比如我们玩切水果游戏，手指会飞快的划过页面，这样就产生了一系列的Move事件，通过Move事件，可以构造出手指移动的路径；</li>
<li>ACTION_UP：Up事件，也就是手指拿起的事件；</li>
</ol>
<p>这三类事件串起来可以描述我们绝大部分的触屏操作：ACTION_DOWN, ACTION_MOVE,ACTION_MOVE…ACTION_MOVE, ACTION_UP。那么这样一组事件流是如何分发到 View 模型中去处理的呢？下面详细分析。</p>
<h2 id="View的事件处理"><a href="#View的事件处理" class="headerlink" title="View的事件处理"></a>View的事件处理</h2><h3 id="事件分发——dispatchTouchEvent"><a href="#事件分发——dispatchTouchEvent" class="headerlink" title="事件分发——dispatchTouchEvent"></a>事件分发——<code>dispatchTouchEvent</code></h3><p>View 的事件处理是从<code>dispatchTouchEvent()</code>方法开始的，View中这个方法比较长，我们抽重点看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = event.getActionMasked();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 过滤</span></span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">        <span class="comment">//noinspection SimplifiableIfStatement</span></span><br><span class="line">        ListenerInfo li = mListenerInfo;</span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">                &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，核心代码就这一段。在事件处理前，首先要做一下安全过滤，<code>onFilterTouchEventForSecurity()</code>方法的定义如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Filter the touch event to apply security policies.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> event The motion event to be filtered.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> True if the event should be dispatched, false if the event should be dropped.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getFilterTouchesWhenObscured</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onFilterTouchEventForSecurity</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//noinspection RedundantIfStatement</span></span><br><span class="line">    <span class="keyword">if</span> ((mViewFlags &amp; FILTER_TOUCHES_WHEN_OBSCURED) != <span class="number">0</span></span><br><span class="line">            &amp;&amp; (event.getFlags() &amp; MotionEvent.FLAG_WINDOW_IS_OBSCURED) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Window is obscured, drop this touch.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如注释所说，这个过滤是为了一些安全策略，有兴趣的读者可以去查看一下<code>FILTER_TOUCHES_WHEN_OBSCURED</code>和<code>FLAG_WINDOW_IS_OBSCURED</code>两个变量的注释，尤其是后者的，可以大致了解一下这里的安全指的是什么。这里我们可以当它是返回的 true 来继续往下分析 2 处。分析 2 之前，我们先看几个方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnTouchListener</span><span class="params">(OnTouchListener l)</span> </span>&#123;</span><br><span class="line">	getListenerInfo().mOnTouchListener = l;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function">ListenerInfo <span class="title">getListenerInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mListenerInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> mListenerInfo;</span><br><span class="line">	&#125;</span><br><span class="line">	mListenerInfo = <span class="keyword">new</span> ListenerInfo();</span><br><span class="line">	<span class="keyword">return</span> mListenerInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个方法指明了<code>mListenerInfo</code>中<code>mOnTouchListener</code>的来源，也就是我们平时开发中通过调用<code>setOnTouchListener()</code>为View设置的<code>OnTouchListener</code>监听，因此 2 处的判断的含义是如果 View 满足以下三个条件：</p>
<ol>
<li>设置了<code>OnTouchListener</code>监听；</li>
<li>View 的状态是 enable 的；</li>
<li>调用<code>OnTouchListener</code>的<code>onTouch</code>方法返回的是true；</li>
</ol>
<p>那么<code>dispatchTouchEvent()</code>方法就会返回true，否则<code>result</code>为 false，会继续执行 3 处，也就是执行自己的<code>onTouchEvent()</code>方法。以下是处理流程图：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/View事件处理流程图.png" width="600" alt="View事件处理流程图"></div>

<h3 id="事件处理——onTouchEvent"><a href="#事件处理——onTouchEvent" class="headerlink" title="事件处理——onTouchEvent"></a>事件处理——<code>onTouchEvent</code></h3><p>下面我们来重点看一下<code>onTouchEvent</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 【注意】这里调用的是getX()和getY()，不加任何的参数！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> x = event.getX();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> y = event.getY();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> action = event.getAction();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 如果 View 是 DISABLED</span></span><br><span class="line">    <span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class="line">        <span class="comment">// 如果是 UP 事件，并且当前 View 处于 PRESSED 状态</span></span><br><span class="line">        <span class="keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 取消 PRESSED 状态</span></span><br><span class="line">            setPressed(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// A disabled view that is clickable still consumes the touch</span></span><br><span class="line">        <span class="comment">// events, it just doesn't respond to them.</span></span><br><span class="line">        <span class="keyword">return</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE</span><br><span class="line">                    || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</span><br><span class="line">                    || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 如果设置了 mTouchDelegate，先调用它的 onTouchEvent 方法</span></span><br><span class="line">    <span class="keyword">if</span> (mTouchDelegate != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mTouchDelegate.onTouchEvent(event)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3 如果 View 可点击</span></span><br><span class="line">    <span class="keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</span><br><span class="line">            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||</span><br><span class="line">            (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                mHasPerformedLongPress = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (performButtonActionOnTouchDown(event)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 4</span></span><br><span class="line">                <span class="comment">// Walk up the hierarchy to determine if we're inside a scrolling container.</span></span><br><span class="line">                <span class="keyword">boolean</span> isInScrollingContainer = isInScrollingContainer();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// For views inside a scrolling container, delay the pressed feedback for</span></span><br><span class="line">                <span class="comment">// a short period in case this is a scroll.</span></span><br><span class="line">                <span class="keyword">if</span> (isInScrollingContainer) &#123;</span><br><span class="line">                    mPrivateFlags |= PFLAG_PREPRESSED;</span><br><span class="line">                    <span class="keyword">if</span> (mPendingCheckForTap == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mPendingCheckForTap = <span class="keyword">new</span> CheckForTap();</span><br><span class="line">                    &#125;</span><br><span class="line">                    mPendingCheckForTap.x = event.getX();</span><br><span class="line">                    mPendingCheckForTap.y = event.getY();</span><br><span class="line">                    <span class="comment">// 5 延迟一段时间再去Check</span></span><br><span class="line">                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                    <span class="comment">// 6 直接设置 PRESSED 状态，并 Check LongClick</span></span><br><span class="line">                    <span class="comment">// Not inside a scrolling container, so show the feedback right away</span></span><br><span class="line">                    setPressed(<span class="keyword">true</span>, x, y);</span><br><span class="line">                    checkForLongClick(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                drawableHotspotChanged(x, y);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 7 判断是否移出了 View 的边界</span></span><br><span class="line">                <span class="keyword">if</span> (!pointInView(x, y, mTouchSlop)) &#123;</span><br><span class="line">                    <span class="comment">// 移出去了就移除 Tap 任务</span></span><br><span class="line">                    removeTapCallback();</span><br><span class="line">                    <span class="comment">// 如果 Tap 任务已经执行</span></span><br><span class="line">                    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 移除 LongPress任务</span></span><br><span class="line">                        removeLongPressCallback();</span><br><span class="line">                        <span class="comment">// 取消 PRESSED 状态</span></span><br><span class="line">                        setPressed(<span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                <span class="keyword">boolean</span> prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 8 如果抬起的时候，View处于 PRESSED 状态或者处于 PRESSED 确认期</span></span><br><span class="line">                <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span> || prepressed) &#123;</span><br><span class="line">                    <span class="comment">// take focus if we don't have it already and we should in</span></span><br><span class="line">                    <span class="comment">// touch mode.</span></span><br><span class="line">                    <span class="comment">// 获取焦点</span></span><br><span class="line">                    <span class="keyword">boolean</span> focusTaken = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;</span><br><span class="line">                        focusTaken = requestFocus();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果处于 PRESSED 确认期，此时确认 PRESSED</span></span><br><span class="line">                    <span class="keyword">if</span> (prepressed) &#123;</span><br><span class="line">                        <span class="comment">// The button is being released before we actually</span></span><br><span class="line">                        <span class="comment">// showed it as pressed.  Make it show the pressed</span></span><br><span class="line">                        <span class="comment">// state now (before scheduling the click) to ensure</span></span><br><span class="line">                        <span class="comment">// the user sees it.</span></span><br><span class="line">                        setPressed(<span class="keyword">true</span>, x, y);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 9 如果此时没有进入长按 (另外一个变量不需要care)</span></span><br><span class="line">                    <span class="keyword">if</span> (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</span><br><span class="line">                        <span class="comment">// This is a tap, so remove the longpress check</span></span><br><span class="line">                        <span class="comment">// 不要再去 Check 长按事件了</span></span><br><span class="line">                        removeLongPressCallback();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Only perform take click actions if we were in the pressed state</span></span><br><span class="line">                        <span class="comment">// 10 判断是否处于焦点状态, 不处于则执行 PerformClick 任务</span></span><br><span class="line">                        <span class="keyword">if</span> (!focusTaken) &#123;</span><br><span class="line">                            <span class="comment">// Use a Runnable and post this rather than calling</span></span><br><span class="line">                            <span class="comment">// performClick directly. This lets other visual state</span></span><br><span class="line">                            <span class="comment">// of the view update before click actions start.</span></span><br><span class="line">                            <span class="keyword">if</span> (mPerformClick == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                mPerformClick = <span class="keyword">new</span> PerformClick();</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (!post(mPerformClick)) &#123;</span><br><span class="line">                                performClick();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 取消 PRESSED 状态</span></span><br><span class="line">                    <span class="keyword">if</span> (mUnsetPressedState == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mUnsetPressedState = <span class="keyword">new</span> UnsetPressedState();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (prepressed) &#123;</span><br><span class="line">                        postDelayed(mUnsetPressedState,</span><br><span class="line">                                ViewConfiguration.getPressedStateDuration());</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!post(mUnsetPressedState)) &#123;</span><br><span class="line">                        <span class="comment">// If the post failed, unpress right now</span></span><br><span class="line">                        mUnsetPressedState.run();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    removeTapCallback();</span><br><span class="line">                &#125;</span><br><span class="line">                mIgnoreNextUpEvent = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class="line">                setPressed(<span class="keyword">false</span>);</span><br><span class="line">                removeTapCallback();</span><br><span class="line">                removeLongPressCallback();</span><br><span class="line">                mInContextButtonPress = <span class="keyword">false</span>;</span><br><span class="line">                mHasPerformedLongPress = <span class="keyword">false</span>;</span><br><span class="line">                mIgnoreNextUpEvent = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;            </span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中几个 case 的处理调换了以下顺序，以便于分析。代码总共做了 10 处注释，基本可以理清楚这段代码的脉络。下面对其中几处做一下补充。</p>
<h4 id="getX-getY-与getX-int-getY-int"><a href="#getX-getY-与getX-int-getY-int" class="headerlink" title="getX()/getY()与getX(int)/getY(int)"></a>getX()/getY()与getX(int)/getY(int)</h4><p>在方法执行的一开始我就标注了一个<strong>【注意】</strong>，这是一个很细节的地方，这两组方法的区别读者可以自己去查 API 文档，注意到它们的不同就可以解释下面的现象：</p>
<p><strong>有一个 View 是Clickable的，如果 View 上有两根手指，假设 A 是先按下的，B 是后按下的，那么如果 B 移出 View 边界，A 抬起依然可以触发 Click 事件，但是如果 A 先移出边界，B 后抬起，则不能触发 Click 事件。</strong>(从实践结果来看，虽然 A 和 B 触发的都是 Move 事件，但是实际上 B 的 Move 事件的坐标并不是绝对坐标，而就是 A 的坐标，只有当 A 抬起之后，B 触发的才会恢复自己的绝对坐标。)</p>
<h4 id="VIEW-的-CLICKABLE"><a href="#VIEW-的-CLICKABLE" class="headerlink" title="VIEW 的 CLICKABLE"></a>VIEW 的 CLICKABLE</h4><p>1 和 3 处合起来可以得出一个结论：一个 View 只要是 <code>CLICKABLE || LONG_CLICKABLE || CONTEXT_CLICKABLE</code> 的，它就能消费事件，与是否 DISABLE 无关，只不过 DISABLE 的时候不会做出响应。</p>
<p>View 在没有任何设置的情况下，默认 CLICKABLE 是 false 的，但是可以通过 xml 中设置 <code>android:clickable=&quot;true&quot;</code>或者调用<code>setClickable(boolean)</code>来更改，或者当我们调用<code>setOnClickListener()</code>的时候，这个标志位也会被默认设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnClickListener</span><span class="params">(@Nullable OnClickListener l)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!isClickable()) &#123;</span><br><span class="line">		setClickable(<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	getListenerInfo().mOnClickListener = l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="手势延迟判断"><a href="#手势延迟判断" class="headerlink" title="手势延迟判断"></a>手势延迟判断</h4><p>4 处在处理事件的时候，首先要判断自身是不是处于一个可以滚动的容器中，这个方法其实是调用的 ViewGroup 的<code>shouldDelayChildPressedState()</code>来判断的，查看了几个常见的 ViewGroup，其中比如 LinearLayout、FrameLayout 等，这个方法返回的就是 false，而像 ScrollView、ListView 返回的就是 true，ViewGroup 中默认返回的就是true。</p>
<p>那么为什么需要做这个判断呢？因为在可滚动的容器中，DOWN 事件发生的时候是无法判断用户的用意到底是点击还是滚动的，因此这里只回去设置一个 <code>PFLAG_PREPRESSED</code> 状态，并且启动了一个 <code>CheckForTap</code> 任务，延迟 <code>ViewConfiguration.getTapTimeout()</code> 再执行；否则就直接设置 Pressed 状态，并且添加一个 <code>CheckForLongPress</code> 任务。 </p>
<h4 id="手势识别任务"><a href="#手势识别任务" class="headerlink" title="手势识别任务"></a>手势识别任务</h4><p>上一小节提到了两个任务：<code>CheckForTap</code> 和 <code>CheckForLongPress</code>。下面细看看这两个任务具体做什么。</p>
<h5 id="CheckForTap"><a href="#CheckForTap" class="headerlink" title="CheckForTap"></a>CheckForTap</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckForTap</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">float</span> x;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">float</span> y;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		mPrivateFlags &amp;= ~PFLAG_PREPRESSED;</span><br><span class="line">		setPressed(<span class="keyword">true</span>, x, y);</span><br><span class="line">		checkForLongClick(ViewConfiguration.getTapTimeout());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个任务一旦执行，就说明用户触摸的一个 View 的时间已经到了可以确认为 Tap 的时长了，所以首先要做的就是取消 <code>PFLAG_PREPRESSED</code>状态，并设置 PRESSED 状态，至此整个 View 确实进入到了 PRESSED 状态。然后它会调用<code>checkForLongClick()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkForLongClick</span><span class="params">(<span class="keyword">int</span> delayOffset)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ((mViewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) &#123;</span><br><span class="line">		mHasPerformedLongPress = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (mPendingCheckForLongPress == <span class="keyword">null</span>) &#123;</span><br><span class="line">			mPendingCheckForLongPress = <span class="keyword">new</span> CheckForLongPress();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		mPendingCheckForLongPress.rememberWindowAttachCount();</span><br><span class="line">		postDelayed(mPendingCheckForLongPress,</span><br><span class="line">				ViewConfiguration.getLongPressTimeout() - delayOffset);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的功能一目了然：如果 View 是<code>LONG_CLICKABLE</code>的，就发起一个<code>CheckForLongPress</code>任务。要注意延迟时间：如果是<code>CheckForTap</code>发起的，就需要减去之前等待确认 Tap 动作的时间，如果是 DOWN 事件直接触发的，那就需要等待<code>ViewConfiguration.getLongPressTimeout()</code>时长。</p>
<h5 id="CheckForLongPress"><a href="#CheckForLongPress" class="headerlink" title="CheckForLongPress"></a>CheckForLongPress</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckForLongPress</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> mOriginalWindowAttachCount;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (isPressed() &amp;&amp; (mParent != <span class="keyword">null</span>)</span><br><span class="line">				&amp;&amp; mOriginalWindowAttachCount == mWindowAttachCount) &#123;</span><br><span class="line">			<span class="keyword">if</span> (performLongClick()) &#123;</span><br><span class="line">				mHasPerformedLongPress = <span class="keyword">true</span>; <span class="comment">// 置位</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rememberWindowAttachCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		mOriginalWindowAttachCount = mWindowAttachCount;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法判断如果当前 View 处于 Pressed 状态，那么就执行<code>performLongClick()</code>方法，这个方法会回调设置的<code>OnLongClickListener</code>监听，具体可以查看<code>performLongClick()</code>方法，这个方法如果返回 true，则会设置标志位。一般来说，如果我们设置了<code>OnLongClickListener</code>，这里就该返回 true。</p>
<h4 id="边界问题"><a href="#边界问题" class="headerlink" title="边界问题"></a>边界问题</h4><p>7 处主要处理的是边界问题，如果 View 移出了边界，那么首先要移除<code>CheckForTap</code>任务。根据前面的分析，只有当 View 处于可滚动容器的时候，才会添加这个任务。移出之后查看 View 是否还处于 PFLAG_PRESSED 状态，如果存在，说明 View 是以下两种情况之一：</p>
<ol>
<li>View 的 Down 事件走的是④-⑤路线，并且<code>CheckForTap</code>任务已经执行了，这个时候任务队列中很可能有<code>CheckForLongPress</code>任务；</li>
<li>View 的 Down 事件走的是④-⑥路线，队列中肯定有一个<code>CheckForLongPress</code>任务；</li>
</ol>
<p>因此接着要做的事情就是移除<code>CheckForLongPress</code>任务，并且取消 Pressed 状态。</p>
<h4 id="焦点"><a href="#焦点" class="headerlink" title="焦点"></a>焦点</h4><p>8 处的处理和焦点相关，如果我们没有移出边界，那么很显然此时肯定处于 PRESSED 或者 PFLAG_PREPRESSED 状态。View 此时要尝试去拿一下焦点。默认来说，Touch Mode 下是无法拿到焦点的，因此 <code>focusTaken</code> 肯定为 false。但是如果我们把 View 的 <code>FOCUSABLE_MASK</code> 和 <code>FOCUSABLE_IN_TOUCH_MODE</code> 标志位都设置了（通过代码和XML都可以），那么 View 就可以在 Touch Mode 下获取焦点，也就是说 <code>focusTaken</code> 在第一次 Up 事件的时候，会被置为 true ，而第二次因为 <code>isFocused()</code> 返回 true（第一次Up的时候因为执行<code>requestFocus()</code>会获取焦点，所以第二次就会返回true）而被置为 false。这个务必注意。</p>
<p>9 除首先判断是否执行了 <code>CheckForLongPress</code>，如果没有执行，那么移除任务，判断 View 是否在 Up 处理中获取到了焦点，如果没有，就会执行<code>PerformClick</code>任务，这个任务从名字看就很眼熟，它执行的就是下面这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">boolean</span> result;</span><br><span class="line">	<span class="keyword">final</span> ListenerInfo li = mListenerInfo;</span><br><span class="line">	<span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnClickListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">		playSoundEffect(SoundEffectConstants.CLICK);</span><br><span class="line">		li.mOnClickListener.onClick(<span class="keyword">this</span>);</span><br><span class="line">		result = <span class="keyword">true</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		result = <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是我们经常为 View 设置的点击监听。</p>
<blockquote>
<p><strong>Google 官方不建议设置 <code>FOCUSABLE_MASK</code> 和 <code>FOCUSABLE_IN_TOUCH_MODE</code> 的理由也在这里，10 处很明显的展示了打开这两个标志位的后果：第一次 Click 的时候，<code>View.OnClickListener</code>方法不会被执行</strong>。相关的资料可以看这篇文章：<a href="http://android-developers.blogspot.jp/2008/12/touch-mode.html" target="_blank" rel="noopener">Touch Mode</a>。</p>
</blockquote>
<h2 id="ViewGroup的事件处理"><a href="#ViewGroup的事件处理" class="headerlink" title="ViewGroup的事件处理"></a>ViewGroup的事件处理</h2><p>分析完单个 View 的事件处理流程，接下来就是要分析 ViewGroup 的事件处理流程，首先要明白的事情是 ViewGroup 也是一种 View，因此它和 View 一样，也具备消费事件的能力，所不同的是：ViewGroup 可能拥有很多个子 View，它要决定事件分发的策略以便于事件能够分发到合适的子 View 去处理。因此虽然 ViewGroup 和 View 一样都是从 <code>onTouchEvent</code>方法开始事件处理，但是行为上是完全不一样的。</p>
<h3 id="ViewGroup-的dispatchTouchEvent"><a href="#ViewGroup-的dispatchTouchEvent" class="headerlink" title="ViewGroup 的dispatchTouchEvent"></a>ViewGroup 的<code>dispatchTouchEvent</code></h3><p>相比较于 View 的<code>dispatchTouchEvent</code>方法，ViewGroup 的<code>dispatchTouchEvent</code>方法要复杂的多：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(ev)) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> action = ev.getAction();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 初始化 ViewGroup 的事件处理状态</span></span><br><span class="line">        <span class="comment">// Handle an initial down.</span></span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            <span class="comment">// Throw away all previous state when starting a new touch gesture.</span></span><br><span class="line">            <span class="comment">// The framework may have dropped the up or cancel event for the previous gesture</span></span><br><span class="line">            <span class="comment">// due to an app switch, ANR, or some other state change.</span></span><br><span class="line">            cancelAndClearTouchTargets(ev);</span><br><span class="line">            resetTouchState();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2 判断是否要拦截事件</span></span><br><span class="line">        <span class="comment">// Check for interception.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">                intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">                ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                intercepted = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// There are no touch targets and this action is not an initial down</span></span><br><span class="line">            <span class="comment">// so this view group continues to intercept touches.</span></span><br><span class="line">            intercepted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// @@ 查看事件是否需要取消</span></span><br><span class="line">        <span class="comment">// Check for cancelation.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> canceled = resetCancelNextUpFlag(<span class="keyword">this</span>)</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_CANCEL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update list of touch targets for pointer down, if needed.</span></span><br><span class="line">        <span class="comment">// 3.0 以上，这里默认置位</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != <span class="number">0</span>;</span><br><span class="line">        TouchTarget newTouchTarget = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> alreadyDispatchedToNewTouchTarget = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Down 事件的处理流程</span></span><br><span class="line">        <span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 如果是 Down 事件或者在允许多指触摸的时候</span></span><br><span class="line">            <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                    || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class="line">                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">                <span class="comment">// 多指触摸</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex(); <span class="comment">// always 0 for down</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> idBitsToAssign = split ? <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex)</span><br><span class="line">                        : TouchTarget.ALL_POINTER_IDS;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Clean up earlier touch targets for this pointer id in case they</span></span><br><span class="line">                <span class="comment">// have become out of sync.</span></span><br><span class="line">                removePointersFromTouchTargets(idBitsToAssign);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">                <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(actionIndex);</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(actionIndex);</span><br><span class="line">                    <span class="comment">// Find a child that can receive the event.</span></span><br><span class="line">                    <span class="comment">// Scan children from front to back.</span></span><br><span class="line">                    <span class="comment">// 4 默认情况下这个列表就是 View 添加的顺序</span></span><br><span class="line">                    <span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildOrderedChildList();</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> customOrder = preorderedList == <span class="keyword">null</span></span><br><span class="line">                            &amp;&amp; isChildrenDrawingOrderEnabled();</span><br><span class="line">                    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">                    <span class="comment">// 5 倒叙遍历所有的子 View，这样最后添加的，在最上面绘制的 View 会首先被分派事件</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> childIndex = customOrder</span><br><span class="line">                                ? getChildDrawingOrder(childrenCount, i) : i;</span><br><span class="line">                        <span class="keyword">final</span> View child = (preorderedList == <span class="keyword">null</span>)</span><br><span class="line">                                ? children[childIndex] : preorderedList.get(childIndex);</span><br><span class="line"></span><br><span class="line">                        ...</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 6 判断 View 能否接受 Touch 事件，并且触摸点是否在本 View 内部</span></span><br><span class="line">                        <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">                                || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                            ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 7 查看目标 View 是否存在在 TargetView 链表中，如果在，则说明已经处理过 Down</span></span><br><span class="line">                        <span class="comment">// 事件，不需要再去处理一次（想象一下两根手指同时触摸一个 View），只需要记录一下第二</span></span><br><span class="line">                        <span class="comment">// 次触摸的 PoniterId</span></span><br><span class="line">                        newTouchTarget = getTouchTarget(child);</span><br><span class="line">                        <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// Child is already receiving touch within its bounds.</span></span><br><span class="line">                            <span class="comment">// Give it the new pointer in addition to the ones it is handling.</span></span><br><span class="line">                            newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        resetCancelNextUpFlag(child);</span><br><span class="line">                        <span class="comment">// 8 分发事件给子 View 或者自己，这个方法会重点分析，它是 ViewGroup 事件处理的核心</span></span><br><span class="line">                        <span class="comment">// 如果返回true，表示事件被成功消费</span></span><br><span class="line">                        <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                            <span class="comment">// Child wants to receive touch within its bounds.</span></span><br><span class="line">                            mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">                            <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">// childIndex points into presorted list, find original index</span></span><br><span class="line">                                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                                        mLastTouchDownIndex = j;</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                mLastTouchDownIndex = childIndex;</span><br><span class="line">                            &#125;</span><br><span class="line">                            mLastTouchDownX = ev.getX();</span><br><span class="line">                            mLastTouchDownY = ev.getY();</span><br><span class="line">                            <span class="comment">// 把 TargetView 添加到链表中去，并且指明它是处理哪些 PointerId 的</span></span><br><span class="line">                            newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                            <span class="comment">// 置位</span></span><br><span class="line">                            alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">                            <span class="comment">// 这个时候一个 Down 事件已经找到目标 View 去消费，后续就不用再继续找了</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// The accessibility focus didn't handle the event, so clear</span></span><br><span class="line">                        <span class="comment">// the flag and do a normal dispatch to all children.</span></span><br><span class="line">                        ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) preorderedList.clear();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 9 如果没找到处理对象，就把这个 PointerId 赋值给最早添加的 TargetView，【Why】</span></span><br><span class="line">                <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Did not find a child to receive the event.</span></span><br><span class="line">                    <span class="comment">// Assign the pointer to the least recently added target.</span></span><br><span class="line">                    newTouchTarget = mFirstTouchTarget;</span><br><span class="line">                    <span class="keyword">while</span> (newTouchTarget.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        newTouchTarget = newTouchTarget.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 10 所有类型事件的处理流程！</span></span><br><span class="line">        <span class="comment">// 这里如果没有找到任何一个目标 View，即这个 ViewGroup 里面的所有</span></span><br><span class="line">        <span class="comment">// View都不消费事件，则调用 dispatchTransformedTouchEvent 处理，这个后面重点说</span></span><br><span class="line">        <span class="comment">// Dispatch to touch targets.</span></span><br><span class="line">        <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No touch targets so treat this as an ordinary view.</span></span><br><span class="line">            handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">                        TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Dispatch to touch targets, excluding the new touch target if we already</span></span><br><span class="line">            <span class="comment">// dispatched to it.  Cancel touch targets if necessary.</span></span><br><span class="line">            TouchTarget predecessor = <span class="keyword">null</span>;</span><br><span class="line">            TouchTarget target = mFirstTouchTarget;</span><br><span class="line">            <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> TouchTarget next = target.next;</span><br><span class="line">                <span class="comment">// 针对 Down 事件，前面已经找到 View 处理过了</span></span><br><span class="line">                <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">                    handled = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 11 判断事件是否要取消，以便于分发正确类型的事件</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class="line">                            || intercepted;</span><br><span class="line">                    <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                            target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                        handled = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果是 CANCEL 事件，就把 TargetView 从链表中删除掉</span></span><br><span class="line">                    <span class="keyword">if</span> (cancelChild) &#123;</span><br><span class="line">                        <span class="comment">// 说明是 TargetView 链表中的第一个</span></span><br><span class="line">                        <span class="keyword">if</span> (predecessor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            mFirstTouchTarget = next;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            predecessor.next = next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        target.recycle();</span><br><span class="line">                        target = next;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 至少循环一次才会赋值</span></span><br><span class="line">                predecessor = target;</span><br><span class="line">                target = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 12 针对 Up 事件做的处理 —— 重置状态</span></span><br><span class="line">        <span class="comment">// Update list of touch targets for pointer up or cancel, if needed.</span></span><br><span class="line">        <span class="keyword">if</span> (canceled</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_UP</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">            resetTouchState();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> idBitsToRemove = <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex);</span><br><span class="line">            removePointersFromTouchTargets(idBitsToRemove);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这么长的代码，只能在代码中进行注释，大概的流程是比较清楚的：</p>
<p>下面还是分小点一一补充。</p>
<h4 id="cancelAndClearTouchTargets事件清理"><a href="#cancelAndClearTouchTargets事件清理" class="headerlink" title="cancelAndClearTouchTargets事件清理"></a><code>cancelAndClearTouchTargets</code>事件清理</h4><p>在 1 处，一旦发现事件类型是 Down 类型，首先要做的就是事件清理，因为 Down 事件是一个事件流的开始，ViewGroup 一旦接收到该事件，则意味着应该初始化状态来准备处理一个新的事件流。我们来看看具体是怎么清理的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cancels and clears all touch targets.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAndClearTouchTargets</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> syntheticEvent = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (event == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            event = MotionEvent.obtain(now, now,</span><br><span class="line">                    MotionEvent.ACTION_CANCEL, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0</span>);</span><br><span class="line">            event.setSource(InputDevice.SOURCE_TOUCHSCREEN);</span><br><span class="line">            syntheticEvent = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (TouchTarget target = mFirstTouchTarget; target != <span class="keyword">null</span>; target = target.next) &#123;</span><br><span class="line">            resetCancelNextUpFlag(target.child);</span><br><span class="line">            dispatchTransformedTouchEvent(event, <span class="keyword">true</span>, target.child, target.pointerIdBits);</span><br><span class="line">        &#125;</span><br><span class="line">        clearTouchTargets();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (syntheticEvent) &#123;</span><br><span class="line">            event.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果传入的 event 为 Null，那么会 Mock 一个 CANCEL 事件出来，否则会使用原 Event，尽量保留原始信息。然后遍历所有的 TargetView，重置状态并分发事件，这分为两步。下面会详细分析。状态重置之后，会调用<code>clearTouchTargets()</code>方法把所有的 TargetView清除掉。这样就完成了初始化的过程，总结一下核心就是两步：</p>
<ol>
<li>之前正在消费事件的View，全部发送一次 CANCEL 事件；</li>
<li>记录消费事件的View链，清空；</li>
</ol>
<h5 id="resetCancelNextUpFlag"><a href="#resetCancelNextUpFlag" class="headerlink" title="resetCancelNextUpFlag"></a><code>resetCancelNextUpFlag</code></h5><p>这个方法在很多地方都被调用，这里统一解释一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Resets the cancel next up flag.</span></span><br><span class="line"><span class="comment"> * Returns true if the flag was previously set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">resetCancelNextUpFlag</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((view.mPrivateFlags &amp; PFLAG_CANCEL_NEXT_UP_EVENT) != <span class="number">0</span>) &#123;</span><br><span class="line">        view.mPrivateFlags &amp;= ~PFLAG_CANCEL_NEXT_UP_EVENT;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是重置一个标志位：<code>PFLAG_CANCEL_NEXT_UP_EVENT</code>。这个标志位是什么意思呢？注释是这样说的：Indicates whether the view is temporarily detached。打开可以猜测一下：如果一个 View 正在从 Window 上 detach（一个中间态），那么这个标志位就会被置位。如果调用该方法的时候，这位被置，则返回true。而这里的清理，只是重置而已，对于是否置位并不关心。</p>
<h5 id="dispatchTransformedTouchEvent"><a href="#dispatchTransformedTouchEvent" class="headerlink" title="dispatchTransformedTouchEvent"></a><code>dispatchTransformedTouchEvent</code></h5><p>这个方法在 8 处和 10 处都出现过，其它的步骤主要是负责定位事件应该传递给什么 View，而这个函数的作用就是做实际分发的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Transforms a motion event into the coordinate space of a particular child view,</span></span><br><span class="line"><span class="comment"> * filters out irrelevant pointer ids, and overrides its action if necessary.</span></span><br><span class="line"><span class="comment"> * If child is null, assumes the MotionEvent will be sent to this ViewGroup instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span></span></span><br><span class="line"><span class="function"><span class="params">        View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注释说的极为清楚，CANCEL 事件是一个特殊事件，重点在于事件类型而非内容</span></span><br><span class="line">    <span class="comment">// Canceling motions is a special case.  We don't need to perform any transformations</span></span><br><span class="line">    <span class="comment">// or filtering.  The important part is the action, not the contents.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldAction = event.getAction();</span><br><span class="line">    <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">        event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// child 如果是Null，就分发事件到父类，也就是调用前面分析的 View 的 dispatchTouchEvent 方法</span></span><br><span class="line">            handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则下发到 child 去处理 CANCEL 事件</span></span><br><span class="line">            handled = child.dispatchTouchEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">        event.setAction(oldAction);</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculate the number of pointers to deliver.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldPointerIdBits = event.getPointerIdBits();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验事件是否合法，如果为 0，说明事件不应该由这个 View 处理</span></span><br><span class="line">    <span class="comment">// If for some reason we ended up in an inconsistent state where it looks like we</span></span><br><span class="line">    <span class="comment">// might produce a motion event with no pointers in it, then drop the event.</span></span><br><span class="line">    <span class="keyword">if</span> (newPointerIdBits == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只要 child 为 null，就会调用父类，也就是 View 的 dispatchTouchEvent 方法</span></span><br><span class="line">    <span class="comment">// If the number of pointers is the same and we don't need to perform any fancy</span></span><br><span class="line">    <span class="comment">// irreversible transformations, then we can reuse the motion event for this</span></span><br><span class="line">    <span class="comment">// dispatch as long as we are careful to revert any changes we make.</span></span><br><span class="line">    <span class="comment">// Otherwise we need to make a copy.</span></span><br><span class="line">    <span class="keyword">final</span> MotionEvent transformedEvent;</span><br><span class="line">    <span class="keyword">if</span> (newPointerIdBits == oldPointerIdBits) &#123;</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span> || child.hasIdentityMatrix()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">                handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> offsetX = mScrollX - child.mLeft;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> offsetY = mScrollY - child.mTop;</span><br><span class="line">                <span class="comment">// 为事件做偏移</span></span><br><span class="line">                event.offsetLocation(offsetX, offsetY);</span><br><span class="line">                <span class="comment">// 分发事件</span></span><br><span class="line">                handled = child.dispatchTouchEvent(event);</span><br><span class="line">                <span class="comment">// 恢复事件</span></span><br><span class="line">                event.offsetLocation(-offsetX, -offsetY);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> handled;</span><br><span class="line">        &#125;</span><br><span class="line">        transformedEvent = MotionEvent.obtain(event);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 分化出一个新的事件</span></span><br><span class="line">        transformedEvent = event.split(newPointerIdBits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perform any necessary transformations and dispatch.</span></span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">        handled = <span class="keyword">super</span>.dispatchTouchEvent(transformedEvent);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> offsetX = mScrollX - child.mLeft;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> offsetY = mScrollY - child.mTop;</span><br><span class="line">        transformedEvent.offsetLocation(offsetX, offsetY);</span><br><span class="line">        <span class="keyword">if</span> (! child.hasIdentityMatrix()) &#123;</span><br><span class="line">            transformedEvent.transform(child.getInverseMatrix());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        handled = child.dispatchTouchEvent(transformedEvent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Done.</span></span><br><span class="line">    transformedEvent.recycle();</span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它其实只做以下几件事情：</p>
<ol>
<li>事件是否是 CANCEL 的，如果是，直接分发即可；</li>
<li>确定分发的事件合法，主要是看 newPointerIdBits 是否为 0，读者要去理解这个方法，需要看一下<code>MotionEvent.getPointerIdBits()</code>方法；</li>
<li>重新计算事件的坐标，并分发，分发的时候判断 child 是否为 null，如果为 null，则分发给 ViewGroup 的父类也就是 View 处理，否则分发给子 View 处理；</li>
</ol>
<h4 id="事件拦截"><a href="#事件拦截" class="headerlink" title="事件拦截"></a>事件拦截</h4><p>2 处的判断看上去可能比较难懂，换一个等价的判断就明白了：<code>actionMasked != MotionEvent.ACTION_DOWN &amp;&amp; mFirstTouchTarget == null</code>。<code>mFirstTouchTarget</code>为 null，也就是说没有找到 View 处理事件，Action 不为 Down，也就是说不是事件流的起始，那这个事件完全就是非法的，不应该传递到这里来，因此肯定不会下发，所以<code>intercepted</code>就置为 true。</p>
<p>if 语句里面的判断和方法调用，就不做解释了。读者去了解一下<code>requestDisallowInterceptTouchEvent()</code>方法和<code>onInterceptTouchEvent()</code>就好，说白了就是 ViewGroup 提供的事件拦截以及禁止事件拦截的两个方法。要注意的是这里方法返回不同的结果对事件流处理造成的影响。</p>
<p>这里接个尾巴，在判断完事件拦截后，@@ 处又调用了一次<code>resetCancelNextUpFlag()</code>方法，这一次它的返回结果就被记录下来了，用于判断事件是否要取消，也就是说我们可以通过这个方法来判断一个 View 是否能合法的接收事件。</p>
<h4 id="多指触摸"><a href="#多指触摸" class="headerlink" title="多指触摸"></a>多指触摸</h4><p>3 处在判断的时候是考虑到了多指触摸的情况的，一个 ViewGroup 里面可能有多个 View，这一个或者多个 View 可以同时被多根手指 Touch，那么在这样的情况下，就需要记录哪个 View 被哪个 Pointer（形象一点可以想象成手指）触摸，这个是通过 TouchTarget 的 pointerIdBits 来记录的，TouchTarget 可以代表着一个触摸对象，它封装了一个 View 以及与触摸相关的信息在内部。</p>
<h4 id="View-是否能接受事件"><a href="#View-是否能接受事件" class="headerlink" title="View 是否能接受事件"></a>View 是否能接受事件</h4><p>6 处判断一个View是否能接受事件，调用了这样一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns true if a child view can receive pointer events.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canViewReceivePointerEvents</span><span class="params">(View child)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE</span><br><span class="line">                || child.getAnimation() != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个判断有依据的是 View 是否可见，或者 View 是否正在执行动画。</p>
<h4 id="关于ACTION-XXXX和ACTION-POINTER-XXXX"><a href="#关于ACTION-XXXX和ACTION-POINTER-XXXX" class="headerlink" title="关于ACTION_XXXX和ACTION_POINTER_XXXX"></a>关于<code>ACTION_XXXX</code>和<code>ACTION_POINTER_XXXX</code></h4><p>XXXX 代表着 DOWN 或者 UP（不存在<code>ACTION_POINTER_MOVE</code>），这里可以从实验得出如下结论：</p>
<ol>
<li>第一个按下去的事件类型是<code>ACTION_DOWN</code>，其余不论按下多少个手指，事件类型都是<code>ACTION_POINTER_DOWN</code>;</li>
<li>不论按下去和抬起来的顺序，最后一个抬起的手指，它触发的事件类型就是<code>ACTION_UP</code>，这个与<code>ACTION_DOWN</code>并不一定发生在同一根手指上；</li>
<li><p>PointerId 可以唯一标记一个手指触摸事件，第一个触摸的手指 ID 为1, 第二个触摸的手指 ID 为2，第三个触摸的手指 ID 为 3，以此类推…因此可以通过下面的方法很方便的将事件发生时手指的触摸情况反映成一个 Bit 组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPointerIdBits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> idBits = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> pointerCount = nativeGetPointerCount(mNativePtr);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pointerCount; i++) &#123;</span><br><span class="line">		idBits |= <span class="number">1</span> &lt;&lt; nativeGetPointerId(mNativePtr, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> idBits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以如果我有四根手指触摸着屏幕，那么通过调用这个方法就可以得到的<code>1111</code>（二进制，后面同含义的数字也是二进制表示），如果我第一个按下的手指抬起，那么计算出来的值就是<code>1110</code>，第四根按下的手指抬起，计算出来的值就是<code>0110</code>，以此类推…因此在 MOVE 中可以通过这种手段确认是哪几根手指处于按下状态。通过以下方法可以获知每一根手指的坐标位置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pointerCount = event.getPointerCount();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pointerCount; i++) &#123;</span><br><span class="line">	<span class="keyword">int</span> id = event.getPointerId(i);</span><br><span class="line">	<span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX(i);</span><br><span class="line">	<span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>相关的还有一个方法是<code>getActionIndex()</code>，这个方法只有在事件类型为<code>ACTION_POINTER_DOWN</code>或者<code>ACTION_POINTER_UP</code>的时候才有意义，其余情况下返回的都是0。详细可见附表数据。</p>
</blockquote>
<p>配合以上几个结论，看 12 处的时候会更加清晰：在<code>ACTION_UP</code>的时候，表示所有手指已经离开 View，所以可以重置状态。而 View 中只会处理<code>ACTION_UP</code>和<code>ACTION_DOWN</code>事件，因此对于 View 来说（这里是狭义的 View，不包括 ViewGroup），只有单指事件。</p>
<h4 id="ACTION-CANCEL事件发生时机"><a href="#ACTION-CANCEL事件发生时机" class="headerlink" title="ACTION_CANCEL事件发生时机"></a><code>ACTION_CANCEL</code>事件发生时机</h4><p>11 处<strong>指明了<code>ACTION_CANCEL</code>事件发生的时机：父 ViewGroup 拦截了子 View 的事件流</strong>。 具体可见<a href="https://developer.android.com/reference/android/view/ViewGroup.html#onInterceptTouchEvent(android.view.MotionEvent" target="_blank" rel="noopener"><code>VierGroup.onInterceptTouchEvent()</code></a>)方法的 API 文档。</p>
<p><strong>其余的点都不是很难理解，第 ⑨ 处留有一个疑问：这里为什么要把 PointerId 记录到第一个添加的 TargetView 中去？。</strong></p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>至此，View 和 ViewGroup 的事件分发处理机制已经解析完毕。</p>
<p>事件被分发到 ViewGroup 之后，会由 ViewGroup 查看哪些子 View 能够接受该事件，判断的初始标准很简单：参考方法<code>canViewReceivePointerEvents()</code>和<code>isTransformedTouchPointInView()</code>，如果找到一个这样的的子 View，尝试调用<code>dispatchTransformedTouchEvent()</code>方法将事件分发给子 View ，如果子 View 处理事件成功（处理过程参考前面的图），则该 View 被加入到 ViewGroup 的 TargetView 链中去，后续的事件会继续分发给它，否则它将不能再接受事件。</p>
<p>如果 ViewGroup 找不到这样一个子 View 进行事件处理，就会尝试调用父类的<code>dispatchTouchEvent()</code>方法处理事件，此时 ViewGroup 把自己当做一个 View 来看待。</p>
<p>以上就是 ViewGroup 进行事件分发 和 View 处理事件的主流程。</p>
<h2 id="附表"><a href="#附表" class="headerlink" title="附表"></a>附表</h2><p>下面是一张三根手指操作 View 的时候，它收到的事件的相关信息打印，打印代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> actionIndex = ev.getActionIndex();</span><br><span class="line">	<span class="keyword">int</span> pointerCount = ev.getPointerCount();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; pointerCount; index++) &#123;</span><br><span class="line">		Log.e(TAG, <span class="string">"PointId: "</span> + ev.getPointerId(index) + <span class="string">" # ActionIndex: "</span> + actionIndex + <span class="string">" # ActionType: "</span> + ev.getActionMasked());</span><br><span class="line">		Log.e(TAG, <span class="string">"X"</span> + index + <span class="string">": "</span> + ev.getX(index) + <span class="string">" # Y"</span> + index + <span class="string">": "</span> + ev.getY(index) + <span class="string">" # PointId: "</span> + ev.getPointerId(actionIndex));</span><br><span class="line">	&#125;</span><br><span class="line">	Log.e(TAG, <span class="string">"======================"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">09-19 10:14:06.045  PointId: 0 # ActionIndex: 0 # ActionType: 0</span><br><span class="line">09-19 10:14:06.045  X0: 224.0 # Y0: 1232.0 # PointId: 0</span><br><span class="line"><span class="number">09</span>-<span class="number">19</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">06.045</span>  ======================</span><br><span class="line">09-19 10:14:06.584  PointId: 0 # ActionIndex: 0 # ActionType: 2</span><br><span class="line">09-19 10:14:06.584  X0: 224.0 # Y0: 1232.0 # PointId: 0</span><br><span class="line"><span class="number">09</span>-<span class="number">19</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">06.584</span>  ======================</span><br><span class="line">09-19 10:14:06.584  PointId: 0 # ActionIndex: 1 # ActionType: 5</span><br><span class="line">09-19 10:14:06.584  X0: 224.0 # Y0: 1232.0 # PointId: 1</span><br><span class="line">09-19 10:14:06.584  PointId: 1 # ActionIndex: 1 # ActionType: 5</span><br><span class="line">09-19 10:14:06.584  X1: 483.0 # Y1: 973.0 # PointId: 1</span><br><span class="line"><span class="number">09</span>-<span class="number">19</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">06.584</span>  ======================</span><br><span class="line">09-19 10:14:06.953  PointId: 0 # ActionIndex: 0 # ActionType: 2</span><br><span class="line">09-19 10:14:06.953  X0: 224.0 # Y0: 1232.0 # PointId: 0</span><br><span class="line">09-19 10:14:06.953  PointId: 1 # ActionIndex: 0 # ActionType: 2</span><br><span class="line">09-19 10:14:06.953  X1: 483.0 # Y1: 973.0 # PointId: 0</span><br><span class="line"><span class="number">09</span>-<span class="number">19</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">06.953</span>  ======================</span><br><span class="line">09-19 10:14:06.954  PointId: 0 # ActionIndex: 2 # ActionType: 5</span><br><span class="line">09-19 10:14:06.954  X0: 224.0 # Y0: 1232.0 # PointId: 2</span><br><span class="line">09-19 10:14:06.954  PointId: 1 # ActionIndex: 2 # ActionType: 5</span><br><span class="line">09-19 10:14:06.954  X1: 483.0 # Y1: 973.0 # PointId: 2</span><br><span class="line">09-19 10:14:06.954  PointId: 2 # ActionIndex: 2 # ActionType: 5</span><br><span class="line">09-19 10:14:06.954  X2: 811.0 # Y2: 1076.0 # PointId: 2</span><br><span class="line"><span class="number">09</span>-<span class="number">19</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">06.954</span>  ======================</span><br><span class="line">09-19 10:14:07.264  PointId: 0 # ActionIndex: 0 # ActionType: 2</span><br><span class="line">09-19 10:14:07.264  X0: 224.0 # Y0: 1232.0 # PointId: 0</span><br><span class="line">09-19 10:14:07.264  PointId: 1 # ActionIndex: 0 # ActionType: 2</span><br><span class="line">09-19 10:14:07.264  X1: 483.0 # Y1: 973.0 # PointId: 0</span><br><span class="line">09-19 10:14:07.264  PointId: 2 # ActionIndex: 0 # ActionType: 2</span><br><span class="line">09-19 10:14:07.264  X2: 809.0 # Y2: 1076.0 # PointId: 0</span><br><span class="line"><span class="number">09</span>-<span class="number">19</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">07.264</span>  ======================</span><br><span class="line">09-19 10:14:07.280  PointId: 0 # ActionIndex: 0 # ActionType: 2</span><br><span class="line">09-19 10:14:07.280  X0: 224.0 # Y0: 1232.0 # PointId: 0</span><br><span class="line">09-19 10:14:07.280  PointId: 1 # ActionIndex: 0 # ActionType: 2</span><br><span class="line">09-19 10:14:07.280  X1: 483.0 # Y1: 973.0 # PointId: 0</span><br><span class="line">09-19 10:14:07.280  PointId: 2 # ActionIndex: 0 # ActionType: 2</span><br><span class="line">09-19 10:14:07.280  X2: 807.0 # Y2: 1076.0 # PointId: 0</span><br><span class="line"><span class="number">09</span>-<span class="number">19</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">07.280</span>  ======================</span><br><span class="line">09-19 10:14:07.297  PointId: 0 # ActionIndex: 0 # ActionType: 2</span><br><span class="line">09-19 10:14:07.297  X0: 224.0 # Y0: 1232.0 # PointId: 0</span><br><span class="line">09-19 10:14:07.297  PointId: 1 # ActionIndex: 0 # ActionType: 2</span><br><span class="line">09-19 10:14:07.297  X1: 483.0 # Y1: 973.0 # PointId: 0</span><br><span class="line">09-19 10:14:07.297  PointId: 2 # ActionIndex: 0 # ActionType: 2</span><br><span class="line">09-19 10:14:07.297  X2: 805.0 # Y2: 1076.0 # PointId: 0</span><br><span class="line"><span class="number">09</span>-<span class="number">19</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">07.297</span>  ======================</span><br><span class="line">09-19 10:14:07.314  PointId: 0 # ActionIndex: 0 # ActionType: 2</span><br><span class="line">09-19 10:14:07.314  X0: 224.0 # Y0: 1232.0 # PointId: 0</span><br><span class="line">09-19 10:14:07.314  PointId: 1 # ActionIndex: 0 # ActionType: 2</span><br><span class="line">09-19 10:14:07.314  X1: 483.0 # Y1: 973.0 # PointId: 0</span><br><span class="line">09-19 10:14:07.314  PointId: 2 # ActionIndex: 0 # ActionType: 2</span><br><span class="line">09-19 10:14:07.314  X2: 803.0 # Y2: 1076.0 # PointId: 0</span><br><span class="line"><span class="number">09</span>-<span class="number">19</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">07.314</span>  ======================</span><br><span class="line">09-19 10:14:07.331  PointId: 0 # ActionIndex: 0 # ActionType: 2</span><br><span class="line">09-19 10:14:07.331  X0: 224.0 # Y0: 1232.0 # PointId: 0</span><br><span class="line">09-19 10:14:07.331  PointId: 1 # ActionIndex: 0 # ActionType: 2</span><br><span class="line">09-19 10:14:07.331  X1: 483.0 # Y1: 973.0 # PointId: 0</span><br><span class="line">09-19 10:14:07.331  PointId: 2 # ActionIndex: 0 # ActionType: 2</span><br><span class="line">09-19 10:14:07.331  X2: 802.0 # Y2: 1076.0 # PointId: 0</span><br><span class="line"><span class="number">09</span>-<span class="number">19</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">07.331</span>  ======================</span><br><span class="line">09-19 10:14:07.405  PointId: 0 # ActionIndex: 1 # ActionType: 6</span><br><span class="line">09-19 10:14:07.405  X0: 224.0 # Y0: 1232.0 # PointId: 1</span><br><span class="line">09-19 10:14:07.405  PointId: 1 # ActionIndex: 1 # ActionType: 6</span><br><span class="line">09-19 10:14:07.406  X1: 483.0 # Y1: 973.0 # PointId: 1</span><br><span class="line">09-19 10:14:07.406  PointId: 2 # ActionIndex: 1 # ActionType: 6</span><br><span class="line">09-19 10:14:07.406  X2: 802.0 # Y2: 1076.0 # PointId: 1</span><br><span class="line"><span class="number">09</span>-<span class="number">19</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">07.406</span>  ======================</span><br><span class="line">09-19 10:14:07.415  PointId: 0 # ActionIndex: 0 # ActionType: 2</span><br><span class="line">09-19 10:14:07.415  X0: 224.0 # Y0: 1232.0 # PointId: 0</span><br><span class="line">09-19 10:14:07.415  PointId: 2 # ActionIndex: 0 # ActionType: 2</span><br><span class="line">09-19 10:14:07.415  X1: 803.0 # Y1: 1076.0 # PointId: 0</span><br><span class="line"><span class="number">09</span>-<span class="number">19</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">07.415</span>  ======================</span><br><span class="line">09-19 10:14:07.421  PointId: 0 # ActionIndex: 0 # ActionType: 6</span><br><span class="line">09-19 10:14:07.421  X0: 224.0 # Y0: 1232.0 # PointId: 0</span><br><span class="line">09-19 10:14:07.421  PointId: 2 # ActionIndex: 0 # ActionType: 6</span><br><span class="line">09-19 10:14:07.421  X1: 803.0 # Y1: 1076.0 # PointId: 0</span><br><span class="line"><span class="number">09</span>-<span class="number">19</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">07.421</span>  ======================</span><br><span class="line">09-19 10:14:07.421  PointId: 2 # ActionIndex: 0 # ActionType: 1</span><br><span class="line">09-19 10:14:07.421  X0: 803.0 # Y0: 1076.0 # PointId: 2</span><br><span class="line"><span class="number">09</span>-<span class="number">19</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">07.421</span>  ======================</span><br></pre></td></tr></table></figure>
<p>注意：手指抬起的顺序不一致，也会引起一些数据变化，读者要理解，可以自己复制代码做实验。</p>
<blockquote>
<p>1 是<code>ACTION_UP</code>，2 是<code>ACTION_DOWN</code>，5 是<code>ACTION_POINTER_DOWN</code>，6 是<code>ACTION_POINTER_UP</code>。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ReactiveX 初探]]></title>
      <url>http://www.timebridge.space/2016/07/30/ReactiveX/</url>
      <content type="html"><![CDATA[<p>ReactiveX，<a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener">GitHub</a> 上的的定义如下：</p>
<blockquote>
<p>A library for composing asynchronous and event-based programs by using observable sequences.</p>
<p>It extends the observer pattern to support sequences of data/events and <strong>adds operators</strong> that allow you to compose sequences together declaratively <strong>while abstracting away concerns about things like low-level threading, synchronization, thread-safety and concurrent data structures</strong>.</p>
</blockquote>
<p>它通过扩展观察者模式来支持基于数据/事件流的开发模式，允许声明一组操作来处理数据/事件，同时能够避免开发者花精力去关注一些底层的概念，比如线程、同步、线程安全以及并发数据结构。</p>
<p>下面来详细讨论一下它的特点。<a id="more"></a></p>
<h2 id="Rx的理念"><a href="#Rx的理念" class="headerlink" title="Rx的理念"></a>Rx的理念</h2><p>Rx 是基于观察者模式的，这个模式在日常应用开发中非常常见，这里不多说。Rx 在观察者模式的基础之上，明确提出四个概念：</p>
<ol>
<li>被观察者(Observable)；</li>
<li>观察者(Subscriber/Observer)；</li>
<li>事件(Event)；</li>
<li>观察关系(Subscription)；</li>
</ol>
<p>被观察者代表的是事件的发出者，观察者是这个事件的处理者，事件可以理解为一个消息或者一块数据（这里可以想想EventBus），观察关系则是用来描述 A 订阅 B 发出的 E 事件这样一个关系，这个关系有时候需要被明确的管理，比如解除订阅，判断是否还在订阅。这四个概念共同组成了Rx的核心，括号里面的类名是RxJava对这四个概念的抽象。</p>
<p>除了抽象这四个概念以外，最前面那段定义还有一个关键的地方：<strong>add operators</strong>，也就是说可以添加操作。Rx不但提供了将事件从 Observale 发送到 Subscriber 的能力，还允许对事件添加一些操作，因此对于 Rx 来说，程序逻辑实际是这样的：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/Rx理念.png" alt="Rx理念"></div>

<p>如图，使用 Rx 构建一段逻辑时，思路就是这样一个过程。我们要做的就是定义好图中的各个模块，以便于它们能够串起来工作。</p>
<h2 id="为什么要使用Rx"><a href="#为什么要使用Rx" class="headerlink" title="为什么要使用Rx"></a>为什么要使用Rx</h2><p>这里建议读者先去看一下<a href="https://github.com/rengwuxian" target="_blank" rel="noopener">扔物线</a>童鞋的文章<a href="http://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="noopener">给 Android 开发者的 RxJava 详解</a>。这篇文章中有几个经典的例子，说明了使用 Rx 的场景。</p>
<p>个人认为 Rx 的使用是有条件的：</p>
<ol>
<li>一个较长的逻辑链 &amp; 存在嵌套；</li>
<li>一个较长的逻辑链 &amp; 线程间切换；</li>
</ol>
<p>较长的逻辑链是指从已有的信息到最终需要输出的信息之间是有一个比较长、比较复杂的处理过程的，比如说扔物线所举的<code>imageCollectorView</code>例子，我们需要需要经过以下几个步骤：</p>
<ol>
<li>遍历所有的文件夹；</li>
<li>遍历文件夹下面所有的文件；</li>
<li>过滤出”.png”结尾的文件；</li>
<li>从文件中解析出Bitmap；</li>
<li>把Bitmap添加到<code>imageCollectorView</code>中去；</li>
</ol>
<p>这个链很长，并且嵌套着多层循环，如果直接以普通的<code>for</code>循环方式进行处理，看上去会比较复杂，但是修改成 Rx 的形式之后，就变得极为整齐，以 Lambda 形式查看代码更是享受。不但如此，这个例子还涉及到线程间切换：</p>
<ol>
<li>在解析出 Bitmap 之前，整个过程都应该发生在后台线程中；</li>
<li>第5步则需要调度到主线程中进行；</li>
</ol>
<p>一般来说在线程间进行切换的代码都非常丑陋，尤其是需要来回切换的时候。Rx 简化了这种切换所需要的形式，只需要简单的调用一个 API 就可以搞定。</p>
<p>为什么我一定要在较长的逻辑链后面添加几个条件呢？因为我觉得 Rx 对代码的可读性是有所降低的，如果仅仅是一些平坦的逻辑，使用普通的 Java 代码会是一个更好的选择，一层嵌套不需要，简单的从后台线程切换到主线程，使用 AsyncTask 可能会是更好的选择。而当使用普通的 Java 代码实现出来的东西已经让你抓狂，我觉得可以去尝试使用 Rx。</p>
<p>平时进行业务开发的时候一般不太会遇到这么复杂的情况，因为我们会用到很多的库，比如Volley，这些库通过封装后台线程操作，已经抹除了很大一部分的复杂性，因此业务层使用 Rx 的可能性好像不大。但是像 Retrofit 这样的底层库，涉及到复杂的流程操作的，使用 Rx 会是一个很好的选择，再也不用手动 new 那么多的 Handler 了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>事实上，Rx 的亮点就在于线程的调度以及丰富的 Operator，以便于开发者通过简单的链式调用就可以很优雅的实现一个功能。</p>
<p>粗略的学习会有粗略的论断，前面给出的条件很可能非常片面，等深入学习各类操作符以及 Rx 的其余特性之后，再来补充修正。</p>
<h2 id="其余资料"><a href="#其余资料" class="headerlink" title="其余资料"></a>其余资料</h2><p>先占个坑，后面慢慢补上。</p>
<ol>
<li><a href="http://reactivex.io/intro.html" target="_blank" rel="noopener">ReactiveX 网站</a></li>
<li><a href="https://github.com/ReactiveX" target="_blank" rel="noopener">GitHub ReactiveX Group</a></li>
</ol>
<p>ReactiveX 网站上面有对各类操作的带图释义。</p>
<p><a href="https://www.gitbook.com/book/mcxiaoke/rxdocs/details" target="_blank" rel="noopener">文档中文翻译</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Binder之Service查询]]></title>
      <url>http://www.timebridge.space/2016/06/21/binder-service-lookup/</url>
      <content type="html"><![CDATA[<p>前一篇文章<a href="http://www.muzileecoding.com/framework/binder-service-register.html" target="_blank" rel="noopener">Binder之Service注册</a>描述了一个 Service 如何在 SM 中完成服务注册，接下来就是要探索如何向 SM 查询这个服务。有前一篇的基础，希望这一篇可以快一些~</p>
<blockquote>
<p>【注意】服务查询和服务注册过程其实非常接近，因此本文会大量引用前一篇文章的分析过程，读者可以仔细阅读上一篇文章之后再来阅读这篇文章。</p>
</blockquote>
<p>本文将以 <strong>前文</strong> 指代文章<a href="http://www.muzileecoding.com/framework/binder-service-register.html" target="_blank" rel="noopener">Binder之Service注册</a>。<a id="more"></a></p>
<h2 id="研究入口"><a href="#研究入口" class="headerlink" title="研究入口"></a>研究入口</h2><p>上一篇研究的对象是 MediaServer 和 MediaPlayerService，可以猜测一下在整个系统中必然有<code>getMediaPlayerService()</code>方法的调用，在 AndroidXRef 中搜索 “getMediaPlayerService” 字符串，很快就可以发现有很多类中调用了这个方法，我们选择 “IMediaDeathNotifier.cpp” 中的一段代码作为入口进行研究：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// establish binder interface to MediaPlayerService</span></span><br><span class="line"><span class="comment">/*static*/</span><span class="keyword">const</span> sp&lt;IMediaPlayerService&gt;&amp;</span><br><span class="line">IMediaDeathNotifier::getMediaPlayerService()</span><br><span class="line">&#123;</span><br><span class="line">    LOGV(<span class="string">"getMediaPlayerService"</span>);</span><br><span class="line">    Mutex::Autolock _l(sServiceLock);</span><br><span class="line">    <span class="keyword">if</span> (sMediaPlayerService.get() == <span class="number">0</span>) &#123;</span><br><span class="line">        sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line">        sp&lt;IBinder&gt; binder;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            binder = sm-&gt;getService(String16(<span class="string">"media.player"</span>));</span><br><span class="line">            <span class="keyword">if</span> (binder != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             usleep(<span class="number">500000</span>); <span class="comment">// 0.5 s</span></span><br><span class="line">        &#125; <span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sDeathNotifier == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        sDeathNotifier = <span class="keyword">new</span> DeathNotifier();</span><br><span class="line">    &#125;</span><br><span class="line">    binder-&gt;linkToDeath(sDeathNotifier);</span><br><span class="line">    sMediaPlayerService = interface_cast&lt;IMediaPlayerService&gt;(binder);</span><br><span class="line">    &#125;</span><br><span class="line">    LOGE_IF(sMediaPlayerService == <span class="number">0</span>, <span class="string">"no media player service!?"</span>);</span><br><span class="line">    <span class="keyword">return</span> sMediaPlayerService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码其实就是<code>getMediaPlayerService</code>方法的实现代码。可以看到核心代码其实只有三行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line">binder = sm-&gt;getService(String16(<span class="string">"media.player"</span>));</span><br><span class="line">sMediaPlayerService = interface_cast&lt;IMediaPlayerService&gt;(binder);</span><br></pre></td></tr></table></figure>
<p>第一行代码是获取 SM 实例的，这一点在前文中已经有非常详细的解析过程，这里就不再重复解析了。重点是后面两句。</p>
<p><strong>【涉及文件】</strong></p>
<table>
<thead>
<tr>
<th>文件</th>
<th>位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>IMediaDeathNotifier.cpp</td>
<td>/frameworks/base/media/libmedia/IMediaDeathNotifier.cpp</td>
</tr>
</tbody>
</table>
<p>包括前文所提到的文件。</p>
<h2 id="发送服务获取命令"><a href="#发送服务获取命令" class="headerlink" title="发送服务获取命令"></a>发送服务获取命令</h2><p>服务获取调用的代码是:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binder = sm-&gt;getService(String16(<span class="string">"media.player"</span>));</span><br></pre></td></tr></table></figure>
<p><code>getService()</code>方法的实现如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> sp&lt;IBinder&gt; getService(<span class="keyword">const</span> String16&amp; name) <span class="keyword">const</span> &#123;</span><br><span class="line">	<span class="keyword">unsigned</span> n;</span><br><span class="line">	<span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; <span class="number">5</span>; n++)&#123;</span><br><span class="line">		<span class="comment">// 调用checkService方法获取</span></span><br><span class="line">		sp&lt;IBinder&gt; svc = checkService(name);</span><br><span class="line">		<span class="keyword">if</span> (svc != <span class="literal">NULL</span>) <span class="keyword">return</span> svc;</span><br><span class="line">		LOGI(<span class="string">"Waiting for service %s...\n"</span>, String8(name).<span class="built_in">string</span>());</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> sp&lt;IBinder&gt; checkService( <span class="keyword">const</span> String16&amp; name) <span class="keyword">const</span> &#123;</span><br><span class="line">	Parcel data, reply;</span><br><span class="line">	data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());</span><br><span class="line">	data.writeString16(name);</span><br><span class="line">	remote()-&gt;transact(CHECK_SERVICE_TRANSACTION, data, &amp;reply);</span><br><span class="line">	<span class="keyword">return</span> reply.readStrongBinder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些方法名字虽然第一次见，可是内容应该非常熟悉了 —— 和注册服务非常非常接近，只不过这一次命令有所变化。关于<code>transact()</code>方法的追踪，上一篇文章中也有非常详细的分析，详见前文 5.2 节。根据前文，我们最终会来到：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用代码: writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL);</span></span><br><span class="line"><span class="comment">// 参数解释: handle 为 0，code 为 CHECK_SERVICE_TRANSACTION， binderFlags 是 TF_ACCEPT_FDS;</span></span><br><span class="line"><span class="keyword">status_t</span> IPCThreadState::writeTransactionData(<span class="keyword">int32_t</span> cmd, <span class="keyword">uint32_t</span> binderFlags,</span><br><span class="line">    <span class="keyword">int32_t</span> handle, <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, <span class="keyword">status_t</span>* statusBuffer)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 该结构体在字典中可查</span></span><br><span class="line">    binder_transaction_data tr;</span><br><span class="line"></span><br><span class="line">    tr.target.handle = handle;</span><br><span class="line">    tr.code = code;</span><br><span class="line">    tr.flags = binderFlags;</span><br><span class="line">    tr.cookie = <span class="number">0</span>;</span><br><span class="line">    tr.sender_pid = <span class="number">0</span>;</span><br><span class="line">    tr.sender_euid = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">status_t</span> err = data.errorCheck();</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">    	<span class="comment">// 将之前写在 data 中的数据再换一种形式写到 binder_transaction_data 中</span></span><br><span class="line">        tr.data_size = data.ipcDataSize(); </span><br><span class="line">        tr.data.ptr.buffer = data.ipcData(); </span><br><span class="line">        tr.offsets_size = data.ipcObjectsCount()*<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>);</span><br><span class="line">        tr.data.ptr.offsets = data.ipcObjects(); </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusBuffer) &#123;</span><br><span class="line">        tr.flags |= TF_STATUS_CODE;</span><br><span class="line">        *statusBuffer = err;</span><br><span class="line">        tr.data_size = <span class="keyword">sizeof</span>(<span class="keyword">status_t</span>);</span><br><span class="line">        tr.data.ptr.buffer = statusBuffer;</span><br><span class="line">        tr.offsets_size = <span class="number">0</span>;</span><br><span class="line">        tr.data.ptr.offsets = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mOut.writeInt32(cmd);<span class="comment">//BC_TRANSACTION</span></span><br><span class="line">    mOut.write(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里要注意的是，除了命令不一样，数据上也有差别了。前文中是进行服务注册，所以数据中是携带了一个序列化的服务节点的，但这里很简单，只有想要获取的服务名字而已。</p>
<h2 id="SM-处理命令"><a href="#SM-处理命令" class="headerlink" title="SM 处理命令"></a>SM 处理命令</h2><p>中间的驱动处理和前文基本一致，这里略去分析，主要是看 SM 如何处理这个命令，处理函数是<code>svcmgr_handler</code>: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint16_t</span> svcmgr_id[] = &#123; </span><br><span class="line">    <span class="string">'a'</span>,<span class="string">'n'</span>,<span class="string">'d'</span>,<span class="string">'r'</span>,<span class="string">'o'</span>,<span class="string">'i'</span>,<span class="string">'d'</span>,<span class="string">'.'</span>,<span class="string">'o'</span>,<span class="string">'s'</span>,<span class="string">'.'</span>,</span><br><span class="line">    <span class="string">'I'</span>,<span class="string">'S'</span>,<span class="string">'e'</span>,<span class="string">'r'</span>,<span class="string">'v'</span>,<span class="string">'i'</span>,<span class="string">'c'</span>,<span class="string">'e'</span>,<span class="string">'M'</span>,<span class="string">'a'</span>,<span class="string">'n'</span>,<span class="string">'a'</span>,<span class="string">'g'</span>,<span class="string">'e'</span>,<span class="string">'r'</span> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">svcmgr_handler</span><span class="params">(struct binder_state *bs,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_txn *txn,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_io *msg,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_io *reply)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span> *<span class="title">si</span>;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> *s;</span><br><span class="line">    <span class="keyword">unsigned</span> len;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="keyword">uint32_t</span> strict_policy;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// svcmgr_handle 被赋值为 svcmgr，即BINDER_SERVICE_MANAGER，即0</span></span><br><span class="line">    <span class="keyword">if</span> (txn-&gt;target != svcmgr_handle)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Equivalent to Parcel::enforceInterface(), reading the RPC</span></span><br><span class="line">    <span class="comment">// header with the strict mode policy mask and the interface name.</span></span><br><span class="line">    <span class="comment">// Note that we ignore the strict_policy and don't propagate it</span></span><br><span class="line">    <span class="comment">// further (since we do no outbound RPCs anyway).</span></span><br><span class="line">    strict_policy = bio_get_uint32(msg);</span><br><span class="line">    s = bio_get_string16(msg, &amp;len);</span><br><span class="line">    <span class="comment">// svcmgr_id是一个字符数组，见最上面，这里判断是通过的，因为s读取出来就是"android.os.IServiceManager"</span></span><br><span class="line">    <span class="keyword">if</span> ((len != (<span class="keyword">sizeof</span>(svcmgr_id) / <span class="number">2</span>)) ||</span><br><span class="line">        <span class="built_in">memcmp</span>(svcmgr_id, s, <span class="keyword">sizeof</span>(svcmgr_id))) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"invalid id %s\n"</span>, str8(s));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(txn-&gt;code) &#123;</span><br><span class="line">    <span class="keyword">case</span> SVC_MGR_GET_SERVICE:</span><br><span class="line">    <span class="keyword">case</span> SVC_MGR_CHECK_SERVICE:</span><br><span class="line">        s = bio_get_string16(msg, &amp;len); <span class="comment">// "media.player"</span></span><br><span class="line">        ptr = do_find_service(bs, s, len);</span><br><span class="line">        <span class="keyword">if</span> (!ptr)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        bio_put_ref(reply, ptr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bio_put_uint32(reply, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里其实可以看到，获取服务和查询服务的处理流程是一样的。</p>
<blockquote>
<p>至于为什么会落到<code>SVC_MGR_CHECK_SERVICE</code>这个命令，前文也有解释。</p>
</blockquote>
<p>在获取服务名称之后，调用<code>do_find_service</code>方法来查询服务: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">do_find_service</span><span class="params">(struct binder_state *bs, <span class="keyword">uint16_t</span> *s, <span class="keyword">unsigned</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span> *<span class="title">si</span>;</span></span><br><span class="line">    si = find_svc(s, len);</span><br><span class="line"></span><br><span class="line"><span class="comment">//    LOGI("check_service('%s') ptr = %p\n", str8(s), si ? si-&gt;ptr : 0);</span></span><br><span class="line">    <span class="keyword">if</span> (si &amp;&amp; si-&gt;ptr) &#123;</span><br><span class="line">        <span class="keyword">return</span> si-&gt;ptr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct svcinfo *<span class="title">find_svc</span><span class="params">(<span class="keyword">uint16_t</span> *s16, <span class="keyword">unsigned</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span> *<span class="title">si</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (si = svclist; si; si = si-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((len == si-&gt;len) &amp;&amp;</span><br><span class="line">            !<span class="built_in">memcmp</span>(s16, si-&gt;name, len * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>))) &#123;</span><br><span class="line">            <span class="keyword">return</span> si;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数<code>find_svc</code>前文已经解析过了，这里其实就是找到在 svclist 中是否有对应的 svcinfo 节点，名称与需要查找的服务名称一致，如果有，则返回 svcinfo 的 ptr 字段，ptr 字段的来源前文也有解释: 服务在 SM 中分配得到的 handle 值。也就是说，返回这个 handle 值就好了。</p>
<p>找到 ptr 之后，我们回到<code>do_find_service</code>，在这里会调用<code>bio_put_ref</code>方法:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bio_put_ref</span><span class="params">(struct binder_io *bio, <span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 该结构体在字典中可查</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_object</span> *<span class="title">obj</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr)</span><br><span class="line">        obj = bio_alloc_obj(bio);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        obj = bio_alloc(bio, <span class="keyword">sizeof</span>(*obj));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!obj)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    obj-&gt;flags = <span class="number">0x7f</span> | FLAT_BINDER_FLAG_ACCEPTS_FDS;</span><br><span class="line">    obj-&gt;type = BINDER_TYPE_HANDLE;</span><br><span class="line">    obj-&gt;pointer = ptr;</span><br><span class="line">    obj-&gt;cookie = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有必要好好分析一下 binder_io 这个结构体相关的方法了，它们集中在 “binder.c” 文件中。首先来看<code>bio_alloc_obj</code>方法: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct binder_object *<span class="title">bio_alloc_obj</span><span class="params">(struct binder_io *bio)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_object</span> *<span class="title">obj</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 下面解释 bio_alloc 方法</span></span><br><span class="line">    obj = bio_alloc(bio, <span class="keyword">sizeof</span>(*obj));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (obj &amp;&amp; bio-&gt;offs_avail) &#123;</span><br><span class="line">    	<span class="comment">// 表示偏移数据可记录数目又少了1，因为下面即将记录新的偏移信息</span></span><br><span class="line">        bio-&gt;offs_avail--;</span><br><span class="line">        <span class="comment">// 记录新的 binder_object 在结构体中的偏移量</span></span><br><span class="line">        *bio-&gt;offs++ = ((<span class="keyword">char</span>*) obj) - ((<span class="keyword">char</span>*) bio-&gt;data0);</span><br><span class="line">        <span class="comment">// 返回 binder_object 结构体的起始位置</span></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bio-&gt;flags |= BIO_F_OVERFLOW;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法声明了一个 <code>binder_object</code> 的结构体，实例化方法调用的是<code>bio_alloc</code>: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">bio_alloc</span><span class="params">(struct binder_io *bio, <span class="keyword">uint32_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    size = (size + <span class="number">3</span>) &amp; (~<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (size &gt; bio-&gt;data_avail) &#123;</span><br><span class="line">        bio-&gt;flags |= BIO_F_OVERFLOW;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *ptr = bio-&gt;data;</span><br><span class="line">        bio-&gt;data += size;</span><br><span class="line">        bio-&gt;data_avail -= size;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法非常简单，首先检测传入的参数 binder_io 是否还有足够的容量分配 size 的空间，如果足够，就操作 data 和 data_avail 变量，仅这样来表示空间分配。方法会返回分配空间的起始地址。综上，这组方法以及 binder_io 结构体其实是对内存分配的一个封装。</p>
<p>回到<code>bio_alloc_obj</code>方法后的代码都有注释，不难理解。再回到<code>bio_put_ref</code>方法后，会在该结构体中填充以下数据: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">obj-&gt;flags = <span class="number">0x7f</span> | FLAT_BINDER_FLAG_ACCEPTS_FDS;</span><br><span class="line">obj-&gt;type = BINDER_TYPE_HANDLE;</span><br><span class="line">obj-&gt;pointer = ptr;</span><br><span class="line">obj-&gt;cookie = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>这部分数据很重要，后面还会用到。回到<code>svcmgr_handler</code>函数，还会执行下面语句才会返回:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bio_put_uint32(reply, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bio_put_uint32</span><span class="params">(struct binder_io *bio, <span class="keyword">uint32_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> *ptr = bio_alloc(bio, <span class="keyword">sizeof</span>(n));</span><br><span class="line">    <span class="keyword">if</span> (ptr)</span><br><span class="line">        *ptr = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是在 binder_io 结构体中分配空间写入数据。执行完毕之后，回到函数<code>binder_parse</code>中:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_parse</span><span class="params">(struct binder_state *bs, struct binder_io *bio,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">uint32_t</span> *ptr, <span class="keyword">uint32_t</span> size, binder_handler func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> *end = ptr + (size / <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (ptr &lt; end) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> cmd = *ptr++;</span><br><span class="line">        <span class="keyword">switch</span>(cmd) &#123;</span><br><span class="line">            ......</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION: &#123;</span><br><span class="line">        	<span class="comment">//该结构体字典中可查</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_txn</span> *<span class="title">txn</span> = (<span class="title">void</span> *) <span class="title">ptr</span>;</span></span><br><span class="line">            <span class="keyword">if</span> ((end - ptr) * <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>) &lt; <span class="keyword">sizeof</span>(struct binder_txn)) &#123;</span><br><span class="line">                LOGE(<span class="string">"parse: txn too small!\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            binder_dump_txn(txn);</span><br><span class="line">            <span class="keyword">if</span> (func) &#123;</span><br><span class="line">                <span class="keyword">unsigned</span> rdata[<span class="number">256</span>/<span class="number">4</span>];</span><br><span class="line">                <span class="comment">// 该结构体字典中可查</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">binder_io</span> <span class="title">msg</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">binder_io</span> <span class="title">reply</span>;</span></span><br><span class="line">                <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">                bio_init(&amp;reply, rdata, <span class="keyword">sizeof</span>(rdata), <span class="number">4</span>);</span><br><span class="line">                bio_init_from_txn(&amp;msg, txn);</span><br><span class="line">                <span class="comment">// 刚刚在这里，不清楚的可以看前文</span></span><br><span class="line">                res = func(bs, txn, &amp;msg, &amp;reply);</span><br><span class="line">                binder_send_reply(bs, &amp;reply, txn-&gt;data, res);</span><br><span class="line">            &#125;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(*txn) / <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下去就是要执行<code>binder_send_reply</code>方法发送 reply 数据:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数解释：status 为0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binder_send_reply</span><span class="params">(struct binder_state *bs,</span></span></span><br><span class="line"><span class="function"><span class="params">                       struct binder_io *reply,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">void</span> *buffer_to_free,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> status)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> cmd_free;</span><br><span class="line">        <span class="keyword">void</span> *buffer;</span><br><span class="line">        <span class="keyword">uint32_t</span> cmd_reply;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_txn</span> <span class="title">txn</span>;</span></span><br><span class="line">    &#125; __attribute__((packed)) data;</span><br><span class="line"></span><br><span class="line">    data.cmd_free = BC_FREE_BUFFER; <span class="comment">// 注意命令</span></span><br><span class="line">    data.buffer = buffer_to_free;</span><br><span class="line">    data.cmd_reply = BC_REPLY; <span class="comment">// 注意命令</span></span><br><span class="line">    data.txn.target = <span class="number">0</span>;</span><br><span class="line">    data.txn.cookie = <span class="number">0</span>;</span><br><span class="line">    data.txn.code = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (status) &#123;</span><br><span class="line">        data.txn.flags = TF_STATUS_CODE;</span><br><span class="line">        data.txn.data_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">        data.txn.offs_size = <span class="number">0</span>;</span><br><span class="line">        data.txn.data = &amp;status;</span><br><span class="line">        data.txn.offs = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 走这里，和前面的分析一对比就非常清晰</span></span><br><span class="line">        data.txn.flags = <span class="number">0</span>;</span><br><span class="line">        data.txn.data_size = reply-&gt;data - reply-&gt;data0;</span><br><span class="line">        data.txn.offs_size = ((<span class="keyword">char</span>*) reply-&gt;offs) - ((<span class="keyword">char</span>*) reply-&gt;offs0);</span><br><span class="line">        data.txn.data = reply-&gt;data0;</span><br><span class="line">        data.txn.offs = reply-&gt;offs0;</span><br><span class="line">    &#125;</span><br><span class="line">    binder_write(bs, &amp;data, <span class="keyword">sizeof</span>(data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>reply 中的数据部分包含两组数据，一个是一个 binder_io 结构体，一个则是整数 0。接下去就不分析了，和前文一样，我们直接进入驱动。</p>
<h2 id="驱动节点生成"><a href="#驱动节点生成" class="headerlink" title="驱动节点生成"></a>驱动节点生成</h2><p>根据前文的分析，答复的处理肯定经过方法<code>binder_transaction</code>，这也是本文分析的重点，我们看看和服务注册具体有什么区别。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_transaction</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_transaction_data *tr, <span class="keyword">int</span> reply)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	......</span><br><span class="line">    <span class="comment">// 核心不同！确实有数据，是通过 binder_object 结构体写入的</span></span><br><span class="line">    off_end = (<span class="keyword">void</span> *)offp + tr-&gt;offsets_size;</span><br><span class="line">    <span class="keyword">for</span> (; offp &lt; off_end; offp++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> *<span class="title">fp</span>;</span></span><br><span class="line">        fp = (struct flat_binder_object *)(t-&gt;buffer-&gt;data + *offp);</span><br><span class="line">        <span class="keyword">switch</span> (fp-&gt;type) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_HANDLE:</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_WEAK_HANDLE: &#123;</span><br><span class="line">            <span class="comment">// 获取服务注册的时候在 SM 中生成的 binder_ref</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span> *<span class="title">ref</span> = <span class="title">binder_get_ref</span>(<span class="title">proc</span>, <span class="title">fp</span>-&gt;<span class="title">handle</span>);</span></span><br><span class="line">            <span class="comment">// 权限检测</span></span><br><span class="line">            <span class="keyword">if</span> (security_binder_transfer_binder(proc-&gt;tsk, target_proc-&gt;tsk)) &#123;</span><br><span class="line">                return_error = BR_FAILED_REPLY;</span><br><span class="line">                <span class="keyword">goto</span> err_binder_get_ref_failed;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ref-&gt;node-&gt;proc == target_proc) &#123;<span class="comment">// 如果请求的服务节点的进程就是请求发起的进程</span></span><br><span class="line">                <span class="keyword">if</span> (fp-&gt;type == BINDER_TYPE_HANDLE)</span><br><span class="line">                    fp-&gt;type = BINDER_TYPE_BINDER; <span class="comment">// 直接更改为 binder 实体节点，不需要引用</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    fp-&gt;type = BINDER_TYPE_WEAK_BINDER;</span><br><span class="line">                fp-&gt;binder = ref-&gt;node-&gt;ptr;</span><br><span class="line">                fp-&gt;cookie = ref-&gt;node-&gt;cookie;</span><br><span class="line">                binder_inc_node(ref-&gt;node, fp-&gt;type == BINDER_TYPE_BINDER, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">                trace_binder_transaction_ref_to_node(t, ref);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                struct binder_ref *new_ref;</span><br><span class="line">                <span class="comment">// ⭐️在目标进程，也就是请求进程中查看该节点的引用，没有则新建</span></span><br><span class="line">                new_ref = binder_get_ref_for_node(target_proc, ref-&gt;node);</span><br><span class="line">                <span class="comment">// 拿到该服务节点在本进程中的 handle 值</span></span><br><span class="line">                fp-&gt;handle = new_ref-&gt;desc;</span><br><span class="line">                binder_inc_ref(new_ref, fp-&gt;type == BINDER_TYPE_HANDLE, <span class="literal">NULL</span>);</span><br><span class="line">                trace_binder_transaction_ref_to_ref(t, ref,</span><br><span class="line">                                    new_ref);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">        BUG_ON(t-&gt;buffer-&gt;async_transaction != <span class="number">0</span>);</span><br><span class="line">        binder_pop_transaction(target_thread, in_reply_to);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 挂载节点</span></span><br><span class="line">    t-&gt;work.type = BINDER_WORK_TRANSACTION;</span><br><span class="line">    list_add_tail(&amp;t-&gt;work.entry, target_list);</span><br><span class="line">    tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;</span><br><span class="line">    list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);</span><br><span class="line">    <span class="keyword">if</span> (target_wait)</span><br><span class="line">        wake_up_interruptible(target_wait);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法前半部分的处理和服务注册都类似，核心不同在于驱动对数据的处理上：</p>
<p><strong>服务注册，binder_transaction中的 binder 节点是一个 binder_node 实体节点，在驱动中它会将它换成 BINDER_TYPE_HANDLE 类型，并在请求注册的进程上生成新的实体节点；但是服务查询中，却只会判断该服务是否属于当前进程，如果服务属于当前进程，则会换成 BINDER_TYPE_BINDER 类型；否则会以 BINDER_TYPE_HANDLE 类型继续传递处理。尤其要注意⭐️的地方！</strong></p>
<p>经过数据处理，binder_transaction 的数据内容已经变化。到这里，SM 的处理全部完成。</p>
<h2 id="查询方的等待"><a href="#查询方的等待" class="headerlink" title="查询方的等待"></a>查询方的等待</h2><p>查询方此时必然在<code>binder_thread_read</code>方法中等待: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_read</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                  struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">void</span>  __user *buffer, <span class="keyword">int</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">signed</span> <span class="keyword">long</span> *consumed, <span class="keyword">int</span> non_block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">w</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span> = <span class="title">NULL</span>;</span></span><br><span class="line">        <span class="keyword">if</span> (!list_empty(&amp;thread-&gt;todo))</span><br><span class="line">            w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work)</span><br><span class="line">            w = list_first_entry(&amp;proc-&gt;todo, struct binder_work, entry);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ptr - buffer == <span class="number">4</span> &amp;&amp; !(thread-&gt;looper &amp; BINDER_LOOPER_STATE_NEED_RETURN)) <span class="comment">/* no data added */</span></span><br><span class="line">                <span class="keyword">goto</span> retry;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end - ptr &lt; <span class="keyword">sizeof</span>(tr) + <span class="number">4</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">switch</span> (w-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> BINDER_WORK_TRANSACTION: &#123;</span><br><span class="line">            t = container_of(w, struct binder_transaction, work);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        ......</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!t)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// reply 的时候，该字段赋值为 NULL</span></span><br><span class="line">        <span class="keyword">if</span> (t-&gt;buffer-&gt;target_node) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 走这里</span></span><br><span class="line">            tr.target.ptr = <span class="literal">NULL</span>;</span><br><span class="line">            tr.cookie = <span class="literal">NULL</span>;</span><br><span class="line">            cmd = BR_REPLY;</span><br><span class="line">        &#125;</span><br><span class="line">        tr.code = t-&gt;code;</span><br><span class="line">        tr.flags = t-&gt;flags;</span><br><span class="line">        tr.sender_euid = t-&gt;sender_euid;</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;from) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">sender</span> = <span class="title">t</span>-&gt;<span class="title">from</span>-&gt;<span class="title">proc</span>-&gt;<span class="title">tsk</span>;</span></span><br><span class="line">            tr.sender_pid = task_tgid_nr_ns(sender,</span><br><span class="line">                            current-&gt;nsproxy-&gt;pid_ns);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tr.sender_pid = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tr.data_size = t-&gt;buffer-&gt;data_size;</span><br><span class="line">        tr.offsets_size = t-&gt;buffer-&gt;offsets_size;</span><br><span class="line">        tr.data.ptr.buffer = (<span class="keyword">void</span> *)t-&gt;buffer-&gt;data +</span><br><span class="line">                    proc-&gt;user_buffer_offset;</span><br><span class="line">        tr.data.ptr.offsets = tr.data.ptr.buffer +</span><br><span class="line">                    ALIGN(t-&gt;buffer-&gt;data_size,</span><br><span class="line">                        <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line">        <span class="keyword">if</span> (put_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(ptr, &amp;tr, <span class="keyword">sizeof</span>(tr)))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(tr);</span><br><span class="line">        trace_binder_transaction_received(t);</span><br><span class="line">        binder_stat_br(proc, thread, cmd);</span><br><span class="line">        list_del(&amp;t-&gt;work.entry);</span><br><span class="line">        t-&gt;buffer-&gt;allow_user_free = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (cmd == BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">            t-&gt;to_parent = thread-&gt;transaction_stack;</span><br><span class="line">            t-&gt;to_thread = thread;</span><br><span class="line">            thread-&gt;transaction_stack = t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            t-&gt;buffer-&gt;transaction = <span class="literal">NULL</span>;</span><br><span class="line">            kfree(t);</span><br><span class="line">            binder_stats_deleted(BINDER_STAT_TRANSACTION);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有必要详细分析一下数据内容了。这里面有一段很重要的数据拷贝: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tr.data_size = t-&gt;buffer-&gt;data_size;</span><br><span class="line">tr.offsets_size = t-&gt;buffer-&gt;offsets_size;</span><br><span class="line">tr.data.ptr.buffer = (<span class="keyword">void</span> *)t-&gt;buffer-&gt;data + proc-&gt;user_buffer_offset;</span><br><span class="line">tr.data.ptr.offsets = tr.data.ptr.buffer + ALIGN(t-&gt;buffer-&gt;data_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line"><span class="keyword">if</span> (put_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">	<span class="keyword">return</span> -EFAULT;</span><br><span class="line">ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line"><span class="keyword">if</span> (copy_to_user(ptr, &amp;tr, <span class="keyword">sizeof</span>(tr)))</span><br><span class="line">	<span class="keyword">return</span> -EFAULT;</span><br></pre></td></tr></table></figure>
<p>首先将数据内容和偏移数据大小记录下来，接着将数据地址映射到用户空间，以便于用户空间可以直接访问这块内存。之后拷贝<code>BR_TRANSACTION</code>命令，拷贝 binder_transaction_data 结构体后返回。中间过程比较冗长，在前文中也做了分析，我们直接到处理返回结果的地方。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::waitForResponse(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> cmd;</span><br><span class="line">    <span class="keyword">int32_t</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        err = mIn.errorCheck();</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (mIn.dataAvail() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        cmd = mIn.readInt32();</span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">            ......</span><br><span class="line">        <span class="keyword">case</span> BR_REPLY:</span><br><span class="line">            &#123;</span><br><span class="line">                binder_transaction_data tr;</span><br><span class="line">                err = mIn.read(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line">                LOG_ASSERT(err == NO_ERROR, <span class="string">"Not enough command data for brREPLY"</span>);</span><br><span class="line">                <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((tr.flags &amp; TF_STATUS_CODE) == <span class="number">0</span>) &#123;</span><br><span class="line">                        reply-&gt;ipcSetDataReference(</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                            tr.data_size,</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                            tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>),</span><br><span class="line">                            freeBuffer, <span class="keyword">this</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        err = *<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">status_t</span>*&gt;(tr.data.ptr.buffer);</span><br><span class="line">                        freeBuffer(<span class="literal">NULL</span>,</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                            tr.data_size,</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                            tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>), <span class="keyword">this</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ......</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里首先从 mIn 中把 binder_transaction_data 结构体读出来，然后调用<code>Parcel.ipcSetDataReference()</code>方法把数据写入到 reply 中去：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 调用代码:reply-&gt;ipcSetDataReference(</span></span><br><span class="line"><span class="comment"> *                          reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),</span></span><br><span class="line"><span class="comment"> *                          tr.data_size,</span></span><br><span class="line"><span class="comment"> *                          reinterpret_cast&lt;const size_t*&gt;(tr.data.ptr.offsets),</span></span><br><span class="line"><span class="comment"> *                          tr.offsets_size/sizeof(size_t),</span></span><br><span class="line"><span class="comment"> *                          freeBuffer, this);</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">void</span> Parcel::ipcSetDataReference(<span class="keyword">const</span> <span class="keyword">uint8_t</span>* data, <span class="keyword">size_t</span> dataSize,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span>* objects, <span class="keyword">size_t</span> objectsCount, release_func relFunc, <span class="keyword">void</span>* relCookie)</span><br><span class="line">&#123;</span><br><span class="line">    freeDataNoInit();</span><br><span class="line">    mError = NO_ERROR;</span><br><span class="line">    mData = <span class="keyword">const_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(data);</span><br><span class="line">    mDataSize = mDataCapacity = dataSize;</span><br><span class="line">    mDataPos = <span class="number">0</span>;</span><br><span class="line">    LOGV(<span class="string">"setDataReference Setting data pos of %p to %d\n"</span>, <span class="keyword">this</span>, mDataPos);</span><br><span class="line">    mObjects = <span class="keyword">const_cast</span>&lt;<span class="keyword">size_t</span>*&gt;(objects);</span><br><span class="line">    mObjectsSize = mObjectsCapacity = objectsCount;</span><br><span class="line">    mNextObjectHint = <span class="number">0</span>;</span><br><span class="line">    mOwner = relFunc;</span><br><span class="line">    mOwnerCookie = relCookie;</span><br><span class="line">    scanForFds();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这几个参数前面基本都见过，不多做解释，但是 objectsCount 的计算式是<code>tr.offsets_size/sizeof(size_t)</code>，即偏移数据量尺寸除以偏移记录大小，因此就是偏移记录的条数，也就是记录的对象数，因为是查询服务，从前面的分析来看，这里只返回了一个对象。然后根据 objects 参数，就可以从 data 中获取到所有的 binder 节点数据。</p>
<p>而 reply 参数是怎么来的呢？来自这里:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remote()-&gt;transact(CHECK_SERVICE_TRANSACTION, data, &amp;reply);</span><br></pre></td></tr></table></figure>
<p>接下去一句便是: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> reply.readStrongBinder();</span><br></pre></td></tr></table></figure>
<p>如上分析，此时 reply 中已经有有关 binder 的数据了，那么是怎么读取的呢？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IBinder&gt; Parcel::readStrongBinder() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;IBinder&gt; val;</span><br><span class="line">    unflatten_binder(ProcessState::self(), *<span class="keyword">this</span>, &amp;val);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> unflatten_binder(<span class="keyword">const</span> sp&lt;ProcessState&gt;&amp; proc,</span><br><span class="line">    <span class="keyword">const</span> Parcel&amp; in, sp&lt;IBinder&gt;* out)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> flat_binder_object* flat = in.readObject(<span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (flat) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (flat-&gt;type) &#123;</span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_BINDER:</span><br><span class="line">                *out = <span class="keyword">static_cast</span>&lt;IBinder*&gt;(flat-&gt;cookie);</span><br><span class="line">                <span class="keyword">return</span> finish_unflatten_binder(<span class="literal">NULL</span>, *flat, in);</span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_HANDLE:</span><br><span class="line">                *out = proc-&gt;getStrongProxyForHandle(flat-&gt;handle);</span><br><span class="line">                <span class="keyword">return</span> finish_unflatten_binder(</span><br><span class="line">                    <span class="keyword">static_cast</span>&lt;BpBinder*&gt;(out-&gt;get()), *flat, in);</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BAD_TYPE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际的读取是在<code>readObject</code>中进行的:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> flat_binder_object* Parcel::readObject(<span class="keyword">bool</span> nullMetaData) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> DPOS = mDataPos;</span><br><span class="line">    <span class="comment">// 首先判断剩余数据量是否足以读取出一个 flat_binder_object</span></span><br><span class="line">    <span class="keyword">if</span> ((DPOS+<span class="keyword">sizeof</span>(flat_binder_object)) &lt;= mDataSize) &#123;</span><br><span class="line">        <span class="comment">// 强转读取</span></span><br><span class="line">        <span class="keyword">const</span> flat_binder_object* obj</span><br><span class="line">                = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> flat_binder_object*&gt;(mData+DPOS);</span><br><span class="line">        mDataPos = DPOS + <span class="keyword">sizeof</span>(flat_binder_object);</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// Ensure that this object is valid...</span></span><br><span class="line">        <span class="keyword">size_t</span>* <span class="keyword">const</span> OBJS = mObjects;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">size_t</span> N = mObjectsSize;</span><br><span class="line">        <span class="keyword">size_t</span> opos = mNextObjectHint;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            LOGV(<span class="string">"Parcel %p looking for obj at %d, hint=%d\n"</span>,</span><br><span class="line">                 <span class="keyword">this</span>, DPOS, opos);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Start at the current hint position, looking for an object at</span></span><br><span class="line">            <span class="comment">// the current data position.</span></span><br><span class="line">            <span class="keyword">if</span> (opos &lt; N) &#123;</span><br><span class="line">                <span class="keyword">while</span> (opos &lt; (N<span class="number">-1</span>) &amp;&amp; OBJS[opos] &lt; DPOS) &#123;</span><br><span class="line">                    opos++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                opos = N<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (OBJS[opos] == DPOS) &#123;</span><br><span class="line">                mNextObjectHint = opos+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> obj;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// Look backwards for it...</span></span><br><span class="line">            <span class="keyword">while</span> (opos &gt; <span class="number">0</span> &amp;&amp; OBJS[opos] &gt; DPOS) &#123;</span><br><span class="line">                opos--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (OBJS[opos] == DPOS) &#123;</span><br><span class="line">                <span class="comment">// Found it!</span></span><br><span class="line">                LOGV(<span class="string">"Parcel found obj %d at index %d with backward search"</span>,</span><br><span class="line">                     <span class="keyword">this</span>, DPOS, opos);</span><br><span class="line">                mNextObjectHint = opos+<span class="number">1</span>;</span><br><span class="line">                LOGV(<span class="string">"readObject Setting data pos of %p to %d\n"</span>, <span class="keyword">this</span>, mDataPos);</span><br><span class="line">                <span class="keyword">return</span> obj;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是一个简单的读取，但是会做一些校验。在当前情况下，当然可以找到我们想要的 flat_binder_object 结构体对象，接着回到<code>unflatten_binder</code>，执行如下代码: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flat) &#123;</span><br><span class="line">	<span class="keyword">switch</span> (flat-&gt;type) &#123;</span><br><span class="line">		<span class="keyword">case</span> BINDER_TYPE_BINDER:</span><br><span class="line">				*out = <span class="keyword">static_cast</span>&lt;IBinder*&gt;(flat-&gt;cookie);</span><br><span class="line"> 				<span class="keyword">return</span> finish_unflatten_binder(<span class="literal">NULL</span>, *flat, in);</span><br><span class="line">		<span class="keyword">case</span> BINDER_TYPE_HANDLE:</span><br><span class="line">				*out = proc-&gt;getStrongProxyForHandle(flat-&gt;handle);</span><br><span class="line">				<span class="keyword">return</span> finish_unflatten_binder(</span><br><span class="line">                    	<span class="keyword">static_cast</span>&lt;BpBinder*&gt;(out-&gt;get()), *flat, in);</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>很明显，我们返回的 Binder 类型是 BINDER_TYPE_HANDLE 的。out 最后被赋值为 <code>proc-&gt;getStrongProxyForHandle(flat-&gt;handle);</code>，<code>getStrongProxyForHandle</code>这个函数我们也是见过的，这里再分析一次，因为情景有些不同。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(<span class="keyword">int32_t</span> handle)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;IBinder&gt; result;</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// handle 为0</span></span><br><span class="line">    handle_entry* e = lookupHandleLocked(handle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// We need to create a new BpBinder if there isn't currently one, OR we</span></span><br><span class="line">        <span class="comment">// are unable to acquire a weak reference on this current one.  See comment</span></span><br><span class="line">        <span class="comment">// in getWeakProxyForHandle() for more info about this.</span></span><br><span class="line">        IBinder* b = e-&gt;binder;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">NULL</span> || !e-&gt;refs-&gt;attemptIncWeak(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            b = <span class="keyword">new</span> BpBinder(handle); </span><br><span class="line">            e-&gt;binder = b;</span><br><span class="line">            <span class="keyword">if</span> (b) e-&gt;refs = b-&gt;getWeakRefs();</span><br><span class="line">            result = b;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// This little bit of nastyness is to allow us to add a primary</span></span><br><span class="line">            <span class="comment">// reference to the remote proxy when this team doesn't have one</span></span><br><span class="line">            <span class="comment">// but another team is sending the handle to us.</span></span><br><span class="line">            result.force_set(b);</span><br><span class="line">            e-&gt;refs-&gt;decWeak(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ProcessState::handle_entry* ProcessState::lookupHandleLocked(<span class="keyword">int32_t</span> handle)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> N = mHandleToObject.size();</span><br><span class="line">    <span class="keyword">if</span> (N &lt;= (<span class="keyword">size_t</span>)handle) &#123;</span><br><span class="line">        handle_entry e;</span><br><span class="line">        e.binder = <span class="literal">NULL</span>;</span><br><span class="line">        e.refs = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">status_t</span> err = mHandleToObject.insertAt(e, N, handle+<span class="number">1</span>-N);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;mHandleToObject.editItemAt(handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为是初次获取这个服务，因此实际上<code>lookupHandleLocked</code>返回的还是一个新建的 handle_entry 结构体，因此实际上<code>getStrongProxyForHandle</code>返回的对象就是<code>new BpBinder(handle)</code>，这整个过程返回的则是<code>new BpBinder(flat-&gt;handle)</code>对象。</p>
<h2 id="最后的交互"><a href="#最后的交互" class="headerlink" title="最后的交互"></a>最后的交互</h2><p>现在Client已经拿到这个<code>new BpBinder(flat-&gt;handle)</code>了，那么怎么和远程服务通信呢？这个其实在注册服务中也分析过了，只不过那时候<code>flat-&gt;handle</code>为 0 而已，而在<code>binder_transaction</code>方法中，是否为 0 是有区别的:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tr-&gt;target.handle) &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span> *<span class="title">ref</span>;</span></span><br><span class="line">	ref = binder_get_ref(proc, tr-&gt;target.handle);</span><br><span class="line">	target_node = ref-&gt;node;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	target_node = binder_context_mgr_node;</span><br><span class="line">	<span class="keyword">if</span> (target_node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		return_error = BR_DEAD_REPLY;</span><br><span class="line">		<span class="keyword">goto</span> err_no_context_mgr_node;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 handle 为 0，默认目标服务节点就是<code>binder_context_mgr_node</code>，但如果不为 0，则会在进程(<code>binder_proc</code>对象)的红黑树中寻找，这个寻找一定是OK的，因为在查询服务的时候就把<code>binder_ref</code>节点插入到红黑树中去了。自然而然也就能定位到目标进程，从而发送请求。</p>
<h2 id="interface-cast"><a href="#interface-cast" class="headerlink" title="interface_cast"></a>interface_cast</h2><p>在发送服务请求之前，还需要做一次转换，因为我们还不知道远程服务的API是什么样子的，这就是<code>IMediaDeathNotifier::getMediaPlayerService()</code>方法中最后一句的作用:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sMediaPlayerService = interface_cast&lt;IMediaPlayerService&gt;(binder);</span><br></pre></td></tr></table></figure>
<p><code>interface_cast</code>在前文已经分析过一次了，很容易推断出最终<code>interface_cast&lt;IMediaPlayerService&gt;(binder);</code>返回的值是：<strong><code>new BpMediaPlayerService(new BpBinder(flat-&gt;handle))</code></strong>。</p>
<p>这在下图中也能看到该对象:</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/Binder-Lib层架构.png" alt="Binder Lib层架构"></div>

<p>这里就不多做分析了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，搜寻服务也分析完毕。如果读者对这几篇文章都已经比较熟悉，墙裂建议阅读推荐文章①和文章③两系列博客！整个分析下来，Binder 机制所做的重要事情如下：</p>
<ol>
<li>启动 SM，并且固定 SM 的 handle 值为0，这样任何其余的服务都可以随时获取到 SM 服务；</li>
<li>服务启动后都会去 SM 注册，这个注册的过程是：在驱动层本进程的映射数据结构<code>binder_proc</code>中生成对应的<code>binder_node</code>节点，这个节点在穿越驱动边界的时候，会在目标进程中生成<code>binder_ref</code>结构体，注册的时候，这个目标进程就是 SM，也就是说 SM 会持有所有服务的引用；</li>
<li>服务查询的时候，也是问询 SM ，SM 就通过名字查询对应的服务引用，在返回的时候同样需要穿越驱动边界，驱动又会查询目标进程是否有该服务节点的引用，没有的话又会去目标进程生成一个，并且生成对应的 handle 值，这个值会最总返回到 Libraries 层；</li>
<li>在 Librries 层会通过 <code>new BpXXXService(new BpBinder(handle))</code>的形式生成服务对象这其实是一个代理，最外层的<code>new BpXXXService()</code>最主要的目的是找到<code>XXXService</code>的接口，而内部<code>new BpBinder(handle)</code>则是为了将请求转发给真正的服务进程，因为这个时候持有 handle，就可以在驱动层查询到对应的<code>binder_node</code>节点，从而可以向对方 proc/thread 挂载任务并唤醒对方；</li>
</ol>
<p>以上。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Binder之Service Manager]]></title>
      <url>http://www.timebridge.space/2016/06/21/binder-servicemanager/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>Service Manager (以下简称 SM )在 Binder 框架中负责的是维护 Service 的查询工作：给我一个名字，给你想要的服务。</strong>要注意的是：这里所说的 SM 并不是我们日常开发中用到的 SM，那个是 Java 层的封装，这里所讲的 SM 位于 Libraries 层。</p>
<p><strong>【涉及文件】</strong></p>
<table>
<thead>
<tr>
<th>文件</th>
<th>位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>service_manager.c</td>
<td>/frameworks/base/cmds/servicemanager/service_manager.c</td>
</tr>
<tr>
<td>Libraries 层 binder.c</td>
<td>/frameworks/base/cmds/servicemanager/binder.c</td>
</tr>
<tr>
<td>驱动层 binder.c</td>
<td>kernel/common/drivers/staging/android/binder.c</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<p>##主要函数调用<br>SM 的启动 main 函数位于”service_manager.c”文件中:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_state</span> *<span class="title">bs</span>;</span></span><br><span class="line">    <span class="comment">// #define BINDER_SERVICE_MANAGER ((void*) 0) </span></span><br><span class="line">    <span class="keyword">void</span> *svcmgr = BINDER_SERVICE_MANAGER;</span><br><span class="line">    <span class="comment">// 1. 打开 Binder 驱动</span></span><br><span class="line">    bs = binder_open(<span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 注册成为 SM</span></span><br><span class="line">    <span class="keyword">if</span> (binder_become_context_manager(bs)) &#123;</span><br><span class="line">        LOGE(<span class="string">"cannot become context manager (%s)\n"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    svcmgr_handle = svcmgr;</span><br><span class="line">    <span class="comment">// 3. 启动循环监听</span></span><br><span class="line">    binder_loop(bs, svcmgr_handler);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要步骤就如代码中注释的那样，分为三步:</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/service_manager_main.png" width="320" alt="SM main函数调用"></div>

<p>我们就从这三步入手，逐步解析 SM 的启动过程。</p>
<h2 id="打开-Binder-驱动"><a href="#打开-Binder-驱动" class="headerlink" title="打开 Binder 驱动"></a>打开 Binder 驱动</h2><p><code>binder_open</code>，顾名思义就是打开 binder 驱动，来看看它在打开时做了什么:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用代码: bs = binder_open(128*1024);</span></span><br><span class="line"><span class="function">struct binder_state *<span class="title">binder_open</span><span class="params">(<span class="keyword">unsigned</span> mapsize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	 <span class="comment">// 该结构可在字典中查询</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_state</span> *<span class="title">bs</span>;</span></span><br><span class="line"></span><br><span class="line">    bs = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*bs));</span><br><span class="line">    <span class="keyword">if</span> (!bs) &#123;</span><br><span class="line">        errno = ENOMEM;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">// 1. 打开驱动</span></span><br><span class="line">    bs-&gt;fd = open(<span class="string">"/dev/binder"</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (bs-&gt;fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"binder: cannot open device (%s)\n"</span>,</span><br><span class="line">                strerror(errno));</span><br><span class="line">        <span class="keyword">goto</span> fail_open;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bs-&gt;mapsize = mapsize;</span><br><span class="line">    <span class="comment">// 2. 内存映射</span></span><br><span class="line">    bs-&gt;mapped = mmap(<span class="literal">NULL</span>, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (bs-&gt;mapped == MAP_FAILED) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"binder: cannot map device (%s)\n"</span>,</span><br><span class="line">                strerror(errno));</span><br><span class="line">        <span class="keyword">goto</span> fail_map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* <span class="doctag">TODO:</span> check version */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bs;</span><br><span class="line"></span><br><span class="line">fail_map:</span><br><span class="line">    close(bs-&gt;fd);</span><br><span class="line">fail_open:</span><br><span class="line">    <span class="built_in">free</span>(bs);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如注释所示，主要步骤分为两步，我们一步一步来看。</p>
<h3 id="驱动层binder-open"><a href="#驱动层binder-open" class="headerlink" title="驱动层binder_open"></a>驱动层<code>binder_open</code></h3><p>程序 binder 驱动设备调用的是<code>open</code>方法，这个方法实际会调用到驱动层的<code>binder_open</code>方法，将打开的文件描述符记录到 binder_state 的 fd 字段: </p>
<blockquote>
<p>至于为什么会有 Libraries 的<code>open</code>方法映射到驱动层的<code>binder_open</code>方法，这属于驱动知识，不详细解释，后面也会有很多这样的映射例子，一般是前面加上<code>binder_</code>做映射，这个关系是 binder 驱动自己定义的。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static int binder_open(struct inode *nodp, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">    //声明proc的数据结构，可在字典中查询</span><br><span class="line">    struct binder_proc *proc;</span><br><span class="line">    proc = kzalloc(sizeof(*proc), GFP_KERNEL);</span><br><span class="line">    if (proc == NULL)</span><br><span class="line">        return -ENOMEM;</span><br><span class="line"></span><br><span class="line">    //增加引用计数</span><br><span class="line">    get_task_struct(current);</span><br><span class="line">    </span><br><span class="line">    //记录当前进程到proc中</span><br><span class="line">    proc-&gt;tsk = current;</span><br><span class="line"></span><br><span class="line">    //初始化链表</span><br><span class="line">    INIT_LIST_HEAD(&amp;proc-&gt;todo);</span><br><span class="line">    //初始化等待队列</span><br><span class="line">    init_waitqueue_head(&amp;proc-&gt;wait);</span><br><span class="line">    //设置优先级</span><br><span class="line">    proc-&gt;default_priority = task_nice(current);</span><br><span class="line">    binder_lock(__func__);</span><br><span class="line">    binder_stats_created(BINDER_STAT_PROC);</span><br><span class="line">    //把binder_proc添加到binder_procs链表中去</span><br><span class="line">    hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs);</span><br><span class="line">    //记录进程ID</span><br><span class="line">    proc-&gt;pid = current-&gt;group_leader-&gt;pid;</span><br><span class="line">    INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);</span><br><span class="line"></span><br><span class="line">    //保存进程信息</span><br><span class="line">    filp-&gt;private_data = proc;</span><br><span class="line">    binder_unlock(__func__);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分配<code>binder_proc</code>对象之后，后面的代码都有注释，这里 current 其实是一个宏，指向的是一个内联函数，返回的结果指向当前的进程，具体在 SOF 的问题 <a href="http://stackoverflow.com/questions/12434651/what-is-the-current-in-linux-kernel-source" target="_blank" rel="noopener">what is the “current” in linux kernel source</a> 下面有详细的解释。接着就是初始化一些队列，记录环境值。最后会将 proc 保存到<code>filp-&gt;private_data</code>中去，后面就可以从这个字段中再把 proc 读取出来。</p>
<blockquote>
<p>这里涉及到很多的C++、Linux、驱动知识，比如将 proc 保存到 <code>filp-&gt;private_data</code> 中去。</p>
</blockquote>
<p>这个就是打开 binder 驱动做的主要工作，以下是调用路径图:</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/binder_open.png" alt="打开binder驱动"></div>

<h3 id="驱动层binder-mmap"><a href="#驱动层binder-mmap" class="headerlink" title="驱动层binder_mmap"></a>驱动层<code>binder_mmap</code></h3><p>接着程序将传入的 mapsize 记录到 binder_state 的 mapsize 字段( main 函数传入的值是 128*1024)；最后调用<code>mmap</code>函数进行内存映射。<code>mmap</code>是系统调用，可以理解为从驱动中划分一块内存出来映射到本进程中，从而 binder 驱动和本进程都可以操作这块内存。</p>
<p>这块较复杂，功力不足暂时分析不了，如果读者有兴趣可以去看老罗的文章<a href="http://blog.csdn.net/luoshengyang/article/details/6621566" target="_blank" rel="noopener">浅谈Service Manager成为Android进程间通信（IPC）机制Binder守护进程之路</a>，直接搜 “binder_mmap” 就好。</p>
<p>至此，binder 驱动打开，并且做好了映射，终于可以直接和驱动通信了。</p>
<blockquote>
<p>这个过程类似于打开了一个文件，定位好了写入位置和可以写入的数据量，接下去就可以写入数据了。</p>
</blockquote>
<h2 id="成为服务管理者"><a href="#成为服务管理者" class="headerlink" title="成为服务管理者"></a>成为服务管理者</h2><p>现在我们已经打开了 binder 驱动，并且记录下它的文件描述符，接着 service_manager 开始申请成为服务管理者了，它调用的方法是<code>binder_become_context_manager</code>。这个方法同样存在于 Libraries 层 “binder.c” 文件中:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_become_context_manager</span><span class="params">(struct binder_state *bs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//#define BINDER_SET_CONTEXT_MGR  _IOW('b', 7, int) </span></span><br><span class="line">    <span class="keyword">return</span> ioctl(bs-&gt;fd, BINDER_SET_CONTEXT_MGR, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只有一行很简单的调用。<code>ioctl</code>也是一个系统调用，最终这个调用会映射到 binder 驱动的 <code>binder_ioctl</code>。</p>
<p>这么一来就进入了驱动层，<code>binder_ioctl</code>是一个较大的方法，它可以处理很多的命令。调用这个方法的第二个参数就代表命令，而上面的调用传进来的是<code>BINDER_SET_CONTEXT_MGR</code>，我们就先看这个命令的处理过程:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">binder_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	 <span class="comment">// 通过 filp-&gt;private_data 获取进程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">    <span class="comment">// 该结构体在字典中可查</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取到线程</span></span><br><span class="line">    thread = binder_get_thread(proc);</span><br><span class="line">    <span class="keyword">if</span> (thread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ret = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> BINDER_SET_CONTEXT_MGR:</span><br><span class="line">        <span class="comment">// binder_context_mgr_node是一个全局静态变量</span></span><br><span class="line">        <span class="keyword">if</span> (binder_context_mgr_node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            printk(KERN_ERR <span class="string">"binder: BINDER_SET_CONTEXT_MGR already set\n"</span>);</span><br><span class="line">            ret = -EBUSY;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = security_binder_set_context_mgr(proc-&gt;tsk);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        <span class="keyword">if</span> (binder_context_mgr_uid != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (binder_context_mgr_uid != current-&gt;cred-&gt;euid) &#123;</span><br><span class="line">                printk(KERN_ERR <span class="string">"binder: BINDER_SET_"</span></span><br><span class="line">                       <span class="string">"CONTEXT_MGR bad uid %d != %d\n"</span>,</span><br><span class="line">                       current-&gt;cred-&gt;euid,</span><br><span class="line">                       binder_context_mgr_uid);</span><br><span class="line">                ret = -EPERM;</span><br><span class="line">                <span class="keyword">goto</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            binder_context_mgr_uid = current-&gt;cred-&gt;euid;</span><br><span class="line">        <span class="comment">// 新建binder_node</span></span><br><span class="line">        binder_context_mgr_node = binder_new_node(proc, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (binder_context_mgr_node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ret = -ENOMEM;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        binder_context_mgr_node-&gt;local_weak_refs++;</span><br><span class="line">        binder_context_mgr_node-&gt;local_strong_refs++;</span><br><span class="line">        binder_context_mgr_node-&gt;has_strong_ref = <span class="number">1</span>;</span><br><span class="line">        binder_context_mgr_node-&gt;has_weak_ref = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ret = -EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line">    <span class="keyword">if</span> (thread)</span><br><span class="line">        thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_NEED_RETURN;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong> 这里是删除了很多代码的，只把核心相关的部分展示出来了。</p>
<p>我们来分析一下代码，首先是调用<code>binder_get_thread</code>方法查找 binder_thread:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct binder_thread *<span class="title">binder_get_thread</span><span class="params">(struct binder_proc *proc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">thread</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// threads: binder_proc进程内用于处理用户请求的线程组成的红黑树(关联binder_thread-&gt;rb_node)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">p</span> = &amp;<span class="title">proc</span>-&gt;<span class="title">threads</span>.<span class="title">rb_node</span>;</span></span><br><span class="line">    <span class="comment">// 遍历红黑树寻找线程节点</span></span><br><span class="line">    <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">        parent = *p;</span><br><span class="line">        thread = rb_entry(parent, struct binder_thread, rb_node);</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;pid &lt; thread-&gt;pid)</span><br><span class="line">            p = &amp;(*p)-&gt;rb_left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current-&gt;pid &gt; thread-&gt;pid)</span><br><span class="line">            p = &amp;(*p)-&gt;rb_right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没找到就新建，初始化线程</span></span><br><span class="line">    <span class="keyword">if</span> (*p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        thread = kzalloc(<span class="keyword">sizeof</span>(*thread), GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (thread == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        binder_stats_created(BINDER_STAT_THREAD);</span><br><span class="line">        thread-&gt;proc = proc;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录进程的pid</span></span><br><span class="line">        thread-&gt;pid = current-&gt;pid;</span><br><span class="line">        <span class="comment">// 初始化thread的两个队列</span></span><br><span class="line">        init_waitqueue_head(&amp;thread-&gt;wait);</span><br><span class="line">        INIT_LIST_HEAD(&amp;thread-&gt;todo);</span><br><span class="line">        <span class="comment">// 挂载节点到 &amp;proc-&gt;threads 红黑树上</span></span><br><span class="line">        rb_link_node(&amp;thread-&gt;rb_node, parent, p);</span><br><span class="line">        rb_insert_color(&amp;thread-&gt;rb_node, &amp;proc-&gt;threads);</span><br><span class="line">        <span class="comment">// 设置状态</span></span><br><span class="line">        thread-&gt;looper |= BINDER_LOOPER_STATE_NEED_RETURN;</span><br><span class="line">        thread-&gt;return_error = BR_OK;</span><br><span class="line">        thread-&gt;return_error2 = BR_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传递进来的是当前进程的记录对象<code>binder_proc</code>，具体的解释已经标注在代码中了。这里标注一个<strong>【疑点】</strong>：按照这里的算法，这棵红黑树是否只可能有一个thread？</p>
<blockquote>
<p>这里给出挂载红黑树的两个操作的解释:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 它把 parent 设为 node 的父结点，并且让 rb_link 指向 node。</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rb_link_node</span><span class="params">(struct rb_node * node, struct rb_node * parent, struct rb_node ** rb_link)</span></span>;</span><br><span class="line">&gt;</span><br><span class="line">&gt;<span class="comment">// 它把已确定父结点的 node 结点融入到以 root 为根的红黑树中</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">void</span> <span class="title">rb_insert_color</span><span class="params">(struct rb_node *node, struct rb_root *root)</span></span>;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>OK，回到前面，获取到 binder_thread 之后，就进入命令<code>BINDER_SET_CONTEXT_MGR</code>的处理阶段，首先是如下一个判断:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (binder_context_mgr_node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	printk(KERN_ERR <span class="string">"binder: BINDER_SET_CONTEXT_MGR already set\n"</span>);</span><br><span class="line">	ret = -EBUSY;</span><br><span class="line">	<span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>binder_context_mgr_node</code>是一个全局变量，它的声明如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该结构体在字典中可查</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">binder_context_mgr_node</span>;</span></span><br></pre></td></tr></table></figure>
<p>它是一个全局静态的 binder_node 结构体，这里的判断是保证全局只有一个 binder_context_mgr_node，也就是说只有一个 SM。第一次进来该变量没有新建过，即该变量为 NULL，所以会去调用方法<code>binder_new_node</code>新建：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用代码：binder_context_mgr_node = binder_new_node(proc, NULL, NULL);</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct binder_node *<span class="title">binder_new_node</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">void</span> __user *ptr,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">void</span> __user *cookie)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">p</span> = &amp;<span class="title">proc</span>-&gt;<span class="title">nodes</span>.<span class="title">rb_node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">        parent = *p;</span><br><span class="line">        node = rb_entry(parent, struct binder_node, rb_node)</span><br><span class="line">        <span class="keyword">if</span> (ptr &lt; node-&gt;ptr)</span><br><span class="line">            p = &amp;(*p)-&gt;rb_left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ptr &gt; node-&gt;ptr)</span><br><span class="line">            p = &amp;(*p)-&gt;rb_right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node = kzalloc(<span class="keyword">sizeof</span>(*node), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    binder_stats_created(BINDER_STAT_NODE);</span><br><span class="line">    rb_link_node(&amp;node-&gt;rb_node, parent, p);</span><br><span class="line">    rb_insert_color(&amp;node-&gt;rb_node, &amp;proc-&gt;nodes);</span><br><span class="line">    node-&gt;debug_id = ++binder_last_id;</span><br><span class="line">    node-&gt;proc = proc;</span><br><span class="line">    node-&gt;ptr = ptr;</span><br><span class="line">    node-&gt;cookie = cookie;</span><br><span class="line">    node-&gt;work.type = BINDER_WORK_NODE;</span><br><span class="line">    INIT_LIST_HEAD(&amp;node-&gt;work.entry);</span><br><span class="line">    INIT_LIST_HEAD(&amp;node-&gt;async_todo);</span><br><span class="line">    binder_debug(BINDER_DEBUG_INTERNAL_REFS,</span><br><span class="line">             <span class="string">"binder: %d:%d node %d u%p c%p created\n"</span>,</span><br><span class="line">             proc-&gt;pid, current-&gt;pid, node-&gt;debug_id,</span><br><span class="line">             node-&gt;ptr, node-&gt;cookie);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里第一行代码就遇到了 binder_proc 中的第二棵红黑树 nodes。nodes 节点记录的是属于该进程的所有 binder_node 节点，前面说了，binder_node 节点可以看做是一个服务实体，因此这棵树上记录的就是该进程提供的所有服务。新建完成之后就是一些赋值操作以及挂载 binder_node 的动作，注意，这里传进来的 ptr 和 cookie 都是 NULL。</p>
<blockquote>
<p>后面就会知道 cookie 为 NULL 其实表明 Libraries 层没有对应的服务。这是 SM 这个服务的特殊性。</p>
</blockquote>
<p>扯到哪了？哦，对了，我们已经在驱动层为 SM 创建了一个全局的服务实体，以下是调用关系图：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/binder_become_context_manager2.png" alt="打开binder驱动"></div>

<p>接下去是对强引用、弱引用的维护，这个涉及到服务实体的释放，我们不需要太关心。上面两个步骤是差不多的路子，都是从 Libraries 层走到驱动层，接下去还有一个步骤，还得把这个过程再走一遍。</p>
<h2 id="启动循环监听"><a href="#启动循环监听" class="headerlink" title="启动循环监听"></a>启动循环监听</h2><p>再回到 service_manager 的<code>main</code>函数，SM 程序调用<code>binder_loop</code>进入循环监听:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binder_loop</span><span class="params">(struct binder_state *bs, binder_handler func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="comment">// 该结构体在字典中可查</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> readbuf[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">    bwr.write_size = <span class="number">0</span>;</span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.write_buffer = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    readbuf[<span class="number">0</span>] = BC_ENTER_LOOPER;</span><br><span class="line">    <span class="comment">//告诉Binder驱动程序， Service Manager要进入循环了</span></span><br><span class="line">    binder_write(bs, readbuf, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        bwr.read_size = <span class="keyword">sizeof</span>(readbuf);</span><br><span class="line">        bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = (<span class="keyword">unsigned</span>) readbuf;</span><br><span class="line"></span><br><span class="line">        res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            LOGE(<span class="string">"binder_loop: ioctl failed (%s)\n"</span>, strerror(errno));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res = binder_parse(bs, <span class="number">0</span>, readbuf, bwr.read_consumed, func);</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">0</span>) &#123;</span><br><span class="line">            LOGE(<span class="string">"binder_loop: unexpected reply?!\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            LOGE(<span class="string">"binder_loop: io error %d %s\n"</span>, res, strerror(errno));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数虽然看上去比较简单，但是要分析的东西非常多。</p>
<h3 id="线程状态更改"><a href="#线程状态更改" class="headerlink" title="线程状态更改"></a>线程状态更改</h3><p><code>for</code>循环前一段代码稍微有点凌乱，整理之后可以看出首先执行的是:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> readbuf[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">readbuf[<span class="number">0</span>] = BC_ENTER_LOOPER;</span><br><span class="line">binder_write(bs, readbuf, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>));</span><br></pre></td></tr></table></figure>
<p>bs 是之前声明的<code>binder_state</code>结构体，这里把<code>BC_ENTER_LOOPER</code>传递进去了，我们直接去看<code>binder_write</code>函数是怎么使用这些参数的:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用代码：binder_write(bs, readbuf, sizeof(unsigned))</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_write</span><span class="params">(struct binder_state *bs, <span class="keyword">void</span> *data, <span class="keyword">unsigned</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    bwr.write_size = len;</span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.write_buffer = (<span class="keyword">unsigned</span>) data;</span><br><span class="line">    bwr.read_size = <span class="number">0</span>;</span><br><span class="line">    bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"binder_write: ioctl failed (%s)\n"</span>,</span><br><span class="line">                strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里用到了 binder_write_read 结构体，在字典中有提到：这个结构体只是负责传输数据，具体语义由上下文环境自行定义。这里就可以很明显的看出来这种玩法：刚刚传进来的 data 字段被赋值到了 bwr 的 write 部分了，即 write_buffer 字段被赋予了<code>BC_ENTER_LOOPER</code>命令，并且 write_consumed 也被赋予了0，表示 binder 驱动没有读取任何数据，通过 wite_consumed 和 write_size 两个字段，就可以指定 write_buffer 中的数据哪一段是有效的，binder 驱动会根据这两个值读取有效数据。数据以及位置设定好之后，再调用<code>ioctl</code>方法，这个方法我们前面有过一次分析，它也会携带一个命令，这次携带的是<code>BINDER_WRITE_READ</code>，到对应驱动函数中看一下这个命令的处理方式:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用代码：res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">binder_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size = _IOC_SIZE(cmd);</span><br><span class="line">    <span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> BINDER_WRITE_READ: &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">        <span class="comment">// 验证数据格式是否正确</span></span><br><span class="line">        <span class="keyword">if</span> (size != <span class="keyword">sizeof</span>(struct binder_write_read)) &#123;</span><br><span class="line">            ret = -EINVAL;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(&amp;bwr, ubuf, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">            ret = -EFAULT;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ret = binder_thread_write(proc, thread, (<span class="keyword">void</span> __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);</span><br><span class="line">            trace_binder_write_done(ret);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">                    ret = -EFAULT;</span><br><span class="line">                <span class="keyword">goto</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ret = binder_thread_read(proc, thread, (<span class="keyword">void</span> __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK);</span><br><span class="line">            trace_binder_read_done(ret);</span><br><span class="line">            <span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo))</span><br><span class="line">                wake_up_interruptible(&amp;proc-&gt;wait);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">                    ret = -EFAULT;</span><br><span class="line">                <span class="keyword">goto</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        binder_debug(BINDER_DEBUG_READ_WRITE,</span><br><span class="line">                 <span class="string">"binder: %d:%d wrote %ld of %ld, read return %ld of %ld\n"</span>,</span><br><span class="line">                 proc-&gt;pid, thread-&gt;pid, bwr.write_consumed, bwr.write_size,</span><br><span class="line">                 bwr.read_consumed, bwr.read_size);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">            ret = -EFAULT;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line">    <span class="keyword">if</span> (thread)</span><br><span class="line">        thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_NEED_RETURN;</span><br><span class="line">    binder_unlock(__func__);</span><br><span class="line">    wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &amp;&amp; ret != -ERESTARTSYS)</span><br><span class="line">        printk(KERN_INFO <span class="string">"binder: %d:%d ioctl %x %lx returned %d\n"</span>, proc-&gt;pid, current-&gt;pid, cmd, arg, ret);</span><br><span class="line">err_unlocked:</span><br><span class="line">    trace_binder_ioctl_done(ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来开动小火车分析 case 的代码。首先是一个判断，这是判断数据格式是否正确。接着调用函数<code>copy_from_user</code>，这个函数的 user 是用户空间的意思，它的目的是从用户空间拷贝数据到内核空间。</p>
<p>我们调用<code>binder_ioctl</code>的时候传入的第三个参数是<code>&amp;bwr</code>，也就是一个 binder_write_read 结构体，这里就是将这个结构体拷贝到驱动层的 bwr 结构体中。</p>
<blockquote>
<p>读者应当熟悉这种模式，这很类似于网络请求。Http请求定义了八种方法，最常见的是Post，Get两种，这就类似于该函数的 cmd 参数，而具体的语义其实是由请求内容确定的，这包括API结构，比如我的接口叫做<code>getorder.api</code>，伴随着这个接口发出去的还有一些数据，这些就类似于 binder_write_read 结构体了。处理完成之后，也在该请求上返回数据。</p>
<p>后面还会见到这种模式的反复使用，它是 binder 机制 Libraries 层和驱动层通信的一种典型模式。 </p>
</blockquote>
<p>理所应当的，接下来就是解析数据的过程。因为传递参数中只有 write 部分有数据，那么接下去的两个判断只有下面这个会执行:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	ret = binder_thread_write(proc, thread, (<span class="keyword">void</span> __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);</span><br><span class="line">	trace_binder_write_done(ret);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">			ret = -EFAULT;</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里调用了<code>binder_thread_write</code>来处理 binder_write_read 结构体的内容，这个函数也是一个非常复杂的函数，因为它需要解析该结构体中可能传输过来的所有的命令，这里我们只看其中一部分，也就是处理命令<code>BC_ENTER_LOOPER</code>的地方:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_thread_write</span><span class="params">(struct binder_proc *proc, struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">void</span> __user *buffer, <span class="keyword">int</span> size, <span class="keyword">signed</span> <span class="keyword">long</span> *consumed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">    <span class="keyword">void</span> __user *ptr = buffer + *consumed;</span><br><span class="line">    <span class="keyword">void</span> __user *end = buffer + size;</span><br><span class="line">    <span class="keyword">while</span> (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (get_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))<span class="comment">//读取cmd</span></span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">        trace_binder_command(cmd);</span><br><span class="line">        <span class="keyword">if</span> (_IOC_NR(cmd) &lt; ARRAY_SIZE(binder_stats.bc)) &#123;</span><br><span class="line">            binder_stats.bc[_IOC_NR(cmd)]++;</span><br><span class="line">            proc-&gt;stats.bc[_IOC_NR(cmd)]++;</span><br><span class="line">            thread-&gt;stats.bc[_IOC_NR(cmd)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BC_ENTER_LOOPER:<span class="comment">//Service将要进入Loop状态时，发送此消息</span></span><br><span class="line">            <span class="keyword">if</span> (thread-&gt;looper &amp; BINDER_LOOPER_STATE_REGISTERED) &#123;</span><br><span class="line">                thread-&gt;looper |= BINDER_LOOPER_STATE_INVALID;</span><br><span class="line">                binder_user_error(<span class="string">"binder: %d:%d ERROR:"</span></span><br><span class="line">                    <span class="string">" BC_ENTER_LOOPER called after "</span></span><br><span class="line">                    <span class="string">"BC_REGISTER_LOOPER\n"</span>,</span><br><span class="line">                    proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//表示进入enter状态，looper用于记录状态</span></span><br><span class="line">            thread-&gt;looper |= BINDER_LOOPER_STATE_ENTERED;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意!!!</span></span><br><span class="line">        *consumed = ptr - buffer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的入参 buffer 指向的是我们在结构体 binder_write_read 中写入的数据，也就是:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bwr.write_buffer = (<span class="keyword">unsigned</span>) data;</span><br></pre></td></tr></table></figure>
<p>而 data 就是<code>BC_ENTER_LOOPER</code>，所以 ptr 实际是指向这段数据的开始，end 指向的是这段数据的末尾。<code>get_user</code>也是一个内核函数，这里可以认为就是从 ptr 开始读取一个 uint32_t 值存储到 cmd 中，那么这个 cmd 就是<code>BC_ENTER_LOOPER</code>，接着指针后移。</p>
<blockquote>
<p>从这里的读取方式来看，可以猜到这是一种非常固定的”命令+数据”的模式，是两层之间约定俗称的协议。</p>
</blockquote>
<p>之后就进入处理阶段，字典里面说到 binder_thread 的 looper 字段记录是线程当前的状态，这里主要进行的就是状态设置，在检测完状态是否正确之后，调用以下语句:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread-&gt;looper |= BINDER_LOOPER_STATE_ENTERED;</span><br></pre></td></tr></table></figure>
<p>设置状态<code>ENTERED</code>，就表示要进入循环状态了。讲完这个再回到<code>binder_ioctl</code>方法去，还没完呢，正常执行完上面的方法之后，会走到这段代码中去:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) &#123;</span><br><span class="line">	ret = -EFAULT;</span><br><span class="line">	goto err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>copy_to_user</code>看名字就知道和<code>copy_from_user</code>函数什么关系了：这个函数是从内核空间拷贝数据到用户空间。这里拷贝的还是 binder_write_read 结构体，要把内核空间的修改反映到 Libraries 层：这里唯一的改动就是 write_consumed 的指针的移动，这个指针在读完数据之后，被执行了如下操作:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">*consumed = ptr - buffer;</span><br></pre></td></tr></table></figure>
<p>ptr 原本指向 buffer 数据的开始，根据上面的写法，实际上<code>*consumed</code>就等于<code>sizeof(uint32_t)</code>，也就是<code>BC_ENTER_LOOPER</code>的长度，这就表示驱动已经读取了 write 部分的数据。</p>
<p>好了到这里总算分析完成<code>binder_write(bs, readbuf, sizeof(unsigned));</code>这一句了。它只做一件事情：告诉驱动层我要进入循环监听状态了。读者务必应熟悉这种交互方式，这里是最简单清楚的一个例子。这里是调用关系图：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/binder_write.png" alt="告诉binder驱动即将进入循环监听"></div>

<h3 id="循环-amp-监听"><a href="#循环-amp-监听" class="headerlink" title="循环 &amp; 监听"></a>循环 &amp; 监听</h3><p>终于进入正题了，前面都是状态准备而已。在分析代码之前，可以先从猜测一下它会怎么做？到目前为止，状态都已经设置完毕，驱动层和当前进程也有共享内存来传输数据，那比较合理的做法就是去读取这块共享内存，看是否有数据可以处理，如果有则读出来进行处理，如果没有，则阻塞，直到有数据写入，被驱动层唤醒再返回。那么实际上是不是这样的呢？Read the fucking code !</p>
<p><code>binder_loop</code>函数接下去的是一个无限循环，再贴一下代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用代码：readbuf[0] = BC_ENTER_LOOPER;</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">	bwr.read_size = <span class="keyword">sizeof</span>(readbuf);</span><br><span class="line">	bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">	bwr.read_buffer = (<span class="keyword">unsigned</span>) readbuf;</span><br><span class="line"></span><br><span class="line">	res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		LOGE(<span class="string">"binder_loop: ioctl failed (%s)\n"</span>, strerror(errno));</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	res = binder_parse(bs, <span class="number">0</span>, readbuf, bwr.read_consumed, func);</span><br><span class="line">	<span class="keyword">if</span> (res == <span class="number">0</span>) &#123;</span><br><span class="line">		LOGE(<span class="string">"binder_loop: unexpected reply?!\n"</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		LOGE(<span class="string">"binder_loop: io error %d %s\n"</span>, res, strerror(errno));</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看循环的第一次执行过程。首先还是在操作 binder_write_read 结构体，只不过这里操作的是 read 部分：它告诉驱动，我要读取数据，读取的数据大小是<code>sizeof(readbuf)</code>。执行的命令也是同样的<code>BINDER_WRITE_READ</code>，因此实际上还是走的这段代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">binder_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size = _IOC_SIZE(cmd);</span><br><span class="line">    <span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> BINDER_WRITE_READ: &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">        <span class="keyword">if</span> (size != <span class="keyword">sizeof</span>(struct binder_write_read)) &#123;</span><br><span class="line">            ret = -EINVAL;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(&amp;bwr, ubuf, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">            ret = -EFAULT;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ret = binder_thread_write(proc, thread, (<span class="keyword">void</span> __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);</span><br><span class="line">            trace_binder_write_done(ret);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">                    ret = -EFAULT;</span><br><span class="line">                <span class="keyword">goto</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ret = binder_thread_read(proc, thread, (<span class="keyword">void</span> __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK);</span><br><span class="line">            trace_binder_read_done(ret);</span><br><span class="line">            <span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo))</span><br><span class="line">                wake_up_interruptible(&amp;proc-&gt;wait);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">                    ret = -EFAULT;</span><br><span class="line">                <span class="keyword">goto</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">            ret = -EFAULT;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line">    <span class="keyword">if</span> (thread)</span><br><span class="line">        thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_NEED_RETURN;</span><br><span class="line">    binder_unlock(__func__);</span><br><span class="line">    wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &amp;&amp; ret != -ERESTARTSYS)</span><br><span class="line">        printk(KERN_INFO <span class="string">"binder: %d:%d ioctl %x %lx returned %d\n"</span>, proc-&gt;pid, current-&gt;pid, cmd, arg, ret);</span><br><span class="line">err_unlocked:</span><br><span class="line">    trace_binder_ioctl_done(ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，在这里分析的时候不要被之前<code>BC_ENTER_LOOPER</code>的 bwr 结构体影响，那个写入的 bwr 是在<code>binder_write</code>方法中新创建的，这里的 bwr 是另外一个变量，就是在<code>binder_loop</code>中创建的。因此在<code>for</code>循环执行前，bwr 的状态是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">bwr.write_size = <span class="number">0</span>;</span><br><span class="line">bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">bwr.write_buffer = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>根据前面的代码，此时<code>bwr.read_size</code>的值是<code>sizeof(readbuf)</code>，因此实际执行的是:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用代码：bwr.read_size = sizeof(readbuf);</span></span><br><span class="line"><span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	ret = binder_thread_read(proc, thread, (<span class="keyword">void</span> __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK);</span><br><span class="line">	trace_binder_read_done(ret);</span><br><span class="line">	<span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo))</span><br><span class="line">		wake_up_interruptible(&amp;proc-&gt;wait);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">			ret = -EFAULT;</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>刚进来就直接调用<code>binder_thread_read</code>函数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 调用代码：ret = binder_thread_read(proc, thread, (void __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK);</span></span><br><span class="line"><span class="comment"> * 参数解释：</span></span><br><span class="line"><span class="comment"> * bwr.read_size = sizeof(readbuf);</span></span><br><span class="line"><span class="comment"> * bwr.read_consumed = 0;</span></span><br><span class="line"><span class="comment"> * bwr.read_buffer = (unsigned) readbuf;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * non_block 是 false 的，因为打开驱动的时候使用的代码是 open("/dev/binder", O_RDWR);</span></span><br><span class="line"><span class="comment"> * 并没有设置 O_NONBLOCK 标识，因此这个操作就是阻塞的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_read</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                  struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">void</span>  __user *buffer, <span class="keyword">int</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">signed</span> <span class="keyword">long</span> *consumed, <span class="keyword">int</span> non_block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> __user *ptr = buffer + *consumed;</span><br><span class="line">    <span class="keyword">void</span> __user *end = buffer + size;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> wait_for_proc_work;</span><br><span class="line">    <span class="keyword">if</span> (*consumed == <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="comment">// 拷贝"BR_NOOP"命令到prt地址，也就是read部分的数据区</span></span><br><span class="line">    	<span class="keyword">if</span> (put_user(BR_NOOP, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        <span class="comment">// 移动指针</span></span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line">retry:</span><br><span class="line">	 <span class="comment">// 成立，因此 wait_for_proc_work 为 true</span></span><br><span class="line">    wait_for_proc_work = thread-&gt;transaction_stack == <span class="literal">NULL</span> &amp;&amp; list_empty(&amp;thread-&gt;todo);</span><br><span class="line">    <span class="comment">// 不成立，thread-&gt;return_error 在 binder_thread 的 return_error 字段在创建的时候就被初始化为 BR_OK，</span></span><br><span class="line">    <span class="comment">// 具体可见方法`binder_get_thread`方法中新建 binder_thread 结构体的部分</span></span><br><span class="line">    <span class="comment">// 另外 ptr = end</span></span><br><span class="line">    <span class="keyword">if</span> (thread-&gt;return_error != BR_OK &amp;&amp; ptr &lt; end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (thread-&gt;return_error2 != BR_OK) &#123;</span><br><span class="line">            <span class="keyword">if</span> (put_user(thread-&gt;return_error2, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">            binder_stat_br(proc, thread, thread-&gt;return_error2);</span><br><span class="line">            <span class="keyword">if</span> (ptr == end)</span><br><span class="line">                <span class="keyword">goto</span> done;</span><br><span class="line">            thread-&gt;return_error2 = BR_OK;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (put_user(thread-&gt;return_error, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">        binder_stat_br(proc, thread, thread-&gt;return_error);</span><br><span class="line">        thread-&gt;return_error = BR_OK;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置状态为等待</span></span><br><span class="line">    thread-&gt;looper |= BINDER_LOOPER_STATE_WAITING;</span><br><span class="line">    <span class="comment">// 表示有一个线程进入就绪状态</span></span><br><span class="line">    <span class="keyword">if</span> (wait_for_proc_work)</span><br><span class="line">        proc-&gt;ready_threads++;</span><br><span class="line">    binder_unlock(__func__);</span><br><span class="line">    <span class="keyword">if</span> (wait_for_proc_work) &#123;</span><br><span class="line">    	<span class="comment">// 之前已经设置 BINDER_LOOPER_STATE_ENTERED 状态，因此判断不成立</span></span><br><span class="line">        <span class="keyword">if</span> (!(thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED |</span><br><span class="line">                    BINDER_LOOPER_STATE_ENTERED))) &#123;</span><br><span class="line">            binder_user_error(<span class="string">"binder: %d:%d ERROR: Thread waiting "</span></span><br><span class="line">                <span class="string">"for process work before calling BC_REGISTER_"</span></span><br><span class="line">                <span class="string">"LOOPER or BC_ENTER_LOOPER (state %x)\n"</span>,</span><br><span class="line">                proc-&gt;pid, thread-&gt;pid, thread-&gt;looper);</span><br><span class="line">            wait_event_interruptible(binder_user_error_wait,</span><br><span class="line">                         binder_stop_on_user_error &lt; <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        binder_set_nice(proc-&gt;default_priority);</span><br><span class="line">        <span class="comment">//打开binder设备的时候使用的是open("/dev/binder", O_RDWR)，而不是open("/dev/ttys", O_RDWR|O_NONBLOCK)，因此是阻塞的，所以non_block为false</span></span><br><span class="line">        <span class="keyword">if</span> (non_block) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!binder_has_proc_work(proc, thread))</span><br><span class="line">                ret = -EAGAIN;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">        	<span class="comment">// 最终会执行到这里</span></span><br><span class="line">            ret = wait_event_freezable_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (non_block) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!binder_has_thread_work(thread))</span><br><span class="line">                ret = -EAGAIN;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            ret = wait_event_freezable(thread-&gt;wait, binder_has_thread_work(thread));</span><br><span class="line">    &#125;</span><br><span class="line">    binder_lock(__func__);</span><br><span class="line">    <span class="comment">// 阻塞释放之后，减少一个就绪的线程</span></span><br><span class="line">    <span class="keyword">if</span> (wait_for_proc_work)</span><br><span class="line">        proc-&gt;ready_threads--;</span><br><span class="line">    <span class="comment">// 表示线程不在等待状态</span></span><br><span class="line">    thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_WAITING;</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中相关注释都已经标明具体在做什么，最终会执行到<code>wait_event_freezable_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread));</code>这一句。从网上找的资料看<code>wait_event_freezable_exclusive</code>基本等同于<code>wait_event_interruptible_exclusive</code>，老罗的分析中代码就是写的这个函数（它的源码版本比较老），调用这个方法之后进程就被阻塞，直到<code>binder_has_thread_work(thread)</code>为 true:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_has_thread_work</span><span class="params">(struct binder_thread *thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !list_empty(&amp;thread-&gt;todo) || thread-&gt;return_error != BR_OK ||</span><br><span class="line">        (thread-&gt;looper &amp; BINDER_LOOPER_STATE_NEED_RETURN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>thread-&gt;todo</code>列表不为空的时候，该函数返回true，至于这个列表中存放的什么，下两篇文章中会解释。</p>
<p>这里详细解释一下<code>wait_event_interruptible_exclusive</code>这个函数，Linux中还有一个类似的函数叫做<code>wait_event_interruptible</code>，exclusive表示排他进程，这个我们不去考虑，官方文档上对于这个方法的解释是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wait_event_interruptible — sleep until a condition gets true</span><br><span class="line"></span><br><span class="line">【Description】</span><br><span class="line">The process is put to sleep (TASK_INTERRUPTIBLE) until the condition evaluates to true or a signal is received. The condition is checked each time the waitqueue wq is woken up.</span><br><span class="line"></span><br><span class="line">wake_up has to be called after changing any variable that could change the result of the wait condition.</span><br><span class="line"></span><br><span class="line">The function will return -ERESTARTSYS if it was interrupted by a signal and 0 if condition evaluated to true.</span><br></pre></td></tr></table></figure>
<p>我们要看的其实是这句：<strong>The function will return -ERESTARTSYS if it was interrupted by a signal and 0 if condition evaluated to true.</strong> 换句话说，如果是被中断的，返回的是<code>-ERESTARTSYS</code>，如果是条件满足后返回的，则返回0。</p>
<p>为什么要解释这个呢？因为在阻塞恢复以后，有这样一段代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br></pre></td></tr></table></figure>
<p>ret 正是该函数的返回值，因此如果是条件满足后阻塞恢复，会继续往下执行。</p>
<p>OK，到这里，我们也把循环监听分析完了，以下是调用关系图:</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/binder_read.png" alt="告诉binder驱动进入循环监听"></div>

<h3 id="处理命令"><a href="#处理命令" class="headerlink" title="处理命令"></a>处理命令</h3><p>当循环监听到消息，即有消息返回的时候，首先会通过一个while循环初步处理数据，之后返回无限循环中，调用方法<code>binder_parse</code>解析请求:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = binder_parse(bs, <span class="number">0</span>, readbuf, bwr.read_consumed, func);</span><br></pre></td></tr></table></figure>
<p>因为这里没有实际的场景，就暂不分析请求处理这块的代码，下面两篇文章中都会涉及到该函数的分析。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上，SM 启动的过程分析完毕。它现在在等待着<code>binder_has_thread_work</code>为真。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Binder之Service注册]]></title>
      <url>http://www.timebridge.space/2016/06/21/binder-service-register/</url>
      <content type="html"><![CDATA[<p>前文<a href="http://www.muzileecoding.com/framework/binder-servicemanager.html" target="_blank" rel="noopener">Binder之Service Manager</a>已经讲述了 SM 如何启动并循环监听消息的，接下去按照逻辑应该是先说如何注册一个服务再说如何获取一个服务，但是从代码层面来说，先说获取服务似乎更好，好纠结。还是按照逻辑来讲吧~</p>
<h2 id="研究对象"><a href="#研究对象" class="headerlink" title="研究对象"></a>研究对象</h2><p>既然是讲述服务注册，最好的当然是从现有的系统中找出一枚服务，研究它的注册过程。<a href="http://www.muzileecoding.com/framework/binder.html" target="_blank" rel="noopener">总纲</a>中推荐的5篇文章正好有一篇是从这个角度切入分析Binder的：文章⑤<a href="http://www.cnblogs.com/innost/archive/2011/01/09/1931456.html" target="_blank" rel="noopener">Android深入浅出之Binder机制</a>。它是从 MediaServer 来切入分析的。</p>
<p>因为我们主要是看注册的过程，选择什么服务是次要的，因此这里也以该服务为分析对象。<strong>以下 MediaServer 简称 MS</strong>。MS 是为系统提供多媒体功能的服务，比如音频、视频等。</p>
<blockquote>
<p>和前一篇文章一样，这里仍然沿用 SM 指代 Service Manager。</p>
</blockquote>
<a id="more"></a><strong>【涉及文件】</strong><br><br>| 文件                      | 位置                                       |<br>| ———————– | —————————————- |<br>| main_mediaserver.cpp    | /frameworks/base/media/mediaserver/main_mediaserver.cpp |<br>| IServiceManager.h       | /frameworks/base/include/binder/IServiceManager.h |<br>| IServiceManager.cpp     | /frameworks/base/libs/binder/IServiceManager.cpp |<br>| IMediaPlayerService.cpp | /frameworks/base/media/libmedia/IMediaPlayerService.cpp |<br>| IPCThreadState.cpp      | /frameworks/base/libs/binder/IPCThreadState.cpp |<br>| ProcessState.cpp        | /frameworks/base/libs/binder/ProcessState.cpp |<br>| Binder.cpp              | /frameworks/base/libs/binder/Binder.cpp  |<br>| BpBinder.cpp            | /frameworks/base/libs/binder/BpBinder.cpp |<br>| Parcel.cpp              | /frameworks/base/libs/binder/Parcel.cpp  |<br>| IInterface.h            | /frameworks/base/include/binder/IInterface.h |<br>其余一些零碎文件、头文件，这里不一一列举了。<br><br>## 初见 MS<br>MS 的<code>main</code>函数位于 “main_mediaserver.cpp” 中，这个文件的代码内容非常简单:<br><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> android;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;ProcessState&gt; proc(ProcessState::self());</span><br><span class="line">    sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line">    LOGI(<span class="string">"ServiceManager: %p"</span>, sm.get());</span><br><span class="line">    AudioFlinger::instantiate();</span><br><span class="line">    MediaPlayerService::instantiate();</span><br><span class="line">    CameraService::instantiate();</span><br><span class="line">    AudioPolicyService::instantiate();</span><br><span class="line">    ProcessState::self()-&gt;startThreadPool();</span><br><span class="line">    IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就只有一个<code>main</code>函数。该方法会初始化很多的多媒体服务，我们选择一个 —— <strong>MediaPlayerService</strong> 分析就好了。因此以下是我们本次的代码分析路径:</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/main_mediaserver_main.png" width="320" alt="MS main函数调用"></div>

<h2 id="打开驱动-amp-内存映射"><a href="#打开驱动-amp-内存映射" class="headerlink" title="打开驱动 &amp; 内存映射"></a>打开驱动 &amp; 内存映射</h2><p><code>main</code>函数的第一行代码核心在于<code>ProcessState::self()</code>这一句:</p>
<blockquote>
<p><code>sp&lt;XXX&gt;</code> 可以看成 <code>XXX *</code>，即指针。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;ProcessState&gt; ProcessState::self()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (gProcess != <span class="literal">NULL</span>) <span class="keyword">return</span> gProcess;</span><br><span class="line">    </span><br><span class="line">    AutoMutex _l(gProcessMutex);</span><br><span class="line">    <span class="keyword">if</span> (gProcess == <span class="literal">NULL</span>) gProcess = <span class="keyword">new</span> ProcessState;</span><br><span class="line">    <span class="keyword">return</span> gProcess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个单例方法，确保只创建一个 ProcessState ，我们看看 ProcessState 的构造函数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ProcessState::ProcessState()</span><br><span class="line">    : mDriverFD(open_driver())</span><br><span class="line">    , mVMStart(MAP_FAILED)</span><br><span class="line">    , mManagesContexts(<span class="literal">false</span>)</span><br><span class="line">    , mBinderContextCheckFunc(<span class="literal">NULL</span>)</span><br><span class="line">    , mBinderContextUserData(<span class="literal">NULL</span>)</span><br><span class="line">    , mThreadPoolStarted(<span class="literal">false</span>)</span><br><span class="line">    , mThreadPoolSeq(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDriverFD &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// XXX Ideally, there should be a specific define for whether we</span></span><br><span class="line">        <span class="comment">// have mmap (or whether we could possibly have the kernel module</span></span><br><span class="line">        <span class="comment">// availabla).</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(HAVE_WIN32_IPC)</span></span><br><span class="line">        <span class="comment">// mmap the binder, providing a chunk of virtual address space to receive transactions.</span></span><br><span class="line">        mVMStart = mmap(<span class="number">0</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (mVMStart == MAP_FAILED) &#123;</span><br><span class="line">            <span class="comment">// *sigh*</span></span><br><span class="line">            LOGE(<span class="string">"Using /dev/binder failed: unable to mmap transaction memory.\n"</span>);</span><br><span class="line">            close(mDriverFD);</span><br><span class="line">            mDriverFD = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        mDriverFD = <span class="number">-1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG_ALWAYS_FATAL_IF(mDriverFD &lt; <span class="number">0</span>, <span class="string">"Binder driver could not be opened.  Terminating."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数并不复杂，但是关键点很隐蔽： <strong><code>mDriverFD(open_driver())</code></strong> ，这里将调用函数<code>open_driver()</code>，并将返回值赋值给<code>mDriverFD</code>。自然而然我们又要去看看<code>open_driver()</code>函数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">open_driver</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/dev/binder"</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        fcntl(fd, F_SETFD, FD_CLOEXEC);</span><br><span class="line">        <span class="keyword">int</span> vers;</span><br><span class="line">        <span class="keyword">status_t</span> result = ioctl(fd, BINDER_VERSION, &amp;vers);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">            LOGE(<span class="string">"Binder ioctl to obtain version failed: %s"</span>, strerror(errno));</span><br><span class="line">            close(fd);</span><br><span class="line">            fd = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="number">0</span> || vers != BINDER_CURRENT_PROTOCOL_VERSION) &#123;</span><br><span class="line">            LOGE(<span class="string">"Binder driver protocol does not match user space protocol!"</span>);</span><br><span class="line">            close(fd);</span><br><span class="line">            fd = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">size_t</span> maxThreads = <span class="number">15</span>;</span><br><span class="line">        result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">            LOGE(<span class="string">"Binder ioctl to set max threads failed: %s"</span>, strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOGW(<span class="string">"Opening '/dev/binder' failed: %s\n"</span>, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里看到了熟悉的代码：它打开了 Binder 驱动。如果打开成功，它会向驱动发送两个命令，一个是<code>BINDER_VERSION</code>，这个无关紧要，略过；一个是<code>BINDER_SET_MAX_THREADS</code>，这个最终还是会走到<code>binder_ioctrl</code>中去，多余代码就不贴了，直接看这条命令的处理case:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ubuf 指代传递进入驱动的数据</span></span><br><span class="line"><span class="keyword">case</span> BINDER_SET_MAX_THREADS:</span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(&amp;proc-&gt;max_threads, ubuf, <span class="keyword">sizeof</span>(proc-&gt;max_threads))) &#123;</span><br><span class="line">			ret = -EINVAL;</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>这个处理很简单，proc指向的是<code>binder_proc</code>实体，这个结构体中有一个 max_threads 字段，这里就是将传递进来的值赋值到这个字段上，至于字段具体什么作用，后面会讲到。</p>
<p>回到前面，ProcessState 实例在新建的时候就打开了 Binder 驱动，接下去有一句很重要的代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mmap the binder, providing a chunk of virtual address space to receive transactions.</span></span><br><span class="line">mVMStart = mmap(<span class="number">0</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p><code>mmap</code>这个函数不是第一次见，看注释就明白这里是在做什么：这里和 SM 一样，也去 binder 驱动中挖一块内存，便于 Service 和驱动进行通信。按注释的说法，就是 “receive transactions”。</p>
<p>再回到 MS 的<code>main</code>函数，执行完第一句之后，我们创建了一个 ProcessState 实例，在这个实例里面打开了 Binder 驱动并做了内存映射，映射起始地址记录在 mVMStart 变量中。</p>
<p>以下是上面分析的函数调用的关系图：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/ProcessState实例化.png" alt="ProcessState实例化"></div>

<h2 id="获取-SM-实例"><a href="#获取-SM-实例" class="headerlink" title="获取 SM 实例"></a>获取 SM 实例</h2><p>第二行代码是:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br></pre></td></tr></table></figure>
<p>看函数名字以及返回的变量指针，就知道这和 SM 相关 —— 这里实际上就是在获取 SM 实例。这个方法来自哪里呢？”IServiceManager.cpp”:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IServiceManager&gt; defaultServiceManager()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (gDefaultServiceManager != <span class="literal">NULL</span>) <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        AutoMutex _l(gDefaultServiceManagerLock);</span><br><span class="line">        <span class="keyword">if</span> (gDefaultServiceManager == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(</span><br><span class="line">                ProcessState::self()-&gt;getContextObject(<span class="literal">NULL</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又是一个单例方法，调用的是<code>interface_cast&lt;IServiceManager&gt;(ProcessState::self()-&gt;getContextObject(NULL));</code>来实例化返回对象的，这个方法包含很多内容，我们一步一步看。</p>
<h3 id="ProcessState-self-gt-getContextObject-NULL"><a href="#ProcessState-self-gt-getContextObject-NULL" class="headerlink" title="ProcessState::self()-&gt;getContextObject(NULL)"></a><code>ProcessState::self()-&gt;getContextObject(NULL)</code></h3><p>首先是<code>ProcessState::self()-&gt;getContextObject(NULL)</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IBinder&gt; ProcessState::getContextObject(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; caller)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> getStrongProxyForHandle(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(<span class="keyword">int32_t</span> handle)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;IBinder&gt; result;</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// handle 为0</span></span><br><span class="line">    handle_entry* e = lookupHandleLocked(handle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// We need to create a new BpBinder if there isn't currently one, OR we</span></span><br><span class="line">        <span class="comment">// are unable to acquire a weak reference on this current one.  See comment</span></span><br><span class="line">        <span class="comment">// in getWeakProxyForHandle() for more info about this.</span></span><br><span class="line">        IBinder* b = e-&gt;binder;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">NULL</span> || !e-&gt;refs-&gt;attemptIncWeak(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            b = <span class="keyword">new</span> BpBinder(handle); </span><br><span class="line">            e-&gt;binder = b;</span><br><span class="line">            <span class="keyword">if</span> (b) e-&gt;refs = b-&gt;getWeakRefs();</span><br><span class="line">            result = b;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// This little bit of nastyness is to allow us to add a primary</span></span><br><span class="line">            <span class="comment">// reference to the remote proxy when this team doesn't have one</span></span><br><span class="line">            <span class="comment">// but another team is sending the handle to us.</span></span><br><span class="line">            result.force_set(b);</span><br><span class="line">            e-&gt;refs-&gt;decWeak(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上调用的是<code>getStrongProxyForHandle</code>获取的返回值，传入参数0，那么这个方法又在干啥呢？我把代码贴在一块了，很明显它又调用了另外一个方法<code>lookupHandleLocked</code>，继续传递参数0:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用代码：lookupHandleLocked(0);</span></span><br><span class="line">ProcessState::handle_entry* ProcessState::lookupHandleLocked(<span class="keyword">int32_t</span> handle)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> N = mHandleToObject.size();</span><br><span class="line">    <span class="keyword">if</span> (N &lt;= (<span class="keyword">size_t</span>)handle) &#123;</span><br><span class="line">        handle_entry e;</span><br><span class="line">        e.binder = <span class="literal">NULL</span>;</span><br><span class="line">        e.refs = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">status_t</span> err = mHandleToObject.insertAt(e, N, handle+<span class="number">1</span>-N);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;mHandleToObject.editItemAt(handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>mHandleToObject</code>是一个 Vector，它的元素是结构体 handle_entry，声明如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">handle_entry</span> &#123;</span></span><br><span class="line">	IBinder* binder;</span><br><span class="line">	RefBase::weakref_type* refs;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Vector&lt;handle_entry&gt; mHandleToObject;</span><br></pre></td></tr></table></figure>
<p>因为进程刚启动，因此<code>mHandleToObject</code>是空的，因此<code>N &lt;= (size_t)handle</code>判断成立，这样就会新建一个 handle_entry 结构体实例，它的 binder 字段是 NULL 。</p>
<p>新建完成后继续回到<code>getStrongProxyForHandle</code>方法，它会取出 binder 字段，并作如下判断:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (b == <span class="literal">NULL</span> || !e-&gt;refs-&gt;attemptIncWeak(<span class="keyword">this</span>))</span><br></pre></td></tr></table></figure>
<p>binder 字段为 NULL，因此最终会走到:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="keyword">new</span> BpBinder(handle); </span><br><span class="line">e-&gt;binder = b;</span><br><span class="line"><span class="keyword">if</span> (b) e-&gt;refs = b-&gt;getWeakRefs();</span><br><span class="line">result = b;</span><br></pre></td></tr></table></figure>
<p>这里会以 handle 为参数新建一个 BpBinder 对象，并赋值给 e 的 binder 字段，最后这个 b 就被赋值给 result 并作为方法返回值，最终返回到了<code>defaultServiceManager</code>方法中。</p>
<blockquote>
<p>BpBinder 后面再做介绍，我们先把 SM 的实例获取讲完。</p>
</blockquote>
<p>因此下面这句代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface_cast&lt;IServiceManager&gt;(ProcessState::self()-&gt;getContextObject(<span class="literal">NULL</span>))</span><br></pre></td></tr></table></figure>
<p>实际上等于:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface_cast&lt;IServiceManager&gt;(<span class="keyword">new</span> BpBinder(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<h3 id="interface-cast"><a href="#interface-cast" class="headerlink" title="interface_cast"></a><code>interface_cast</code></h3><p>接下来我们来啃<code>interface_cast</code>，它是一个内联的模板函数，定义在 “IInterface.h”中: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</span><br><span class="line"><span class="keyword">inline</span> sp&lt;INTERFACE&gt; interface_cast(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> INTERFACE::asInterface(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以前面那行代码又等价于:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IServiceManager::asInterface(<span class="keyword">new</span> BpBinder(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p><code>asInterface</code>这个方法实际又不是来自<code>IServiceManager</code>，而是来自<code>IInterface</code>（<code>IServiceManager</code>继承于<code>IInterface</code>），所以我们又回到了 “IInterface.h” 这个文件，在这个文件里面又发现这个方法实际上是定义在两个宏里面的:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_META_INTERFACE(INTERFACE)                               \</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> android::String16 descriptor;                          \</span><br><span class="line">    <span class="keyword">static</span> android::sp&lt;I##INTERFACE&gt; asInterface(                       \</span><br><span class="line">            <span class="keyword">const</span> android::sp&lt;android::IBinder&gt;&amp; obj);                  \</span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">const</span> android::<span class="function">String16&amp; <span class="title">getInterfaceDescriptor</span><span class="params">()</span> <span class="keyword">const</span></span>;    \</span><br><span class="line">    I##INTERFACE();                                                     \</span><br><span class="line">    <span class="keyword">virtual</span> ~I##INTERFACE();                                            \</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPLEMENT_META_INTERFACE(INTERFACE, NAME)                       \</span></span><br><span class="line">    <span class="keyword">const</span> android::String16 I##INTERFACE::descriptor(NAME);             \</span><br><span class="line">    <span class="keyword">const</span> android::String16&amp;                                            \</span><br><span class="line">            I##INTERFACE::getInterfaceDescriptor() <span class="keyword">const</span> &#123;              \</span><br><span class="line">        <span class="keyword">return</span> I##INTERFACE::descriptor;                                \</span><br><span class="line">    &#125;                                                                   \</span><br><span class="line">    android::sp&lt;I##INTERFACE&gt; I##INTERFACE::asInterface(                \</span><br><span class="line">            <span class="keyword">const</span> android::sp&lt;android::IBinder&gt;&amp; obj)                   \</span><br><span class="line">    &#123;                                                                   \</span><br><span class="line">        android::sp&lt;I##INTERFACE&gt; intr;                                 \</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="literal">NULL</span>) &#123;                                              \</span><br><span class="line">            intr = <span class="keyword">static_cast</span>&lt;I##INTERFACE*&gt;(                          \</span><br><span class="line">                obj-&gt;queryLocalInterface(                               \</span><br><span class="line">                        I##INTERFACE::descriptor).get());               \</span><br><span class="line">            <span class="keyword">if</span> (intr == <span class="literal">NULL</span>) &#123;                                         \</span><br><span class="line">                intr = <span class="keyword">new</span> Bp##INTERFACE(obj);                          \</span><br><span class="line">            &#125;                                                           \</span><br><span class="line">        &#125;                                                               \</span><br><span class="line">        <span class="keyword">return</span> intr;                                                    \</span><br><span class="line">    &#125;                                                                   \</span><br><span class="line">    I##INTERFACE::I##INTERFACE() &#123; &#125;                                    \</span><br><span class="line">    I##INTERFACE::~I##INTERFACE() &#123; &#125;                                   \</span><br></pre></td></tr></table></figure>
<p>恩…不出意外，子类中应该有相关使用声明。我们回到 “IServiceManager.h” 文件中，果然发现有这么一行代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_META_INTERFACE(ServiceManager);</span><br></pre></td></tr></table></figure>
<p>而在 “IServiceManager.cpp” 中，又有这么一条:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMPLEMENT_META_INTERFACE(ServiceManager, <span class="string">"android.os.IServiceManager"</span>);</span><br></pre></td></tr></table></figure>
<p>看样子搞懂这个宏，就知道<code>interface_cast</code>到底在干什么了。先来看看添加这条语句后倒地增加了什么样的方法:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> android::String16 IServiceManager::descriptor(NAME);</span><br><span class="line"><span class="keyword">const</span> android::String16&amp; IServiceManager::getInterfaceDescriptor() <span class="keyword">const</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> IServiceManager::descriptor;</span><br><span class="line">&#125; </span><br><span class="line">android::sp&lt;IServiceManager&gt; IServiceManager::asInterface(<span class="keyword">const</span> android::sp&lt;android::IBinder&gt;&amp; obj) &#123;</span><br><span class="line">	android::sp&lt;IServiceManager&gt; intr;</span><br><span class="line">	<span class="comment">//还记得obj是啥么？new BpBinder(0)，所以肯定不为null</span></span><br><span class="line">	<span class="keyword">if</span> (obj != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		intr = <span class="keyword">static_cast</span>&lt;IServiceManager*&gt;(obj-&gt;queryLocalInterface(IServiceManager::descriptor).get());</span><br><span class="line">		<span class="keyword">if</span> (intr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			intr = <span class="keyword">new</span> BpServiceManager(obj);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> intr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IServiceManager:: IServiceManager() &#123; &#125;</span><br><span class="line">IServiceManager::~ IServiceManager() &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>哈，看到了我们最想看到的函数，也就是<code>asInterface</code>，这又是在干啥呢？这里调用了一个 <code>queryLocalInterface</code> 方法，我们看看 BpBinder 中的实现，在文件 “Binder.cpp” 中可以找到:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IInterface&gt;  IBinder::queryLocalInterface(<span class="keyword">const</span> String16&amp; descriptor)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此这里就会执行<code>new BpServiceManager(obj)</code>并返回对象，因此下面这句代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface_cast&lt;IServiceManager&gt;(<span class="keyword">new</span> BpBinder(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p>实际上就等于:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> BpServiceManager(<span class="keyword">new</span> BpBinder(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p>通过这样一个语句，我们就可以获得一个 SM 实例。实际上到这里我们只知道 <code>defaultServiceManager()</code> 方法返回了一个<code>IServiceManager</code>的对象，实际指向的是 BpServiceManager 实例，具体这个对象和 SM 什么关系、如何帮助我们完成服务注册我们并不清楚。不要捉急，下面一节讲完就清楚了。</p>
<p>好了，喘口气，下面是调用关系图：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/defaultServiceManager.png" alt="defaultServiceManager调用"></div>

<p>看上去有点复杂，但是更复杂的还在后面。</p>
<h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><p>这里再贴一下<code>main</code>函数的代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> android;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	 <span class="comment">// 实例化 Process</span></span><br><span class="line">    sp&lt;ProcessState&gt; proc(ProcessState::self());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取 SM</span></span><br><span class="line">    sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line">    LOGI(<span class="string">"ServiceManager: %p"</span>, sm.get());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化服务</span></span><br><span class="line">    AudioFlinger::instantiate();</span><br><span class="line">    MediaPlayerService::instantiate();</span><br><span class="line">    CameraService::instantiate();</span><br><span class="line">    AudioPolicyService::instantiate();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 很重要的两个方法，后面分析</span></span><br><span class="line">    ProcessState::self()-&gt;startThreadPool();</span><br><span class="line">    IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从<code>main</code>函数看，到这里主要做了两件事情：</p>
<ol>
<li>初始化 ProcessState 变量，初始化过程主要是打开 binder 驱动，进行内存映射；</li>
<li>获取 defaultServiceManager，它实际上是一个 BpServiceManager 对象；</li>
</ol>
<p>如注释所写，接下去就是要初始化服务了。这下面有很多的服务进行初始化，包括音频，视频，照相机等，我们找<code>MediaPlayerService</code>为例进行研究。因为这部分分析涉及到的函数很多，调用链较长，因此这里先贴一下主要函数调用关系图（看不清可以右击查看大图）：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/服务注册函数调用链.png" alt="服务注册函数调用链"></div>

<p>首先来看 MediaPlayerService 的<code>instantiate()</code>方法了:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MediaPlayerService::instantiate() &#123;</span><br><span class="line">    defaultServiceManager()-&gt;addService(</span><br><span class="line">            String16(<span class="string">"media.player"</span>), <span class="keyword">new</span> MediaPlayerService());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为方法<code>defaultServiceManager()</code>是一个单例方法，因此这里获取到的其实还是前面新建的那个实例。接着调用的就是它的<code>addService</code>方法，我们终于走到了 <strong>服务注册</strong> 的地方！</p>
<p>我们来看这个方法的实现（位于 “IServiceManager.cpp” 中）:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> status_t <span class="title">addService</span><span class="params">(<span class="keyword">const</span> String16&amp; name, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; service)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Parcel data, reply;</span><br><span class="line">	data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());</span><br><span class="line">	data.writeString16(name);</span><br><span class="line">	data.writeStrongBinder(service);</span><br><span class="line">	<span class="keyword">status_t</span> err = remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply);</span><br><span class="line">	<span class="keyword">return</span> err == NO_ERROR ? reply.readExceptionCode() : err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里出了一个和 Android Java 层很相似的概念: Parcel，用于序列化对象。从代码看，它先序列化两个字符串，再序列化 service ，最后通过<code>remote()-&gt;transact()</code>发送到某个地方去了。让我们吸口气，一步步潜下去瞧瞧。</p>
<h3 id="Parcel-序列化"><a href="#Parcel-序列化" class="headerlink" title="Parcel 序列化"></a>Parcel 序列化</h3><p>这里使用 Parcel 对象将数据全部打包，相关方法都集中在<code>Parcel.cpp</code>。前面写入了两个字符串，第一个是 RPC 头部，不需要多关注，实际写入值是 “android.os.IServiceManager” （这个方法建议读者自行查看，其实前面还写入了一些信息，会在下面指出），相关代码直接看 <code>IServiceManager::getInterfaceDescriptor()</code>即可；接着写入参数 name 的值，也就是传入的 “media.player”；最后写入了 Service，这里有必要好好看看方法<code>writeStrongBinder</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> Parcel::writeStrongBinder(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> flatten_binder(ProcessState::self(), val, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> flatten_binder(<span class="keyword">const</span> sp&lt;ProcessState&gt;&amp; proc,</span><br><span class="line">    <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; binder, Parcel* out)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 该结构体在字典中可查</span></span><br><span class="line">    flat_binder_object obj;</span><br><span class="line">    </span><br><span class="line">    obj.flags = <span class="number">0x7f</span> | FLAT_BINDER_FLAG_ACCEPTS_FDS;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//传入的是new MediaPlayerService()，因此不为NULL</span></span><br><span class="line">    <span class="keyword">if</span> (binder != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    	  <span class="comment">// 什么鬼？</span></span><br><span class="line">        IBinder *local = binder-&gt;localBinder();</span><br><span class="line">        <span class="keyword">if</span> (!local) &#123;</span><br><span class="line">            BpBinder *proxy = binder-&gt;remoteBinder();</span><br><span class="line">            <span class="keyword">if</span> (proxy == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                LOGE(<span class="string">"null proxy"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int32_t</span> handle = proxy ? proxy-&gt;handle() : <span class="number">0</span>;</span><br><span class="line">            obj.type = BINDER_TYPE_HANDLE;</span><br><span class="line">            obj.handle = handle;</span><br><span class="line">            obj.cookie = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            obj.type = BINDER_TYPE_BINDER;</span><br><span class="line">            obj.binder = local-&gt;getWeakRefs();</span><br><span class="line">            obj.cookie = local;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        obj.type = BINDER_TYPE_BINDER;</span><br><span class="line">        obj.binder = <span class="literal">NULL</span>;</span><br><span class="line">        obj.cookie = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> finish_flatten_binder(binder, obj, out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它实际调用的是<code>flatten_binder</code>方法，看名字意思是把一个 binder 对象扁平化，看上去很有序列化的味道（想象把一个对象转成 JSON），在这个方法里这个 binder 对象就是我们的<code>new MediaPlayerService()</code>。</p>
<p>后面还调用了很多 binder 的方法，比如<code>localBinder()</code>，<code>remoteBinder()</code>，开始大面积出现 IBinder，BpBinder 等概念，这里必须要分析一下一些类之间的关系，这也是为了方便后面分析。</p>
<p>Binder 机制在 Libraries 层面建立了一组对象，它们协同起来与驱动交互，完成 IPC 功能。这里就不一步步看代码了，直接上关系图:</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/Binder-Lib层架构.png" alt="Binder Lib层架构"></div>

<p>这里直接画上了<code>MediaPlayerService</code>服务并标注了一些重要的属性和方法，好了，看着图我们继续往下走。</p>
<blockquote>
<p>PS: 凡是出现了 MediaPlayerService 的地方，实际都可以由别的 Service 替换。</p>
</blockquote>
<p>首先我们要看的是<code>binder-&gt;localBinder();</code>，这个方法最先声明是在 IBinder 中，我搜索代码只能看到关于该方法如下的实现:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BBinder* IBinder::localBinder()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BpBinder* IBinder::remoteBinder()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说返回为 NULL ，从 MediaPlayerService 到 IBinder 的继承树中再也没有别的实现，但是这个不符合常理：因为这里研究的是如何注册一个 Service，且 MediaPlayerService 确实又是本地的，按照道理<code>localBinder()</code>应该有返回，翻看几篇文章，也没有关于<code>localBinder()</code>方法的其余实现代码的展示，这里留作一个<strong>【疑点】</strong>。</p>
<blockquote>
<p>找的眼睛都快瞎了！</p>
</blockquote>
<p>那么按照常理实际会执行下面的代码才对:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj.type = BINDER_TYPE_BINDER;</span><br><span class="line">obj.binder = local-&gt;getWeakRefs();</span><br><span class="line">obj.cookie = local;</span><br></pre></td></tr></table></figure>
<p>这里会产生一个type为<code>BINDER_TYPE_BINDER</code>的<code>flat_binder_object</code>结构体对象，binder 字段记录的是本地 binder 的弱引用对象，<strong>cookie 中记录的则是本地服务实体的地址</strong>。接着就调用<code>finish_flatten_binder()</code>方法:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> status_t <span class="title">finish_flatten_binder</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; binder, <span class="keyword">const</span> flat_binder_object&amp; flat, Parcel* out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> out-&gt;writeObject(flat, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就只是写入对象了：到这里为止，我们把 Service 的名字和 Service 本身写入到一个Parcel对象中去。现在 out 里面的数据应该是这样的：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/service注册transact数据.png" width="600" alt="service注册transact数据"></div>

<blockquote>
<p>data 中还有一些元数据，比如写入字符串之前会写入字符串长度，图中没有标注出来。</p>
</blockquote>
<p>这张图非常重要，后面直到服务注册成功，这部分数据格式、内容都不会变化，因此在 SM 中注册时候，最后解析的格式还是按照这个顺序进行。<strong>以下称这幅图为 “服务注册初始数据图”</strong> 。</p>
<h3 id="传输数据"><a href="#传输数据" class="headerlink" title="传输数据"></a>传输数据</h3><p>在准备好数据之后，接下来就是调用:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// data 大致就是上图的样子，reply 不为空</span></span><br><span class="line"><span class="keyword">status_t</span> err = remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply);</span><br></pre></td></tr></table></figure>
<p>这里顾名思义是在传输数据。<code>remote()</code>是什么呢？要知道<code>addService()</code>这个方法其实是来自类<code>BpServiceManager</code>的，它和上面类图中的<code>BpMediaPlayerService</code>位置类似，因此这个方法实际来自于<code>BpRefBase</code>。我们看一下这几个类的代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#############  BpServiceManager  ###############</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BpServiceManager</span> :</span> <span class="keyword">public</span> BpInterface&lt;IServiceManager&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BpServiceManager(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; impl)</span><br><span class="line">        : BpInterface&lt;IServiceManager&gt;(impl)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#############  BpInterface  ###############</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BpInterface</span> :</span> <span class="keyword">public</span> INTERFACE, <span class="keyword">public</span> BpRefBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">                                BpInterface(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; remote);</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IBinder*            <span class="title">onAsBinder</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#############  BpRefBase  ###############</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BpRefBase</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">                            BpRefBase(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; o);</span><br><span class="line">    <span class="keyword">virtual</span>                 ~BpRefBase();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>            <span class="title">onFirstRef</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>            <span class="title">onLastStrongRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span>            <span class="title">onIncStrongAttempted</span><span class="params">(<span class="keyword">uint32_t</span> flags, <span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span>  IBinder*        <span class="title">remote</span><span class="params">()</span>                </span>&#123; <span class="keyword">return</span> mRemote; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span>  IBinder*        <span class="title">remote</span><span class="params">()</span> <span class="keyword">const</span>          </span>&#123; <span class="keyword">return</span> mRemote; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">                            BpRefBase(<span class="keyword">const</span> BpRefBase&amp; o);</span><br><span class="line">    BpRefBase&amp;              <span class="keyword">operator</span>=(<span class="keyword">const</span> BpRefBase&amp; o);</span><br><span class="line"></span><br><span class="line">    IBinder* <span class="keyword">const</span>          mRemote;</span><br><span class="line">    RefBase::weakref_type*  mRefs;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span>        mState;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>BpRefBase 的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get() 方法应该是 sp 持有的，可以类比 Java 的弱引用</span></span><br><span class="line">BpRefBase::BpRefBase(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; o)</span><br><span class="line">    : mRemote(o.get()), mRefs(<span class="literal">NULL</span>), mState(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    extendObjectLifetime(OBJECT_LIFETIME_WEAK);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mRemote) &#123;</span><br><span class="line">        mRemote-&gt;incStrong(<span class="keyword">this</span>);           <span class="comment">// Removed on first IncStrong().</span></span><br><span class="line">        mRefs = mRemote-&gt;createWeak(<span class="keyword">this</span>);  <span class="comment">// Held for our entire lifetime.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样很隐蔽，mRemote的赋值来自<code>o.get()</code>，因此<code>remote()</code>返回的实际就是新建 BpServiceManager 时传入的参数，也就是<code>new BpBinder(0)</code>，换句话说，我们应该去 BpBinder 中寻找<code>transact()</code>函数的实现:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用代码：status_t err = remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply);</span></span><br><span class="line"><span class="comment">// 参数解释：data 就是服务注册初始数据图所示内容，reply 是一个 Parcel 对象，flags 默认是 0</span></span><br><span class="line"><span class="keyword">status_t</span> BpBinder::transact(</span><br><span class="line">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Once a binder has died, it will never come back to life.</span></span><br><span class="line">    <span class="keyword">if</span> (mAlive) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里又转到<code>IPCThreadState::self()</code>里面去了，看上去似乎又是一个获取单例的方法，它的方法如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">IPCThreadState* IPCThreadState::self()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (gHaveTLS) &#123;</span><br><span class="line">restart:</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">pthread_key_t</span> k = gTLS;</span><br><span class="line">        IPCThreadState* st = (IPCThreadState*)pthread_getspecific(k);</span><br><span class="line">        <span class="keyword">if</span> (st) <span class="keyword">return</span> st;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IPCThreadState;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (gShutdown) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    pthread_mutex_lock(&amp;gTLSMutex);</span><br><span class="line">    <span class="keyword">if</span> (!gHaveTLS) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pthread_key_create(&amp;gTLS, threadDestructor) != <span class="number">0</span>) &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;gTLSMutex);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        gHaveTLS = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;gTLSMutex);</span><br><span class="line">    <span class="keyword">goto</span> restart;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的实现涉及到一些 Linux 函数以及线程知识：它并不是前面所说的获取单例，而是获取线程变量副本。相似的机制 Java 中也有，可以查看文章 <a href="http://www.muzileecoding.com/java/Java-threadlocal.html" target="_blank" rel="noopener">ThreadLocal 源码剖析</a>，简单来说，就是为每个线程创建一个变量的副本，保证线程之间不共享原有的变量，保证线程内部只有一个该变量的副本。关于这个知识点，在网上找到一篇文章:<a href="http://blog.csdn.net/lmh12506/article/details/8452700" target="_blank" rel="noopener">pthread_key_t和pthread_key_create()详解</a>，读者读完这两篇文章之后，再看这个函数就会比较清晰，这里就不做详细分析了。总结一下该函数: 为该进程中的每一个线程创建唯一一个 IPCThreadState 对象。</p>
<blockquote>
<p>这个创建并不是线程一启动就进行的，而是在这个变量中获取该变量的时候进行创建的。</p>
</blockquote>
<p>好，咱继续走！创建之后调用的是 IPCThreadState 的<code>transact()</code>函数: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用代码: status_t status = IPCThreadState::self()-&gt;transact(mHandle, code, data, reply, flags);</span></span><br><span class="line"><span class="comment">// 参数解释: handle 是 BpBinder 的实例化参数，也就是0，code 是 ADD_SERVICE_TRANSACTION，flags是0</span></span><br><span class="line"><span class="keyword">status_t</span> IPCThreadState::transact(<span class="keyword">int32_t</span> handle,</span><br><span class="line">                                  <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data,</span><br><span class="line">                                  Parcel* reply, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">status_t</span> err = data.errorCheck();</span><br><span class="line"></span><br><span class="line">    flags |= TF_ACCEPT_FDS;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">// 数据没有问题，判断通过</span></span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err);</span><br><span class="line">        <span class="keyword">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">            err = waitForResponse(reply);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err = waitForResponse(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = waitForResponse(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法删除一些Log和无用代码之后，大致就是上面这个样子。首先进来调用的就是<code>writeTransactionData()</code>方法:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用代码: writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL);</span></span><br><span class="line"><span class="comment">// 参数解释: handle 为0，code 为 ADD_SERVICE_TRANSACTION， binderFlags 是 TF_ACCEPT_FDS;</span></span><br><span class="line"><span class="keyword">status_t</span> IPCThreadState::writeTransactionData(<span class="keyword">int32_t</span> cmd, <span class="keyword">uint32_t</span> binderFlags,</span><br><span class="line">    <span class="keyword">int32_t</span> handle, <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, <span class="keyword">status_t</span>* statusBuffer)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 该结构体在字典中可查</span></span><br><span class="line">    binder_transaction_data tr;</span><br><span class="line"></span><br><span class="line">    tr.target.handle = handle;</span><br><span class="line">    tr.code = code;</span><br><span class="line">    tr.flags = binderFlags;</span><br><span class="line">    tr.cookie = <span class="number">0</span>;</span><br><span class="line">    tr.sender_pid = <span class="number">0</span>;</span><br><span class="line">    tr.sender_euid = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">status_t</span> err = data.errorCheck();</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">    	<span class="comment">// 将之前写在 data 中的数据再换一种形式写到 binder_transaction_data 中</span></span><br><span class="line">        tr.data_size = data.ipcDataSize(); </span><br><span class="line">        tr.data.ptr.buffer = data.ipcData(); </span><br><span class="line">        tr.offsets_size = data.ipcObjectsCount()*<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>);</span><br><span class="line">        tr.data.ptr.offsets = data.ipcObjects(); </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusBuffer) &#123;</span><br><span class="line">        tr.flags |= TF_STATUS_CODE;</span><br><span class="line">        *statusBuffer = err;</span><br><span class="line">        tr.data_size = <span class="keyword">sizeof</span>(<span class="keyword">status_t</span>);</span><br><span class="line">        tr.data.ptr.buffer = statusBuffer;</span><br><span class="line">        tr.offsets_size = <span class="number">0</span>;</span><br><span class="line">        tr.data.ptr.offsets = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mOut.writeInt32(cmd);<span class="comment">//BC_TRANSACTION</span></span><br><span class="line">    mOut.write(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们终于遇到一直在等待的重要结构体了: binder_transaction_data。</p>
<blockquote>
<p>如果读者看过推荐文章①，一定知道 binder_transaction 表示IPC之间的一个请求，而  binder_transaction_data 就是为了这样一个事务包装的结构体对象。</p>
</blockquote>
<p>这里主要将之前写入 Parcel 的数据再设置到 binder_transaction_data 结构体中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tr.data_size = data.ipcDataSize();  <span class="comment">//记录数据大小</span></span><br><span class="line">tr.data.ptr.buffer = data.ipcData();  <span class="comment">// 记录数据内容</span></span><br><span class="line">tr.offsets_size = data.ipcObjectsCount()*<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>);</span><br><span class="line">tr.data.ptr.offsets = data.ipcObjects();</span><br></pre></td></tr></table></figure>
<p>这四个数据是有必要说道说道的，前两个很简单，就是我们之前写入的数据尺寸以及内容（注意，内容没有变），内容就是”服务注册初始数据图”所绘制的。后两个要注意了：这两个数据就是为了 flat_binder_object 准备的，在最终传输的数据中，我们是需要记录哪些位置存放着 flat_binder_object 对象的，其中<code>tr.data.ptr.offsets</code>中存放的就是每个对象实际的偏移量，<code>tr.offsets_size</code>中存放的就是这些偏移数据的大小 —— 记录这些元数据是为后面可以再反序列化出 flat_binder_object 对象。</p>
<p>那么问题来了，mOut 是什么东西呢？它也是个 Parcel 对象，它在<code>IPCThreadState</code>初始化的时候被设置相应的初始值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">IPCThreadState::IPCThreadState()</span><br><span class="line">    : mProcess(ProcessState::self()),</span><br><span class="line">      mMyThreadId(androidGetTid()),</span><br><span class="line">      mStrictModePolicy(<span class="number">0</span>),</span><br><span class="line">      mLastTransactionBinderFlags(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_setspecific(gTLS, <span class="keyword">this</span>);</span><br><span class="line">    clearCaller();</span><br><span class="line">    <span class="comment">// 注意，这两个变量的容量都不为0</span></span><br><span class="line">    mIn.setDataCapacity(<span class="number">256</span>);</span><br><span class="line">    mOut.setDataCapacity(<span class="number">256</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行完成<code>writeTransactionData</code>之后数据都被写入了 mOut 内，那是在哪里发送数据到驱动层的呢？回到<code>IPCThreadState::transact()</code>方法，在调用<code>writeTransactionData()</code>方法之后，做了一些错误检测，之后就是调用函数<code>waitForResponse()</code>，代码删减一下如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::waitForResponse(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> cmd;</span><br><span class="line">    <span class="keyword">int32_t</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((err = talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        err = mIn.errorCheck();</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (mIn.dataAvail() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 注意：下面有一段很长的命令解析，这段数据来自驱动。等分析完数据的发送之后，我们还会回到这里</span></span><br><span class="line">        cmd = mIn.readInt32();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            err = executeCommand(cmd);</span><br><span class="line">            <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里又调用了一个<code>talkWithDriver()</code>函数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法声明的时候默认 doReceive 是 true</span></span><br><span class="line"><span class="keyword">status_t</span> IPCThreadState::talkWithDriver(<span class="keyword">bool</span> doReceive)</span><br><span class="line">&#123;</span><br><span class="line">    LOG_ASSERT(mProcess-&gt;mDriverFD &gt;= <span class="number">0</span>, <span class="string">"Binder driver is not opened"</span>);</span><br><span class="line">    </span><br><span class="line">    binder_write_read bwr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Is the read buffer empty?</span></span><br><span class="line">    <span class="comment">// 为 true</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> needRead = mIn.dataPosition() &gt;= mIn.dataSize();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// We don't want to write anything if we are still reading</span></span><br><span class="line">    <span class="comment">// from data left in the input buffer and the caller</span></span><br><span class="line">    <span class="comment">// has requested to read the next data.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> outAvail = (!doReceive || needRead) ? mOut.dataSize() : <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将 mOut中 的数据写入到bwr中</span></span><br><span class="line">    bwr.write_size = outAvail;</span><br><span class="line">    bwr.write_buffer = (<span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)mOut.data();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is what we'll read. 这两个变量名取得很好</span></span><br><span class="line">    <span class="keyword">if</span> (doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">    	<span class="comment">//注意：前面说了，这个 mIn 在 IPCThreadState 中初始化的时候就被设置为 256 的容量</span></span><br><span class="line">        bwr.read_size = mIn.dataCapacity();</span><br><span class="line">        bwr.read_buffer = (<span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)mIn.data();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bwr.read_size = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Return immediately if there is nothing to do.</span></span><br><span class="line">    <span class="keyword">if</span> ((bwr.write_size == <span class="number">0</span>) &amp;&amp; (bwr.read_size == <span class="number">0</span>)) <span class="keyword">return</span> NO_ERROR;</span><br><span class="line"></span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> defined(HAVE_ANDROID_OS)</span></span><br><span class="line">        <span class="keyword">if</span> (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</span><br><span class="line">            err = NO_ERROR;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err = -errno;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        err = INVALID_OPERATION;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (err == -EINTR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err &gt;= NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bwr.write_consumed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bwr.write_consumed &lt; (<span class="keyword">ssize_t</span>)mOut.dataSize())</span><br><span class="line">                mOut.remove(<span class="number">0</span>, bwr.write_consumed);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mOut.setDataSize(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bwr.read_consumed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mIn.setDataSize(bwr.read_consumed);</span><br><span class="line">            mIn.setDataPosition(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在和驱动交互之前，还是需要把数据写入 binder_write_read 结构体中，然后使用<code>ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr)</code>命令将数据写入驱动。</p>
<blockquote>
<p>这里是第二次遇到这种模式了。这里做了一点小修改：通过两个 Parcel 对象进行数据读写，bwr 是这两个对象和驱动层交互的介质。</p>
</blockquote>
<p>回想一下这个时候 <code>mOut.data()</code>，也就是bwr.write_buffer中是什么内容？ <strong>是一个命令 <code>BC_TRANSACTION</code> + <code>binder_transaction_data</code>结构体，<code>binder_transaction_data</code>结构体中记录着服务注册初始数据图中所描述的 data 数据结构以及一些元数据(具体转换都在<code>IPCThreadState::writeTransactionData()</code>方法中)。</strong></p>
<p>接着来！看来要知道如何注册的，问题就在于解析<code>ioctl</code>期间到底发生了什么事情，我们来看一下驱动层对于<code>BINDER_WRITE_READ</code>的命令的解析，之前已经有过类似的例子，执行如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">binder_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> BINDER_WRITE_READ: &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">        <span class="keyword">if</span> (size != <span class="keyword">sizeof</span>(struct binder_write_read)) &#123;</span><br><span class="line">            ret = -EINVAL;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(&amp;bwr, ubuf, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">            ret = -EFAULT;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;<span class="comment">//写入内容</span></span><br><span class="line">            <span class="comment">//参数：前两个表示发起传输动作的进程和线程</span></span><br><span class="line">            ret = binder_thread_write(proc, thread, (<span class="keyword">void</span> __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);</span><br><span class="line">            trace_binder_write_done(ret);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">                    ret = -EFAULT;</span><br><span class="line">                <span class="keyword">goto</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// write之后紧接着调用read</span></span><br><span class="line">        <span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;<span class="comment">//读取内容</span></span><br><span class="line">            ret = binder_thread_read(proc, thread, (<span class="keyword">void</span> __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK);</span><br><span class="line">            trace_binder_read_done(ret);</span><br><span class="line">            <span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo))</span><br><span class="line">                wake_up_interruptible(&amp;proc-&gt;wait);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">                    ret = -EFAULT;</span><br><span class="line">                <span class="keyword">goto</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再写回去</span></span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">            ret = -EFAULT;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里<code>bwr.write_size</code>和<code>bwr.read_size</code>都大于 0，我们先来看<code>binder_thread_write</code>。这个函数解析的时候会首先读取一个 cmd 参数，从前面的代码中不难发现，这个 cmd 是<code>BC_TRANSACTION</code>，它的处理如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> BC_TRANSACTION:</span><br><span class="line"><span class="keyword">case</span> BC_REPLY: &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line">		<span class="comment">// 从用户空间拷贝到内核空间</span></span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(&amp;tr, ptr, <span class="keyword">sizeof</span>(tr)))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		<span class="comment">// 已经读取了tr，向后移动指针</span></span><br><span class="line">		ptr += <span class="keyword">sizeof</span>(tr);</span><br><span class="line">		</span><br><span class="line">		binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面几步都已经比较熟悉，数据读取和写入一一对应，binder_transaction_data 对应数据被复制到驱动层。最后调用的是<code>binder_transaction</code>函数进行解析，前面两个参数很熟悉，最后一个参数为 false 。</p>
<blockquote>
<p>让我哭一会儿，这个方法在源码里面是一个 400 多行的函数….我要罢工了！</p>
</blockquote>
<p>删删删，删完之后还剩下这么多: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tr 的 write 数据中有 binder 节点信息，就是之前写入mOut中的数据</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_transaction</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_transaction_data *tr, <span class="keyword">int</span> reply)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">tcomplete</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> *offp, *off_end;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">target_proc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">target_thread</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">target_list</span>;</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> *target_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">in_reply_to</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_log_entry</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> return_error;</span><br><span class="line">    e = binder_transaction_log_add(&amp;binder_transaction_log);</span><br><span class="line">    e-&gt;call_type = reply ? <span class="number">2</span> : !!(tr-&gt;flags &amp; TF_ONE_WAY);</span><br><span class="line">    e-&gt;from_proc = proc-&gt;pid;</span><br><span class="line">    e-&gt;from_thread = thread-&gt;pid;</span><br><span class="line">    e-&gt;target_handle = tr-&gt;target.handle;</span><br><span class="line">    e-&gt;data_size = tr-&gt;data_size;</span><br><span class="line">    e-&gt;offsets_size = tr-&gt;offsets_size;</span><br><span class="line">    <span class="comment">// transaction 和 reply 是同一个处理流程，但这里是transaction，因此 reply 为false</span></span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 在 IPCThreadState::writeTransactionData 可以看到 handle 被赋值了，</span></span><br><span class="line">        <span class="comment">// 而且解析中特意指出这个 handle 为 0，因此这个判断不成立</span></span><br><span class="line">        <span class="keyword">if</span> (tr-&gt;target.handle) &#123;</span><br><span class="line">            struct binder_ref *ref;</span><br><span class="line">            ref = binder_get_ref(proc, tr-&gt;target.handle);</span><br><span class="line">            <span class="keyword">if</span> (ref == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                binder_user_error(<span class="string">"binder: %d:%d got "</span></span><br><span class="line">                    <span class="string">"transaction to invalid handle\n"</span>,</span><br><span class="line">                    proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">                return_error = BR_FAILED_REPLY;</span><br><span class="line">                <span class="keyword">goto</span> err_invalid_target_handle;</span><br><span class="line">            &#125;</span><br><span class="line">            target_node = ref-&gt;node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="comment">// target_node: 目标节点，前面分析说了，binder_node 表示一个服务节点，</span></span><br><span class="line">            <span class="comment">// 这里的目标节点的含义就是发送请求的目标节点，这里是在注册服务，所以目标</span></span><br><span class="line">            <span class="comment">// 节点就是 binder_context_mgr_node，也就是 SM 注册成为守护进程的时</span></span><br><span class="line">            <span class="comment">// 候生成的节点：这也就是说 handle = 0就代表着指向 SM 服务节点。</span></span><br><span class="line">            target_node = binder_context_mgr_node;</span><br><span class="line">            <span class="keyword">if</span> (target_node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                return_error = BR_DEAD_REPLY;</span><br><span class="line">                <span class="keyword">goto</span> err_no_context_mgr_node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        e-&gt;to_node = target_node-&gt;debug_id;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取目标节点所在的进程，也就是 SM 服务进程(在binder_new_node()方法中新建node的时候进行了赋值)</span></span><br><span class="line">        target_proc = target_node-&gt;proc;</span><br><span class="line">        <span class="keyword">if</span> (target_proc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            return_error = BR_DEAD_REPLY;</span><br><span class="line">            <span class="keyword">goto</span> err_dead_binder;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 权限检测</span></span><br><span class="line">        <span class="keyword">if</span> (security_binder_transaction(proc-&gt;tsk, target_proc-&gt;tsk) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            return_error = BR_FAILED_REPLY;</span><br><span class="line">            <span class="keyword">goto</span> err_invalid_target_handle;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// thread-&gt;transaction_stack 为 null，不成立</span></span><br><span class="line">        <span class="keyword">if</span> (!(tr-&gt;flags &amp; TF_ONE_WAY) &amp;&amp; thread-&gt;transaction_stack) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">tmp</span>;</span></span><br><span class="line">            tmp = thread-&gt;transaction_stack;</span><br><span class="line">            <span class="keyword">if</span> (tmp-&gt;to_thread != thread) &#123;</span><br><span class="line">                binder_user_error(<span class="string">"binder: %d:%d got new "</span></span><br><span class="line">                    <span class="string">"transaction with bad transaction stack"</span></span><br><span class="line">                    <span class="string">", transaction %d has target %d:%d\n"</span>,</span><br><span class="line">                    proc-&gt;pid, thread-&gt;pid, tmp-&gt;debug_id,</span><br><span class="line">                    tmp-&gt;to_proc ? tmp-&gt;to_proc-&gt;pid : <span class="number">0</span>,</span><br><span class="line">                    tmp-&gt;to_thread ?</span><br><span class="line">                    tmp-&gt;to_thread-&gt;pid : <span class="number">0</span>);</span><br><span class="line">                return_error = BR_FAILED_REPLY;</span><br><span class="line">                <span class="keyword">goto</span> err_bad_call_stack;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tmp-&gt;from &amp;&amp; tmp-&gt;from-&gt;proc == target_proc)</span><br><span class="line">                    target_thread = tmp-&gt;from;</span><br><span class="line">                tmp = tmp-&gt;from_parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果找到了合适的线程，获取目标线程的两组List，实际这里 target_thread 为 NULL</span></span><br><span class="line">    <span class="keyword">if</span> (target_thread) &#123;</span><br><span class="line">        e-&gt;to_thread = target_thread-&gt;pid;</span><br><span class="line">        target_list = &amp;target_thread-&gt;todo;</span><br><span class="line">        target_wait = &amp;target_thread-&gt;wait;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则获取目标进程的两组List</span></span><br><span class="line">        target_list = &amp;target_proc-&gt;todo;</span><br><span class="line">        target_wait = &amp;target_proc-&gt;wait;</span><br><span class="line">    &#125;</span><br><span class="line">    e-&gt;to_proc = target_proc-&gt;pid;</span><br><span class="line">    <span class="comment">/* <span class="doctag">TODO:</span> reuse incoming transaction for reply */</span></span><br><span class="line">    <span class="comment">// t 是 binder_transaction 结构体，该结构体可以在字典中查询</span></span><br><span class="line">    t = kzalloc(<span class="keyword">sizeof</span>(*t), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        return_error = BR_FAILED_REPLY;</span><br><span class="line">        <span class="keyword">goto</span> err_alloc_t_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    binder_stats_created(BINDER_STAT_TRANSACTION);</span><br><span class="line">    <span class="comment">// tcomplete 是 binder_work 结构体，该结构体可以在字典中查询</span></span><br><span class="line">    tcomplete = kzalloc(<span class="keyword">sizeof</span>(*tcomplete), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (tcomplete == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        return_error = BR_FAILED_REPLY;</span><br><span class="line">        <span class="keyword">goto</span> err_alloc_tcomplete_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    binder_stats_created(BINDER_STAT_TRANSACTION_COMPLETE);</span><br><span class="line">    t-&gt;debug_id = ++binder_last_id;</span><br><span class="line">    e-&gt;debug_id = t-&gt;debug_id;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// reply 为 false， tr-flags 为 TF_ACCEPT_FDS，因此成立</span></span><br><span class="line">    <span class="keyword">if</span> (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY))</span><br><span class="line">        t-&gt;from = thread; <span class="comment">// 指向当前线程</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        t-&gt;from = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为 binder_transaction 结构体设置属性，包括把该 transaction 交给哪个 proc，哪个 thread</span></span><br><span class="line">    t-&gt;sender_euid = proc-&gt;tsk-&gt;cred-&gt;euid;</span><br><span class="line">    t-&gt;to_proc = target_proc;</span><br><span class="line">    t-&gt;to_thread = target_thread;</span><br><span class="line">    <span class="comment">// code 为 ADD_SERVICE_TRANSACTION</span></span><br><span class="line">    t-&gt;code = tr-&gt;code;</span><br><span class="line">    t-&gt;flags = tr-&gt;flags;</span><br><span class="line">    t-&gt;priority = task_nice(current);</span><br><span class="line">    trace_binder_transaction(reply, t, target_node);</span><br><span class="line">    <span class="comment">// 注意，这是在target_proc中进行内存分配，包括数据填入</span></span><br><span class="line">    t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size,</span><br><span class="line">        tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;buffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        return_error = BR_FAILED_REPLY;</span><br><span class="line">        <span class="keyword">goto</span> err_binder_alloc_buf_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;buffer-&gt;allow_user_free = <span class="number">0</span>;</span><br><span class="line">    t-&gt;buffer-&gt;debug_id = t-&gt;debug_id;</span><br><span class="line">    t-&gt;buffer-&gt;transaction = t;</span><br><span class="line">    t-&gt;buffer-&gt;target_node = target_node;</span><br><span class="line">    trace_binder_transaction_alloc_buf(t-&gt;buffer);</span><br><span class="line">    <span class="comment">// 增加引用计数</span></span><br><span class="line">    <span class="keyword">if</span> (target_node)</span><br><span class="line">        binder_inc_node(target_node, <span class="number">1</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    offp = (<span class="keyword">size_t</span> *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拷贝 transaction 数据</span></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) &#123;</span><br><span class="line">        binder_user_error(<span class="string">"binder: %d:%d got transaction with invalid "</span></span><br><span class="line">            <span class="string">"data ptr\n"</span>, proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">        return_error = BR_FAILED_REPLY;</span><br><span class="line">        <span class="keyword">goto</span> err_copy_data_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拷贝 transaction offset指针</span></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) &#123;</span><br><span class="line">        binder_user_error(<span class="string">"binder: %d:%d got transaction with invalid "</span></span><br><span class="line">            <span class="string">"offsets ptr\n"</span>, proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">        return_error = BR_FAILED_REPLY;</span><br><span class="line">        <span class="keyword">goto</span> err_copy_data_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// offsets 数据记录末尾</span></span><br><span class="line">    off_end = (<span class="keyword">void</span> *)offp + tr-&gt;offsets_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 flat_binder_object </span></span><br><span class="line">    <span class="keyword">for</span> (; offp &lt; off_end; offp++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> *<span class="title">fp</span>;</span></span><br><span class="line">        <span class="keyword">if</span> (*offp &gt; t-&gt;buffer-&gt;data_size - <span class="keyword">sizeof</span>(*fp) ||</span><br><span class="line">            t-&gt;buffer-&gt;data_size &lt; <span class="keyword">sizeof</span>(*fp) ||</span><br><span class="line">            !IS_ALIGNED(*offp, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *))) &#123;</span><br><span class="line">            binder_user_error(<span class="string">"binder: %d:%d got transaction with "</span></span><br><span class="line">                <span class="string">"invalid offset, %zd\n"</span>,</span><br><span class="line">                proc-&gt;pid, thread-&gt;pid, *offp);</span><br><span class="line">            return_error = BR_FAILED_REPLY;</span><br><span class="line">            <span class="keyword">goto</span> err_bad_offset;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 我们之前存进去的扁平化的flat_binder_object对象</span></span><br><span class="line">        fp = (struct flat_binder_object *)(t-&gt;buffer-&gt;data + *offp);</span><br><span class="line">        <span class="keyword">switch</span> (fp-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_BINDER:</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_WEAK_BINDER: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span> *<span class="title">ref</span>;</span></span><br><span class="line">            <span class="comment">// 获取Binder实体节点，这个proc表示当前进程，也就是发起命令的进程，</span></span><br><span class="line">            <span class="comment">// 初次注册，通过binder_get_node拿不到Binder节点</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">node</span> = <span class="title">binder_get_node</span>(<span class="title">proc</span>, <span class="title">fp</span>-&gt;<span class="title">binder</span>);</span></span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">// 新建binder节点，这个方法之前分析过了：会在proc的nodes红黑树上</span></span><br><span class="line">                <span class="comment">// 创建对应的binder节点，表示该proc提供该服务，这里要注意的是，和</span></span><br><span class="line">                <span class="comment">// SM 不同，这里后面两个参数都实际传递了值进去，因此，binder_node</span></span><br><span class="line">                <span class="comment">// 可以根据cookie来寻找 Libraries 层的服务位置，也就是</span></span><br><span class="line">                <span class="comment">// BBinder —— 我们要注册的服务。</span></span><br><span class="line">                node = binder_new_node(proc, fp-&gt;binder, fp-&gt;cookie);</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    return_error = BR_FAILED_REPLY;</span><br><span class="line">                    <span class="keyword">goto</span> err_binder_new_node_failed;</span><br><span class="line">                &#125;</span><br><span class="line">                node-&gt;min_priority = fp-&gt;flags &amp; FLAT_BINDER_FLAG_PRIORITY_MASK;</span><br><span class="line">                node-&gt;accept_fds = !!(fp-&gt;flags &amp; FLAT_BINDER_FLAG_ACCEPTS_FDS);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 保证指针值一致</span></span><br><span class="line">            <span class="keyword">if</span> (fp-&gt;cookie != node-&gt;cookie) &#123;</span><br><span class="line">                binder_user_error(<span class="string">"binder: %d:%d sending u%p "</span></span><br><span class="line">                    <span class="string">"node %d, cookie mismatch %p != %p\n"</span>,</span><br><span class="line">                    proc-&gt;pid, thread-&gt;pid,</span><br><span class="line">                    fp-&gt;binder, node-&gt;debug_id,</span><br><span class="line">                    fp-&gt;cookie, node-&gt;cookie);</span><br><span class="line">                <span class="keyword">goto</span> err_binder_get_ref_for_node_failed;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (security_binder_transfer_binder(proc-&gt;tsk, target_proc-&gt;tsk)) &#123;</span><br><span class="line">                return_error = BR_FAILED_REPLY;</span><br><span class="line">                <span class="keyword">goto</span> err_binder_get_ref_for_node_failed;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建好对应的 binder_node 之后，去对应的 target_proc中寻找是否有该node的引用</span></span><br><span class="line">            <span class="comment">// 没有的话，binder_get_ref_for_node 会新建一个 binder_ref 对象，插入到我们之</span></span><br><span class="line">            <span class="comment">// 前提到过的 binder_proc 的四棵红黑树中的两棵里面去，分别是 refs_by_node 和</span></span><br><span class="line">            <span class="comment">// refs_by_desc。注意，binder_ref 中也包含了该node的引用。</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// binder_get_ref_for_node 寻找 binder_ref 的过程是直接通过比较node来进行的。</span></span><br><span class="line">            ref = binder_get_ref_for_node(target_proc, node);</span><br><span class="line">            <span class="keyword">if</span> (ref == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                return_error = BR_FAILED_REPLY;</span><br><span class="line">                <span class="keyword">goto</span> err_binder_get_ref_for_node_failed;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 前面提到过，binder 驱动会更改类型</span></span><br><span class="line">            <span class="keyword">if</span> (fp-&gt;type == BINDER_TYPE_BINDER)</span><br><span class="line">                fp-&gt;type = BINDER_TYPE_HANDLE;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                fp-&gt;type = BINDER_TYPE_WEAK_HANDLE;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 同前面提到过，这里也会更改数据。</span></span><br><span class="line">            <span class="comment">// desc 值，其实就是该 binder_node 节点在 target_proc 中的 handle，通过这个handle</span></span><br><span class="line">            <span class="comment">// 可以直接找到对应的 binder_node 节点，也就是找到对应的服务，这里解释的可能不清楚，等</span></span><br><span class="line">            <span class="comment">// 下一篇文章讲述获取服务的时候，这里就很清楚了。</span></span><br><span class="line">            fp-&gt;handle = ref-&gt;desc;</span><br><span class="line">            binder_inc_ref(ref, fp-&gt;type == BINDER_TYPE_HANDLE,</span><br><span class="line">                       &amp;thread-&gt;todo);</span><br><span class="line">            trace_binder_transaction_node_to_ref(t, node, ref);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123; <span class="comment">// 成立</span></span><br><span class="line">        BUG_ON(t-&gt;buffer-&gt;async_transaction != <span class="number">0</span>);</span><br><span class="line">        t-&gt;need_reply = <span class="number">1</span>;</span><br><span class="line">        t-&gt;from_parent = thread-&gt;transaction_stack;</span><br><span class="line">        <span class="comment">// 记录这个transaction，等下 SM 回复的时候需要使用这个 transaction</span></span><br><span class="line">        thread-&gt;transaction_stack = t; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// t-&gt;work 是 binder_work 结构体，该结构体在字典中可查询</span></span><br><span class="line">    t-&gt;work.type = BINDER_WORK_TRANSACTION;</span><br><span class="line">    <span class="comment">// 添加 t 到目标进程的todo list中去</span></span><br><span class="line">    list_add_tail(&amp;t-&gt;work.entry, target_list);</span><br><span class="line">    tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;</span><br><span class="line">    <span class="comment">// 添加到当前线程的 todo list中去</span></span><br><span class="line">    list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);</span><br><span class="line">    <span class="comment">// 唤醒队列</span></span><br><span class="line">    <span class="keyword">if</span> (target_wait)</span><br><span class="line">        wake_up_interruptible(target_wait);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是有200多行…这里我直接在代码里面添加注释来解析代码。到这里我们在目标线程中插入了一个<code>binder_transaction</code>，这里的目标进程就是 SM 进程；并在自己线程的 todo 列表中插入了一个<code>binder_work</code>结构体实例（这个结构体，等会儿 SM 回复的时候需要使用）。</p>
<p>里面有一个重要函数，这里也使用这种方式进行分析:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数解释：proc 是目标进程，这里就是指 SM，node 是指服务节点，这里代指 MS 服务 binder 节点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct binder_ref *<span class="title">binder_get_ref_for_node</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                          struct binder_node *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">n</span>;</span></span><br><span class="line">    <span class="comment">// 红黑树</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">p</span> = &amp;<span class="title">proc</span>-&gt;<span class="title">refs_by_node</span>.<span class="title">rb_node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="comment">// 该结构体字典中可查</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span> *<span class="title">ref</span>, *<span class="title">new_ref</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过比较 node 来寻找对应的 binder_ref 对象</span></span><br><span class="line">    <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">        parent = *p;</span><br><span class="line">        ref = rb_entry(parent, struct binder_ref, rb_node_node);</span><br><span class="line">        <span class="keyword">if</span> (node &lt; ref-&gt;node)</span><br><span class="line">            p = &amp;(*p)-&gt;rb_left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node &gt; ref-&gt;node)</span><br><span class="line">            p = &amp;(*p)-&gt;rb_right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> ref;</span><br><span class="line">    &#125;</span><br><span class="line">    new_ref = kzalloc(<span class="keyword">sizeof</span>(*ref), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (new_ref == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    binder_stats_created(BINDER_STAT_REF);</span><br><span class="line">    new_ref-&gt;debug_id = ++binder_last_id;</span><br><span class="line">    new_ref-&gt;proc = proc;</span><br><span class="line">    <span class="comment">// 注意：binder_ref 中是直接携带 node 引用的，因为在驱动中node以及引用都在</span></span><br><span class="line">    <span class="comment">// 同一个内存空间，因此这样的赋值是可以的。</span></span><br><span class="line">    new_ref-&gt;node = node;</span><br><span class="line">    rb_link_node(&amp;new_ref-&gt;rb_node_node, parent, p);</span><br><span class="line">    <span class="comment">// 将红黑树节点插入到 refs_by_node 中</span></span><br><span class="line">    rb_insert_color(&amp;new_ref-&gt;rb_node_node, &amp;proc-&gt;refs_by_node);</span><br><span class="line">    new_ref-&gt;desc = (node == binder_context_mgr_node) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成desc值，实际就是一个 binder_node 节点在 target_proc 中的 handle 值</span></span><br><span class="line">    <span class="keyword">for</span> (n = rb_first(&amp;proc-&gt;refs_by_desc); n != <span class="literal">NULL</span>; n = rb_next(n)) &#123;</span><br><span class="line">        ref = rb_entry(n, struct binder_ref, rb_node_desc);</span><br><span class="line">        <span class="keyword">if</span> (ref-&gt;desc &gt; new_ref-&gt;desc)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        new_ref-&gt;desc = ref-&gt;desc + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//红黑树操作</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> new_ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结一下这一段代码中有关 binder_node 和 binder_ref 的操作：</p>
<p><strong>当一个<code>BC_TRANSACTION</code>命令被处理的时候，binder 驱动会根据携带的元数据解析数据内容，查看是否有 binder 节点信息，如果存在 binder 节点，那么会检测当前进程的<code>binder_proc</code>结构体的红黑树中是否存在代表该节点的<code>binder_node</code>结构体，如果没有则需要新建并放到红黑树中去，其次会检测目标进程是否有对该节点的引用，如果没有，则需要新建<code>binder_ref</code>结构体并挂载到目标进程的红黑树中</strong>。</p>
<h3 id="与-SM-接头"><a href="#与-SM-接头" class="headerlink" title="与 SM 接头"></a>与 SM 接头</h3><p>列出的<code>binder_transaction</code>方法代码的最后几句如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//唤醒队列</span></span><br><span class="line"><span class="keyword">if</span> (target_wait)</span><br><span class="line">	wake_up_interruptible(target_wait);</span><br></pre></td></tr></table></figure>
<p>还记得我们分析 SM 的时候，在循环监听部分，它在最后做的是什么吗？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret = wait_event_freezable_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread));</span><br></pre></td></tr></table></figure>
<p>一看就是对应的好么！碰巧上面的 target_wait 就是 SM 的 wait 队列，因此<code>wake_up_interruptible</code>就唤醒了正在等待的 SM 服务。所以我们又转回 SM。但在转到 SM 之前，我们得知道 MS 后面会做什么？</p>
<h3 id="等待-SM-的答复"><a href="#等待-SM-的答复" class="headerlink" title="等待 SM 的答复"></a>等待 SM 的答复</h3><p><code>binder_transaction</code>方法执行完毕之后，<code>binder_thread_write</code>函数也执行完毕，返回到<code>binder_ioctl</code>函数。接下去要执行如下代码: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// write之后紧接着调用read</span></span><br><span class="line"><span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;<span class="comment">//读取内容</span></span><br><span class="line">	ret = binder_thread_read(proc, thread, (<span class="keyword">void</span> __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK);</span><br><span class="line">	trace_binder_read_done(ret);</span><br><span class="line">	<span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo))</span><br><span class="line">		wake_up_interruptible(&amp;proc-&gt;wait);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">			ret = -EFAULT;</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//再写回去</span></span><br><span class="line"><span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">	ret = -EFAULT;</span><br><span class="line">	<span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>bwr</code> 变量在传入之前赋值如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bwr.read_size = mIn.dataCapacity(); <span class="comment">// 256</span></span><br><span class="line">bwr.read_buffer = (<span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)mIn.data();</span><br><span class="line">bwr.read_consumed = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><code>bwr.read_size &gt; 0</code>这个判断是成立的，因此我们进入<code>binder_thread_read</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_read</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                  struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">void</span>  __user *buffer, <span class="keyword">int</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">signed</span> <span class="keyword">long</span> *consumed, <span class="keyword">int</span> non_block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// ptr 指向 read_buffer的起始位置</span></span><br><span class="line">    <span class="keyword">void</span> __user *ptr = buffer + *consumed;</span><br><span class="line">    <span class="keyword">void</span> __user *end = buffer + size;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> wait_for_proc_work;</span><br><span class="line">    <span class="comment">// 入参为0，写入命令 BR_NOOP</span></span><br><span class="line">    <span class="keyword">if</span> (*consumed == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (put_user(BR_NOOP, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line">retry:</span><br><span class="line">    <span class="comment">// 根据前面 binder_transaction 的代码，两者都不为空</span></span><br><span class="line">    wait_for_proc_work = thread-&gt;transaction_stack == <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">                list_empty(&amp;thread-&gt;todo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置状态为等待</span></span><br><span class="line">    thread-&gt;looper |= BINDER_LOOPER_STATE_WAITING;</span><br><span class="line">    <span class="keyword">if</span> (wait_for_proc_work)</span><br><span class="line">        proc-&gt;ready_threads++;</span><br><span class="line">    binder_unlock(__func__);</span><br><span class="line">    <span class="keyword">if</span> (wait_for_proc_work) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (non_block) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!binder_has_thread_work(thread))</span><br><span class="line">                ret = -EAGAIN;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="comment">// 执行这里，但是 binder_has_thread_work 返回 true，可以见下面函数的解析</span></span><br><span class="line">            ret = wait_event_freezable(thread-&gt;wait, binder_has_thread_work(thread));</span><br><span class="line">    &#125;</span><br><span class="line">    binder_lock(__func__);</span><br><span class="line">    <span class="keyword">if</span> (wait_for_proc_work)</span><br><span class="line">        proc-&gt;ready_threads--;</span><br><span class="line">    thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_WAITING;</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">w</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span> = <span class="title">NULL</span>;</span></span><br><span class="line">        <span class="keyword">if</span> (!list_empty(&amp;thread-&gt;todo)) <span class="comment">// 此时不为空，这里会取一个 binder_work 出来，之后变为空</span></span><br><span class="line">            w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work)</span><br><span class="line">            w = list_first_entry(&amp;proc-&gt;todo, struct binder_work, entry);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ptr - buffer == <span class="number">4</span> &amp;&amp; !(thread-&gt;looper &amp; BINDER_LOOPER_STATE_NEED_RETURN)) <span class="comment">/* no data added */</span></span><br><span class="line">                <span class="keyword">goto</span> retry;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end - ptr &lt; <span class="keyword">sizeof</span>(tr) + <span class="number">4</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">switch</span> (w-&gt;type) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">case</span> BINDER_WORK_TRANSACTION_COMPLETE: &#123; <span class="comment">// 可以看 binder_transaction 函数</span></span><br><span class="line">            cmd = BR_TRANSACTION_COMPLETE;</span><br><span class="line">            <span class="comment">// 又写入一个新的命令：BR_TRANSACTION_COMPLETE</span></span><br><span class="line">            <span class="keyword">if</span> (put_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">            binder_stat_br(proc, thread, cmd);</span><br><span class="line">            <span class="comment">// 资源释放</span></span><br><span class="line">            list_del(&amp;w-&gt;entry);</span><br><span class="line">            kfree(w);</span><br><span class="line">            binder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        ......</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!t)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相关代码解析已经写作代码注释，可以看到它往<code>bwr</code>中参数写入了两个命令：<code>BR_NOOP</code>和<code>BR_TRANSACTION_COMPLETE</code>，接着返回到<code>binder_ioctl</code>函数，执行:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">	ret = -EFAULT;</span><br><span class="line">	<span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将数据又写回到用户空间，在用户空间等待的，自然是<code>IPCThreadState::talkWithDriver()</code>方法中的如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (err &gt;= NO_ERROR) &#123;</span><br><span class="line">	<span class="keyword">if</span> (bwr.write_consumed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (bwr.write_consumed &lt; (<span class="keyword">ssize_t</span>)mOut.dataSize())</span><br><span class="line">			mOut.remove(<span class="number">0</span>, bwr.write_consumed);</span><br><span class="line">		<span class="keyword">else</span> <span class="comment">// 写入数据全部读取完毕，清零</span></span><br><span class="line">			mOut.setDataSize(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (bwr.read_consumed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// 设置数据所在范围</span></span><br><span class="line">		mIn.setDataSize(bwr.read_consumed);</span><br><span class="line">		mIn.setDataPosition(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要是数据清理以及标记有效数据存储在 mIn 中的什么位置，这里的有效数据就是两个命令，我们继续往下看，就又回到了<code>IPCThreadState::waitForResponse</code>方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::waitForResponse(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> cmd;</span><br><span class="line">    <span class="keyword">int32_t</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        err = mIn.errorCheck();</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (mIn.dataAvail() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        cmd = mIn.readInt32();</span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</span><br><span class="line">            <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            ......</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            err = executeCommand(cmd); <span class="comment">// 执行 executeCommand 方法</span></span><br><span class="line">            <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">finish:</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (acquireResult) *acquireResult = err;</span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err);</span><br><span class="line">        mLastError = err;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> IPCThreadState::executeCommand(<span class="keyword">int32_t</span> cmd)</span><br><span class="line">&#123;</span><br><span class="line">    BBinder* obj;</span><br><span class="line">    RefBase::weakref_type* refs;</span><br><span class="line">    <span class="keyword">status_t</span> result = NO_ERROR;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">case</span> BR_NOOP: <span class="comment">// 不做任何处理</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候 mIn 第一个读出的命令是 <code>BR_NOOP</code>，什么也不做。<code>while</code>循环继续执行，执行的时候出现了什么情况呢？又进入了<code>IPCThreadState::talkWithDriver()</code>：（PS：又得走一遍？）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// doReceive 默认为 true</span></span><br><span class="line"><span class="keyword">status_t</span> IPCThreadState::talkWithDriver(<span class="keyword">bool</span> doReceive)</span><br><span class="line">&#123;</span><br><span class="line">	binder_write_read bwr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Is the read buffer empty?</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> needRead = mIn.dataPosition() &gt;= mIn.dataSize();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// We don't want to write anything if we are still reading</span></span><br><span class="line">    <span class="comment">// from data left in the input buffer and the caller</span></span><br><span class="line">    <span class="comment">// has requested to read the next data.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> outAvail = (!doReceive || needRead) ? mOut.dataSize() : <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    bwr.write_size = outAvail;</span><br><span class="line">    bwr.write_buffer = (<span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)mOut.data();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is what we'll read.</span></span><br><span class="line">    <span class="keyword">if</span> (doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">        bwr.read_size = mIn.dataCapacity();</span><br><span class="line">        bwr.read_buffer = (<span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)mIn.data();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 走这里</span></span><br><span class="line">        bwr.read_size = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Return immediately if there is nothing to do.</span></span><br><span class="line">    <span class="keyword">if</span> ((bwr.write_size == <span class="number">0</span>) &amp;&amp; (bwr.read_size == <span class="number">0</span>)) <span class="keyword">return</span> NO_ERROR;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mIn 的数据在驱动层返回的时候设置过一次：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mIn.setDataSize(bwr.read_consumed);</span><br><span class="line">mIn.setDataPosition(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>dataPosition 代表有效数据的起始点，dataSize 代表数据的大小，前面说过这个时候数据包含两个命令，现在只读取了一个，还剩一个，因此<code>mIn.dataPosition() &lt; mIn.dataSize()</code>，因此<code>needRead</code>为false，<code>doReceive</code>为false，因此 outAvail 是 0，那么 <code>(bwr.write_size == 0) &amp;&amp; (bwr.read_size == 0)</code>成立，直接返回 <code>NO_ERROR</code>。</p>
<p>好了，这里并没有走的很深入，我们又回到<code>IPCThreadState::waitForResponse</code>方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::waitForResponse(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> cmd;</span><br><span class="line">    <span class="keyword">int32_t</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        err = mIn.errorCheck();</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (mIn.dataAvail() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        cmd = mIn.readInt32();</span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</span><br><span class="line">        	<span class="comment">// reply 是传进来的，这里只是break，循环继续</span></span><br><span class="line">            <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">finish:</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>命令读完啦，第三次进入<code>talkWithDriver()</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::talkWithDriver(<span class="keyword">bool</span> doReceive)</span><br><span class="line">&#123;</span><br><span class="line">    LOG_ASSERT(mProcess-&gt;mDriverFD &gt;= <span class="number">0</span>, <span class="string">"Binder driver is not opened"</span>);</span><br><span class="line">    </span><br><span class="line">    binder_write_read bwr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Is the read buffer empty?</span></span><br><span class="line">    <span class="comment">// 为 true，经过两轮循环之后，mIn 中的数据已经读取完毕</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> needRead = mIn.dataPosition() &gt;= mIn.dataSize();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// We don't want to write anything if we are still reading</span></span><br><span class="line">    <span class="comment">// from data left in the input buffer and the caller</span></span><br><span class="line">    <span class="comment">// has requested to read the next data.</span></span><br><span class="line">    <span class="comment">// mOut 前面已经被清零，因此 outAvail 为 0</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> outAvail = (!doReceive || needRead) ? mOut.dataSize() : <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    bwr.write_size = outAvail;</span><br><span class="line">    bwr.write_buffer = (<span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)mOut.data();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is what we'll read.</span></span><br><span class="line">    <span class="keyword">if</span> (doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">        bwr.read_size = mIn.dataCapacity(); <span class="comment">// 不为 0</span></span><br><span class="line">        bwr.read_buffer = (<span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)mIn.data();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bwr.read_size = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return immediately if there is nothing to do.</span></span><br><span class="line">    <span class="keyword">if</span> ((bwr.write_size == <span class="number">0</span>) &amp;&amp; (bwr.read_size == <span class="number">0</span>)) <span class="keyword">return</span> NO_ERROR;</span><br><span class="line"></span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 进入binder驱动</span></span><br><span class="line">        <span class="keyword">if</span> (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</span><br><span class="line">            err = NO_ERROR;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err = -errno;</span><br><span class="line">    &#125; <span class="keyword">while</span> (err == -EINTR);</span><br><span class="line"></span><br><span class="line">    .....</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码注释如上，不多解释，咱又进入驱动层了，因为只有<code>bwr.read_size</code>大于0，因此直接进入函数<code>binder_thread_read</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_read</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                  struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">void</span>  __user *buffer, <span class="keyword">int</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">signed</span> <span class="keyword">long</span> *consumed, <span class="keyword">int</span> non_block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> __user *ptr = buffer + *consumed;</span><br><span class="line">    <span class="keyword">void</span> __user *end = buffer + size;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> wait_for_proc_work;</span><br><span class="line">    <span class="keyword">if</span> (*consumed == <span class="number">0</span>) &#123; <span class="comment">// 同样滴，这里还是 0</span></span><br><span class="line">        <span class="keyword">if</span> (put_user(BR_NOOP, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line">retry:</span><br><span class="line">    <span class="comment">// thread-&gt;transaction_stack 不为空，&amp;thread-&gt;todo 为空，因此 wait_for_proc_work 为 false</span></span><br><span class="line">    wait_for_proc_work = thread-&gt;transaction_stack == <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">                list_empty(&amp;thread-&gt;todo);</span><br><span class="line">    <span class="comment">//设置状态为等待</span></span><br><span class="line">    thread-&gt;looper |= BINDER_LOOPER_STATE_WAITING;</span><br><span class="line">    <span class="keyword">if</span> (wait_for_proc_work)</span><br><span class="line">        proc-&gt;ready_threads++;</span><br><span class="line">    binder_unlock(__func__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wait_for_proc_work) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (non_block) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!binder_has_thread_work(thread))</span><br><span class="line">                ret = -EAGAIN;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="comment">// 走到这里，这时候 thread 的 todo 列表为空，阻塞</span></span><br><span class="line">            ret = wait_event_freezable(thread-&gt;wait, binder_has_thread_work(thread));</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，最终阻塞在了<code>thread</code>的<code>todo</code>队列上。</p>
<p>也就是说，MediaPlayerService 在发起一个注册请求的同时，通过向自己当前线程的<code>todo</code>队列上挂载 binder_work 对象，可以很顺利的向 Libraries 层发送消息。而 Libraries 此时处于一个循环读取数据的状态，在没有数据可以读取的情况下，就会被阻塞住，直到<code>todo</code>再次不为空。</p>
<h2 id="SM-的处理"><a href="#SM-的处理" class="headerlink" title="SM 的处理"></a>SM 的处理</h2><p>开始这一节之前，读者可以回顾一下文章 <a href="http://www.muzileecoding.com/framework/binder-servicemanager.html" target="_blank" rel="noopener">Binder之Service Manager</a> 的 5.3 和 5.4 小节。</p>
<p><strong>【注意】</strong> 下面的函数和前面的分析很类似，但是都是运行在 SM 进程中的，千万不要混淆了！</p>
<p>首先这里是因为条件符合才返回的，因此会走到<code>binder_thread_read</code>函数的<code>while</code>循环中去:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">w</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span> = <span class="title">NULL</span>;</span></span><br><span class="line">        <span class="keyword">if</span> (!list_empty(&amp;thread-&gt;todo))</span><br><span class="line">            w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work)</span><br><span class="line">            w = list_first_entry(&amp;proc-&gt;todo, struct binder_work, entry);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ptr - buffer == <span class="number">4</span> &amp;&amp; !(thread-&gt;looper &amp; BINDER_LOOPER_STATE_NEED_RETURN)) <span class="comment">/* no data added */</span></span><br><span class="line">                <span class="keyword">goto</span> retry;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end - ptr &lt; <span class="keyword">sizeof</span>(tr) + <span class="number">4</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 根据不同的 work 类型进行处理</span></span><br><span class="line">        <span class="keyword">switch</span> (w-&gt;type) &#123;</span><br><span class="line">	        <span class="keyword">case</span> BINDER_WORK_TRANSACTION: &#123;</span><br><span class="line">	        t = container_of(w, struct binder_transaction, work);</span><br><span class="line">	        &#125;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里从 thread/proc 的<code>todo</code>队列中获取 binder_work 来进行处理，以下是根据不同的 work 类型进行处理，前面插入 binder_work 的代码是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t-&gt;work 是 binder_work 结构体，该结构体在字典中可查询</span></span><br><span class="line">t-&gt;work.type = BINDER_WORK_TRANSACTION;</span><br><span class="line"><span class="comment">// 添加 t 到目标进程的todo list中去</span></span><br><span class="line">list_add_tail(&amp;t-&gt;work.entry, target_list);</span><br></pre></td></tr></table></figure>
<p>因此类型是”BINDER_WORK_TRANSACTION”，所以接着调用<code>container_of</code>方法获取 t，即 binder_transaction 对象。</p>
<blockquote>
<p><code>container_of</code>的作用：根据结构体的成员变量获取所在结构体的首地址。</p>
<p>代码里面藏着很多这样的函数/宏 —— 强大但是很不好阅读。</p>
</blockquote>
<p>获取到 binder_transaction 对象之后，剩下的就是解析了:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tr 是 binder_transaction_data 结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">w</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!t)<span class="comment">// 通过</span></span><br><span class="line">	<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 赋值：t-&gt;buffer-&gt;target_node = target_node; </span></span><br><span class="line"> <span class="comment">// 因此条件成立，且target_node指向的是 binder_context_mgr_node</span></span><br><span class="line"><span class="keyword">if</span> (t-&gt;buffer-&gt;target_node) &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span> = <span class="title">t</span>-&gt;<span class="title">buffer</span>-&gt;<span class="title">target_node</span>;</span></span><br><span class="line">	<span class="comment">// tr 是 binder_transaction_data 类型，还记得target这两个变量的值么？</span></span><br><span class="line">	tr.target.ptr = target_node-&gt;ptr;</span><br><span class="line">	tr.cookie =  target_node-&gt;cookie;</span><br><span class="line">	t-&gt;saved_priority = task_nice(current);</span><br><span class="line">	<span class="keyword">if</span> (t-&gt;priority &lt; target_node-&gt;min_priority &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY))</span><br><span class="line">		binder_set_nice(t-&gt;priority);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY) || t-&gt;saved_priority &gt; target_node-&gt;min_priority)</span><br><span class="line">		binder_set_nice(target_node-&gt;min_priority);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//注意这个命令的赋值</span></span><br><span class="line">	cmd = BR_TRANSACTION;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	tr.target.ptr = <span class="literal">NULL</span>;</span><br><span class="line">	tr.cookie = <span class="literal">NULL</span>;</span><br><span class="line">	cmd = BR_REPLY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tr.code = t-&gt;code;</span><br><span class="line">tr.flags = t-&gt;flags;</span><br><span class="line">tr.sender_euid = t-&gt;sender_euid;</span><br><span class="line"><span class="keyword">if</span> (t-&gt;from) &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">sender</span> = <span class="title">t</span>-&gt;<span class="title">from</span>-&gt;<span class="title">proc</span>-&gt;<span class="title">tsk</span>;</span></span><br><span class="line">	tr.sender_pid = task_tgid_nr_ns(sender, current-&gt;nsproxy-&gt;pid_ns);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	tr.sender_pid = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">tr.data_size = t-&gt;buffer-&gt;data_size;</span><br><span class="line">tr.offsets_size = t-&gt;buffer-&gt;offsets_size;</span><br><span class="line"><span class="comment">// 根据老罗的文章：这里正是 binder 机制的精髓，即如何做到复制一次的。</span></span><br><span class="line">tr.data.ptr.buffer = (<span class="keyword">void</span> *)t-&gt;buffer-&gt;data +  proc-&gt;user_buffer_offset;</span><br><span class="line">tr.data.ptr.offsets = tr.data.ptr.buffer + ALIGN(t-&gt;buffer-&gt;data_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line"></span><br><span class="line"><span class="comment">// @read数据@ 下面就是把cmd 和 tr 结构体 copy 到用户空间，cmd = BR_TRANSACTION;</span></span><br><span class="line"><span class="keyword">if</span> (put_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">	<span class="keyword">return</span> -EFAULT;</span><br><span class="line">ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (copy_to_user(ptr, &amp;tr, <span class="keyword">sizeof</span>(tr)))</span><br><span class="line">	<span class="keyword">return</span> -EFAULT;</span><br><span class="line">ptr += <span class="keyword">sizeof</span>(tr);</span><br><span class="line"></span><br><span class="line">trace_binder_transaction_received(t);</span><br><span class="line">binder_stat_br(proc, thread, cmd);</span><br><span class="line"><span class="comment">// 处理完毕，删除节点</span></span><br><span class="line">list_del(&amp;t-&gt;work.entry);</span><br><span class="line">t-&gt;buffer-&gt;allow_user_free = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 添加服务的时候是需要回复的，这里判断成立</span></span><br><span class="line"><span class="keyword">if</span> (cmd == BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">	t-&gt;to_parent = thread-&gt;transaction_stack;</span><br><span class="line">	t-&gt;to_thread = thread;</span><br><span class="line">	thread-&gt;transaction_stack = t; <span class="comment">// 放到栈顶 </span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	t-&gt;buffer-&gt;transaction = <span class="literal">NULL</span>;</span><br><span class="line">	kfree(t);</span><br><span class="line">	binder_stats_deleted(BINDER_STAT_TRANSACTION);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 跳出循环</span></span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>相关解析都在注释中，之前传过来的数据都被拷贝到用户空间中去了，之后就跳出循环，回到<code>binder_ioctl()</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">binder_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size = _IOC_SIZE(cmd);</span><br><span class="line">    <span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> BINDER_WRITE_READ: &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">        <span class="keyword">if</span> (size != <span class="keyword">sizeof</span>(struct binder_write_read)) &#123;</span><br><span class="line">            ret = -EINVAL;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(&amp;bwr, ubuf, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">            ret = -EFAULT;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ret = binder_thread_write(proc, thread, (<span class="keyword">void</span> __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);</span><br><span class="line">            trace_binder_write_done(ret);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">                    ret = -EFAULT;</span><br><span class="line">                <span class="keyword">goto</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="comment">// 数据都被拷贝到用户空间了</span></span><br><span class="line">            ret = binder_thread_read(proc, thread, (<span class="keyword">void</span> __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK);</span><br><span class="line">            trace_binder_read_done(ret);</span><br><span class="line">            <span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo))</span><br><span class="line">                wake_up_interruptible(&amp;proc-&gt;wait);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">                    ret = -EFAULT;</span><br><span class="line">                <span class="keyword">goto</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//再次拷贝数据到用户空间</span></span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">            ret = -EFAULT;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，所有的数据顺利传输到了用户空间，在用户空间等待它的是<code>binder_loop()</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binder_loop</span><span class="params">(struct binder_state *bs, binder_handler func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="comment">// 该结构体在字典中可查</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> readbuf[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">    bwr.write_size = <span class="number">0</span>;</span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.write_buffer = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    readbuf[<span class="number">0</span>] = BC_ENTER_LOOPER;</span><br><span class="line">    <span class="comment">//告诉Binder驱动程序， Service Manager要进入循环了</span></span><br><span class="line">    binder_write(bs, readbuf, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        bwr.read_size = <span class="keyword">sizeof</span>(readbuf);</span><br><span class="line">        bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = (<span class="keyword">unsigned</span>) readbuf;</span><br><span class="line"></span><br><span class="line">        res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            LOGE(<span class="string">"binder_loop: ioctl failed (%s)\n"</span>, strerror(errno));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res = binder_parse(bs, <span class="number">0</span>, readbuf, bwr.read_consumed, func);</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">0</span>) &#123;</span><br><span class="line">            LOGE(<span class="string">"binder_loop: unexpected reply?!\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            LOGE(<span class="string">"binder_loop: io error %d %s\n"</span>, res, strerror(errno));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>ioctl()</code>返回之后，调用的就是<code>binder_parse()</code>函数，这个函数可以处理很多的命令，我们就看相关部分:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_parse</span><span class="params">(struct binder_state *bs, struct binder_io *bio,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">uint32_t</span> *ptr, <span class="keyword">uint32_t</span> size, binder_handler func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> *end = ptr + (size / <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (ptr &lt; end) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> cmd = *ptr++;</span><br><span class="line">        <span class="keyword">switch</span>(cmd) &#123;</span><br><span class="line">            ......</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION: &#123;</span><br><span class="line">        	<span class="comment">//该结构体字典中可查</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_txn</span> *<span class="title">txn</span> = (<span class="title">void</span> *) <span class="title">ptr</span>;</span></span><br><span class="line">            <span class="keyword">if</span> ((end - ptr) * <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>) &lt; <span class="keyword">sizeof</span>(struct binder_txn)) &#123;</span><br><span class="line">                LOGE(<span class="string">"parse: txn too small!\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            binder_dump_txn(txn);</span><br><span class="line">            <span class="keyword">if</span> (func) &#123;</span><br><span class="line">                <span class="keyword">unsigned</span> rdata[<span class="number">256</span>/<span class="number">4</span>];</span><br><span class="line">                <span class="comment">// 该结构体字典中可查</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">binder_io</span> <span class="title">msg</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">binder_io</span> <span class="title">reply</span>;</span></span><br><span class="line">                <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">                bio_init(&amp;reply, rdata, <span class="keyword">sizeof</span>(rdata), <span class="number">4</span>);</span><br><span class="line">                bio_init_from_txn(&amp;msg, txn);</span><br><span class="line">                res = func(bs, txn, &amp;msg, &amp;reply);</span><br><span class="line">                binder_send_reply(bs, &amp;reply, txn-&gt;data, res);</span><br><span class="line">            &#125;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(*txn) / <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里读出来的命令就是<code>BR_TRANSACTION</code>，然后将数据部分（一个 binder_transaction_data 结构体，读者可以搜”@read数据@”定位）解析成<code>binder_txn</code>结构体(对比结构体字段就可以知道转换确实可行)。接着是声明了两个 binder_io 结构体，在字典中可查。在这里还有两个方法，也一并列举一下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bio_init_from_txn</span><span class="params">(struct binder_io *bio, struct binder_txn *txn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bio-&gt;data = bio-&gt;data0 = txn-&gt;data;</span><br><span class="line">    bio-&gt;offs = bio-&gt;offs0 = txn-&gt;offs;</span><br><span class="line">    bio-&gt;data_avail = txn-&gt;data_size;</span><br><span class="line">    bio-&gt;offs_avail = txn-&gt;offs_size / <span class="number">4</span>;</span><br><span class="line">    bio-&gt;flags = BIO_F_SHARED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bio_init</span><span class="params">(struct binder_io *bio, <span class="keyword">void</span> *data,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">uint32_t</span> maxdata, <span class="keyword">uint32_t</span> maxoffs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> n = maxoffs * <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &gt; maxdata) &#123;</span><br><span class="line">        bio-&gt;flags = BIO_F_OVERFLOW;</span><br><span class="line">        bio-&gt;data_avail = <span class="number">0</span>;</span><br><span class="line">        bio-&gt;offs_avail = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bio-&gt;data = bio-&gt;data0 = data + n;</span><br><span class="line">    bio-&gt;offs = bio-&gt;offs0 = data;</span><br><span class="line">    bio-&gt;data_avail = maxdata - n;</span><br><span class="line">    bio-&gt;offs_avail = maxoffs;</span><br><span class="line">    bio-&gt;flags = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个结构体在这里解释的意义不大，下一篇文章<a href="http://www.muzileecoding.com/framework/binder-service-lookup.html" target="_blank" rel="noopener">Binder之Service查询</a>中有较详细的解释。</p>
<p>最后调用func来处理命令，func是从 SM 的<code>main</code>函数中传递过来的，它真实的指向是<code>svcmgr_handler</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint16_t</span> svcmgr_id[] = &#123; </span><br><span class="line">    <span class="string">'a'</span>,<span class="string">'n'</span>,<span class="string">'d'</span>,<span class="string">'r'</span>,<span class="string">'o'</span>,<span class="string">'i'</span>,<span class="string">'d'</span>,<span class="string">'.'</span>,<span class="string">'o'</span>,<span class="string">'s'</span>,<span class="string">'.'</span>,</span><br><span class="line">    <span class="string">'I'</span>,<span class="string">'S'</span>,<span class="string">'e'</span>,<span class="string">'r'</span>,<span class="string">'v'</span>,<span class="string">'i'</span>,<span class="string">'c'</span>,<span class="string">'e'</span>,<span class="string">'M'</span>,<span class="string">'a'</span>,<span class="string">'n'</span>,<span class="string">'a'</span>,<span class="string">'g'</span>,<span class="string">'e'</span>,<span class="string">'r'</span> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">svcmgr_handler</span><span class="params">(struct binder_state *bs,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_txn *txn,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_io *msg,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_io *reply)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span> *<span class="title">si</span>;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> *s;</span><br><span class="line">    <span class="keyword">unsigned</span> len;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="keyword">uint32_t</span> strict_policy;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// svcmgr_handle 被赋值为 svcmgr，即BINDER_SERVICE_MANAGER，即0</span></span><br><span class="line">    <span class="keyword">if</span> (txn-&gt;target != svcmgr_handle)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Equivalent to Parcel::enforceInterface(), reading the RPC</span></span><br><span class="line">    <span class="comment">// header with the strict mode policy mask and the interface name.</span></span><br><span class="line">    <span class="comment">// Note that we ignore the strict_policy and don't propagate it</span></span><br><span class="line">    <span class="comment">// further (since we do no outbound RPCs anyway).</span></span><br><span class="line">    strict_policy = bio_get_uint32(msg);</span><br><span class="line">    s = bio_get_string16(msg, &amp;len);</span><br><span class="line">    <span class="comment">// svcmgr_id是一个字符数组，见最上面，这里判断是通过的，因为s读取出来就是"android.os.IServiceManager"</span></span><br><span class="line">    <span class="keyword">if</span> ((len != (<span class="keyword">sizeof</span>(svcmgr_id) / <span class="number">2</span>)) ||</span><br><span class="line">        <span class="built_in">memcmp</span>(svcmgr_id, s, <span class="keyword">sizeof</span>(svcmgr_id))) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"invalid id %s\n"</span>, str8(s));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(txn-&gt;code) &#123;</span><br><span class="line">		......</span><br><span class="line">    <span class="keyword">case</span> SVC_MGR_ADD_SERVICE:</span><br><span class="line">        s = bio_get_string16(msg, &amp;len); <span class="comment">// "media.player"</span></span><br><span class="line">        ptr = bio_get_ref(msg);</span><br><span class="line">        <span class="keyword">if</span> (do_add_service(bs, s, len, ptr, txn-&gt;sender_euid))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">	</span><br><span class="line">		......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bio_put_uint32(reply, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 code 最初是什么呢？读者往上翻翻就知道是<code>ADD_SERVICE_TRANSACTION</code>，它是定义在 “IServiceManager.h” 中的一个枚举值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">	GET_SERVICE_TRANSACTION = IBinder::FIRST_CALL_TRANSACTION,</span><br><span class="line">	CHECK_SERVICE_TRANSACTION,</span><br><span class="line">	ADD_SERVICE_TRANSACTION,</span><br><span class="line">	LIST_SERVICES_TRANSACTION,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>IBinder::FIRST_CALL_TRANSACTION</code>的定义如下：<code>FIRST_CALL_TRANSACTION  = 0x00000001</code>，即1，那么ADD_SERVICE_TRANSACTION就是 3。而这里 code 的几个可能值类型也是枚举值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    SVC_MGR_GET_SERVICE = <span class="number">1</span>,</span><br><span class="line">    SVC_MGR_CHECK_SERVICE,</span><br><span class="line">    SVC_MGR_ADD_SERVICE,</span><br><span class="line">    SVC_MGR_LIST_SERVICES,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所以，<code>SVC_MGR_ADD_SERVICE</code>的值也是 3，即执行该 case。从代码看应该正好有四句数据读取代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">strict_policy = bio_get_uint32(msg); <span class="comment">// 读取 StrictModePolicy，一个int值</span></span><br><span class="line">s = bio_get_string16(msg, &amp;len); <span class="comment">// “android.os.IServiceManager”</span></span><br><span class="line">s = bio_get_string16(msg, &amp;len);</span><br><span class="line">ptr = bio_get_ref(msg);</span><br></pre></td></tr></table></figure>
<p>还记得服务注册初始数据图么？它正好也是四个部分，与这里是一一对应，这部分数据从一开始的分析就出现了，一直到现在才开始解析，调用链极长。第四个变量还需要看一下方法<code>bio_get_ref</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">bio_get_ref</span><span class="params">(struct binder_io *bio)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_object</span> *<span class="title">obj</span>;</span></span><br><span class="line"></span><br><span class="line">    obj = _bio_get_obj(bio);</span><br><span class="line">    <span class="keyword">if</span> (!obj)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;type == BINDER_TYPE_HANDLE)</span><br><span class="line">        <span class="keyword">return</span> obj-&gt;pointer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">binder_object</span> *_<span class="title">bio_get_obj</span>(<span class="title">struct</span> <span class="title">binder_io</span> *<span class="title">bio</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> n;</span><br><span class="line">    <span class="keyword">unsigned</span> off = bio-&gt;data - bio-&gt;data0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; bio-&gt;offs_avail; n++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bio-&gt;offs[n] == off)</span><br><span class="line">        	<span class="comment">//获取 binder_object 对象</span></span><br><span class="line">            <span class="keyword">return</span> bio_get(bio, <span class="keyword">sizeof</span>(struct binder_object));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bio-&gt;data_avail = <span class="number">0</span>;</span><br><span class="line">    bio-&gt;flags |= BIO_F_OVERFLOW;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里还是得看服务注册初始数据图：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/service注册transact数据.png" width="600" alt="service注册transact数据"></div>

<p>实际上我们在这个位置存储的对象并不是 binder_object 结构体，而是 flat_binder_object 结构体，但是字段上看，的确是可以强转的。另外不知道读者还是否记得，binder 驱动在传递 binder 节点的时候，已经把 Type 改成了 BINDER_TYPE_HANDLE 了，因此这里的 ptr 实际就是 SM 为 MediaPlayerService 分配的 handle 值。</p>
<p>接下去就到了正主出现的时刻：<code>do_add_service</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数解释：s 就是 "media.player"</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_add_service</span><span class="params">(struct binder_state *bs,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">uint16_t</span> *s, <span class="keyword">unsigned</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">void</span> *ptr, <span class="keyword">unsigned</span> uid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 该结构体在字典中可查</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span> *<span class="title">si</span>;</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (!ptr || (len == <span class="number">0</span>) || (len &gt; <span class="number">127</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (!svc_can_register(uid, s)) &#123;</span><br><span class="line">        LOGE(<span class="string">"add_service('%s',%p) uid=%d - PERMISSION DENIED\n"</span>,</span><br><span class="line">             str8(s), ptr, uid);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    si = find_svc(s, len);</span><br><span class="line">    <span class="keyword">if</span> (si) &#123;</span><br><span class="line">        <span class="keyword">if</span> (si-&gt;ptr) &#123;</span><br><span class="line">            LOGE(<span class="string">"add_service('%s',%p) uid=%d - ALREADY REGISTERED, OVERRIDE\n"</span>,</span><br><span class="line">                 str8(s), ptr, uid);</span><br><span class="line">            svcinfo_death(bs, si);</span><br><span class="line">        &#125;</span><br><span class="line">        si-&gt;ptr = ptr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        si = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*si) + (len + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">        <span class="keyword">if</span> (!si) &#123;</span><br><span class="line">            LOGE(<span class="string">"add_service('%s',%p) uid=%d - OUT OF MEMORY\n"</span>,</span><br><span class="line">                 str8(s), ptr, uid);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        si-&gt;ptr = ptr;</span><br><span class="line">        si-&gt;len = len;</span><br><span class="line">        <span class="built_in">memcpy</span>(si-&gt;name, s, (len + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">        si-&gt;name[len] = <span class="string">'\0'</span>;</span><br><span class="line">        si-&gt;death.func = svcinfo_death;</span><br><span class="line">        si-&gt;death.ptr = si;</span><br><span class="line">        si-&gt;next = svclist;</span><br><span class="line">        svclist = si;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    binder_acquire(bs, ptr);</span><br><span class="line">    binder_link_to_death(bs, ptr, &amp;si-&gt;death);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数一进来首先是参数判断，从这里可以看出，实际上 Service 名字的长度是有限制的，转成字符数组必须在长度 127 以内；第二步是权限检测：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> uid;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">&#125; allowed[] = &#123;</span><br><span class="line">#ifdef LVMX</span><br><span class="line">    &#123; AID_MEDIA, <span class="string">"com.lifevibes.mx.ipc"</span> &#125;,</span><br><span class="line">#endif</span><br><span class="line">    &#123; AID_MEDIA, <span class="string">"media.audio_flinger"</span> &#125;,</span><br><span class="line">    &#123; AID_MEDIA, <span class="string">"media.player"</span> &#125;,</span><br><span class="line">    &#123; AID_MEDIA, <span class="string">"media.camera"</span> &#125;,</span><br><span class="line">    &#123; AID_MEDIA, <span class="string">"media.audio_policy"</span> &#125;,</span><br><span class="line">    &#123; AID_DRM,   <span class="string">"drm.drmManager"</span> &#125;,</span><br><span class="line">    &#123; AID_NFC,   <span class="string">"nfc"</span> &#125;,</span><br><span class="line">    &#123; AID_RADIO, <span class="string">"radio.phone"</span> &#125;,</span><br><span class="line">    &#123; AID_RADIO, <span class="string">"radio.sms"</span> &#125;,</span><br><span class="line">    &#123; AID_RADIO, <span class="string">"radio.phonesubinfo"</span> &#125;,</span><br><span class="line">    &#123; AID_RADIO, <span class="string">"radio.simphonebook"</span> &#125;,</span><br><span class="line"><span class="comment">/* <span class="doctag">TODO:</span> remove after phone services are updated: */</span></span><br><span class="line">    &#123; AID_RADIO, <span class="string">"phone"</span> &#125;,</span><br><span class="line">    &#123; AID_RADIO, <span class="string">"sip"</span> &#125;,</span><br><span class="line">    &#123; AID_RADIO, <span class="string">"isms"</span> &#125;,</span><br><span class="line">    &#123; AID_RADIO, <span class="string">"iphonesubinfo"</span> &#125;,</span><br><span class="line">    &#123; AID_RADIO, <span class="string">"simphonebook"</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">svc_can_register</span><span class="params">(<span class="keyword">unsigned</span> uid, <span class="keyword">uint16_t</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((uid == <span class="number">0</span>) || (uid == AID_SYSTEM))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; <span class="keyword">sizeof</span>(allowed) / <span class="keyword">sizeof</span>(allowed[<span class="number">0</span>]); n++)</span><br><span class="line">        <span class="keyword">if</span> ((uid == allowed[n].uid) &amp;&amp; str16eq(name, allowed[n].name))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有 root 进程或者 system server 进程或者具有特殊名字的服务才能注册的。再接着就是查看是否有同名服务注册：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct svcinfo *<span class="title">find_svc</span><span class="params">(<span class="keyword">uint16_t</span> *s16, <span class="keyword">unsigned</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span> *<span class="title">si</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (si = svclist; si; si = si-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((len == si-&gt;len) &amp;&amp;</span><br><span class="line">            !<span class="built_in">memcmp</span>(s16, si-&gt;name, len * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>))) &#123;</span><br><span class="line">            <span class="keyword">return</span> si;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有必要解释一下 svclist 这个变量了，它是一个链表，元素就是 svcinfo，所有注册过来的服务都以 svcinfo 记录下来添加在 svclist 中，因此函数<code>find_svc()</code>实际在做事情是遍历该链表，找出是否有同名的服务已经注册过了。如果有，则更新服务，用新的 ptr 替换旧有的 ptr，否则分配新的 svcinfo 结构体，记录服务信息，并挂载到 svclist 链表上，执行完毕后返回 0。</p>
<p>好了，到这里，<strong>服务终于注册到 SM 了</strong>。实际上还没有完结，因为 MediaPlayerService 还在等待回复啊！</p>
<h2 id="注册答复"><a href="#注册答复" class="headerlink" title="注册答复"></a>注册答复</h2><p>注册答复的起始点我们还得回到<code>binder_parse</code>方法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_parse</span><span class="params">(struct binder_state *bs, struct binder_io *bio,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">uint32_t</span> *ptr, <span class="keyword">uint32_t</span> size, binder_handler func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> *end = ptr + (size / <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (ptr &lt; end) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> cmd = *ptr++;</span><br><span class="line">        <span class="keyword">switch</span>(cmd) &#123;</span><br><span class="line">            ......</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION: &#123;</span><br><span class="line">        	<span class="comment">//该结构体字典中可查</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_txn</span> *<span class="title">txn</span> = (<span class="title">void</span> *) <span class="title">ptr</span>;</span></span><br><span class="line">            <span class="keyword">if</span> ((end - ptr) * <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>) &lt; <span class="keyword">sizeof</span>(struct binder_txn)) &#123;</span><br><span class="line">                LOGE(<span class="string">"parse: txn too small!\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            binder_dump_txn(txn);</span><br><span class="line">            <span class="keyword">if</span> (func) &#123;</span><br><span class="line">                <span class="keyword">unsigned</span> rdata[<span class="number">256</span>/<span class="number">4</span>];</span><br><span class="line">                <span class="comment">// 该结构体字典中可查</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">binder_io</span> <span class="title">msg</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">binder_io</span> <span class="title">reply</span>;</span></span><br><span class="line">                <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">                bio_init(&amp;reply, rdata, <span class="keyword">sizeof</span>(rdata), <span class="number">4</span>);</span><br><span class="line">                bio_init_from_txn(&amp;msg, txn);</span><br><span class="line">                res = func(bs, txn, &amp;msg, &amp;reply);</span><br><span class="line">                binder_send_reply(bs, &amp;reply, txn-&gt;data, res);</span><br><span class="line">            &#125;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(*txn) / <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在调用<code>svcmgr_handler</code>函数处理请求之后，会接着调用<code>binder_send_reply</code>发送答复：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数解释：status 为0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binder_send_reply</span><span class="params">(struct binder_state *bs,</span></span></span><br><span class="line"><span class="function"><span class="params">                       struct binder_io *reply,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">void</span> *buffer_to_free,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> status)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> cmd_free;</span><br><span class="line">        <span class="keyword">void</span> *buffer;</span><br><span class="line">        <span class="keyword">uint32_t</span> cmd_reply;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_txn</span> <span class="title">txn</span>;</span></span><br><span class="line">    &#125; __attribute__((packed)) data;</span><br><span class="line"></span><br><span class="line">    data.cmd_free = BC_FREE_BUFFER; <span class="comment">// 注意命令</span></span><br><span class="line">    data.buffer = buffer_to_free;</span><br><span class="line">    data.cmd_reply = BC_REPLY; <span class="comment">// 注意命令</span></span><br><span class="line">    data.txn.target = <span class="number">0</span>;</span><br><span class="line">    data.txn.cookie = <span class="number">0</span>;</span><br><span class="line">    data.txn.code = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (status) &#123;</span><br><span class="line">        data.txn.flags = TF_STATUS_CODE;</span><br><span class="line">        data.txn.data_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">        data.txn.offs_size = <span class="number">0</span>;</span><br><span class="line">        data.txn.data = &amp;status;</span><br><span class="line">        data.txn.offs = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 走这里</span></span><br><span class="line">        data.txn.flags = <span class="number">0</span>;</span><br><span class="line">        data.txn.data_size = reply-&gt;data - reply-&gt;data0;</span><br><span class="line">        data.txn.offs_size = ((<span class="keyword">char</span>*) reply-&gt;offs) - ((<span class="keyword">char</span>*) reply-&gt;offs0);</span><br><span class="line">        data.txn.data = reply-&gt;data0;</span><br><span class="line">        data.txn.offs = reply-&gt;offs0;</span><br><span class="line">    &#125;</span><br><span class="line">    binder_write(bs, &amp;data, <span class="keyword">sizeof</span>(data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里包装了很多数据，通过<code>binder_write</code>又写回到 驱动中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_write</span><span class="params">(struct binder_state *bs, <span class="keyword">void</span> *data, <span class="keyword">unsigned</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    bwr.write_size = len;</span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.write_buffer = (<span class="keyword">unsigned</span>) data;</span><br><span class="line">    bwr.read_size = <span class="number">0</span>;</span><br><span class="line">    bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"binder_write: ioctl failed (%s)\n"</span>,</span><br><span class="line">                strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，只有write部分是有数据的，接着又回到了<code>binder_thread_write</code>方法中，其中有两个命令，一个是<code>BC_FREE_BUFFER</code>，另外一个是<code>BC_REPLY</code>，前者顾名思义就是释放缓冲区，我们就不去看了，后者比较重要：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> BC_TRANSACTION:</span><br><span class="line"><span class="keyword">case</span> BC_REPLY: &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(&amp;tr, ptr, <span class="keyword">sizeof</span>(tr)))</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		ptr += <span class="keyword">sizeof</span>(tr);</span><br><span class="line">		binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法已经来过一次了，只不过上次是<code>BC_TRANSACTION</code>命令。自然而然又要进入<code>binder_transaction</code>了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数解释：reply 是 true</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_transaction</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_transaction_data *tr, <span class="keyword">int</span> reply)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">tcomplete</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> *offp, *off_end;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">target_proc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">target_thread</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">target_list</span>;</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> *target_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">in_reply_to</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_log_entry</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> return_error;</span><br><span class="line">    e = binder_transaction_log_add(&amp;binder_transaction_log);</span><br><span class="line">    e-&gt;call_type = reply ? <span class="number">2</span> : !!(tr-&gt;flags &amp; TF_ONE_WAY);</span><br><span class="line">    e-&gt;from_proc = proc-&gt;pid;</span><br><span class="line">    e-&gt;from_thread = thread-&gt;pid;</span><br><span class="line">    e-&gt;target_handle = tr-&gt;target.handle;</span><br><span class="line">    e-&gt;data_size = tr-&gt;data_size;</span><br><span class="line">    e-&gt;offsets_size = tr-&gt;offsets_size;</span><br><span class="line">    <span class="keyword">if</span> (reply) &#123; <span class="comment">// true</span></span><br><span class="line">        in_reply_to = thread-&gt;transaction_stack; <span class="comment">// 之前放了一个进去，不为null</span></span><br><span class="line">        binder_set_nice(in_reply_to-&gt;saved_priority);</span><br><span class="line">        <span class="keyword">if</span> (in_reply_to-&gt;to_thread != thread) &#123;</span><br><span class="line">            .....</span><br><span class="line">            <span class="keyword">goto</span> err_bad_call_stack;</span><br><span class="line">        &#125;</span><br><span class="line">        thread-&gt;transaction_stack = in_reply_to-&gt;to_parent;</span><br><span class="line">        target_thread = in_reply_to-&gt;from; <span class="comment">// 找到发送请求的线程</span></span><br><span class="line">        <span class="keyword">if</span> (target_thread == <span class="literal">NULL</span>) &#123; </span><br><span class="line">            return_error = BR_DEAD_REPLY;</span><br><span class="line">            <span class="keyword">goto</span> err_dead_binder;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 校验，保证是同一个 transaction</span></span><br><span class="line">        <span class="keyword">if</span> (target_thread-&gt;transaction_stack != in_reply_to) &#123;</span><br><span class="line">            <span class="keyword">goto</span> err_dead_binder;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 本次回复的目标进程</span></span><br><span class="line">        target_proc = target_thread-&gt;proc;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (target_thread) &#123;</span><br><span class="line">        e-&gt;to_thread = target_thread-&gt;pid;</span><br><span class="line">        target_list = &amp;target_thread-&gt;todo;</span><br><span class="line">        target_wait = &amp;target_thread-&gt;wait;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        target_list = &amp;target_proc-&gt;todo;</span><br><span class="line">        target_wait = &amp;target_proc-&gt;wait;</span><br><span class="line">    &#125;</span><br><span class="line">    e-&gt;to_proc = target_proc-&gt;pid;</span><br><span class="line">    t = kzalloc(<span class="keyword">sizeof</span>(*t), GFP_KERNEL);</span><br><span class="line">    binder_stats_created(BINDER_STAT_TRANSACTION);</span><br><span class="line">    tcomplete = kzalloc(<span class="keyword">sizeof</span>(*tcomplete), GFP_KERNEL);</span><br><span class="line">    binder_stats_created(BINDER_STAT_TRANSACTION_COMPLETE);</span><br><span class="line">    t-&gt;debug_id = ++binder_last_id;</span><br><span class="line">    e-&gt;debug_id = t-&gt;debug_id;</span><br><span class="line">    <span class="keyword">if</span> (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY))</span><br><span class="line">        t-&gt;from = thread;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 走这里</span></span><br><span class="line">        t-&gt;from = <span class="literal">NULL</span>; </span><br><span class="line">    t-&gt;sender_euid = proc-&gt;tsk-&gt;cred-&gt;euid;</span><br><span class="line">    t-&gt;to_proc = target_proc;</span><br><span class="line">    t-&gt;to_thread = target_thread;</span><br><span class="line">    t-&gt;code = tr-&gt;code;</span><br><span class="line">    t-&gt;flags = tr-&gt;flags;</span><br><span class="line">    t-&gt;priority = task_nice(current);</span><br><span class="line">    trace_binder_transaction(reply, t, target_node);</span><br><span class="line">    t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size,</span><br><span class="line">        tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));</span><br><span class="line">    t-&gt;buffer-&gt;allow_user_free = <span class="number">0</span>;</span><br><span class="line">    t-&gt;buffer-&gt;debug_id = t-&gt;debug_id;</span><br><span class="line">    t-&gt;buffer-&gt;transaction = t;</span><br><span class="line">    t-&gt;buffer-&gt;target_node = target_node;</span><br><span class="line">    trace_binder_transaction_alloc_buf(t-&gt;buffer);</span><br><span class="line">    <span class="keyword">if</span> (target_node)</span><br><span class="line">        binder_inc_node(target_node, <span class="number">1</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    offp = (<span class="keyword">size_t</span> *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)));</span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) &#123;</span><br><span class="line">        return_error = BR_FAILED_REPLY;</span><br><span class="line">        <span class="keyword">goto</span> err_copy_data_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) &#123;</span><br><span class="line">        return_error = BR_FAILED_REPLY;</span><br><span class="line">        <span class="keyword">goto</span> err_copy_data_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!IS_ALIGNED(tr-&gt;offsets_size, <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>))) &#123;</span><br><span class="line">        return_error = BR_FAILED_REPLY;</span><br><span class="line">        <span class="keyword">goto</span> err_bad_offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">        <span class="comment">// 执行pop，删除该 binder_transaction</span></span><br><span class="line">        binder_pop_transaction(target_thread, in_reply_to);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;work.type = BINDER_WORK_TRANSACTION;</span><br><span class="line">    <span class="comment">// 又是挂载任务</span></span><br><span class="line">    list_add_tail(&amp;t-&gt;work.entry, target_list);</span><br><span class="line">    tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;</span><br><span class="line">    list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);</span><br><span class="line">    <span class="comment">// 唤醒线程</span></span><br><span class="line">    <span class="keyword">if</span> (target_wait)</span><br><span class="line">        wake_up_interruptible(target_wait);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释已经添加，和之前进来差不多，只不过角色互换了：SM 往 MediaPlayerService 的 申请服务注册线程上面挂载了一个任务。最终 SM 的线程唤醒了在<code>target_wait</code>上等待的线程，即我们在 <strong>2.3.4 节</strong> 描述的 MediaPlayerService 的申请服务注册线程。然后 SM 欢快的回去进行收尾工作。</p>
<p>MediaPlayerService 的申请服务注册线程被唤醒后会做什么，这里不做分析了，读者可以自行分析，下篇文章会涉及。</p>
<h2 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h2><p>在服务初始化完成之后，”main_mediaserver” 会执行下面两行代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ProcessState::self()-&gt;startThreadPool();</span><br><span class="line">IPCThreadState::self()-&gt;joinThreadPool();</span><br></pre></td></tr></table></figure>
<p>下面就来解析一下这两行代码：</p>
<h3 id="ProcessState-self-gt-startThreadPool"><a href="#ProcessState-self-gt-startThreadPool" class="headerlink" title="ProcessState::self()-&gt;startThreadPool()"></a><code>ProcessState::self()-&gt;startThreadPool()</code></h3><p>该方法的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ProcessState::startThreadPool()</span><br><span class="line">&#123;</span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    <span class="keyword">if</span> (!mThreadPoolStarted) &#123;</span><br><span class="line">        mThreadPoolStarted = <span class="literal">true</span>;</span><br><span class="line">        spawnPooledThread(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">``</span><br><span class="line">设置`mThreadPoolStarted`属性之后，调用方法`spawnPooledThread`：</span><br><span class="line"></span><br><span class="line">​```C++</span><br><span class="line"><span class="comment">// 参数解释：isMain为true</span></span><br><span class="line"><span class="keyword">void</span> ProcessState::spawnPooledThread(<span class="keyword">bool</span> isMain)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mThreadPoolStarted) &#123;</span><br><span class="line">        <span class="keyword">int32_t</span> s = android_atomic_add(<span class="number">1</span>, &amp;mThreadPoolSeq);</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">"Binder Thread #%d"</span>, s);</span><br><span class="line">        LOGV(<span class="string">"Spawning new pooled thread, name=%s\n"</span>, buf);</span><br><span class="line">        sp&lt;Thread&gt; t = <span class="keyword">new</span> PoolThread(isMain);</span><br><span class="line">        t-&gt;run(buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要工作是新建了 PoolThread 实例，并调用<code>run()</code>方法，该类定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PoolThread</span> :</span> <span class="keyword">public</span> Thread</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    PoolThread(<span class="keyword">bool</span> isMain)</span><br><span class="line">        : mIsMain(isMain)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">threadLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        IPCThreadState::self()-&gt;joinThreadPool(mIsMain);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> mIsMain;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>run()</code>来源于父类，会调用虚方法<code>threadLoop()</code>，而在<code>threadLoop()</code>中调用的却是<code>IPCThreadState::self()-&gt;joinThreadPool(mIsMain)</code>，好了，万剑归宗，直接看这个方法吧。</p>
<h3 id="7-2-IPCThreadState-self-gt-joinThreadPool"><a href="#7-2-IPCThreadState-self-gt-joinThreadPool" class="headerlink" title="7.2 IPCThreadState::self()-&gt;joinThreadPool()"></a>7.2 <code>IPCThreadState::self()-&gt;joinThreadPool()</code></h3><p>该方法的在 header 文件中的定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">joinThreadPool</span><span class="params">(<span class="keyword">bool</span> isMain = <span class="literal">true</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>默认参数为 true。</p>
<blockquote>
<p>老罗的文章在这里有个小错误，默认值确实是 true，我看了1.6，2.2.3，4.0.4几个版本都是true。</p>
</blockquote>
<p>这个方法的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> IPCThreadState::joinThreadPool(<span class="keyword">bool</span> isMain)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进入 Looper 状态</span></span><br><span class="line">    mOut.writeInt32(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// This thread may have been spawned by a thread that was in the background</span></span><br><span class="line">    <span class="comment">// scheduling group, so first we will make sure it is in the default/foreground</span></span><br><span class="line">    <span class="comment">// one to avoid performing an initial transaction in the background.</span></span><br><span class="line">    <span class="comment">// 调度线程的优先级</span></span><br><span class="line">    androidSetThreadSchedulingGroup(mMyThreadId, ANDROID_TGROUP_DEFAULT);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">status_t</span> result;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">int32_t</span> cmd;</span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取命令</span></span><br><span class="line">        result = talkWithDriver();</span><br><span class="line">        <span class="keyword">if</span> (result &gt;= NO_ERROR) &#123;</span><br><span class="line">            <span class="keyword">size_t</span> IN = mIn.dataAvail();</span><br><span class="line">            <span class="keyword">if</span> (IN &lt; <span class="keyword">sizeof</span>(<span class="keyword">int32_t</span>)) <span class="keyword">continue</span>;</span><br><span class="line">            cmd = mIn.readInt32();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用该函数执行命令</span></span><br><span class="line">            result = executeCommand(cmd);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调度线程的优先级</span></span><br><span class="line">        androidSetThreadSchedulingGroup(mMyThreadId, ANDROID_TGROUP_DEFAULT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Let this thread exit the thread pool if it is no longer</span></span><br><span class="line">        <span class="comment">// needed and it is not the main process thread.</span></span><br><span class="line">        <span class="keyword">if</span>(result == TIMED_OUT &amp;&amp; !isMain) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (result != -ECONNREFUSED &amp;&amp; result != -EBADF);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出 Looper 状态</span></span><br><span class="line">    mOut.writeInt32(BC_EXIT_LOOPER);</span><br><span class="line">    <span class="comment">// 不再接受数据</span></span><br><span class="line">    talkWithDriver(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以这里是起了两个线程，不停的从驱动中读取数据，并交给<code>executeCommand()</code>执行命令。在处理各种命令的时候，有一段如下的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tr.target.ptr) &#123;</span><br><span class="line">	sp&lt;BBinder&gt; b((BBinder*)tr.cookie);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">status_t</span> error = b-&gt;transact(tr.code, buffer, &amp;reply, tr.flags);</span><br><span class="line">	<span class="keyword">if</span> (error &lt; NO_ERROR) reply.setError(error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码可谓精华了！还记得<code>cookie</code>记录的是什么么？服务实例在用户空间的引用地址！所以这里是根据这个地址又拿到了该服务的实例，然后还记得这张图么？</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/Binder-Lib层架构.png" alt="Binder Lib层架构"></div>

<p>BBinder的<code>transact()</code>方法实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> BBinder::transact(</span><br><span class="line">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    data.setDataPosition(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err = NO_ERROR;</span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">        <span class="keyword">case</span> PING_TRANSACTION:</span><br><span class="line">            reply-&gt;writeInt32(pingBinder());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            err = onTransact(code, data, reply, flags);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reply != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        reply-&gt;setDataPosition(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里调用的又是<code>onTransact()</code>，而这个方法又是在BBinder的子类，比如<code>BnMediaPlayerService</code>中实现的 —— 即可以根据具体的服务 API 进行不同的解析，并完成相关功能。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>代码分析完毕，读者可能觉得整个过程无比繁杂，有些方法又臭又长，还不止调用一次。但实际上这块机制并不复杂，理解起来困难可能是因为：</p>
<ol>
<li>C++ 语言编写，对于 Java 开发者来说语言不熟悉，C++ 本身的语言特性也导致阅读起来比较困难；</li>
<li>涉及驱动层，驱动知识造成障碍；</li>
<li>不能调试，如果是一个开源框架，我们是可以写一个 Demo 去调试某个点的，这样就不用费这么多精力把脑子当做计算机使用了；</li>
<li>对 Libraries 和 Binder 驱动层的交互协议不清楚，这样在数据上就比较难搞清楚结构，方法调用链又长，调用几层之后对于参数的内容就模糊了；</li>
<li>代码问题，这两层的代码写的并不好，注释也少，理解起来非常费力；</li>
</ol>
<blockquote>
<p>和 framework 层的代码比起来，这里的方法调用链其实并不算长。</p>
</blockquote>
<p>这里类比网络请求做一些文字描述，希望有助于读者搞清楚 Binder 的机理。大体过程上有以下几个关键部分：</p>
<ol>
<li>使用<code>binder_write_read</code>结构体在 Libraries 层和驱动层之间做数据传输介质，类比网络请求，该结构体就相当于 Request 和 Response 的合体；</li>
<li>有传输介质之后，传输使用的手段是<code>ioctl</code>、<code>open</code>等函数，类比网络请求，就像<code>openConnection()</code>等函数；</li>
<li>如果我们要发送数据，则在<code>binder_write_read</code>结构体的 write 部分写入数据，驱动层会 copy 数据到内核空间，并读取数据进行处理，当然，这个时候也会携带一些命令，比如<code>BINDER_WRITE_READ</code>，类比网络请求，这些命令类似于<code>GET</code>，<code>POST</code>等；</li>
<li>如果<code>binder_write_read</code>的 read 部分要求读取数据，那么驱动层会查看有没有事务要处理，有没有数据要传输给上层（具体传输什么数据，由场景确定），如果有就写入到 read 部分并 copy 到 Libraries 层，函数返回，Libraries 层读取数据进行处理，同样的这个时候数据中也会有命令，类比网络请求，这些命令就像”200”，”404”，”500”等 Http Status Code；如果没有数据，则会阻塞在自己的事务处理队列上，<ol>
<li>驱动层拿到数据之后，会做一些处理，比如生成<code>binder_node</code>节点，在目标进程中生成<code>binder_ref</code>节点，并操作红黑树、插入<code>binder_transaction</code>等等，这些过程看上去极为复杂，原因是我们一开始并不了解 binder 具体要做什么。实际上 binder 记录这些数据只为两件事：binder_transaction 能够正确发送到目标进程和目标进程处理完事务之后能够正确找到回复进程。这是 IPC 的主要任务，其余的数据都是为了这两个目标准备的。举个例子，比如在注册的时候在目标进程的 transaction_stack 中插入 binder_transaction 节点，就是为了处理完事务之后可以找到回复进程；</li>
</ol>
</li>
</ol>
<p>以上前四点和一个网络请求并无二致，只是数据规则变了一下，最后一点则是机制本身导致的特性。另外这里有一个核心点一定要整理一下：</p>
<p><strong>每一个服务都会对应在驱动层生成一个<code>binder_node</code>节点，这个节点是记录在本服务进程在驱动层的映射<code>binder_proc</code>结构体中的，binder驱动会维护很多的<code>binder_proc</code>结构体，在除本进程外的<code>binder_proc</code>结构体中，引用本进程的服务，一律使用的是<code>binder_ref</code>结构体！至于如何通过<code>binder_ref</code>结构体获取到对应的服务，正是下一篇文章所要探索的内容。</strong></p>
<p>以上，如果读者想要了解原理的话，直接读这部分即可。如果读者想了解一些较细致的原理的话，墙裂建议阅读推荐文章①和文章③两系列博客，还是那个评价：整理有序，图文并茂。实乃对付此等巨兽的神兵之作。</p>
<p>至此，服务注册分析完成。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[观影《辩护人》]]></title>
      <url>http://www.timebridge.space/2016/06/19/paraclete/</url>
      <content type="html"><![CDATA[<p>豆瓣评分9.1分，应该归入极好的电影一类的了，是在公司电影俱乐部和同事一起观看的。</p>
<p>看久了国内这些“搞笑、无厘头、秀特效”的电影之后，就感觉是在一堆玻璃种找到了一块玉石，沉甸甸的。</p>
<p>影片最大的感受是：<strong>判断是否去做一件事的标准决不是它的高低贵贱，而是它是否是正确的，正确的判断标准是是否对绝大部分人有益。</strong>明白自己的责任，不畏他人的眼光，坚决贯彻自己的选择，so man不是吗？<a id="more"></a></p>
<p>宋佑硕搬过砖（是真的搬砖），以高中学历做过法官，以律师身份进行过不动产代书，这些都被别人瞧不起，但是他丝毫没有动摇，他很明白自己在做什么，要做什么。</p>
<p>在这些铺垫之后，终于进入国安法官司的主情节。因为有这样的性格和三观，他才能顶住各方压力，不畏恐吓，坚定自己的信念完成那场官司（此处赞演技），朝着自己的最终目标（朴镇宇无罪）一步步迈进，最终赢得同行的尊重。</p>
<p>电影情节平缓有序，结尾连续三个高潮，成功塑造了宋佑硕的形象，赞的一逼！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Gradle系列十三：实战]]></title>
      <url>http://www.timebridge.space/2016/06/18/gradle-advaced-usage/</url>
      <content type="html"><![CDATA[<h4 id="生成项目报告"><a href="#生成项目报告" class="headerlink" title="生成项目报告"></a>生成项目报告</h4><p>可以使用插件 <strong>project-report</strong> ，具体见<a href="https://docs.gradle.org/current/userguide/project_reports_plugin.html" target="_blank" rel="noopener">The Project Report Plugin</a>。</p>
<p>这里面包含依赖（文本格式、HTML格式）、Task、属性等的报告<a id="more"></a></p>
<h4 id="指定JDK版本"><a href="#指定JDK版本" class="headerlink" title="指定JDK版本"></a>指定JDK版本</h4><p>在“gradle.properties”文件夹下面添加如下语句:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.gradle.java.home=/Library/Java/JavaVirtualMachines/jdk1.8.0_25.jdk/Contents/Home</span><br></pre></td></tr></table></figure>
<p>值是<code>JAVA_HOME</code>。</p>
<h4 id="关于”provided”"><a href="#关于”provided”" class="headerlink" title="关于”provided”"></a>关于”provided”</h4><p>这篇文章有比较深入详细的解释：<a href="https://sinking.in/blog/provided-scope-in-gradle/" target="_blank" rel="noopener">PROVIDED SCOPE IN GRADLE</a>。实际上编译和打包这两个过程是独立的，这可以通过 SourceSet 的属性来控制：首先定义”provided” configuration，将由它配置的文件加到compileClasspath，这样编译即可通过，但是在runtimeClasspath中我们并不加入 “provided” 配置的文件，这就OK了。</p>
<blockquote>
<p>日了狗，Javan Plugin的<code>compile</code>居然不会把依赖打包入最终的jar包，与设想的很不一样。</p>
</blockquote>
<h4 id="强制刷新缓存"><a href="#强制刷新缓存" class="headerlink" title="强制刷新缓存"></a>强制刷新缓存</h4><p>命令：<code>gradle build --refresh-dependencies</code>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Gradle系列八：生命周期]]></title>
      <url>http://www.timebridge.space/2016/06/18/gradle-lifecycle/</url>
      <content type="html"><![CDATA[<p>Gradle 的核心是一门以依赖为基础的 DSL。开发者通过定义 Task 以及 Task 之间的依赖来完成任务。Gradle 确认会根据依赖关系来执行 Task，并且每一个 Task 都只会被执行一次，Gradle 会在执行 Task 之前先构建一个依赖关系图。</p>
<blockquote>
<p>构建脚本就是用于配置这个依赖关系图，因此构建脚本实际上是配置脚本。</p>
</blockquote>
<a id="more"></a>
<h2 id="一、构建步骤"><a href="#一、构建步骤" class="headerlink" title="一、构建步骤"></a>一、构建步骤</h2><p>Gradle 构建有三个步骤。</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Initialization</strong></td>
<td>Gradle 支持单项目或者多项目构建，在该阶段，Gradle 确认哪些项目会参与构建，然后为每一个项目创建 Project 对象</td>
</tr>
<tr>
<td><strong>Configuration</strong></td>
<td>这个阶段就是配置 Initialization 阶段创建的 Project 对象，所有的配置脚本都会被执行</td>
</tr>
<tr>
<td><strong>Execution</strong></td>
<td>这个阶段 Gradle 会确认哪些在 Configuration 阶段创建和配置的 Task 会被执行，哪些 Task 会被执行取决于<code>gradle</code>命令的参数以及当前的目录，确认之后便会执行</td>
</tr>
</tbody>
</table>
<h2 id="二、生命周期示例"><a href="#二、生命周期示例" class="headerlink" title="二、生命周期示例"></a>二、生命周期示例</h2><p>如果我们在一个目录下面执行<code>gradle init</code>命令，那么标准的 gradle 构建项目下是会创建 “settings.gradle” 文件的。对于单项目构建，这个文件是可选的，但对于多项目构建，这个文件是必须的。这个文件会在 initialization 阶段被执行，这个文件会根据命名规范列出需要参与构建的项目。</p>
<p>在一个 “settings.gradle” 文件中写入如下内容:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println <span class="string">'This is executed during the initialization phase.'</span></span><br></pre></td></tr></table></figure>
<p>在 “build.gradle” 文件中写入如下内容:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">println <span class="string">'This is executed during the configuration phase.'</span></span><br><span class="line"></span><br><span class="line">task configured &#123;</span><br><span class="line">    println <span class="string">'This is also executed during the configuration phase.'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task test &lt;&lt; &#123;</span><br><span class="line">    println <span class="string">'This is executed during the execution phase.'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task testBoth &#123;</span><br><span class="line">    doFirst &#123;</span><br><span class="line">      println <span class="string">'This is executed first during the execution phase.'</span></span><br><span class="line">    &#125;</span><br><span class="line">    doLast &#123;</span><br><span class="line">      println <span class="string">'This is executed last during the execution phase.'</span></span><br><span class="line">    &#125;</span><br><span class="line">    println <span class="string">'This is executed during the configuration phase as well.'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行命令<code>gradle test testBoth</code>，就会得到如下输出:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; gradle test testBoth</span><br><span class="line">This is executed during the initialization phase.</span><br><span class="line">This is executed during the configuration phase.</span><br><span class="line">This is also executed during the configuration phase.</span><br><span class="line">This is executed during the configuration phase as well.</span><br><span class="line">:test</span><br><span class="line">This is executed during the execution phase.</span><br><span class="line">:testBoth</span><br><span class="line">This is executed first during the execution phase.</span><br><span class="line">This is executed last during the execution phase.</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"></span><br><span class="line">Total time: <span class="number">1</span> secs</span><br></pre></td></tr></table></figure>
<p>根据文案提示，具体的动作发生的生命周期阶段都是很清楚的。</p>
<blockquote>
<p>对于构建脚本(即 “build.gradle”)来说，属性获取和方法调用都被代理到 Project 对象，而同样的，在 “settings.gradle” 中进行的属性获取和方法调用都会被代理到 Settings对象。</p>
<p>这一点会在在<a href="http://www.muzileecoding.com/gradlestudy/gradle-advaced-do.html" target="_blank" rel="noopener">Gradle DO模型</a>中详细解释。</p>
</blockquote>
<h2 id="三、Initialization"><a href="#三、Initialization" class="headerlink" title="三、Initialization"></a>三、Initialization</h2><p>Gradle 如何知道自己在构建的是一个单项目构建项目还是一个项目构建项目呢？如果它是在一个有 “settings.gradle” 的文件夹下面运行，事情就变得很简单，但是 Gradle 允许在任何一个子项目下面执行命令，所以这涉及到一个寻找 “build.gradle” 文件的过程，搜寻路径如下:</p>
<ol>
<li>It looks in a directory called master which has the same nesting level as the current dir.</li>
<li>If not found yet, it searches parent directories.</li>
<li>If not found yet, the build is executed as a single project build.</li>
<li>If a settings.gradle file is found, Gradle checks if the current project is part of the multiproject hierarchy defined in the found settings.gradle file. If not, the build is executed as a single project build. Otherwise a multiproject build is executed.</li>
</ol>
<blockquote>
<p>这个搜索过程很奇怪，因为实际上 Gradle 的构建项目并不一定只嵌套两层。</p>
</blockquote>
<p>为什么要进行这样的搜索呢？Gradle 在执行构建的时候是需要确认是不是在多项目下的子项目中。如果是在子项目中，那么只有子项目以及它们依赖的子项目会被构建，但是一些配置以及依赖关系是需要从多项目构建配置中读取的，因此还是需要确认究竟是不是多项目。开发者可以使用<code>-u</code>命令来告诉 Gradle 不要进行搜索，那么当前项目就会被当做单项目进行构建，如果当前项目包含 “settings.gradle” 文件，则<code>-u</code>无效。</p>
<p>另外，以上的搜索方法只适合于 physical hierarchical 或者 flat layout 类型的构建项目。</p>
<blockquote>
<p>不了解这两个概念的，可以在文章<a href="http://www.muzileecoding.com/gradlestudy/gradle-project-and-script.html" target="_blank" rel="noopener">Gradle 项目和脚本</a>中查询到。</p>
</blockquote>
<h2 id="四、生命周期"><a href="#四、生命周期" class="headerlink" title="四、生命周期"></a>四、生命周期</h2><p>Gradle 的构建分为三个阶段，在这些阶段之间，开发者是可以收到一些回调的，回调分为两类: </p>
<ol>
<li>实现某一类型的监听接口；</li>
<li>提供一个回调闭包以供调用；</li>
</ol>
<p>下面都是以闭包的形式举得例子，并且也不全面，建议直接阅读 API 文档获取更多的方法。</p>
<h4 id="4-1-Project-evaluation"><a href="#4-1-Project-evaluation" class="headerlink" title="4.1 Project evaluation"></a>4.1 Project evaluation</h4><p>在一个 Project 被 evaluate(这个词始终没有找到好的翻译，实践中它是指向 Configuration 之后，Execution 之前的一个阶段，所以应该是指Project被配置好) 之后，会收到一个回调，通过这个回调可以添加额外的配置，或者打一些 Log:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    afterEvaluate &#123; project -&gt;</span><br><span class="line">        <span class="keyword">if</span> (project.hasTests) &#123;</span><br><span class="line">            println <span class="string">"Adding test task to $project"</span></span><br><span class="line">            project.task(<span class="string">'test'</span>) &lt;&lt; &#123;</span><br><span class="line">                println <span class="string">"Running tests for $project"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，在有<code>hasTests</code>属相的Project中创建一个名为<code>test</code>的 Task。这就是通过提供闭包的形式在生命周期的某个节点上添加动作的效果。</p>
<p>但有时候 evaluate 会失败，如果这个时候需要收到消息，就应该使用另外一个回调:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gradle.afterProject &#123;project, projectState -&gt;</span><br><span class="line">    <span class="keyword">if</span> (projectState.failure) &#123;</span><br><span class="line">        println <span class="string">"Evaluation of $project FAILED"</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        println <span class="string">"Evaluation of $project succeeded"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以对 Gradle 对象添加 <code>ProjectEvaluationListener</code> 来监听这些事件。</p>
<h4 id="4-2-Task-creation"><a href="#4-2-Task-creation" class="headerlink" title="4.2 Task creation"></a>4.2 Task creation</h4><p>在一个 Task 被添加到 Project 的时候（也就是创建的时候），也可以收到回调，这可以被用来设置一些默认值或者添加行为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tasks.whenTaskAdded &#123; task -&gt;</span><br><span class="line">    task.ext.srcDir = <span class="string">'src/main/java'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task a</span><br><span class="line"></span><br><span class="line">println <span class="string">"source dir is $a.srcDir"</span></span><br></pre></td></tr></table></figure>
<p>当然也可以通过在<code>TaskContainer</code>中添加 Action 来达到目的。</p>
<h5 id="4-2-1-Task-execution-graph-ready"><a href="#4-2-1-Task-execution-graph-ready" class="headerlink" title="4.2.1 Task execution graph ready"></a>4.2.1 Task execution graph ready</h5><p>前面说了，开发者定义完 Task 以及它们的依赖关系之后，在执行前会生成 Task execution graph。在生成完这张图（Configuration 阶段完成）之后也会收到一个回调，利用这个回调，我们可以检查是否有我们需要的 Task，以及整个 Graph 的状态是否符合我们的预期，比如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">task distribution &lt;&lt; &#123;</span><br><span class="line">    println <span class="string">"We build the zip with version=$version"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">task <span class="title">release</span><span class="params">(dependsOn: <span class="string">'distribution'</span>)</span> &lt;&lt; </span>&#123;</span><br><span class="line">    println <span class="string">'We release now'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gradle.taskGraph.whenReady &#123;taskGraph -&gt;</span><br><span class="line">    <span class="keyword">if</span> (taskGraph.hasTask(release)) &#123;</span><br><span class="line">        version = <span class="string">'1.0'</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        version = <span class="string">'1.0-SNAPSHOT'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行<code>gradle -q distribution</code>之后，可以得到如下输出:</p>
<pre><code>&gt;gradle -q distribution
We build the zip with version=1.0-SNAPSHOT
</code></pre><p>执行<code>gradle -q release</code>之后，输出则如下:</p>
<pre><code>&gt;gradle -q release
We build the zip with version=1.0
We release now
</code></pre><p>这样我们就可以在一个 Task 被执行之前根据环境对它进行控制。</p>
<p>另外也可以通过添加<code>TaskExecutionGraphListener</code>监听到<code>TaskExecutionGraph</code>来接收事件。</p>
<h5 id="4-2-2-Task-execution"><a href="#4-2-2-Task-execution" class="headerlink" title="4.2.2 Task execution"></a>4.2.2 Task execution</h5><p>在 Task 执行前后也可以接受回调事件，并且无论是否执行成功都能收到:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">task ok</span><br><span class="line"></span><br><span class="line"><span class="function">task <span class="title">broken</span><span class="params">(dependsOn: ok)</span> &lt;&lt; </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">'broken'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gradle.taskGraph.beforeTask &#123; Task task -&gt;</span><br><span class="line">    println <span class="string">"executing $task ..."</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gradle.taskGraph.afterTask &#123; Task task, TaskState state -&gt;</span><br><span class="line">    <span class="keyword">if</span> (state.failure) &#123;</span><br><span class="line">        println <span class="string">"FAILED"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        println <span class="string">"done"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行一下<code>gradle -q broken</code>，可以得到如下输出:</p>
<pre><code>&gt; gradle -q broken
executing task &apos;:ok&apos; ...
done
executing task &apos;:broken&apos; ...
FAILED
</code></pre><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>Gradle 执行构建的三个阶段非常清楚，提供了多种方式让开发者有机会监听、更改构建状态，这也是 Gradle 强大、灵活的原因之一。</p>
<p>除了上面提到的这些方法，监听声明周期的方法有很多，主要集中在<code>TaskExecutionGraph</code>、<code>Gradle</code>和<code>Project</code>三个类中，全部列出来意义不大，建议读者在有需求的时候可以将相关方法都研究一下，注释还是比较全面的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Gradle系列十一：Daemon]]></title>
      <url>http://www.timebridge.space/2016/06/18/gradle-daemon/</url>
      <content type="html"><![CDATA[<p>维基百科定义:</p>
<blockquote>
<p>A daemon is a computer program that runs as a background process, rather than being under the direct control of an interactive user.</p>
</blockquote>
<p>Gradle 运行在 JVM 上，需要耗费一定的时间运行多个支持库，因此看上去运行起来比较慢，Gradle 使用 Daemon 来解决这个问题：<strong>通过一个长期运行在后台来执行构建的进程，可以缓存一些构建数据在内存中，利用 JVM 在运行代码期间对代码的优化（避免每次运行都做优化）来提高构建速度</strong>。</p>
<p>决定是否使用 Daemon 只需要简单的配置即可，且使用和不使用 Daemon 的时候构建没有任何不同。<a id="more"></a></p>
<h3 id="1-打开Daemon"><a href="#1-打开Daemon" class="headerlink" title="1. 打开Daemon"></a>1. 打开Daemon</h3><p><strong>默认情况下是不打开 Daemon 的，但是强烈建议在开发机器上打开这个配置（持续集成服务器上关闭）。</strong> 有很多方式打开 Daemon，但是最常用的方式是在<code>«USER_HOME»/.gradle/gradle.properties</code>中加入下面一行:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.gradle.daemon=<span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>«USER_HOME» 通常的目录是:</p>
<ol>
<li>C:\Users\<username> (Windows Vista &amp; 7+)</username></li>
<li>/Users/<username> (Mac OS X)</username></li>
<li>/home/<username> (Linux)</username></li>
</ol>
<p>如果找不到对应文件，可以新建一个。</p>
</blockquote>
<p>一旦打开 Daemon，不论 Gradle 是什么版本，所有的构建都会得到速度的提升。</p>
<p>除了上面的方法，还可以通过添加<code>--daemon</code>或者<code>--no-daemon</code>来对单次构建进行配置。</p>
<h3 id="2-关闭Daemon"><a href="#2-关闭Daemon" class="headerlink" title="2. 关闭Daemon"></a>2. 关闭Daemon</h3><p>每一个 Gradle Daemon 进程在3小时无活动的情况下都会自动关闭。但是我们也可以通过执行<code>gradle --stop</code>命令显示的关闭它 —— 这个命令会关闭所有的执行该命令所用同一版本的 Gradle 唤起的 Daemon 进程。</p>
<blockquote>
<p>如果安装了 JDK，可以很简单使用<code>jps</code>命令查看关闭情况。</p>
<p>有时候会有多个 Gradle Daemon 进程，原因可能是因为 Gradle 找不到空闲的 Daemon 进程和 Compatible 进程（比如 JVM 配置不符合当前构建的要求）—— 关于这块，文档中有详细的描述。</p>
<p>实际在关闭之后还是会看到<code>GradleDaemon</code>命名的进程。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Gradle系列十：Warpper]]></title>
      <url>http://www.timebridge.space/2016/06/18/gradle-wrapper/</url>
      <content type="html"><![CDATA[<p>大部分的软件都需要提前安装才能使用，如果安装很简单那么还可以接受，但是有时候安装需要考虑版本问题、配置环境，是比较复杂的。构建软件的工具版本有时候还是随着软件的迭代进行升级的，这样安装构建工具更加麻烦。</p>
<p>Wrapper 是 Gradle 提供来解决这个问题的。<a id="more"></a></p>
<h3 id="添加Wrapper"><a href="#添加Wrapper" class="headerlink" title="添加Wrapper"></a>添加Wrapper</h3><p>在上面讲<code>gradle tasks</code>命令的时候，有一组 Task 被归类为<code>Build Setup tasks</code>，它们是用来初始化一个构建项目的，我们新建一个空文件夹，在该文件夹下面执行<code>gradle init</code>命令，再查看这个文件夹的内容，会发现内容如下：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/gradle项目初始状态.png" alt="gradle项目初始状态"></div>

<p>如图，这就是一个标准的 Gradle 构建项目的配置。</p>
<p>另外还有一个命令是<code>gradle wrapper</code>，在我们最开始的例子中，我们只新建了一个<code>build.gradle</code>文件，执行该命令之后，也能得到如上的文件结构(不过没有<code>settings.gradle</code>文件)。这个命令实际可以指定需要配置的 Wrapper 的版本，如下:<code>gradle wrapper --gradle-version 2.0</code>即可。</p>
<p>在这些文件中，有四个文件就是为 Wrapper 功能生成的:</p>
<ol>
<li>gradlew (Unix Shell script)</li>
<li>gradlew.bat (Windows batch file)</li>
<li>gradle/wrapper/gradle-wrapper.jar (Wrapper JAR)</li>
<li>gradle/wrapper/gradle-wrapper.properties (Wrapper properties)</li>
</ol>
<h3 id="Wrapper使用"><a href="#Wrapper使用" class="headerlink" title="Wrapper使用"></a>Wrapper使用</h3><p>如果项目配置了 Gradle Wrapper (存在上面的目录结构)，就可以在根目录下面执行下面两个命令:</p>
<ul>
<li><strong><code>./gradlew &lt;task&gt;</code></strong> （在类Unix机器上，比如Linux或者Mac）</li>
<li><strong><code>gradlew &lt;task&gt;</code></strong> （在Windows机器上）</li>
</ul>
<p>因为每一个 Wrapper 都指定了一个特定版本的 Gradle，所以当我们第一次执行以上命令的时候，它就会去下载对应版本 Gradle，然后用这个版本去构建项目——下载的 Gradle 存放在<code>$USER_HOME/.gradle/wrapper/dists</code>。</p>
<blockquote>
<p>Wrapper提供了绑定 Gradle 版本到项目以及下载对应版本的 Gradle 的能力，这样只需要把 Wrapper 相关文件和项目一起提交到版本控制工具中，就可以保证以后构建这个项目的时候，始终使用的是同一个版本的构建工具。</p>
</blockquote>
<p>如果使用 Wrapper 构建，那么本机上的任何构建版本都会被忽略。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在<code>gradle-wrapper.properties</code>文件中，有一个配置项如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">distributionUrl=https\:<span class="comment">//services.gradle.org/distributions/gradle-2.3-bin.zip</span></span><br></pre></td></tr></table></figure>
<p>这个 Url 指定了 Gradle 的下载地址，可以修改这个地址下载不同版本的 Gradle。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Gradle系列六：命令行]]></title>
      <url>http://www.timebridge.space/2016/06/18/gradle-command/</url>
      <content type="html"><![CDATA[<p>当看完 Task 入门，我们已经可以写一些简单的脚本了。下面来系统学习一下 Gradle 命令行相关内容。</p>
<p>以下面脚本为例：<a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">task compile &lt;&lt; &#123;</span><br><span class="line">    println <span class="string">'compiling source'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">task <span class="title">compileTest</span><span class="params">(dependsOn: compile)</span> &lt;&lt; </span>&#123;</span><br><span class="line">    println <span class="string">'compiling unit tests'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//依赖两个Task</span></span><br><span class="line"><span class="function">task <span class="title">test</span><span class="params">(dependsOn: [compile, compileTest])</span> &lt;&lt; </span>&#123;</span><br><span class="line">    println <span class="string">'running unit tests'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">task <span class="title">dist</span><span class="params">(dependsOn: [compile, test])</span> &lt;&lt; </span>&#123;</span><br><span class="line">    println <span class="string">'building the distribution'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依赖关系如下:<br><img src="https://docs.gradle.org/current/userguide/img/commandLineTutorialTasks.png" alt="脚本依赖关系"></p>
<h3 id="1-Excluding-tasks"><a href="#1-Excluding-tasks" class="headerlink" title="1. Excluding tasks"></a>1. Excluding tasks</h3><p>可以使用<code>-x</code>选项剔除一个 Task 的执行，比如针对以上脚本，我们运行<code>gradle dist -x test</code>，会得到如下输出:</p>
<pre><code>&gt; gradle dist -x test
:compile
compiling source
:dist
building the distribution

BUILD SUCCESSFUL

Total time: 1 secs
</code></pre><p>只有 compile 和 dist 两个任务执行了，test 以及被 test 依赖的 compileTest 都没有执行。另外虽然 test 没有执行，但是依赖 test 的 dist 还是执行完成了，这说明<code>dependOn</code>其实并不是一个强依赖。</p>
<h3 id="2-Task-name-abbreviation"><a href="#2-Task-name-abbreviation" class="headerlink" title="2. Task name abbreviation"></a>2. Task name abbreviation</h3><p>执行Task的时候可以使用 Task 名字缩写，比如执行 dist 可以使用<code>gradle -q di</code>，执行 compileTest 可以使用<code>gradle compTest</code>或者<code>gradle cT</code>。</p>
<h3 id="3-Selecting-which-build-to-execute"><a href="#3-Selecting-which-build-to-execute" class="headerlink" title="3. Selecting which build to execute"></a>3. Selecting which build to execute</h3><p>一般我们执行<code>gradle</code>命令的时候，Gradle 会在当前目录下寻找脚本，我们可以使用<code>-b</code>选项来指定其余路径下面的脚本文件，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle -q -b subdir/myproject.gradle hello</span><br></pre></td></tr></table></figure>
<p>一旦使用了<code>-b</code>选项，那么 “settings.gradle” 文件将不会被使用。对于多项目脚本，可以使用<code>-p</code>指定目录：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle -q -p subdir hello</span><br></pre></td></tr></table></figure>
<h3 id="4-获取脚本文件信息"><a href="#4-获取脚本文件信息" class="headerlink" title="4. 获取脚本文件信息"></a>4. 获取脚本文件信息</h3><p>通过<code>gradle tasks</code>命令能看到当前可执行的所有 Task。每一个 Task 后面都会跟上 description 用于描述 Task 的具体功能（等讲到脚本的生命周期的时候，会提到如何为一个 Task 添加描述）。在我的脚本中执行<code>gradle -q tasks</code>，可以获得如下输出:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">------------------------------------------------------------</span><br><span class="line">All tasks runnable from root project</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Build Setup tasks</span><br><span class="line">-----------------</span><br><span class="line">init - Initializes a <span class="keyword">new</span> Gradle build. [incubating]</span><br><span class="line">wrapper - Generates Gradle wrapper files. [incubating]</span><br><span class="line"></span><br><span class="line">Help tasks</span><br><span class="line">----------</span><br><span class="line">components - Displays the components produced by root project <span class="string">'gradle'</span>. [incubating]</span><br><span class="line">dependencies - Displays all dependencies declared in root project <span class="string">'gradle'</span>.</span><br><span class="line">dependencyInsight - Displays the insight into a specific dependency in root project <span class="string">'gradle'</span>.</span><br><span class="line">help - Displays a help message.</span><br><span class="line">projects - Displays the sub-projects of root project <span class="string">'gradle'</span>.</span><br><span class="line">properties - Displays the properties of root project <span class="string">'gradle'</span>.</span><br><span class="line">tasks - Displays the tasks runnable from root project <span class="string">'gradle'</span>.</span><br><span class="line"></span><br><span class="line">To see all tasks and more detail, run gradle tasks --all</span><br><span class="line"></span><br><span class="line">To see more detail about a task, run gradle help --task &lt;task&gt;</span><br></pre></td></tr></table></figure>
<p>可以打印出所有可执行的 Task，包括子 Project 中的 Task。每一个 Task 后面都跟着这个 Task 的功能描述。</p>
<p>其中<code>Help tasks</code>中的 Task 可以获取关于本脚本的很多信息，比如<code>gradle dependencies</code>可以列出根项目所依赖的项目。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java动态代理实现]]></title>
      <url>http://www.timebridge.space/2016/06/14/aidl-demo/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>AIDL</strong> ，全称 Android Interface Definition Language，是用于定义 IPC 的客户端和服务端之间的交互接口的。</p>
<p>在 Android 上，进程之间是不能直接通信的，必须通过操作系统对数据进行转化传输，才能打破进程边界，完成进行通信。这个过程如果手动完成会比较枯燥复杂， Android 上的 IPC 实际依赖的是底层 Binder 框架，而 <strong>AIDL</strong> 是 Android 在 Java 层对 Binder 机制的封装。<a id="more"></a></p>
<p>官网介绍 <strong>AIDL</strong> 的地址是 <a href="https://developer.android.com/guide/components/aidl.html" target="_blank" rel="noopener">Android Interface Definition Language (AIDL)</a>。本文主要是实践一个例子，具体详细的内容读者可以直接看官网，本文不做介绍，主要包括:</p>
<ol>
<li><strong>AIDL</strong> 支持的数据类型（下面例子中也能看到）；</li>
<li>什么时候应当使用 <strong>AIDL</strong>（还有Messenger等IPC方式）；</li>
</ol>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h4 id="AIDL-文件的创建"><a href="#AIDL-文件的创建" class="headerlink" title="AIDL 文件的创建"></a>AIDL 文件的创建</h4><p>首先在项目<code>A</code>下面右击一个 module ，选择”New” -&gt; “Folder” -&gt; “AIDL Folder”，就可以在 module 下面新建一个 aidl 文件夹，具体如下:</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/aidl_foler.png" width="250" alt="AIDL 文件夹"></div>

<p>然后我们在这个文件夹下面新建一个包，比如”com.footprint.littleshell”，然后选择”New” -&gt; “AIDL” -&gt; “AIDL File”，输入文件名，就可以新建一个 aidl 文件出来了，在文件中输入如下内容:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.footprint.littleshell.MyRect;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMyAidlInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">basicTypes</span><span class="params">(<span class="keyword">int</span> anInt, <span class="keyword">long</span> aLong, <span class="keyword">boolean</span> aBoolean, <span class="keyword">float</span> aFloat,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">double</span> aDouble, String aString)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">MyRect <span class="title">newRect</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个接口以及<code>MyRect</code>都是仿照官网上的例子写的，并且<code>basicTypes</code>方法在文件创建的时候就默认被添加了，表明 <strong>AIDL</strong> 支持的几种基本类型，这里没有删掉，直接拿来使用，而<code>newRect</code>的返回值是一个复杂对象。</p>
<p>Android IPC 或者说 <strong>ADIL</strong> 传输复杂对象是需要进行特殊处理的，这一点在<a href="https://developer.android.com/guide/components/aidl.html#PassingObjects" target="_blank" rel="noopener">官网</a>上有特别描述，主要分为以下几步:</p>
<ol>
<li>复杂对象类必须实现<code>Parcelable</code>接口(这里就不细说了)；</li>
<li>创建<code>.aidl</code>文件来声明该类；</li>
</ol>
<p>我们一步步照做，首先创建<code>MyRect</code>类，它的代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.footprint.littleshell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Parcel;</span><br><span class="line"><span class="keyword">import</span> android.os.Parcelable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRect</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> left;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> top;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> right;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> bottom;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcelable.Creator&lt;MyRect&gt; CREATOR = <span class="keyword">new</span></span><br><span class="line">            Parcelable.Creator&lt;MyRect&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> MyRect <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> MyRect(in);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">public</span> MyRect[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> MyRect[size];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyRect</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        readFromParcel(in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        left = in.readInt();</span><br><span class="line">        top = in.readInt();</span><br><span class="line">        right = in.readInt();</span><br><span class="line">        bottom = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        dest.writeInt(left);</span><br><span class="line">        dest.writeInt(top);</span><br><span class="line">        dest.writeInt(right);</span><br><span class="line">        dest.writeInt(bottom);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按要求实现了相关的方法，这保证这个类可以在 Android 系统上被序列化反序列化，从而能够在进程间传递。</p>
<p>第二步就是创建 “aidl” 文件，具体位置前面的截图可以看到，文件名为 “MyRect.aidl”，内容为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyRect.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.footprint.littleshell;</span><br><span class="line"></span><br><span class="line">parcelable MyRect;</span><br></pre></td></tr></table></figure>
<p>这样一来我们就可以编译项目了，编译完成之后，可以在下图位置找到生成的接口文件:</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/AIDL生成文件位置.png" width="250" alt="AIDL生成文件位置"></div>

<p>文件的具体内容就详细去看了，后面会有文章详细剖析它的内容，本文主要讲述如何去用。</p>
<h4 id="IPC-调用"><a href="#IPC-调用" class="headerlink" title="IPC 调用"></a>IPC 调用</h4><p>既然是 IPC，就必然有 Client 和 Server 。先来写一个 Service:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Return the interface</span></span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">// 返回Stub的实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IMyAidlInterface.Stub mBinder = <span class="keyword">new</span> IMyAidlInterface.Stub() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">basicTypes</span><span class="params">(<span class="keyword">int</span> anInt, <span class="keyword">long</span> aLong, <span class="keyword">boolean</span> aBoolean, <span class="keyword">float</span> aFloat, <span class="keyword">double</span> aDouble, String aString)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> MyRect <span class="title">newRect</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            MyRect myRect = <span class="keyword">new</span> MyRect();</span><br><span class="line">            myRect.bottom = <span class="number">1</span>;</span><br><span class="line">            myRect.top = <span class="number">2</span>;</span><br><span class="line">            myRect.left = <span class="number">3</span>;</span><br><span class="line">            myRect.right = <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">return</span> myRect;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>别忘了在 “AndroidManifest.xml” 文件中进行注册:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span></span></span><br><span class="line"><span class="tag">	<span class="attr">android:name</span>=<span class="string">".RemoteService"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">android:exported</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>写完就可以 run 到你的手机上了。接下来就来写 Client。</p>
<p>新建一个项目，按照前面创建文件的步骤，创建一遍同样的 <strong>AIDL</strong> 文件，或者直接 Copy 也可以。</p>
<p>新建<code>AIDLActivity</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.footprint.androidaircraftcarrier.lab;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.ComponentName;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.content.ServiceConnection;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder;</span><br><span class="line"><span class="keyword">import</span> android.os.RemoteException;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.footprint.androidaircraftcarrier.R;</span><br><span class="line"><span class="keyword">import</span> com.footprint.littleshell.IMyAidlInterface;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIDLActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    Button ipcButton;</span><br><span class="line"></span><br><span class="line">    IMyAidlInterface mService;</span><br><span class="line">    ServiceConnection serviceConnection;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_aidl);</span><br><span class="line"></span><br><span class="line">        serviceConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">                mService = IMyAidlInterface.Stub.asInterface(service);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Toast.makeText(AIDLActivity.<span class="keyword">this</span>, mService.newRect().right + <span class="string">""</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ipcButton = (Button)findViewById(R.id.button_service);</span><br><span class="line">        ipcButton.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">                intent.setComponent(<span class="keyword">new</span> ComponentName(<span class="string">"com.footprint.littleshell"</span>, <span class="string">"com.footprint.littleshell.RemoteService"</span>));</span><br><span class="line">                bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们点击 Button 之后，该 App 就会尝试调用<code>RemoteService</code>，而<code>RemoteService</code>存在于另外一个 App 中，运行该 App，点击按钮，就可以看到如下结果:</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/IPC调用.png" width="250" alt="IPC调用"></div>

<p>它确实拿到了远程 Service 创建的<code>MyRect</code>实例对象并获取了其中的属性。这样就完成了 IPC 调用。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Gradle系列十二：高级主题列表]]></title>
      <url>http://www.timebridge.space/2016/06/13/gradle-advaced-topiclist/</url>
      <content type="html"><![CDATA[<p>以下这些主题，是进阶Gradle的必备主题，但是官网上其实有对应的已经描述很好的文档了，因此这里就不重复劳动了，读者可以仔细阅读这几篇文章:</p>
<ol>
<li><a href="https://docs.gradle.org/current/userguide/custom_plugins.html" target="_blank" rel="noopener">自定义Plugin</a></li>
<li><a href="https://docs.gradle.org/current/userguide/custom_tasks.html" target="_blank" rel="noopener">自定义Task类型</a></li>
<li><a href="https://docs.gradle.org/current/userguide/gradle_daemon.html" target="_blank" rel="noopener">Gradle Daemon</a></li>
<li><a href="https://docs.gradle.org/current/userguide/organizing_build_logic.html" target="_blank" rel="noopener">组织构建逻辑</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Gradle系列九：DO模型]]></title>
      <url>http://www.timebridge.space/2016/06/13/gradle-advaced-do/</url>
      <content type="html"><![CDATA[<h2 id="一、Domain-Object"><a href="#一、Domain-Object" class="headerlink" title="一、Domain Object"></a>一、Domain Object</h2><p>Gradle 脚本实际上是配置脚本，在脚本执行的时候，Gradle会配置一些特定类型的对象，这些对象就被称为脚本的 delegate 对象，也是构建领域的领域对象，下文简称 <strong>DO</strong>。</p>
<blockquote>
<p>要理解delegate，可以查看文章<a href="http://www.muzileecoding.com/gradlestudy/groovy.html" target="_blank" rel="noopener">Groovy 语法</a>。</p>
</blockquote>
<p><strong>DO 的意义就在于脚本可以使用被代理的对象的方法</strong>——这一点非常重要，是脚本中可调用方法的重要来源。<a id="more"></a></p>
<h2 id="二、顶级DO"><a href="#二、顶级DO" class="headerlink" title="二、顶级DO"></a>二、顶级DO</h2><p>Gradle 有三种脚本类型，如下表所示:</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/顶级DO.png" width="480" alt="顶级DO"></div>

<p>我们最常配置的脚本文件就是<code>build.gradle</code>和<code>settings.gradle</code>，这两类脚本文件会分别被 delegate 到 Project 实例和 Settings ，。了【实例。</p>
<blockquote>
<p>“delegate到”的意思就是脚本中的配置以及方法调用都会被转移到代理对象上。</p>
</blockquote>
<p>但是实际上每一个脚本文件最直接对应的 DO 是 Script 对象，Script 对象根据脚本文件类型来判断将脚本中的配置代理到什么类型的对象上去。</p>
<h3 id="2-1-DO创建过程"><a href="#2-1-DO创建过程" class="headerlink" title="2.1 DO创建过程"></a>2.1 DO创建过程</h3><p>这里简单描述一下一个脚本执行过程中相关顶级 DO 的创建过程:</p>
<ol>
<li>为构建创建一个 Settings 对象；</li>
<li>搜寻 settings.gradle 脚本文件，如果有，通过该脚本配置Settings对象；</li>
<li>根据配置好的 settings.gradle 对象创建 Project 树；</li>
<li>根据每一个 build.gradle 文件配置对应的 Project 对象；</li>
</ol>
<p>这里省略了 Script 对象和 Gradle 对象的创建，前者在扫描到脚本文件的时候就被创建了，后者则是在构建过程初始化的时候被创建。</p>
<h2 id="三、Project进阶"><a href="#三、Project进阶" class="headerlink" title="三、Project进阶"></a>三、Project进阶</h2><p>这里讲到 DO 之后，就建立了 Gradle 这门 DSL 语言与 Java 类的关联，从这个角度，可以进一步解释很多的问题。</p>
<h3 id="3-1-方法和属性"><a href="#3-1-方法和属性" class="headerlink" title="3.1 方法和属性"></a>3.1 方法和属性</h3><p>这里以一个 Android 项目的<code>build.gradle</code>文件内容为例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">'com.android.tools.build:gradle:2.0.0'</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> Do not place your application dependencies here; they belong</span></span><br><span class="line">        <span class="comment">// in the individual module build.gradle files</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 Groovy 的角度看，这样的语法就是一个方法调用，应该是一个类似如下定义的方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="keyword">void</span> <span class="title">buildscript</span><span class="params">(Closure closure)</span></span>&#123;</span><br><span class="line">	<span class="comment">//method body</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="keyword">void</span> <span class="title">allprojects</span><span class="params">(Closure closure)</span></span>&#123;</span><br><span class="line">	<span class="comment">//method body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么这个方法是来自哪里的呢？实际上就是来自 Project，打开<a href="https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html" target="_blank" rel="noopener">Project的API文档</a>，就可以看到这两个方法:  </p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/project-api.png" width="4800" alt="顶级DO"></div>

<p>属性也是如此。</p>
<h3 id="3-2-搜寻路径"><a href="#3-2-搜寻路径" class="headerlink" title="3.2 搜寻路径"></a>3.2 搜寻路径</h3><p>在实际的脚本文件以及来自网上的很多脚本案例中，除了以上可以从 Project 的 API 文档中查询到的方法之外，还有一些方法是无法找到的，比如之前介绍的很重要的声明属性的 ext，它的形式也表明它是一个方法，但是 Project 中确实没有这个方法。</p>
<blockquote>
<p>在实践中我使用反射来寻找这个方法，但是并没有找到：它不属于 Project 或者 Task 类。</p>
</blockquote>
<p>那么这个方法来自哪里呢？当我们在脚本中调用一个方法的时候，它是有一个搜索路径的:</p>
<ol>
<li>Project 本身</li>
<li>build file</li>
<li>添加进来的 extension 产生的同名方法</li>
<li>convention methods</li>
<li>添加进来的 Task 产生的同名方法</li>
<li>父 Project 的方法，直到根 Project 为止</li>
</ol>
<p>这里是官网上列出的六个搜寻点，但<strong>在实践中发现，最初的搜索点应该是 Script 对象，接着才是 Project 本身</strong>。</p>
<p>对于属性，也有类似的搜索路径:</p>
<ol>
<li>Project 本身</li>
<li>extra property</li>
<li>添加 extensions 产生的同名属性</li>
<li>convention 添加的属性</li>
<li>添加 Task 产生的同名属性</li>
<li>从父 Project 继承的 extra 属性和 convention 属性，直到根项目</li>
</ol>
<p>鉴于两种原因，导致方法和属性的定位非常不容易:</p>
<ol>
<li>Groovy 可以轻松地动态创建类，并为类添加属性和方法。举个栗子，虽然文档中写明<code>build.gradle</code>中的配置会代理到 Project 对象，但在实际运行的时候，Gradle 创建了一个 Project 的 Default 实现类来作为代理对象，这个类的具体实现在文档中是不可查的（但是可以利用反射进行探索）；</li>
<li>如搜寻路径中写明的，Gradle 允许通过 extension、convention等多种手段来添加方法和属性，这会随着 Gradle 对 DSL 的定义和实现、插件的使用等变化，这部分也很难查；</li>
</ol>
<p>因此，除了阅读 API 文档之外，还需要阅读 User Guide 等文档来寻找一些特殊的用法。</p>
<h3 id="3-2-Container"><a href="#3-2-Container" class="headerlink" title="3.2 Container"></a>3.2 Container</h3><p>Project 允许配置很多的内容，比如声明一组 Task、创建一组扩展、定义一组配置等等，在 Gradle 中，有一组 Container 来管理这些元素。</p>
<h4 id="3-2-1-TaskContainer"><a href="#3-2-1-TaskContainer" class="headerlink" title="3.2.1 TaskContainer"></a>3.2.1 TaskContainer</h4><p>负责管理所有的 Task 实例，通过 Project 的 task 方法即可创建 Task 实例放入其中。</p>
<p><a href="https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html" target="_blank" rel="noopener">Project</a> 类有一个方法<code>getTasks()</code>，它返回的就是<a href="https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html" target="_blank" rel="noopener">TaskContainer</a>对象，读者可以自行查阅这个类，可以发现很多有关 Task 的新玩法。</p>
<h4 id="3-2-2-ConfigurationContainer"><a href="#3-2-2-ConfigurationContainer" class="headerlink" title="3.2.2 ConfigurationContainer"></a>3.2.2 ConfigurationContainer</h4><ol>
<li>A Configuration represents a group of artifacts and their dependencies.</li>
<li>Configuration is an instance of a FileCollection that contains all dependencies but not artifacts. If you want to refer to the artifacts declared in this configuration please use getArtifacts() or getAllArtifacts().</li>
</ol>
<p>关于 Configuration，在<a href="http://www.muzileecoding.com/gradlestudy/gradle-advaced-dependency-management.html" target="_blank" rel="noopener">Gradle 依赖管理</a>有描述。另外在官方例子中也有一些与此相关，比如<a href="https://docs.gradle.org/current/userguide/dependency_management.html#defineConfiguration" target="_blank" rel="noopener">Definition of a configuration</a>。读者可以自行查阅。</p>
<h4 id="3-2-3-ExtensionContainer"><a href="#3-2-3-ExtensionContainer" class="headerlink" title="3.2.3 ExtensionContainer"></a>3.2.3 ExtensionContainer</h4><p>与其余两个 Container 不同，ExtensionContainer 是一个顶级接口，无父接口。特性是会在 Project 中创建同名的属性和方法。重要的子接口 —— Convention。</p>
<p>关于 Extension 的用法，在<a href="https://docs.gradle.org/current/userguide/custom_plugins.html" target="_blank" rel="noopener">Writing Custom Plugins</a>一章中正好有例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: GreetingPlugin</span><br><span class="line"></span><br><span class="line">greeting &#123;</span><br><span class="line">    message = <span class="string">'Hi'</span></span><br><span class="line">    greeter = <span class="string">'Gradle'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(Project project)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 可以创建扩展，从而在外部获得配置</span></span><br><span class="line">        project.extensions.create(<span class="string">"greeting"</span>, GreetingPluginExtension)</span><br><span class="line">        project.task(<span class="string">'hello'</span>) &lt;&lt; &#123;</span><br><span class="line">            println <span class="string">"$&#123;project.greeting.message&#125; from $&#123;project.greeting.greeter&#125;"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingPluginExtension</span> </span>&#123;</span><br><span class="line">    String message</span><br><span class="line">    String greeter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>project 有一个 extensions 属性（也有一个<code>getExtensions()</code>），它的类型就是 ExtensionContainer ，同样，读者也能在这里找到各种玩法。这其中是有一个非常特别的方法的: <code>getExtraProperties()</code>，它返回的对象类型为<a href="https://docs.gradle.org/current/javadoc/org/gradle/api/plugins/ExtraPropertiesExtension.html" target="_blank" rel="noopener">ExtraPropertiesExtension</a>，前面说了<code>ext()</code>方法不可查，但是读者查看这个类的相关文档之后，会有意外收获的。</p>
<p>它的子类 Convention 更加牛逼，官方解释如下：</p>
<blockquote>
<p>A Convention manages a set of convention objects. When you add a convention object to a Convention, and the properties and methods of the convention object become available as properties and methods of the object which the convention is associated to. A convention object is simply a POJO or POGO. Usually, a Convention is used by plugins to extend a Project or a Task.</p>
</blockquote>
<p>这个目前在官方文档中没有发现相关使用指导(坑)，但是网上有<a href="http://aetomation.aestasit.com/posts/injecting-utility-methods-in-gradle-projects-using-plugin-conventions/#.V3e1TZN95TY" target="_blank" rel="noopener">大牛</a>探索出了用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This line will enable our plugin for</span></span><br><span class="line"><span class="comment">// the build that imports this script.</span></span><br><span class="line">apply plugin: UtilitiesPlugin</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This is a plugin.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UtilitiesPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span> </span>&#123;</span><br><span class="line">	<span class="function">def <span class="keyword">void</span> <span class="title">apply</span><span class="params">(Project project)</span> </span>&#123;</span><br><span class="line">		project.convention.plugins.utilities =</span><br><span class="line">			<span class="keyword">new</span> UtilitiesPluginConvention(project)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Plugin convention class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UtilitiesPluginConvention</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Project project</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">UtilitiesConvention</span><span class="params">(Project project)</span>  </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.project = project</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* DEFINE YOUR UTILITY METHODS HERE */</span></span><br><span class="line">	<span class="function">def <span class="title">printMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		println <span class="string">"Message from "</span> + project.name</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个使用完全符合 Convention 的接口定义。</p>
<h2 id="四、DO总结"><a href="#四、DO总结" class="headerlink" title="四、DO总结"></a>四、DO总结</h2><p>根据以上分析，Gradle 的 DO 树如下:</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/gradle-do.png" width="480" alt="Gradle DO 树"></div>

<p>这些 DO 共同搭建了一个构建框架，开发者通过在脚本中对这些 DO 做出配置来控制构建过程。当然这里只是列出了一些重要的 DO，在 官网的 Java Doc 中，还有许许多多的 DO 有待探索，但这里构建的是整个 Gradle DO 基础，建立于此，读者可以自行学习其余的用法。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Gradle系列三：项目和脚本]]></title>
      <url>http://www.timebridge.space/2016/06/13/gradle-project-and-script/</url>
      <content type="html"><![CDATA[<h2 id="一、初见Gradle脚本"><a href="#一、初见Gradle脚本" class="headerlink" title="一、初见Gradle脚本"></a>一、初见Gradle脚本</h2><p>读者可以在任意目录下面建立一个<code>build.gradle</code>文件，将以下内容拷贝进去:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task compile &lt;&lt; &#123;</span><br><span class="line">    println <span class="string">'compiling source'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在本目录下面执行命令<code>gradle -q compile</code>，就可以看到命令行输出”compiling source”字符:<a id="more"></a></p>
<pre><code>&gt;gradle -q compile
compiling source
</code></pre><p><code>build.gradle</code>就是一个 Gradle 脚本文件，可以独立运行。虽然例子和构建没有任何关系，但是这就是一个非常简单的，由单个脚本文件组成的构建项目。</p>
<blockquote>
<p>这里的 <strong>构建项目</strong> 可能有歧义：Gradle 其实是内嵌在开发项目中的一组文件。Gradle 构建工具通过读取这些文件，了解开发者对项目的配置，完成项目的构建，这里讲 Gradle 的这组文件称为“构建项目”。</p>
</blockquote>
<h2 id="二、Project-和-Task"><a href="#二、Project-和-Task" class="headerlink" title="二、Project 和 Task"></a>二、Project 和 Task</h2><p>我们在脚本文件中写入的内容是什么意思呢？它是一个 <strong>Task</strong>，它的语法以及用法会在<a href="http://www.muzileecoding.com/gradlestudy/gradle-task.html" target="_blank" rel="noopener">Gradle Task</a>中细说，这里只需要知道它是一个类似方法的代码片段就 OK 了。</p>
<p>借助这个脚本文件，我们先重点看一下 Gradle 相关的几个重要概念：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/Gradle项目概念模型.png" height="400" alt="Gradle项目概念模型"></div>

<p>上图展示了一个 Gradle 构建项目的核心概念模型（其余概念将在 <a href="http://www.muzileecoding.com/gradlestudy/gradle-advaced-do.html" target="_blank" rel="noopener">Gradle DO 模型</a>中描述）。这个图中有三个重要的概念：<strong>Project</strong>、<strong>Task</strong> 和 <strong>Action</strong>。Gradle 的构建核心就是基于 Project 和 Task 的（Action 在讲述 Task 的时候会详细解释，这里不影响理解，略过）。</p>
<p>每一个 Gradle 构建项目包含一个或者多个 Project —— 这个 Project 是一个很不明确的概念，它和一个<code>build.gradle</code>文件一一对应，它可以什么都不做，比如我们前面举的例子，只是打印一个字符串，也可以完成类似编译一个 Java 应用——打 Jar 包——上传到 Maven 仓库这样复杂的操作，这完全取决于你在<code>build.gradle</code>文件中实现的功能。</p>
<p>每一个 Project 又由一个或者多个 Task 组成，前面的例子就是由一个叫做<code>compile</code>的 Task 组成的，一个 Task 代表一小段可以执行的构建代码，在实际的应用中，一个 Task 可能完成编译一组类、打一个 Jar 包、生成 Javadoc 文档、上传归档文件到仓库等功能。</p>
<blockquote>
<p>有 Android 经验的小伙伴可以将 Project 映射到一个 Android 项目，子 Project 映射到 Module 去理解。</p>
<p>如果把Project看成是一个类，而Task看成是一个个方法，理解起来会更加形象。</p>
</blockquote>
<h2 id="三、多项目文件结构"><a href="#三、多项目文件结构" class="headerlink" title="三、多项目文件结构"></a>三、多项目文件结构</h2><p>前面举得例子非常简单，实际生产环境中多 Project 形式的项目是非常普遍的，比如 Android 中一个主项目往往有多个 Module ，最后的 APK 打包其实就是将这些 Module 的产物打包在一起的过程。虽然项目的嵌套形式不一定一样，但是它的 Gradle 配置应当具备以下特征：</p>
<ol>
<li>在项目根目录/主目录下面有一个<code>settings.gradle</code>文件，同时也有一个<code>build.gradle</code>文件 —— 对应着上图中最顶层的 Project；</li>
<li>每一个子项目也有自己的<code>build.gradle</code>文件；</li>
</ol>
<p><code>settings.gradle</code>是用于告诉 Gradle：构建项目由哪些开发项目组成，它们是如何组织的。在这样一个复杂的目录结构下面，我们可以直接使用<code>gradle projects</code>命令来查看项目结构。</p>
<p>在 “GRADLE_HOME/samples/java” 目录下面，找到 “multiproject” 目录，在该目录下面执行<code>gradle -q projects</code>，就会得到如下输出:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; gradle -q projects</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Root project</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Root project <span class="string">'multiproject'</span></span><br><span class="line">+--- Project <span class="string">':api'</span></span><br><span class="line">+--- Project <span class="string">':services'</span></span><br><span class="line">|    +--- Project <span class="string">':services:shared'</span></span><br><span class="line">|    \--- Project <span class="string">':services:webservice'</span></span><br><span class="line">\--- Project <span class="string">':shared'</span></span><br><span class="line"></span><br><span class="line">To see a list of the tasks of a project, run gradle &lt;project-path&gt;:tasks</span><br><span class="line">For example, <span class="keyword">try</span> running gradle :api:tasks</span><br></pre></td></tr></table></figure>
<p>这说明:</p>
<ol>
<li><code>multiproject</code>项目包含三个直系子Project：<code>api</code>, <code>services</code>和<code>shared</code>；</li>
<li>子项目<code>services</code>又包含<code>shared</code>和<code>webservice</code>两个子项目；</li>
</ol>
<p>对比实际文件目录结构，很容易理解这些项目的组织过程。而它的<code>settings.gradle</code>文件如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include <span class="string">"shared"</span>, <span class="string">"api"</span>, <span class="string">"services:webservice"</span>, <span class="string">"services:shared"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>“multiproject” 下面其实还有一个<code>buildSrc</code>目录，里面也有<code>build.gradle</code>文件，但是并没有在命令行中打印出来，这是因为<code>settings.gradle</code>文件中没有配置该项目。</p>
</blockquote>
<p>根目录下面的<code>build.gradle</code>文件通常会有一些子项目共有的配置，比如共享的依赖，在这个文件里面，也可以对子项目进行配置，具体可以查看<a href="https://docs.gradle.org/current/userguide/organizing_build_logic.html" target="_blank" rel="noopener">组织构建逻辑</a>。</p>
<blockquote>
<p><code>build.gradle</code>文件不一定要叫这个名字，可以以子模块的名字命名。</p>
</blockquote>
<h2 id="四、多项目构建"><a href="#四、多项目构建" class="headerlink" title="四、多项目构建"></a>四、多项目构建</h2><p>上面已经看到一个多项目构建是如何配置的了，下面进一步阐述。</p>
<h3 id="4-1-项目定位"><a href="#4-1-项目定位" class="headerlink" title="4.1 项目定位"></a>4.1 项目定位</h3><p>多项目构建是以一棵树的形式展现的，树中的每一个节点都代表着一个 project（是不是很类似前面的结构图？），每一个 project 都有一个代表自己位置的路径。大部分情况下，这个位置和项目所在文件系统中的相对位置是一致的，然而，这是可配置的。 project 树是根据 “settings.gradle” 文件来创建的，这个文件默认是放在根 project 目录下面，但是实际上根目录的位置也可以在该文件中重新定义。</p>
<p>换句话说， <strong>只要有 “settings.gradle” 文件，只要可以定义出一个 project 树出来就好</strong> 。</p>
<h3 id="4-2-构建-Project-树"><a href="#4-2-构建-Project-树" class="headerlink" title="4.2 构建 Project 树"></a>4.2 构建 Project 树</h3><p>在 settings.gradle 文件中，有一组方法可以用于构建 project 树。主要有 “Hierarchical layouts” 和 “flat physical layouts” 。</p>
<h4 id="4-2-1-Hierarchical-layout"><a href="#4-2-1-Hierarchical-layout" class="headerlink" title="4.2.1 Hierarchical layout"></a>4.2.1 Hierarchical layout</h4><p>举个例子，在 “settings.gradle” 中写入如下脚本:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include <span class="string">'project1'</span>, <span class="string">'project2:child'</span>, <span class="string">'project3:child1'</span></span><br></pre></td></tr></table></figure>
<p><code>include</code>方法使用路径作为参数，路径是根据相对路径得出的，只不过路径分隔符变成了<code>:</code>。我们只需要标注出叶子节点项目即可，也就是说，如果我们包含项目 ‘services:hotels:api’，那构建的时候就会创建三个 projects: ‘services’, ‘services:hotels’ 和 ‘services:hotels:api’。</p>
<h4 id="4-2-2-Flat-physical-layouts"><a href="#4-2-2-Flat-physical-layouts" class="headerlink" title="4.2.2 Flat physical layouts"></a>4.2.2 Flat physical layouts</h4><p>举个例子，在 “settings.gradle” 中写入如下脚本:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">includeFlat <span class="string">'project3'</span>, <span class="string">'project4'</span></span><br></pre></td></tr></table></figure>
<p><code>includeFlat</code>方法以目录作为参数，这些目录必须是根 project 的兄弟目录，也就是说和项目根目录平级。在多 project 树中，这些目录的位置是作为根 project 的子项目存在。</p>
<h3 id="4-3-项目信息修改"><a href="#4-3-项目信息修改" class="headerlink" title="4.3 项目信息修改"></a>4.3 项目信息修改</h3><p>多项目构建树是由 “project descriptors” 构成的，可以在 settings 文件中随时更改这些 descriptors，包括更改 project 名称，project 目录，以及 project 构建名称。例子如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取属性</span></span><br><span class="line">println rootProject.name</span><br><span class="line"><span class="function">println <span class="title">project</span><span class="params">(<span class="string">':projectA'</span>)</span>.name</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//更改属性</span></span></span><br><span class="line"><span class="function">rootProject.name </span>= <span class="string">'main'</span></span><br><span class="line">project(<span class="string">':projectA'</span>).projectDir = <span class="keyword">new</span> File(settingsDir, <span class="string">'../my-project-a'</span>)</span><br><span class="line">project(<span class="string">':projectA'</span>).buildFileName = <span class="string">'projectA.gradle'</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>初始化脚本的代理对象 Settings 的<code>project</code>方法返回的是 ProjectDescriptor 对象。</p>
</blockquote>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>以上就是一些关于项目结构以及重要文件配置的说明。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Gradle系列五：属性]]></title>
      <url>http://www.timebridge.space/2016/06/13/gradle-property/</url>
      <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>无论是配置构建环境、控制构建过程还是记录构建中间信息，我们都需要用到属性。Gradle为我们提供了多种属性声明方式，下面详细阐述。</p>
<h2 id="二、ext"><a href="#二、ext" class="headerlink" title="二、ext"></a>二、ext</h2><p>在Gradle中最常见的定义属性的方式就是通过ext定义，比如在<code>build.gradle</code>中写入：<a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ext &#123;</span><br><span class="line">	developer_name = <span class="string">"bigfootprint"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println developer_name</span><br></pre></td></tr></table></figure>
<p>执行<code>gradle -q</code>命令，就可以看到如下输出:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bigfootprint</span><br></pre></td></tr></table></figure>
<p>在ext中声明的属性，我们是可以直接使用的，不用带任何的前缀。</p>
<blockquote>
<p>读者可能比较感兴趣，为什么这里可以通过ext来定义这样的属性？这个将在<a href="http://www.muzileecoding.com/gradlestudy/gradle-advaced-do.html" target="_blank" rel="noopener">Gradle DO模型</a>中阐述，这里只需要知道这种写法是可以声明属性的就好。</p>
</blockquote>
<p>不仅仅可以使用 ext 为构建项目添加属性，还可以用 ext 为 Task 添加属性，比如在<code>build.gradle</code>文件中可以写入如下内容:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">task taskExt&#123;</span><br><span class="line">	ext&#123;</span><br><span class="line">		taskowner = <span class="string">"bigfootprint"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println taskExt.taskowner</span><br></pre></td></tr></table></figure>
<p>执行<code>gradle -q</code>可以看到如下输出:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bigfootprint</span><br></pre></td></tr></table></figure>
<h2 id="三、其余方式"><a href="#三、其余方式" class="headerlink" title="三、其余方式"></a>三、其余方式</h2><p>ext 是声明属性最方便的方式，但是 Gradle 还提供了别的方式进行属性声明。</p>
<h4 id="3-1-gradle-properties"><a href="#3-1-gradle-properties" class="headerlink" title="3.1 gradle.properties"></a>3.1 gradle.properties</h4><p>在这类文件中添加的属性配置，在构建中也可以使用。该文件有两个地方可以放置：</p>
<ol>
<li>环境变量”GRADLE_USER_HOME”指向的位置，如果没有设置，默认是在”USER_HOME/.gradle”下面；</li>
<li>项目根目录下面——对于多项目的构建来说，该文件可以存放在任意的子项目文件夹下；</li>
</ol>
<p>如果以上两个位置都有该文件且定义有相同的属性，则 “USER_HOME” 下面的定义具有更高的优先级。</p>
<blockquote>
<p>项目中如果有多个目录的 “gradle.properties” 文件中有同样的属性，且 “USER_HOME” 下面没有该属性定义，则优先查找命令执行的当前目录下的属性文件，找不到则去父项目中寻找。</p>
</blockquote>
<h4 id="3-2-命令行"><a href="#3-2-命令行" class="headerlink" title="3.2 命令行"></a>3.2 命令行</h4><p>使用<code>-D</code>命令行选项，可以给运行Gradle进程的JVM传递系统属性，在执行<code>gradle</code>使用<code>-D</code>选项也有同样的效果。</p>
<p>除了使用<code>-D</code>命令行选项，还可以使用<code>-P</code>选项。使用见后面的示例。</p>
<p>使用命令行传递的属性优先级最高。</p>
<h4 id="3-3-特殊命名的系统属性或者环境变量"><a href="#3-3-特殊命名的系统属性或者环境变量" class="headerlink" title="3.3 特殊命名的系统属性或者环境变量"></a>3.3 特殊命名的系统属性或者环境变量</h4><p>Gradle 可以根据特殊命名的系统属性或者环境变量来为构建设置属性。这个特性在我们没有 CI 服务器的管理权限，同时又需要为构建设置一些不能轻易暴露的属性的时候非常有用。</p>
<p>这种情况下，不能使用<code>-P</code>选项，也不能更改系统级别的配置文件。正确的策略是修改 CI 服务器的构建任务，添加一个符合某种模式的变量——这个变量对系统内的普通用户不可见：</p>
<ol>
<li>环境变量的格式如下: <code>ORG_GRADLE_PROJECT_prop=somevalue</code>;</li>
<li>系统属性的格式如下: <code>org.gradle.project.prop</code>;</li>
</ol>
<blockquote>
<p>比如签名信息，就可以使用这种方式进行属性设置。</p>
</blockquote>
<h4 id="3-4-设置系统属性"><a href="#3-4-设置系统属性" class="headerlink" title="3.4 设置系统属性"></a>3.4 设置系统属性</h4><p>严格来说，这一项不属于该主题。它是通过特殊的命名规范，在<code>gradle.properties</code>文件中设置特殊格式的属性来设置系统属性——这种方式只有在项目根目录下的<code>gradle.properties</code>文件中才有效，它的格式是<code>systemProp.propName</code>。</p>
<h4 id="3-5-示例"><a href="#3-5-示例" class="headerlink" title="3.5 示例"></a>3.5 示例</h4><p>比如在<code>gradle.properties</code>中设置如下属性: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gradlePropertiesProp=gradlePropertiesValue</span><br><span class="line">sysProp=shouldBeOverWrittenBySysProp</span><br><span class="line">envProjectProp=shouldBeOverWrittenByEnvProp</span><br><span class="line">systemProp.system=systemValue</span><br></pre></td></tr></table></figure>
<p>在<code>build.gradle</code>文件中创建如下Task:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">task printProps &lt;&lt; &#123;</span><br><span class="line">    println commandLineProjectProp</span><br><span class="line">    println gradlePropertiesProp</span><br><span class="line">    println systemProjectProp</span><br><span class="line">    println envProjectProp</span><br><span class="line">    println System.properties[&apos;system&apos;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行如下命令: <code>gradle -q -PcommandLineProjectProp=commandLineProjectPropValue -Dorg.gradle.project.systemProjectProp=systemPropertyValue printProps</code>，则可以得到如下输出:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">commandLineProjectPropValue</span><br><span class="line">gradlePropertiesValue</span><br><span class="line">systemPropertyValue</span><br><span class="line">envPropertyValue</span><br><span class="line">systemValue</span><br></pre></td></tr></table></figure>
<blockquote>
<p>【注意】<code>-P</code>命令直接使用键值对的形式就好，但是<code>-D</code>的属性名前面则要加上<code>org.gradle.project.</code>前缀。</p>
</blockquote>
<h2 id="四、属性查看"><a href="#四、属性查看" class="headerlink" title="四、属性查看"></a>四、属性查看</h2><p>我们可以使用<code>gradle properties</code>命令查看某个project的属性，下面是在某个构建项目根目录下执行命令的输出片段:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; gradle -q api:properties</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Project :api - The shared API <span class="keyword">for</span> the application</span><br><span class="line">------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">allprojects: [project <span class="string">':api'</span>]</span><br><span class="line">ant: org.gradle.api.internal.project.DefaultAntBuilder@<span class="number">12345</span></span><br><span class="line">antBuilderFactory: org.gradle.api.internal.project.DefaultAntBuilderFactory@<span class="number">12345</span></span><br><span class="line">artifacts: org.gradle.api.internal.artifacts.dsl.DefaultArtifactHandler_Decorated@<span class="number">12345</span></span><br><span class="line">asDynamicObject: org.gradle.api.internal.ExtensibleDynamicObject@<span class="number">12345</span></span><br><span class="line">baseClassLoaderScope: org.gradle.api.internal.initialization.DefaultClassLoaderScope@<span class="number">12345</span></span><br><span class="line">buildDir: /home/user/gradle/samples/userguide/tutorial/projectReports/api/build</span><br><span class="line">buildFile: /home/user/gradle/samples/userguide/tutorial/projectReports/api/build.gradle</span><br></pre></td></tr></table></figure>
<p>在脚本中，如果使用了一个未定义的属性，则会抛出异常。如果构建过程依赖于一个可选的属性，那么可以使用<code>hasProperty(&#39;propertyName&#39;)</code>来判断某个属性是否被设置，未设置的情况下不要使用。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Gradle系列八：简介&安装]]></title>
      <url>http://www.timebridge.space/2016/06/12/gradle-basic/</url>
      <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>和 Maven、Ant 类似，Gradle 是一个优秀的构建工具。它基于一门 JVM 脚本语言——<a href="http://www.muzileecoding.com/gradlestudy/groovy.html" target="_blank" rel="noopener">Groovy</a>，具有以下特点：</p>
<ol>
<li>支持多种语言，官网说到，LinkedIn 使用 Gradle 完成对60多种语言的编译，包括 Java、Scala、Python 等；</li>
<li>支持 Eclipse、Android Studio、IntelliJ 以及 Jekins 等工具插件；</li>
<li>支持 Maven、Ivy、flat 文件等多种依赖处理，并且支持依赖传递；</li>
<li>对整个构建过程的精细化控制；</li>
<li>通过增量式构建以、构建缓存和并行构建三种方式最大限度的提高了Gradle Daemon 的编译速度；</li>
<li>提供对编译过程的数据分析，便于开发者优化编译步骤和模块，解决编译问题；<a id="more"></a></li>
</ol>
<blockquote>
<p><a href="http://gradle.org/whygradle-build-automation/" target="_blank" rel="noopener">官网</a>上可以看到详情，在<a href="https://docs.gradle.org/current/userguide/overview.html" target="_blank" rel="noopener">User Guide第二章</a>中也有相关的描述。</p>
</blockquote>
<h2 id="二、环境"><a href="#二、环境" class="headerlink" title="二、环境"></a>二、环境</h2><p>如果你的设备已经有完善的 Java 环境(JDK 6以及上)，那么以下简单的几步就可以配置好 Gradle 环境:</p>
<ol>
<li>从官网下载 ZIP 包: <a href="http://gradle.org/gradle-download/" target="_blank" rel="noopener">链接</a>；</li>
<li>解压 ZIP 包到某个文件夹，地址 A；</li>
<li>在环境变量中添加<code>GRADLE_HOME</code>变量，指向 A；</li>
<li>把<code>GRADLE_HOME/bin</code>添加到 PATH 环境变量中去；</li>
</ol>
<p>这几步就足以运行 Gradle 了。在命令行中执行<code>gradle -v</code>命令，如果能正确打印出 Gradle 的版本，就 OK 了。</p>
<p>另外要注意下载的 ZIP 包中，除了我们需要的 Gradle Binary ，还有以下内容:</p>
<ol>
<li>User Guide（PDF &amp; HTML）</li>
<li>DSL Reference</li>
<li>API Documentation(Java Doc and Goovydoc)</li>
<li>Sample</li>
<li>Binary source</li>
</ol>
<blockquote>
<p>官网上可以找到非常完整的表述: <a href="https://docs.gradle.org/current/userguide/installation.html" target="_blank" rel="noopener">Installing Gradle</a>。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Gradle系列七：依赖管理]]></title>
      <url>http://www.timebridge.space/2016/05/21/gradle-advaced-dependency-management/</url>
      <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>依赖管理分为两部分: </p>
<ol>
<li><strong>dependencies(依赖)</strong> Gradle 需要知道哪些东西是构建你项目的必需品以便于找到它们，比如我们在进行单元测试的时候就需要依赖 junit jar 包；</li>
<li><strong>publications(发布)</strong> Gradle 在构建完成项目之后，可能需要上传构建产物，比如我们打包出来的 aar 文件、jar 包；</li>
</ol>
<p>很多项目都需要依赖别的资源以完成功能，比如以 SSH 架构搭建 J2EE 项目打出 war 包，就必须依赖 spring 等框架提供的 jar 包 —— 这些就构成一个项目的依赖。<a id="more"></a></p>
<p>Gradle 允许开发者告诉它项目构建依赖哪些资源，它就会负责帮你解决这些依赖，包括下载它们、将它们加入到构建中，其中根据一定的格式去解析依赖资源并寻找它们的过程就称为 <strong>dependency resolution</strong>，即<strong>依赖解析</strong>。</p>
<blockquote>
<p>这一点胜过 Ant，Ant 只能给出需要加载的资源的绝对或者相对路径，否则就要使用 Ivy。</p>
</blockquote>
<p>通常来说，一个项目的依赖也会依赖别的资源，Gradle 也需要照顾到这些依赖——这被称为 <strong>transitive dependencies</strong>，即<strong>传递依赖</strong>。</p>
<p>大部分项目是为了构建出一些可以给别的项目使用的文件，将这些文件交给其余项目使用的最简单的方式就是通过发布，Gradle 会为你完成这个工作——帮助你完成构建，得到产出文件，将其上传到某个别人可以获取到的地方。发布的具体位置决定于开发者：可能只是简单的将文件拷贝到一个本地文件夹下面，或者上传到一个远程Maven仓库，或者会在同一个项目的子项目中运用这个输出，这就是 <strong>publication</strong>，即<strong>发布</strong>。</p>
<h2 id="二、入门"><a href="#二、入门" class="headerlink" title="二、入门"></a>二、入门</h2><p>来看一个脚本:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'java'</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile group: <span class="string">'org.hibernate'</span>, name: <span class="string">'hibernate-core'</span>, version: <span class="string">'3.6.7.Final'</span></span><br><span class="line">    testCompile group: <span class="string">'junit'</span>, name: <span class="string">'junit'</span>, version: <span class="string">'4.+'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个脚本做了什么呢？首先它声明<code>Hibernate core 3.6.7.Final</code>在构建过程中是必须的，当然，该文件依赖的文件也是必须的。其次该脚本声明了大于等于4.0版本的junit包是编译测试时必须的。最后，它指明这些文件应当在Maven的中央仓库去寻找符合条件的文件。</p>
<h2 id="三、依赖与Configuration"><a href="#三、依赖与Configuration" class="headerlink" title="三、依赖与Configuration"></a>三、依赖与Configuration</h2><p>依赖的本质是什么呢？在 Gradle 中，依赖其实是一组组的 Configuration ，Configutation 这个名字起的非常不友好，它的本意应该是 Dependency-Group ，而一个依赖本身可以看做是一个文件（当然，这个文件也可能依赖别的文件）。</p>
<p>首先来说明一下为什么会有分组的概念，以及从什么维度进行分组呢？举个例子就明白了：比如我开发了一个 Java 项目，在我编译的时候，我有一组需要依赖的外部资源，当我进行单元测试的时候，我还需要依赖另外一组资源，比如 Junit jar 包，Mockito jar 包，但是当我测试完成正式发布的时候，测试所依赖的资源其实是不需要打包进去的。这样一来，我们至少应该把依赖的资源分为两组：正常打包所依赖的资源和测试需要依赖的资源。在 Java 插件中，前者统一归入 “compile” 分组下，后者统一归入 “testCompile” 分组下。</p>
<p>简而言之，所有的依赖最后的用处不一定一致，也不一定需要打包到最后的产物中去，因此我们需要对依赖进行分组，并对组进行管理。</p>
<p>很多的插件都会声明自己的 configuration ，例子如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">configurations &#123;</span><br><span class="line">    compile</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用如下方式可以对一个 Configuration 进行配置:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">configurations &#123;</span><br><span class="line">    compile &#123;</span><br><span class="line">        description = <span class="string">'compile classpath'</span></span><br><span class="line">        transitive = <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    runtime &#123;</span><br><span class="line">        extendsFrom compile</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">configurations.compile &#123;</span><br><span class="line">    description = <span class="string">'compile classpath'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>configuration 的配置有很多可以讲述的地方，限于篇幅和主题，这里不展开细说，相信读者看完<a href="http://www.muzileecoding.com/gradlestudy/gradle-advaced-do.html" target="_blank" rel="noopener">Gradle DO模型</a>是可以自行完成相关学习的。</p>
<p>文档 <a href="https://docs.gradle.org/current/userguide/dependency_management.html#sec:working_with_dependencies" target="_blank" rel="noopener">Dependency Management 23.5节</a> 也讲述了一些 Configuration 的用法，读者可以关注。</p>
<h2 id="四、依赖配置"><a href="#四、依赖配置" class="headerlink" title="四、依赖配置"></a>四、依赖配置</h2><p>依赖配置分为两部分:</p>
<ol>
<li>告诉 Gradle 依赖什么；</li>
<li>告诉 Gradle 去哪里寻找这些依赖；</li>
</ol>
<h4 id="4-1-依赖什么"><a href="#4-1-依赖什么" class="headerlink" title="4.1 依赖什么"></a>4.1 依赖什么</h4><p>Gradle 支持的依赖分为以下几类:</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>External module dependency</td>
<td>对仓库中的某个外部 module 的依赖</td>
</tr>
<tr>
<td>Project dependency</td>
<td>对同项目下的某个子项目的依赖</td>
</tr>
<tr>
<td>File dependency</td>
<td>对本地文件系统中的一组文件的依赖</td>
</tr>
<tr>
<td>Client module dependency</td>
<td>也是对仓库中的某个外部 module 的依赖，不过 module 的原始信息会在 build 文件中重新声明，比如依赖的某个包的版本，是否需要对某个依赖包进行传递依赖解析，当我们需要覆写某个module的原始信息的时候，就使用这类依赖</td>
</tr>
<tr>
<td>Gradle API dependency</td>
<td>依赖当前 Gradle 版本的 API，一般只有在开发 Gradle 插件或者 Task 类型的时候才会使用该类依赖</td>
</tr>
<tr>
<td>Local Groovy dependency</td>
<td>依赖当前 Gradle 版本使用的 Groovy 版本，一般只有在开发 Gradle 插件或者 Task 类型的时候才会使用该类依赖</td>
</tr>
</tbody>
</table>
<p>一般情况下，我们只会用到前三种配置，而且这种配置是极为简单的，它们的使用例子如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">	<span class="comment">// External module dependency</span></span><br><span class="line">   runtime group: <span class="string">'org.springframework'</span>, name: <span class="string">'spring-core'</span>, version: <span class="string">'2.5'</span></span><br><span class="line">   runtime <span class="string">'org.springframework:spring-core:2.5'</span>,</span><br><span class="line">            <span class="string">'org.springframework:spring-aop:2.5'</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Project dependency</span></span><br><span class="line">   <span class="function">compile <span class="title">project</span><span class="params">(<span class="string">':shared'</span>)</span></span></span><br><span class="line"><span class="function">   </span></span><br><span class="line"><span class="function">   <span class="comment">// File dependencies</span></span></span><br><span class="line"><span class="function">   runtime <span class="title">files</span><span class="params">(<span class="string">'libs/a.jar'</span>, <span class="string">'libs/b.jar'</span>)</span></span></span><br><span class="line"><span class="function">   runtime <span class="title">fileTree</span><span class="params">(dir: <span class="string">'libs'</span>, include: <span class="string">'*.jar'</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>第四种不是很常见，它的例子如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="function">runtime <span class="title">module</span><span class="params">(<span class="string">"org.codehaus.groovy:groovy:2.4.4"</span>)</span> </span>&#123;</span><br><span class="line">        dependency(<span class="string">"commons-cli:commons-cli:1.0"</span>) &#123;</span><br><span class="line">        	  <span class="comment">// 更改传递性</span></span><br><span class="line">            transitive = <span class="keyword">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">module</span>(group: <span class="string">'org.apache.ant'</span>, name: <span class="string">'ant'</span>, version: <span class="string">'1.9.6'</span>) &#123;</span><br><span class="line">        	  <span class="comment">// 更改依赖包</span></span><br><span class="line">            dependencies <span class="string">"org.apache.ant:ant-launcher:1.9.6@jar"</span>,</span><br><span class="line">                         <span class="string">"org.apache.ant:ant-junit:1.9.6"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们大部分时候需要指定依赖什么，但有时候我们还需要指出我们不能依赖什么，有以下两种方式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">configurations &#123;</span><br><span class="line">    compile.exclude <span class="keyword">module</span>: <span class="string">'commons'</span></span><br><span class="line">    all*.exclude group: <span class="string">'org.gradle.test.excludes'</span>, <span class="keyword">module</span>: <span class="string">'reports'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile(<span class="string">"org.gradle.test.excludes:api:1.0"</span>) &#123;</span><br><span class="line">        exclude <span class="keyword">module</span>: <span class="string">'shared'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一种是通过 Configuration，一种是通过 Dependency。前者可以指定某一 Confuration 还是所有的 Configuration 都排除对某一资源的依赖。</p>
<h4 id="4-2-去哪里寻找依赖"><a href="#4-2-去哪里寻找依赖" class="headerlink" title="4.2 去哪里寻找依赖"></a>4.2 去哪里寻找依赖</h4><p>Gradle 从仓库中寻找依赖的文件，仓库只是一堆文件的集合，通过”group”、”name”和”version”三个维度来组织。Gradle 可以解析多种仓库格式，比如 Maven 和 Ivy，并且提供多种不同的访问仓库的方式，比如使用本地文件系统或者 HTTP。</p>
<p>Gradle 默认情况下不会定义任何的仓库，在使用外部仓库之前，开发者而必须至少配置一个仓库，其中一个选择就是使用 Maven 中央仓库:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然也可以使用 JCenter:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了这些默认的可以快捷指定的仓库，我们可以选择用一下方式指定一些其余的仓库:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    maven &#123;</span><br><span class="line">        url <span class="string">"http://repo.mycompany.com/maven2"</span></span><br><span class="line">    &#125;</span><br><span class="line">    ivy &#123;</span><br><span class="line">        url <span class="string">"http://repo.mycompany.com/repo"</span></span><br><span class="line">    &#125;</span><br><span class="line">    ivy &#123;</span><br><span class="line">        <span class="comment">// URL can refer to a local directory</span></span><br><span class="line">        url <span class="string">"../local-repo"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上配置所示，Gradle 会按照顺序来搜寻一个依赖，直到找到依赖位置。关于Gradle支持的仓库配置方式，同样在 <a href="https://docs.gradle.org/current/userguide/dependency_management.html#sec:repositories" target="_blank" rel="noopener">Dependency Management 23.6节</a> 中有详细的描述，包括对于一些需要密码的仓库应当如何配置都有详细说明。</p>
<h2 id="五、依赖版本"><a href="#五、依赖版本" class="headerlink" title="五、依赖版本"></a>五、依赖版本</h2><h4 id="5-1-动态版本-Dynamic-Versions-和变化模块-Changing-Modules"><a href="#5-1-动态版本-Dynamic-Versions-和变化模块-Changing-Modules" class="headerlink" title="5.1 动态版本(Dynamic Versions)和变化模块(Changing Modules)"></a>5.1 动态版本(Dynamic Versions)和变化模块(Changing Modules)</h4><p>绝大部分时候，我们可以明确写出我们想要依赖的 Module 的版本，比如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtime group: <span class="string">'org.springframework'</span>, name: <span class="string">'spring-core'</span>, version: <span class="string">'2.5'</span></span><br></pre></td></tr></table></figure>
<p>这就是指定依赖2.5版本的 spring-core。但是有时候我们有一些别的需求：</p>
<ol>
<li><strong>依赖某个Module最新的版本，或者某个范围内的最新版本。</strong> 这种最新版本的获得不是通过手动更改版本号来获得的，而是使用”2.+”这样的符号，由依赖管理系统自动获取的，如果这时候最新版本是2.5，那就使用2.5，如果有2.6，就使用2.6，而我的配置始终是”2.+”，这就是 <strong>Dynamic Versions</strong> 。</li>
<li><strong>依赖某个版本的最新一版。</strong> 这听上去有点奇怪。最佳的例子其实就是 Maven 的 <strong>SNAPSHOT</strong>，我可以指定依赖某一个版本的 <strong>SNAPSHOT</strong> 版本，比如”2.5-SNAPSHOT”，这样在这个版本上有任何的修改依赖方都可以尽快得知，同时 Module 的开发者也可以去开发2.6版本，而不会影响到2.5版本，这就是 <strong>Changing Modules</strong> 。</li>
</ol>
<p>默认来说，Gradle 缓存这两种版本 24h。</p>
<h4 id="5-2-版本冲突"><a href="#5-2-版本冲突" class="headerlink" title="5.2 版本冲突"></a>5.2 版本冲突</h4><p>如果在编译的过程中，我们依赖同一个 Module 的两个不同版本，就会带来版本冲突，版本冲突不但会导致编译不通过，错误的解决方式也会影响产品的功能。Gradle 提供两种依赖冲突解决策略：</p>
<ol>
<li><strong>Newest</strong> 使用最新版本的依赖，这是 Gradle 的默认策略，只要依赖的包是向后兼容的，那么这个策略通常就是合适的；</li>
<li><strong>Fail</strong> 一旦版本冲突，构建就失败。这个策略要求在脚本中解决所有的冲突——可以参照<a href="https://docs.gradle.org/current/dsl/org.gradle.api.artifacts.ResolutionStrategy.html" target="_blank" rel="noopener">ResolutionStrategy</a>提供的解决方案；</li>
</ol>
<p>尽管上面两项策略已经可以解决大部分的冲突问题，但是 Gradle 仍然做的更多，提供一些更精细的手段来解决版本冲突：可以将第一级或者所有的依赖（包括传递依赖）设置为<code>forced</code>来指定一个版本，例子如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'java'</span> <span class="comment">//so that there are some configurations</span></span><br><span class="line"></span><br><span class="line">configurations.all &#123;</span><br><span class="line">  resolutionStrategy &#123;</span><br><span class="line">    <span class="comment">// fail eagerly on version conflict (includes transitive dependencies)</span></span><br><span class="line">    <span class="comment">// e.g. multiple different versions of the same dependency (group and name are equal)</span></span><br><span class="line">    failOnVersionConflict()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// force certain versions of dependencies (including transitive)</span></span><br><span class="line">    <span class="comment">//  *append new forced modules:</span></span><br><span class="line">    force <span class="string">'asm:asm-all:3.3.1'</span>, <span class="string">'commons-io:commons-io:1.4'</span></span><br><span class="line">    <span class="comment">//  *replace existing forced modules with new ones:</span></span><br><span class="line">    forcedModules = [<span class="string">'asm:asm-all:3.3.1'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add dependency substitution rules</span></span><br><span class="line">    dependencySubstitution &#123;</span><br><span class="line">      <span class="function">substitute <span class="title">module</span><span class="params">(<span class="string">'org.gradle:api'</span>)</span> with <span class="title">project</span><span class="params">(<span class="string">':api'</span>)</span></span></span><br><span class="line"><span class="function">      substitute <span class="title">project</span><span class="params">(<span class="string">':util'</span>)</span> with <span class="title">module</span><span class="params">(<span class="string">'org.gradle:util:3.0'</span>)</span></span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">// cache dynamic versions for 10 minutes</span></span></span><br><span class="line"><span class="function">    cacheDynamicVersionsFor 10*60, 'seconds'</span></span><br><span class="line"><span class="function">    <span class="comment">// don't cache changing modules at all</span></span></span><br><span class="line"><span class="function">    cacheChangingModulesFor 0, 'seconds'</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>前面描述的<code>exclude</code>形式也是一种解决冲突的办法，我们可以在根项目下移除对某个资源所有版本的依赖，统一依赖一个最新版本的包，但这种方式比较粗暴，不一定是最佳解决方案。</p>
</blockquote>
<h2 id="六、高级配置"><a href="#六、高级配置" class="headerlink" title="六、高级配置"></a>六、高级配置</h2><p>上面讲述的是一些基本的配置方案，99%的情况下，我们只需要简单的配置一下就可以使用了，但是 Gradle 对配置的支持远不止如此。</p>
<h4 id="6-1-依赖替换"><a href="#6-1-依赖替换" class="headerlink" title="6.1 依赖替换"></a>6.1 依赖替换</h4><p>这里举几个例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">configurations.all &#123;</span><br><span class="line">    resolutionStrategy.eachDependency &#123; DependencyResolveDetails details -&gt;</span><br><span class="line">        <span class="keyword">if</span> (details.requested.group == <span class="string">'org.software'</span> &amp;&amp; details.requested.name == <span class="string">'some-library'</span> &amp;&amp; details.requested.version == <span class="string">'1.2'</span>) &#123;</span><br><span class="line">            <span class="comment">//prefer different version which contains some necessary fixes</span></span><br><span class="line">            details.useVersion <span class="string">'1.2.1'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是版本替换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">configurations.all &#123;</span><br><span class="line">    resolutionStrategy.eachDependency &#123; DependencyResolveDetails details -&gt;</span><br><span class="line">        <span class="keyword">if</span> (details.requested.name == <span class="string">'groovy-all'</span>) &#123;</span><br><span class="line">            <span class="comment">//prefer 'groovy' over 'groovy-all':</span></span><br><span class="line">            details.useTarget group: details.requested.group, name: <span class="string">'groovy'</span>, version: details.requested.version</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (details.requested.name == <span class="string">'log4j'</span>) &#123;</span><br><span class="line">            <span class="comment">//prefer 'log4j-over-slf4j' over 'log4j', with fixed version:</span></span><br><span class="line">            details.useTarget <span class="string">"org.slf4j:log4j-over-slf4j:1.7.10"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是包替换，直接将一个依赖替换成可兼容的另外一个包。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">configurations.all &#123;</span><br><span class="line">    resolutionStrategy.dependencySubstitution &#123;</span><br><span class="line">        <span class="function">substitute <span class="title">module</span><span class="params">(<span class="string">"org.utils:api"</span>)</span> with <span class="title">project</span><span class="params">(<span class="string">":api"</span>)</span></span></span><br><span class="line"><span class="function">        substitute <span class="title">module</span><span class="params">(<span class="string">"org.utils:util:2.5"</span>)</span> with <span class="title">project</span><span class="params">(<span class="string">":util"</span>)</span></span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>以上是用 project 替换 module。</p>
<p>依赖管理有一组解析规则，一组替换规则，还有一组映射规则（可能有多个 module 符合条件），读者知道有这些就足够了，具体的内容可以参考<a href="https://docs.gradle.org/current/userguide/dependency_management.html" target="_blank" rel="noopener">Dependency Management 23.8节</a>。</p>
<h4 id="6-2-依赖缓存"><a href="#6-2-依赖缓存" class="headerlink" title="6.2 依赖缓存"></a>6.2 依赖缓存</h4><p>为了加快构建速度，Gradle 会对下载下来的依赖资源进行缓存，避免每次都去下载。</p>
<p>Gradle 的依赖缓存分为两种类型的存储:</p>
<ol>
<li>下载下来的依赖资源文件(artifacts)，包括二进制文件，比如jar包以及 meta-data，比如 POM 文件和 Ivy 文件。文件的存储路径上包含着 SHA1 校验值，这意味着两个同名不同内容的文件不会可以同时被缓存；</li>
<li>解析出来的 module meta-data 的二进制存储，包括解析出来的动态版本的结果，module 的描述信息，以及文件；</li>
</ol>
<p>分开存储的主要目的是将下载下来的文件与缓存 metadata 分开。从<a href="https://docs.gradle.org/current/userguide/dependency_management.html#sec:dependency_cache" target="_blank" rel="noopener">官网文档</a>以及实际设备的缓存内容来看，缓存划分的维度很多，包括：Gradle 版本，Repository，Checksum 等，会在设备上留下数量庞大的缓存的信息。</p>
<blockquote>
<p>缓存的 artifacts 是以 SHA1 校验值作为身份标识的，可以使用该值校验本地资源文件与远程是否一致。</p>
<p>缓存可能同时被多个进程操作，这个时候 Gradle 使用文件锁来保证一致性。</p>
</blockquote>
<p>虽然默认会使用缓存，但是我们可以主动控制这一行为: </p>
<ol>
<li><strong><code>--offline</code></strong> 告诉 Gradle 只能使用缓存中的资源文件，不需要去检测资源文件是否已经被更新，如果本地缓存中找不到资源文件，则构建失败；</li>
<li><strong><code>--refresh-dependencies</code></strong> Gradle 可能因为配置问题或者拉取了错误的资源文件，导致用户需要再次去服务端拉取最新的文件，更新本地缓存，这个时候就可以在命令行中添加该选项，它会使得 Gradle 忽略本地的所有缓存，并更新相关的所有配置、文件。</li>
</ol>
<p>另外，Gradle 还提供了 ResolutionStrategy 来更精细化的控制缓存，最常用的就是缓存过期时间，默认情况下 Gradle 缓存动态版本 (dynamic version) 的时间是24h，我们可以通过如下代码更改:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">configurations.all &#123;</span><br><span class="line">    resolutionStrategy.cacheDynamicVersionsFor <span class="number">10</span>, <span class="string">'minutes'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以更改变化模块 (changing module) 的时间:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">configurations.all &#123;</span><br><span class="line">    resolutionStrategy.cacheChangingModulesFor <span class="number">4</span>, <span class="string">'hours'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="七、发布"><a href="#七、发布" class="headerlink" title="七、发布"></a>七、发布</h2><p>依赖配置也可以用于配置产物发布，发布的产物被称为 <strong>publication artifacts</strong>。</p>
<p>事实上，插件已经定义好一个项目的产物了，也就是说，具体上传什么，不需要开发者再告诉 Gradle。</p>
<blockquote>
<p>这里提到一个之前没有提过的概念: 插件。可以认为这个就是某一类项目的构建脚本，比如专门把 J2EE 项目构建成 war 包。</p>
</blockquote>
<p>剩下的就是告诉 Gradle 把构建产物发布到什么地方了，具体做法就是把一个仓库传递给<code>uploadArchives</code>Task:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        ivy &#123;</span><br><span class="line">            credentials &#123;</span><br><span class="line">                username <span class="string">"username"</span></span><br><span class="line">                password <span class="string">"pw"</span></span><br><span class="line">            &#125;</span><br><span class="line">            url <span class="string">"http://repo.mycompany.com"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置好之后，执行<code>gradle uploadArchives</code>命令就可以上传发布产物了—— Gradle 会为你负责其余的一切，比如添加 Maven 需要的 pom.xml文件。</p>
<blockquote>
<p>发布到 Maven 仓库需要使用 Maven 插件，具体见<a href="https://docs.gradle.org/current/userguide/publishing_maven.html" target="_blank" rel="noopener">Maven Publishing</a>。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Gradle系列四：Task]]></title>
      <url>http://www.timebridge.space/2016/05/19/gradle-task/</url>
      <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p><strong>Task</strong>，是一小段可以执行的脚本代码，它是组成 Gradle 脚本文件的重要内容。</p>
<p>类比起来，可以将 Gradle 脚本文件看成一个类，将 Task 看成这个类中的一个方法。</p>
<blockquote>
<p>实际上脚本文件以及 Task 确实映射到 Java 类，这一点会在<a href="http://www.muzileecoding.com/gradlestudy/gradle-advaced-do.html" target="_blank" rel="noopener">Gradle DO模型</a>中说明。<a id="more"></a></p>
</blockquote>
<h2 id="二、入门"><a href="#二、入门" class="headerlink" title="二、入门"></a>二、入门</h2><p>当我们在一个目录下执行<code>gradle</code>命令的时候，<code>gradle</code>命令会首先在当前目录下寻找<code>build.gradle</code>文件，也就是 Gradle 脚本文件——通过这个文件，我们可以定义一个 Project 和一系列 Task。</p>
<p>比如我们在一个<code>build.gradle</code>文件中写入如下内容:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">task hello &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println <span class="string">'Hello world!'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在命令行中执行<code>gradle -q hello:</code>，就会有如下输出:</p>
<pre><code>&gt; gradle -q hello
Hello world!
</code></pre><p>这个例子非常简单，我们定义了一个叫做”hello”的 Task，在这个 Task 中，我们插入了一个 Action —— Action也是一小段可执行的 Groovy 脚本文件，它是组成 Task 的基本元素，以闭包的形式声明。为什么要这样实现 Task 呢？这样做主要是为了更加灵活的控制 Task 的行为。</p>
<blockquote>
<p>不了解闭包的话可以看文章: <a href="http://www.muzileecoding.com/gradlestudy/groovy.html" target="_blank" rel="noopener">Groovy 语法</a>。</p>
<p>官网上说 Groovy 的 Task 和 Ant 的 Target 在概念上是一致的。有 Ant 经验的小伙伴可以类比理解。</p>
</blockquote>
<h2 id="三、Task模型"><a href="#三、Task模型" class="headerlink" title="三、Task模型"></a>三、Task模型</h2><p><strong>Task 是一组 Action 的组合，这组 Action 存储在一个链表中，当我们执行 Task 的时候，其实是在顺序执行这组 Action。</strong></p>
<p>Task 提供了一组高级功能，可以让我们在 Action 链表前后插入 Action ，我们来看一个例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">task hello &lt;&lt; &#123;</span><br><span class="line">    println <span class="string">'Hello A'</span></span><br><span class="line">&#125;</span><br><span class="line">hello.doFirst &#123;</span><br><span class="line">    println <span class="string">'Hello B'</span></span><br><span class="line">&#125;</span><br><span class="line">hello.doLast &#123;</span><br><span class="line">    println <span class="string">'Hello C'</span></span><br><span class="line">&#125;</span><br><span class="line">hello.doFirst &#123;</span><br><span class="line">    println <span class="string">'Hello D'</span></span><br><span class="line">&#125;</span><br><span class="line">hello &lt;&lt; &#123;</span><br><span class="line">    println <span class="string">'Hello E'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们执行以上代码，可以得到如下输出:</p>
<pre><code>Hello D
Hello B
Hello A
Hello C
Hello E
</code></pre><p>这个顺序是怎么产生的呢？解释一下语法就明白了:</p>
<p><strong>Task 可以执行两种方法: <code>doLast</code>和<code>doFirst</code>，其中<code>&lt;&lt;</code>符号和<code>doLast</code>等效。前面说了，可以想象Task内部有一个 Action 链表，<code>doLast</code>负责在这个链表的最后面插入元素，<code>doFirst</code>负责在链表的最前面插入元素。最后执行的时候，按顺序执行 Action 链表。</strong></p>
<p>对比以上代码，输出是符合预期的。</p>
<h2 id="四、Task基础语法"><a href="#四、Task基础语法" class="headerlink" title="四、Task基础语法"></a>四、Task基础语法</h2><blockquote>
<p>Task 内部是可以使用任何的 Groovy 语法的，关于 Groovy 语法，可以查看 <a href="http://www.muzileecoding.com/gradlestudy/groovy.html" target="_blank" rel="noopener">Groovy 语法</a></p>
</blockquote>
<h3 id="4-1-依赖"><a href="#4-1-依赖" class="headerlink" title="4.1 依赖"></a>4.1 依赖</h3><p>当我们写一个类，并在其中写了诸多方法的时候，我们是需要一个地方组合这些方法实现目标功能的，这就像 Java 中的<code>main</code>函数，给整个程序一个入口，从而便于其余的类和方法按照一定的逻辑运行起来。那么在Gradle 脚本文件中，是如何组织这些 Task 的联系的呢？答案是 <strong>依赖</strong> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">task hello &lt;&lt; &#123;</span><br><span class="line">    println <span class="string">'Hello world!'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">task <span class="title">intro</span><span class="params">(dependsOn: hello)</span> &lt;&lt; </span>&#123;</span><br><span class="line">    println <span class="string">"I'm Gradle"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如代码所示，我们定义了两个 Task ，并通过<code>dependsOn</code>关键字声明<code>intro</code>依赖<code>hello</code>，执行一下<code>gradle -q intro</code>命令，输出如下:</p>
<pre><code>&gt; gradle -q intro
Hello world!
I&apos;m Gradle
</code></pre><p>虽然执行的是<code>intro</code>Task，但是实际先执行的是<code>hello</code>，因为前者依赖后者的执行。下面这种方式和上面等效:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">task hello &lt;&lt; &#123;</span><br><span class="line">    println <span class="string">'Hello world!'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">task <span class="title">intro</span><span class="params">()</span> &lt;&lt; </span>&#123;</span><br><span class="line">    println <span class="string">"I'm Gradle"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">intro.dependsOn hello</span><br></pre></td></tr></table></figure>
<p>除了依赖已知的 Task，依赖还能以如下形式进行:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">task <span class="title">taskX</span><span class="params">(dependsOn: <span class="string">'taskY'</span>)</span> &lt;&lt; </span>&#123;</span><br><span class="line">    println <span class="string">'taskX'</span></span><br><span class="line">&#125;</span><br><span class="line">task taskY &lt;&lt; &#123;</span><br><span class="line">    println <span class="string">'taskY'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个 Task 可以依赖一个还未声明的 Task，只需要以字符串形式表示 Task 名字即可。</p>
<p>下面是一个比较复杂的例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">task compile &lt;&lt; &#123;</span><br><span class="line">    println <span class="string">'compiling source'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">task <span class="title">compileTest</span><span class="params">(dependsOn: compile)</span> &lt;&lt; </span>&#123;</span><br><span class="line">    println <span class="string">'compiling unit tests'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//依赖两个Task</span></span><br><span class="line"><span class="function">task <span class="title">test</span><span class="params">(dependsOn: [compile, compileTest])</span> &lt;&lt; </span>&#123;</span><br><span class="line">    println <span class="string">'running unit tests'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">task <span class="title">dist</span><span class="params">(dependsOn: [compile, test])</span> &lt;&lt; </span>&#123;</span><br><span class="line">    println <span class="string">'building the distribution'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在命令行中执行<code>gradle dist test</code>，可以得到如下输出:</p>
<pre><code>&gt; gradle dist test
:compile
compiling source
:compileTest
compiling unit tests
:test
running unit tests
:dist
building the distribution

BUILD SUCCESSFUL

Total time: 1 secs
</code></pre><p>这里我们可以得出一个结论: <strong>无论一个Task在一次执行中如何被依赖，它都只会执行一次</strong> 。</p>
<h3 id="4-2-创建"><a href="#4-2-创建" class="headerlink" title="4.2 创建"></a>4.2 创建</h3><p>直接使用<code>task</code>关键字声明一个Task是最常见的方式，但实际上我们还可以动态创建 Task ，比如在脚本文件中写入:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>.times &#123; counter -&gt;</span><br><span class="line">    task <span class="string">"task$counter"</span> &lt;&lt; &#123;</span><br><span class="line">        println <span class="string">"I'm task number $counter"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行<code>gradle -q task1</code>，就可以得到如下输出:</p>
<pre><code>&gt; gradle -q task1
I&apos;m task number 1
</code></pre><p>动态生成的 Task 也能以上面的任意一种依赖形式进行 Task 依赖声明。</p>
<h3 id="4-3-获取"><a href="#4-3-获取" class="headerlink" title="4.3 获取"></a>4.3 获取</h3><p>这个点其实前面已经用到了，可能因为比较符合思维，因此不一定能注意到，这里特意提一下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">task hello &lt;&lt; &#123;</span><br><span class="line">    println <span class="string">'Hello world!'</span></span><br><span class="line">&#125;</span><br><span class="line">hello.doLast &#123;</span><br><span class="line">    println <span class="string">"Greetings from the $hello.name task."</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，在往<code>hello</code>中插入 Action 的时候，直接可以使用<code>hello</code>去引用 Task ，实际上，每一个声明出来的 Task 都被当成 Gradle 脚本文件的一个属性，因此可以直接通过这种方式存取（就像类中声明的一个变量）。</p>
<blockquote>
<p>还有一种办法是通过<code>Project.getTasks().findByPath()</code>或者<code>Project.getTasks().getByPath()</code>方法拿，但是我们这里没有讲到 Domain Object，因此略过。</p>
</blockquote>
<h3 id="4-4-额外属性"><a href="#4-4-额外属性" class="headerlink" title="4.4 额外属性"></a>4.4 额外属性</h3><p>在写一个方法的时候，我们常常会去声明一些本地变量，Task 也具备这些功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">task myTask &#123;</span><br><span class="line">    ext.myProperty = <span class="string">"myValue"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task printTaskProperties &lt;&lt; &#123;</span><br><span class="line">    println myTask.myProperty</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Task 中可以声明一个变量，保存到 ext 中去，之后在关于这个 Task的任何操作中就都可以使用它了，如上，执行命令<code>gradle -q printTaskProperties</code>就有如下输出:</p>
<pre><code>&gt; gradle -q printTaskProperties
myValue
</code></pre><blockquote>
<p>细心的读者可能比较奇怪，这里的<code>myTask</code>声明比较奇怪，声明的时候没有使用<code>doLast</code>，<code>doFirst</code>，<code>&lt;&lt;</code>中的任何一种，在闭包里面也只是简单的一行 Groovy 代码，这是一种什么声明方式？</p>
<p>这个其实和脚本的生命周期相关，会在<a href="http://www.muzileecoding.com/gradlestudy/gradle-lifecycle.html" target="_blank" rel="noopener">Gradle 生命周期</a>讲解，这段代码在配置阶段执行。这里只需要知道<strong>以这种方式声明的 Task 中的代码会先于其余 Action 执行</strong>就好了。</p>
</blockquote>
<h3 id="4-5-默认Task"><a href="#4-5-默认Task" class="headerlink" title="4.5 默认Task"></a>4.5 默认Task</h3><p>前面我们执行一个 Task 的时候，都需要指定 Task 名字，其实 Gradle 脚本文件中是可以通过<code>defaultTasks</code>指定默认 Task 的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">defaultTasks <span class="string">'clean'</span>, <span class="string">'run'</span></span><br><span class="line"></span><br><span class="line">task clean &lt;&lt; &#123;</span><br><span class="line">    println <span class="string">'Default Cleaning!'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task run &lt;&lt; &#123;</span><br><span class="line">    println <span class="string">'Default Running!'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task other &lt;&lt; &#123;</span><br><span class="line">    println <span class="string">"I'm not a default task!"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在只需要执行<code>gradle -q</code>命令，就可以得到如下输出:</p>
<pre><code>&gt; gradle -q
Default Cleaning!
Default Running!
</code></pre><p>这种情况下改名了就等价于<code>gradle -q clean run</code>。</p>
<h2 id="五、Task-高级语法"><a href="#五、Task-高级语法" class="headerlink" title="五、Task 高级语法"></a>五、Task 高级语法</h2><p>官方文档中有一章是专门为深入 Task 做讲解的: <a href="https://docs.gradle.org/current/userguide/more_about_tasks.html" target="_blank" rel="noopener">More about Tasks</a>。这里因为没有讲到 DO，不能很好的解释一些概念，这里就略过了，等讲完<a href="http://www.muzileecoding.com/gradlestudy/gradle-advaced-do.html" target="_blank" rel="noopener">Gradle DO模型</a>读者可以自行学习这一章节。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Gradle系列一：Groovy语法]]></title>
      <url>http://www.timebridge.space/2016/05/18/groovy/</url>
      <content type="html"><![CDATA[<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/groovy-icon.png" height="250" alt="One Piece"></div>

<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p><a href="http://www.groovy-lang.org/" target="_blank" rel="noopener">Groovy</a> 是 Java 平台上设计的面向对象编程语言。它拥有类似 Python、Ruby 和 Smalltalk 的一些特性，可以作为 Java 平台的脚本语言使用。<a id="more"></a></p>
<p>Groovy 的语法与 Java 非常相似，多数的 Java 代码同时也是正确的 Groovy 代码，两者可以混编，<strong>Groovy 代码最终还是会被编译为字节码运行在 JVM 上</strong>。它与 Java 的关系可以描述如下：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/groovy&java.png" height="160" alt="Groovy和Java的关系"></div>

<p>简而言之，<strong>两者是互补的而非替代的</strong>。</p>
<h2 id="二、组成"><a href="#二、组成" class="headerlink" title="二、组成"></a>二、组成</h2><div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/Groovy组成.png" alt="Groovy组成"></div>

<p>如图，是 Groovy 语言主要的组成部分:</p>
<ol>
<li><strong>GDK</strong>  主要是针对 Java 原有的库的功能扩充，是的一些操作更加的方便；</li>
<li><strong>Library</strong>  扩展功能，为常用功能开发了一组工具类，比如读取XML，SQL查询等；</li>
<li><strong>Language</strong>  最核心的部分，优化了 Java 原有的语法，比如<code>switch</code>可以运用在任何类型的对象上；添加新型的语法内容，比如闭包；</li>
</ol>
<h2 id="三、环境搭建"><a href="#三、环境搭建" class="headerlink" title="三、环境搭建"></a>三、环境搭建</h2><p>关于环境搭建，可以参考这篇文章<a href="http://www.muzileecoding.com/groovy/Groovy-install-and-ide-plugin.html" target="_blank" rel="noopener">Groovy安装和Eclipse插件安装</a>。</p>
<h2 id="四、常见语法"><a href="#四、常见语法" class="headerlink" title="四、常见语法"></a>四、常见语法</h2><p><strong>【约定】</strong> 以下示例中给出的<code>assert</code>语句全部都为 true。</p>
<h3 id="4-1-类声明"><a href="#4-1-类声明" class="headerlink" title="4.1 类声明"></a>4.1 类声明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String title</span><br><span class="line">	</span><br><span class="line">	Book (String theTitle)&#123;</span><br><span class="line">     	title = theTitle</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">String <span class="title">getTitle</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> title</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和 Java 很像，只是语句后面不需要再添加分号。</p>
<h3 id="4-2-方法和变量"><a href="#4-2-方法和变量" class="headerlink" title="4.2 方法和变量"></a>4.2 方法和变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Book gina = <span class="keyword">new</span> Book(<span class="string">'Groovy Study'</span>)</span><br><span class="line">def hello = <span class="string">'Hello, '</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> gina.getTitle() == <span class="string">'Groovy Study'</span></span><br><span class="line"><span class="keyword">assert</span> hello + getTitleBackwards(gina) == <span class="string">'Hello, ydutS yvoorG'</span></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">getTitleBackwards</span><span class="params">(book)</span></span>&#123;</span><br><span class="line">	String title = book.getTitle()</span><br><span class="line">	title.reverse()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法调用形式</span></span><br><span class="line">println (<span class="string">'Groovy is great!'</span>)</span><br><span class="line">println <span class="string">'Groovy is great'</span></span><br></pre></td></tr></table></figure>
<p>这里可以看到类的初始化和 Java 并无不同(先忽略 String ，后面细说)，和 Java 不一样的是，定义/声明变量和方法使用<code>def</code>关键字，不需要再指明类型了。</p>
<h3 id="4-3-GroovyBean"><a href="#4-3-GroovyBean" class="headerlink" title="4.3 GroovyBean"></a>4.3 GroovyBean</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookBean</span></span>&#123;</span><br><span class="line">	String title</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def groovyBook = <span class="keyword">new</span> BookBean()</span><br><span class="line"></span><br><span class="line">groovyBook.setTitle(<span class="string">'Groovy conquers the world'</span>)</span><br><span class="line"><span class="keyword">assert</span> groovyBook.getTitle() == <span class="string">'Groovy conquers the world'</span></span><br></pre></td></tr></table></figure>
<p>Groovy 不需要手动添加 getter 和 setter ，会为类自动生成 —— 声明 Bean 成为一件简单清爽的事情。</p>
<h3 id="4-4-GString"><a href="#4-4-GString" class="headerlink" title="4.4 GString"></a>4.4 GString</h3><p><strong>这个是重点！！</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def nick = <span class="string">'ReGina'</span></span><br><span class="line">def book = <span class="string">'Groovy Study'</span></span><br><span class="line"><span class="keyword">assert</span> <span class="string">"$nick is $book"</span> == <span class="string">'ReGina is Groovy Study'</span></span><br><span class="line"></span><br><span class="line">def language = <span class="string">'groovy'</span></span><br><span class="line">def improvedSentence = <span class="string">"$&#123;language.capitalize()&#125; is awesome!”</span></span><br><span class="line"><span class="string">assert improvedSentence == 'Groovy is awesome!'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">assert "</span>abc<span class="string">" - "</span>a<span class="string">" == "</span>bc<span class="string">"</span></span><br></pre></td></tr></table></figure>
<p>String 的定义既可以使用单引号，也可以使用双引号，操作也变得更加丰富：添加了变量替换、方法调用（值计算）、加减操作等强大形象的功能。</p>
<p>其实 Groovy 中的 String 不止以上两种形式，以下是汇总表格:</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/groovy-string.png" alt="Groovy字符串形式"></div>

<p>如图，除了单引号，双引号，还有三个单引号，三个双引号的形式，三个引号是用于多行展示的，比Java要方便很多。其中<code>Placeholder resolved</code>表示是否支持变量计算替换，<code>Backslash escape</code>表示是否支持转义。</p>
<h3 id="4-5-Number"><a href="#4-5-Number" class="headerlink" title="4.5 Number"></a>4.5 Number</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def x = <span class="number">1</span></span><br><span class="line">def y = <span class="number">2</span></span><br><span class="line"><span class="keyword">assert</span> x + y == <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> x.plus(y) == <span class="number">3</span></span><br><span class="line"><span class="keyword">assert</span> x <span class="keyword">instanceof</span> Integer</span><br></pre></td></tr></table></figure>
<p>数字除了相加，还能调用方法。这是因为<strong>在 Groovy 中，一切都是对象，没有基本类型</strong>，基本类型都会升级成包装类型运行。</p>
<h3 id="4-6-Range"><a href="#4-6-Range" class="headerlink" title="4.6 Range"></a>4.6 Range</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def x = <span class="number">1</span>..<span class="number">10</span></span><br><span class="line"><span class="keyword">assert</span> x.contains(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">assert</span> x.contains(<span class="number">15</span>) == <span class="keyword">false</span></span><br><span class="line"><span class="keyword">assert</span> x.size() == <span class="number">10</span></span><br><span class="line"><span class="keyword">assert</span> x.from == <span class="number">1</span></span><br><span class="line"><span class="keyword">assert</span> x.to == <span class="number">10</span></span><br><span class="line"><span class="keyword">assert</span> x.reverse() == <span class="number">10</span>..<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>一个新的类，用于表达一个范围。它具备很多神奇的功能，下面的一些例子中可以看到它的一些用法，具体可以参考<a href="http://www.groovy-lang.org/documentation.html" target="_blank" rel="noopener">官方Doc</a>、</p>
<h3 id="4-7-List"><a href="#4-7-List" class="headerlink" title="4.7 List"></a>4.7 List</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">def num = [<span class="string">'一'</span>, <span class="string">'二'</span>, <span class="string">'三'</span>, <span class="string">'四'</span>, <span class="string">'五'</span>, <span class="string">'六'</span>, <span class="string">'七'</span>, <span class="string">'八'</span>, <span class="string">'九'</span>, <span class="string">'十'</span>]</span><br><span class="line"><span class="keyword">assert</span> num[<span class="number">4</span>] == <span class="string">'五'</span></span><br><span class="line"></span><br><span class="line">num[<span class="number">10</span>] = <span class="string">'十一'</span></span><br><span class="line"><span class="keyword">assert</span> num.size() == <span class="number">11</span></span><br><span class="line"></span><br><span class="line">def list = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">list.each() &#123; item -&gt;</span><br><span class="line">	<span class="keyword">assert</span> item == list[item]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List list2 = [<span class="number">1</span>, <span class="number">2</span>, *list, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">assert</span> list2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">def myList = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> myList[<span class="number">0</span>..<span class="number">2</span>] == [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="keyword">assert</span> myList[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>] == [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'e'</span>]</span><br><span class="line"></span><br><span class="line">myList[<span class="number">0</span>..<span class="number">2</span>] = [<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>]</span><br><span class="line"><span class="keyword">assert</span> myList == [<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>]</span><br><span class="line"></span><br><span class="line">myList[<span class="number">3</span>..<span class="number">5</span>] = []</span><br><span class="line"><span class="keyword">assert</span> myList == [<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>]</span><br><span class="line"></span><br><span class="line">myList[<span class="number">1</span>..<span class="number">1</span>] = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">assert</span> myList == [<span class="string">'x'</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="string">'z'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> myList[-<span class="number">1</span>] == <span class="string">'z'</span></span><br><span class="line"></span><br><span class="line">List myList = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="keyword">assert</span> [<span class="string">'a'</span>, <span class="string">'x'</span>, <span class="string">'c'</span>].grep(myList) == <span class="string">'a'</span></span><br><span class="line"></span><br><span class="line">def kings = [<span class="string">'Dierk'</span>, <span class="string">'Paul'</span>]</span><br><span class="line">kings = kings.sort&#123; item -&gt; </span><br><span class="line">	item.size()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">assert</span> kings = [<span class="string">'Paul'</span>, <span class="string">'Dierk'</span>]</span><br><span class="line"></span><br><span class="line">def odd = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].findAll &#123;item -&gt;</span><br><span class="line">	item % <span class="number">2</span> == <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">assert</span> odd == [<span class="number">1</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>List 是我们首先介绍的一个集合 ，可以看到它的声明、使用方式和我们熟悉的数组非常类似，配合 range 使用，更加炫酷噢(看不懂的地方语法可以后面再看)！</p>
<p>这是 GDK 对 Java 增强的一个很好的例子。</p>
<h3 id="4-8-Map"><a href="#4-8-Map" class="headerlink" title="4.8 Map"></a>4.8 Map</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def http = [</span><br><span class="line">	<span class="number">100</span> : <span class="string">'CONTINUE'</span>,</span><br><span class="line">	<span class="number">200</span> : <span class="string">'OK'</span>,</span><br><span class="line">	<span class="number">400</span> : <span class="string">'BAD REQUEST'</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> http[<span class="number">200</span>] == <span class="string">'OK'</span></span><br><span class="line"><span class="keyword">assert</span> http.200 == <span class="string">'OK'</span></span><br><span class="line">http[<span class="number">500</span>] = <span class="string">'INTERNAL SERVER ERROR'</span></span><br><span class="line"><span class="keyword">assert</span> http.size() == <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>这里展示的是 Map 的增强使用，非常符合人的直觉思维，比 Java 的阅读性也更高。</p>
<h3 id="4-9-Control-Structure"><a href="#4-9-Control-Structure" class="headerlink" title="4.9 Control Structure"></a>4.9 Control Structure</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(index in <span class="number">1</span>..<span class="number">10</span>)&#123;</span><br><span class="line">	println index</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def list = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span>(index in list)&#123;</span><br><span class="line">	println index</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def age = <span class="number">36</span></span><br><span class="line"><span class="keyword">switch</span>(age)&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">16</span>..<span class="number">20</span> : <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">21</span>..<span class="number">50</span> : <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>: <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制结构也得到进一步增强，比如例子中，for 可以与 range 配合使用，<code>switch...case...</code>也可以和 range 结合。</p>
<h3 id="4-10-Other"><a href="#4-10-Other" class="headerlink" title="4.10 Other"></a>4.10 Other</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> code = <span class="string">'1 + 49.0'</span></span><br><span class="line"><span class="keyword">assert</span> <span class="number">50.0</span> == evaluate(code)</span><br><span class="line"></span><br><span class="line">value ?: <span class="keyword">default</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(candidate)&#123;</span><br><span class="line">	<span class="keyword">case</span> classifier1: handle1() ; <span class="keyword">break</span>;</span><br><span class="line">c	ase classifier2: handle2() ; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些是一些额外的例子，比如计算表达式的值，三目操作符的简化（空则用 default 值），主要目的是展现一下 Groovy 所做的优化以及一些”奇技淫巧”。</p>
<h3 id="4-11-总结"><a href="#4-11-总结" class="headerlink" title="4.11 总结"></a>4.11 总结</h3><p>Groovy 对原 Java 的语法以及集合等做了大量的扩充，不但增强了原有功能，使用起来更加快速自然，也添加新的语法，使得语言的表达能力更强。</p>
<p>上面的例子并不系统，主要目的是为了让读者对 Groovy 这门语言有大概的认知。系统学习的话还是建议看<a href="http://www.groovy-lang.org/documentation.html" target="_blank" rel="noopener">官方文档</a>。</p>
<h2 id="五、Closure"><a href="#五、Closure" class="headerlink" title="五、Closure"></a>五、Closure</h2><p>本节所要介绍的 <strong>Closure(闭包)</strong> 是语法的一个重要组成部分，因为非常重要，因此单独拉出来作为一节阐述。</p>
<blockquote>
<p>要学习 Gradle，闭包的概念必须理解。</p>
</blockquote>
<h3 id="5-1-Closure是什么-？"><a href="#5-1-Closure是什么-？" class="headerlink" title="5.1 Closure是什么 ？"></a>5.1 Closure是什么 ？</h3><p>对于 Java 程序员来说，Closure 是一个比较陌生的概念: </p>
<ol>
<li>A closure is a piece of code wrapped up as an object. </li>
<li>It acts like a method in that it can take parameters and it can return a value. </li>
<li>It’s a normal object in that you can pass a reference to it around just as you can a reference to any other object. </li>
</ol>
<p>这就是 Closure，中文称为闭包。从概念上类比一下，闭包就是 C++ 中的函数（可以通过函数指针引用），OC 中的 Block，JavaScript 中的 Closure。</p>
<p>通俗的说：<strong>闭包就是一段代码，可以接受参数，可以在程序中像变量一样传递。</strong></p>
<h3 id="5-2-声明和使用"><a href="#5-2-声明和使用" class="headerlink" title="5.2 声明和使用"></a>5.2 声明和使用</h3><p>先来个最简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Closure printer = &#123;line -&gt; println line&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是一个简单的闭包声明，它接受一个参数 line。使用例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Closure printer = &#123;line -&gt; println line&#125;</span><br><span class="line">printer(<span class="string">"Hello world"</span>)</span><br></pre></td></tr></table></figure>
<p>执行以上代码，就可以看到命令行中打印出 “Hello world”。可以看到闭包的使用和方法调用极其类似。下面来展示更多的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def adder = &#123;x, y -&gt; <span class="keyword">return</span> x+y&#125; <span class="comment">//闭包adder</span></span><br><span class="line"><span class="function"><span class="keyword">assert</span> <span class="title">adder</span><span class="params">(<span class="number">4</span>, <span class="number">3</span>)</span> </span>== <span class="number">7</span></span><br><span class="line"><span class="keyword">assert</span> adder.call(<span class="number">2</span>,<span class="number">6</span>) == <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>一目了然。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">benchmark</span><span class="params">(<span class="keyword">int</span> repeat, Closure worker)</span> </span>&#123;</span><br><span class="line">	def start = System.nanoTime()</span><br><span class="line">	repeat.times&#123; worker(it) &#125;</span><br><span class="line"></span><br><span class="line">	def stop = System.nanoTime()</span><br><span class="line">	<span class="keyword">return</span> stop - start</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def slow = benchmark(<span class="number">10000</span>,  &#123;(<span class="keyword">int</span>)it/<span class="number">2</span>&#125;)</span><br><span class="line">def fast = benchmark(<span class="number">10000</span>) &#123;it.intdiv(<span class="number">2</span>)&#125;</span><br><span class="line"><span class="keyword">assert</span> fast * <span class="number">15</span> &lt; slow</span><br></pre></td></tr></table></figure>
<p>这个例子比较复杂一些:</p>
<ol>
<li>首先定义了一个方法<code>benchmark</code>，它接受一个闭包作为参数；</li>
<li>调用的时候直接传递进去两个闭包: <code>{(int)it/2}</code>和<code>{it.intdiv(2)}</code>；</li>
<li>在方法内部，通过<code>worker(it)</code>的方式调用闭包；</li>
</ol>
<h3 id="5-3-闭包要点"><a href="#5-3-闭包要点" class="headerlink" title="5.3 闭包要点"></a>5.3 闭包要点</h3><p>关于闭包，还有几个要点是必须要了解的：</p>
<ol>
<li>当看到 {} 的时候，应当认为等同于:new Closure(){}；</li>
<li>任何一个 closure 都有一个默认的参数：it，它指向传递给 closure 的第一个参数，如果没有传递参数，则 it 为 null；</li>
<li>closure 总是有返回值，如果没有写 return，则返回最后一行代码的左值；如果没有值，则是 null；</li>
</ol>
<p>下面给一个例子解释一下第二点和第三点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义闭包，使用默认参数it</span></span><br><span class="line">def odd = &#123; it % <span class="number">2</span> == <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将List中的数传递进入闭包，如果闭包返回true，则放到结果List中去</span></span><br><span class="line"><span class="keyword">assert</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].grep(odd) == [<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//将switch的参数传给闭包，如果为true，则执行case</span></span><br><span class="line"><span class="keyword">switch</span>(<span class="number">10</span>)&#123;</span><br><span class="line">	<span class="keyword">case</span> odd : <span class="keyword">assert</span> <span class="keyword">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">2</span> in odd)</span><br><span class="line">	<span class="keyword">assert</span> <span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<p>这个例子展示的用法比较偏，但正展示了 Groovy 的强大功能，其中闭包 odd 的返回值就是<code>it % 2 == 1</code>。</p>
<h3 id="5-4-与方法的关系"><a href="#5-4-与方法的关系" class="headerlink" title="5.4 与方法的关系"></a>5.4 与方法的关系</h3><p>Closure 确实是一种新的语法机制，但是 Groovy 提供了一种办法，可以将一个方法转换成闭包:</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/grrovy-closure&method.png" height="188" alt="Groovy方法转换成闭包"></div>

<p>其中<code>receiver</code>代表的是一个对象实例，<code>.&amp;</code>是固定格式，<code>someMethod</code>是对象的一个方法名。来看个例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiMethodSample</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">mysteryMethod</span> <span class="params">(String value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span>  value.length()</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">mysteryMethod</span><span class="params">(List list)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> list.size()</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">mysteryMethod</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x + y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MultiMethodSample instance = <span class="keyword">new</span> MultiMethodSample()</span><br><span class="line">Closure multi = instance.&amp;mysteryMethod</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> <span class="number">10</span> == multi (<span class="string">'string arg'</span>) </span><br><span class="line"><span class="keyword">assert</span> <span class="number">3</span> = multi ([<span class="string">'list'</span>, <span class="string">'of'</span>, <span class="string">'values'</span>])</span><br><span class="line"><span class="keyword">assert</span> <span class="number">14</span> = multi (<span class="number">6</span>, <span class="number">8</span>)</span><br></pre></td></tr></table></figure>
<p>如图，通过<code>instance.&amp;mysteryMethod</code>就可以生成一个闭包，这个闭包与一般定义的还不同，它可以根据参数的不同执行到不同的方法，保留了方法的重载机制 —— 从这个角度说：<strong>闭包和方法本质上就是一样的</strong>。</p>
<h3 id="5-5-Scope"><a href="#5-5-Scope" class="headerlink" title="5.5 Scope"></a>5.5 Scope</h3><p>这里要讲一个很重要的东西: <strong>Scope</strong>，什么是 Scope 呢？</p>
<blockquote>
<p>The environment available inside a closure is called its <strong>scope</strong>.</p>
</blockquote>
<p>具体来说，Scope 就是考察:</p>
<ol>
<li>this指向什么？</li>
<li>可以获取哪些外部变量和方法? </li>
</ol>
<h4 id="5-5-1-this指针"><a href="#5-5-1-this指针" class="headerlink" title="5.5.1 this指针"></a>5.5.1 <code>this</code>指针</h4><p>来看个例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def x = <span class="number">0</span></span><br><span class="line"><span class="number">10</span>.times &#123;</span><br><span class="line">	x ++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> x == <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p><code>times</code>方法本身并不知道 x 的存在，但 Closure 却可以对<code>x</code>进行读写，这是怎么做到的呢？</p>
<p>这里又要引入一个新的概念 <strong>Birthday Context</strong> :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The closure somehow remembers the context at the point of its declaration and carries it along throughout its lifetime. That way, it can work on that original context whenever the situation calls <span class="keyword">for</span> it. This is called the __birthday context__ of the closures.</span><br></pre></td></tr></table></figure>
<p>即：闭包会”记住”它声明的时候的上下文环境，在它的生命周期期间内一直引用着这个环境，这样，闭包就能随时操作原来的环境(包括变量)，这个上下文环境就称为闭包的 <strong>Birthday Context</strong> 。</p>
<p>还是以上面的例子为参考，引用关系如下:</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/闭包birthday-context.png" height="150" alt="Groovy的Birthday Context引用关系"></div>

<p>如图，Script 就是代表脚本文件本身，<code>x</code>就是声明在脚本文件中的，同时脚本文件中有声明了闭包<code>{x++}</code>，这个闭包就持有对外部环境的引用，这里可以看到就是<code>x</code>，当把闭包传给<code>times</code>函数的时候，闭包依然可以获得<code>x</code>的引用。</p>
<p>在 Java 中，在一个方法中调用<code>this</code>指向的是当前对象本身，那么在闭包中使用<code>this</code>也是指向当前对象么？非也:</p>
<blockquote>
<p>its owner: the object in whose scope the closure was declared.</p>
</blockquote>
<p><strong>闭包中的<code>this</code>指向的是它的 owner，即创建它的对象</strong>。还是来看个例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mother</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> field = <span class="number">1</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">method</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span> &#125;</span><br><span class="line">	<span class="function">Closure <span class="title">birth</span><span class="params">(param)</span></span>&#123;</span><br><span class="line">		def local = <span class="number">3</span></span><br><span class="line">		def closure = &#123;caller -&gt;</span><br><span class="line">     		[ self : <span class="keyword">this</span>, field:field, method: method(),</span><br><span class="line">     		local : local, param : param, caller : caller,</span><br><span class="line">     		owner : owner,  delegate: delegate</span><br><span class="line">     		]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> closure</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Mother julia = <span class="keyword">new</span> Mother()</span><br><span class="line">def closure = julia.birth(<span class="number">4</span>)</span><br><span class="line">def context = closure.call(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> context.self == julia</span><br><span class="line"><span class="keyword">assert</span> context.field == <span class="number">1</span></span><br><span class="line"><span class="keyword">assert</span> context.method == <span class="number">2</span></span><br><span class="line"><span class="keyword">assert</span> context.local == <span class="number">3</span></span><br><span class="line"><span class="keyword">assert</span> context.param == <span class="number">4</span></span><br><span class="line"><span class="keyword">assert</span> context.caller == <span class="keyword">this</span></span><br><span class="line"><span class="keyword">assert</span> context.owner == julia</span><br></pre></td></tr></table></figure>
<p>读者可以自己跑一下看看：例子中的 closure 中的 this 指向的就是它的创建者 mother。</p>
<blockquote>
<p>【注意】方法不是对象，因此例子中的 closure 的创建者不是<code>birth</code>方法，而是 julia 对象。</p>
</blockquote>
<h4 id="5-5-2-外部变量和方法"><a href="#5-5-2-外部变量和方法" class="headerlink" title="5.5.2 外部变量和方法"></a>5.5.2 外部变量和方法</h4><p>还是从前面的例子看，<code>method()</code>方法和 field 变量是如何解析到的呢？</p>
<p>在 Closure 中，类似 method() 和 field 这样的类成员称为 <strong>vanilla reference</strong> 。vanilla reference 解析的时候，默认前面是加上<code>this.</code>引用的，即它们的解析是针对 owner 的。</p>
<h4 id="5-5-3-delegate"><a href="#5-5-3-delegate" class="headerlink" title="5.5.3 delegate"></a>5.5.3 delegate</h4><p><strong>delegate</strong> 是从例子中看到的，它是闭包的一个默认属性，它有什么作用呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设List中有这个方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span></span>&#123;</span><br><span class="line">	<span class="function">def <span class="title">with</span><span class="params">(Closure doit)</span> </span>&#123;</span><br><span class="line">		doit.delegate = <span class="keyword">this</span></span><br><span class="line">		doit()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def list = []</span><br><span class="line">def expected = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">list.with&#123;</span><br><span class="line">	<span class="comment">// birth context 中并没有 add 方法</span></span><br><span class="line">	add <span class="number">1</span></span><br><span class="line">	add <span class="number">2</span></span><br><span class="line">	<span class="keyword">assert</span> delegate == expected</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设在<code>List</code>类中有一个<code>with()</code>方法，闭包传递给它之后，先修改 delegate 为 this，然后再执行闭包。那么上面的 assert 就成立。为什么呢？</p>
<p>因为 <strong>delegate 实际是用于更改 vanilla reference 的解析对象的</strong>。前面说了，在闭包中调用方法，默认前面是加上 this 的，但是 delegate 可以修改这个默认值，在前面的例子中，我们实际把 delegate 修改指向了 this，这个 this 实际指向的是 List 本身，因此这个<code>add()</code>方法调用的是 List 本身的<code>add()</code>方法，所以最后<code>assert delegate == expected</code>是成立的。</p>
<h4 id="5-5-4-Vanilla-Reference解析"><a href="#5-5-4-Vanilla-Reference解析" class="headerlink" title="5.5.4 Vanilla Reference解析"></a>5.5.4 Vanilla Reference解析</h4><p>前面说了 <strong>Vanilla Reference</strong> 的解析方式，有以下三种：</p>
<ol>
<li>The closure itself : 比如例子中的 local 变量；</li>
<li>The owner : 比如第二个例子中的 expected；</li>
<li>The delegate : 比如<code>add()</code>方法的解析；</li>
</ol>
<p>既然有三个解析途径，那么解析顺序是如何的呢？是不是设置了 delegate 就一定会改变 <strong>Vanilla Reference</strong> 的解析对象呢？</p>
<p>首先肯定是本地变量解析优先的，剩下的 owner 和 delegate 的解析顺序，则是决定于<code>resolveStrategy</code>，总共有四种情况:</p>
<ol>
<li>delegate first // 优先针对 delegate 解析</li>
<li>delegate only // 只对 delegate 解析</li>
<li>owner first // 优先针对 owner 解析</li>
<li>owner only // 只针对 owner 解析</li>
</ol>
<p>修改例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">closure.resolveStrategy = Closure.DELEGATE_ONLY</span><br></pre></td></tr></table></figure>
<p>通过更改解析策略，就可以控制解析对象和顺序。</p>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>Groovy 作为一门脚本语言，与 Java 保持极大的相似性和兼容性，学习成本很低，并且极大的扩展了 Java 语言的表达能力！</p>
<p>这里分析 Groovy，主要是为学习 Gradle 提供一个基础，因此这里的列举既不系统也不深入，如果要深入学习，推荐以下资料:</p>
<ol>
<li><a href="http://www.groovy-lang.org/documentation.html" target="_blank" rel="noopener">官方文档</a>，Groovy的官方资料还是很全面的；</li>
<li>《Groovy In Action》，这个系列书对于入门以及稍微深入一门技术都还挺不错的；</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Gradle系列总]]></title>
      <url>http://www.timebridge.space/2016/05/18/Gradle-Outline/</url>
      <content type="html"><![CDATA[<p>本系列文章适合两类读者：</p>
<ol>
<li>对 Gradle 有所了解；</li>
<li>看了很多 Gradle 资料，但是仍然搞不明白 Gradle 是怎么回事；</li>
</ol>
<p>这系列文章可以为这两类读者理清思路，为后续的 Gradle 学习打下坚实的基础。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 驱动开发]]></title>
      <url>http://www.timebridge.space/2016/05/16/linux-driver-dev/</url>
      <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本章说明里面说本章的内容会注重于 Application 层，看了几天 Binder 的源码，发现已经掉进 Library 层的坑了，悲剧的是，不看一下 Binder 驱动，貌似连 Binder 这关都过不了，没办法，只能看看驱动到底怎么写。</p>
<p>网上教学写入门级 Linux 驱动的例子很多，比如<a href="http://liucw.blog.51cto.com/6751239/1218461" target="_blank" rel="noopener">【驱动】linux设备驱动·入门</a>、<a href="http://jp.51studyit.com/article/details/53732.htm" target="_blank" rel="noopener">linux驱动编写（虚拟字符设备编写）</a>，这两个例子步骤比较全，但是例子本身太简单，所以又找到一枚：<a href="http://www.cnblogs.com/lknlfy/archive/2012/04/27/2473804.html" target="_blank" rel="noopener">Linux内存映射（mmap）</a>。这篇文章简直就是为学习Binder而生，但是它的步骤很简略。因此结合前面两个例子提供的步骤以及第三篇文章的内容，这边讲述一下最终的实践经历。<a id="more"></a></p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p><strong>实践环境如下：Mac OS + VirtualBox 5.0.14 + Ubuntu-12.04.5</strong></p>
<blockquote>
<p>在Mac本身环境下貌似不行，目录结构不一致。</p>
</blockquote>
<h4 id="1-驱动程序"><a href="#1-驱动程序" class="headerlink" title="1. 驱动程序"></a>1. 驱动程序</h4><p>在Ubuntu系统桌面上新建文件<code>mymap.c</code>，将<a href="http://www.cnblogs.com/lknlfy/archive/2012/04/27/2473804.html" target="_blank" rel="noopener">Linux内存映射（mmap）</a>中如下内容拷贝进去:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/moduleparam.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/list.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/pci.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_NAME <span class="meta-string">"mymap"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="built_in">array</span>[<span class="number">10</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_open</span><span class="params">(struct inode *inode, struct file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">my_map</span><span class="params">(struct file *filp, struct vm_area_struct *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> page;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> i;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> start = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)vma-&gt;vm_start;</span><br><span class="line">    <span class="comment">//unsigned long end =  (unsigned long)vma-&gt;vm_end;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(vma-&gt;vm_end - vma-&gt;vm_start);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到物理地址</span></span><br><span class="line">    page = virt_to_phys(buffer);    </span><br><span class="line">    <span class="comment">//将用户空间的一个vma虚拟内存区映射到以page开始的一段连续物理页面上</span></span><br><span class="line">    <span class="keyword">if</span>(remap_pfn_range(vma,start,page&gt;&gt;PAGE_SHIFT,size,PAGE_SHARED))<span class="comment">//第三个参数是页帧号，由物理地址右移PAGE_SHIFT得到</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//往该内存写10字节数据</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        buffer[i] = <span class="built_in">array</span>[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">dev_fops</span> = &#123;</span></span><br><span class="line">    .owner    = THIS_MODULE,</span><br><span class="line">    .open    = my_open,</span><br><span class="line">    .mmap   = my_map,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">misc</span> = &#123;</span></span><br><span class="line">    .minor = MISC_DYNAMIC_MINOR,</span><br><span class="line">    .name = DEVICE_NAME,</span><br><span class="line">    .fops = &amp;dev_fops,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">dev_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;    </span><br><span class="line">	 printk(KERN_ALERT <span class="string">"(init)Hello,World!\n"</span>);</span><br><span class="line">    <span class="comment">//注册混杂设备</span></span><br><span class="line">    ret = misc_register(&amp;misc);</span><br><span class="line">    <span class="comment">//内存分配</span></span><br><span class="line">    buffer = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)kmalloc(PAGE_SIZE,GFP_KERNEL);</span><br><span class="line">    <span class="comment">//将该段内存设置为保留</span></span><br><span class="line">    SetPageReserved(virt_to_page(buffer));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">dev_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//注销设备</span></span><br><span class="line">    misc_deregister(&amp;misc);</span><br><span class="line">    <span class="comment">//清除保留</span></span><br><span class="line">    ClearPageReserved(virt_to_page(buffer));</span><br><span class="line">    <span class="comment">//释放内存</span></span><br><span class="line">    kfree(buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(dev_init);</span><br><span class="line">module_exit(dev_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"LKN@SCUT"</span>);</span><br></pre></td></tr></table></figure>
<p>完整拷贝，不需要任何的修改。</p>
<blockquote>
<p>比起原博客的代码，在<code>dev_init()</code>函数中增加了一行代码：<code>printk(KERN_ALERT &quot;(init)Hello,World!\n&quot;);</code>，用于检测安装。</p>
</blockquote>
<h4 id="2-Makefile文件"><a href="#2-Makefile文件" class="headerlink" title="2. Makefile文件"></a>2. Makefile文件</h4><p>在桌面上新建一个文件<code>Makefile</code>，内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">obj-m := mymap.o</span><br><span class="line">PWD := $(shell pwd)</span><br><span class="line">KDIR := /lib/modules/$(shell uname -r)/build</span><br><span class="line">all:</span><br><span class="line">    $(MAKE) -C $(KDIR) M=$(PWD) modules</span><br></pre></td></tr></table></figure>
<p><strong>【注意！】</strong> 最后一行开头是一个Tab，不要用空格代替，实践的时候被坑了。具体问题可见<a href="http://ubuntuforums.org/showthread.php?t=1795434" target="_blank" rel="noopener">这里</a>。</p>
<blockquote>
<p>KDIR也有赋值为<code>/usr/src/linux-source-2.6.24/</code>的，即目录是在<code>/usr/src/</code>下面，读者可作参考，我这个目录下面是找不到source目录的。</p>
</blockquote>
<h4 id="3-配置环境"><a href="#3-配置环境" class="headerlink" title="3. 配置环境"></a>3. 配置环境</h4><p>在编译出驱动文件之前，需要首先在系统命令行shell下安装当前版本的linux内核源代码：<code>sudo apt-get install linux-source</code>。</p>
<h4 id="4-编译"><a href="#4-编译" class="headerlink" title="4. 编译"></a>4. 编译</h4><p>进入桌面文件夹，执行如下命令：<code>make</code>。即可得到如下输入：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/driver-make.png" width="400" alt="Make驱动"></div>

<p>这个命令执行完毕后，会在桌面上生成很多文件，其中一个是<code>mymap.ko</code>，这个就是驱动。</p>
<h4 id="5-安装卸载"><a href="#5-安装卸载" class="headerlink" title="5. 安装卸载"></a>5. 安装卸载</h4><p>执行<code>sudo insmod ./mymap.ko</code>命令就能安装该驱动，执行<code>dmesg | tail -n 1</code>则可以看到输入”(init)Hello, world!”的输出，如下图：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/driver-install.png" width="400" alt="驱动安装"></div>

<p>另外我们可以执行<code>lsmod</code>命令，是可以找到一行<code>mymap</code>驱动的输出的。</p>
<p>卸载驱动的命令是<code>rmmod</code>。</p>
<h4 id="6-验证"><a href="#6-验证" class="headerlink" title="6. 验证"></a>6. 验证</h4><p>安装卸载中已经提到一些验证方法，但是<a href="http://www.cnblogs.com/lknlfy/archive/2012/04/27/2473804.html" target="_blank" rel="noopener">Linux内存映射（mmap）</a>则是用程序去验证的。</p>
<p>在桌面上新建一个<code>test.c</code>文件，内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE 4096</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc , <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p_map;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打开设备</span></span><br><span class="line">    fd = open(<span class="string">"/dev/mymap"</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"open fail\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内存映射</span></span><br><span class="line">    p_map = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)mmap(<span class="number">0</span>, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED,fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(p_map == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"mmap fail\n"</span>);</span><br><span class="line">        <span class="keyword">goto</span> here;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印映射后的内存中的前10个字节内容</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,p_map[i]);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">here:</span><br><span class="line">    munmap(p_map, PAGE_SIZE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不用做任何的更改。</p>
<p>执行命令<code>gcc -o test test.c</code>即可在桌面上生成<code>test</code>可执行文件。执行该文件，就可以得到如下输出:</p>
<p><div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/driver-verify.png" width="400" alt="驱动安装验证"></div><br>与原博客的结果一致。</p>
<blockquote>
<p>如果打印出来的是”open fail”，可以看一下权限是否足够，可以在root权限下尝试执行。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个实践非常简单（就是环境和执行过程坑），对于Makefile里面的配置，以及驱动的写法，这里都没有做过多的解释，但是推荐的文章里面有表述，做这个实践主要的目的是：</p>
<ol>
<li>感受一下写驱动的过程；</li>
<li>体验一下虚拟设备（挂载、读写）、mmap内存映射；</li>
</ol>
<p>了解这些对于理解Binder驱动非常有用，详细的驱动相关的知识可以阅读《Linux设备驱动程序》这本书。</p>
<p>PS：关于文件描述符和进程的关系，可以参考这篇文章: <a href="http://blog.csdn.net/cywosp/article/details/38965239" target="_blank" rel="noopener">Linux中的文件描述符与打开文件之间的关系</a>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Binder总纲]]></title>
      <url>http://www.timebridge.space/2016/05/16/binder/</url>
      <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>关于 Binder 的文章，网上已经有非常多的资料，下面推荐几篇：</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>文章</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td><a href="http://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="noopener">Android Bander设计与实现 - 设计篇</a></td>
<td>被很多博客推荐的博客，只讲设计不讲代码。介绍了 Binder 机制中的很多概念以及很多关键点的逻辑，非常值得一读，最主要的是里面有一张神图，清楚的展示了相关概念之间的关系。</td>
</tr>
<tr>
<td>②</td>
<td><a href="http://weishu.me/2016/01/12/binder-index-for-newer/" target="_blank" rel="noopener">Binder学习指南</a></td>
<td>如标题所言，有学习指南，也推荐了第一篇博客，目前还只是停留在 Java 层，有待深入。但是开头的 Linux 系统相关知识的讲解比较有用，另外比喻也非常恰当。</td>
</tr>
<tr>
<td>③</td>
<td><a href="http://blog.csdn.net/codefly/article/category/1054447" target="_blank" rel="noopener">红茶一杯话Binder</a></td>
<td>这篇文章真正的做到了有图有真相！虽然是讲代码，但是解析图画的太棒了，一目了然，一定要坚持看完上中下三篇，讲解非常精彩。</td>
</tr>
<tr>
<td>④</td>
<td><a href="http://blog.csdn.net/luoshengyang/article/details/6618363" target="_blank" rel="noopener">Android进程间通信（IPC）机制Binder简要介绍和学习计划</a></td>
<td>老罗的文章。首先是分工明确，四篇文章讲述Binder机制的四个要点；其次是讲解的非常细致深入，可以当做字典查看。</td>
</tr>
<tr>
<td>⑤</td>
<td><a href="http://www.cnblogs.com/innost/archive/2011/01/09/1931456.html" target="_blank" rel="noopener">Android深入浅出之Binder机制</a></td>
<td>邓凡平大神的博客，也是老罗推荐的博客。这篇文章直接从 MediaPlayerService 切入，讲解细致，娓娓道来。建议在看完前面几篇文章之后再来看这篇文章。</td>
</tr>
</tbody>
</table>
<a id="more"></a><strong>因为有大神的文章，才能入得 Binder 的大门一探究竟，非常感谢！</strong><br><br>说实话，几篇文章加起来该讲的也都讲得差不多了。本文只是试着按照自己的思路去梳理一下 Binder 的机制，对上面几篇文章的有引用的地方会标记出来。<br><br>这里也省去一些背景介绍，包括为什么选择 Binder、Binder 的设计思想等等，这些在文章①中都有阐述。<br><br>## Binder结构<br>老罗的文章中对此的解析最为清晰，因为他在<a href="http://www.cnblogs.com/innost/archive/2011/01/09/1931456.html" target="_blank" rel="noopener">学习计划</a>中画了个图。图中可以清晰的看到 Binder 分为四个部分:<br><br>1. Client —— 服务使用方<br>2. Server —— 服务提供方<br>3. Binder Driver —— 底层驱动<br>4. Service Manager —— 服务管理方<br><br>下面这个图是 Android 的系统架构图:<br><br><div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/Android-Arc.png" alt="Android系统架构"></div><br><br>事实上老罗的图是分布在 Libraries 和 Linux Kernel 层的，即 Client、Server以及 Service Manager 三部分属于 Libraries，而Binder Driver属于 Linux Kernel 层。<br><br>大部分文章分析 Binder 的时候也是这样，脱离了我们最常接触的 Application Framework 层在讲述，导致不容易理解。但 Binder 的核心逻辑确实不在 Java 层，Java层只是为了方便开发者使用而进行的一层包装，因此我们也先搞清楚以上四个概念，然后再去琢磨Java层。<br><br>#### 结构解释<br>看完文章②关于Linux知识的解释再来看这四个部分的关系，可能理解起来还不是很容易。这里用一种通俗一点的方式来解释一下为什么会形成这四个部分。<br><br>首先要知道的一点是：进程不像线程，进程之间的内存是不共享的，这也是为什么我们创造多种多样的方式来实现进程间通讯的原因。以 Android 开发为例，可以想象两个 Activity，有时候在跳转的时候，Intent 需要携带的数据过于复杂，序列化已经不不可能，那该怎么办呢？<br><br>一种办法就是将数据设置为静态变量，还有一种办法就是存到 Application 类中（当然还有其他办法）。以上两种办法总结一下无非是找一个两个 Activity 都能访问到的第三方变量来中转数据。对于进程来说，采取的办法也类似：虽然进程之间直接通讯是被禁止的，但是通过内核是可以的。内核是所有进程运行的环境，可以把数据交给内核，让内核发送给对应的进程，对方进程也以同样的方式将结果返回回来。<br>&gt;内核理解起来太抽象的话，可以想象一个文件，一个文件可以被任何的应用读取，因此我可以让一个应用在文件中写入一段话，另外一个应用去读取这段话，这样也可以完成一次通信。<br><br>这就是 Client，Server，Binder Driver 之间的关系，只不过 Client/Server 和 Binder Driver 之间的调用不是一般的方法调用，而是 <strong>系统调用</strong> 。<br><br>那么 Service Manager 又是用来做什么的呢？这一点文章②描述的很清晰。简单来说，一个 Service 启动起来之后，给自己取一个名字，注册到 ServiceManager 中去，告诉 Service Manager：如果有人找”XXXX”，你让它来找我好了，Service Manager 就记下了，这就是<strong>服务的注册过程</strong>。这个时候有个 Client 听说有个叫”XXXX”的 Service 能干某事儿，就问 Service Manager ，有这个叫”XXXX”的 Service 没有？ Service Manager 一查自己的记录表，就找到了这个 Service ，欢快地把它交给了 Client，这就是<strong>服务的查询过程</strong>。Client 拿到 Service 之后就可以享受 Service 提供的服务了。没有 Service Manager，Clients 就不知道去哪里寻找想要的服务。<br><br>这么一来，我们就搞清楚了 Binder 机制每个部分的职责以及大体的交互是什么样子的。实际的问题要复杂很多，接下来就是要深究<strong>三个核心问题</strong>:<br><br>1. Service Manager 是如何启动并成为服务管理者的？<br>2. Service 是如何将自己注册到 Service Manager 中去的？<br>3. Client 是如何寻找对应的 Service 的？<br><br>这三个点是 Binder 机制交互的核心，搞清楚这三个点，就可以比较好的理解 Binder 机制了。<br><br>### 建议<br>在开始介绍之前，建议读者先根据文章<a href="http://www.muzileecoding.com/framework/linux-driver-dev.html" target="_blank" rel="noopener">Linux 驱动开发</a>自己动手写个驱动，对Linux系统不陌生的童鞋花不了多少时间，文章中给出的几篇文章链接也建议花时间看一下。了解一个简单驱动是如何编写的，对于后面讲解 Binder 驱动大有裨益。<br><br>另外既然要分析源码，代码文件自然少不了，这里推荐一个网站:<a href="http://androidxref.com/" target="_blank" rel="noopener">AndroidXref</a>。可以方便查看多个 Android 版本的系统源代码。<br><br>###v声明<br>在阅读<a href="http://blog.csdn.net/codefly/article/category/1054447" target="_blank" rel="noopener">@悠然红茶</a>的博客时，深感画图的重要性，尤其是函数的调用关系图，在分析复杂系统的时候显得特别有用：可以清晰的定位到目前正在分析哪一块。因此接下去的文章会借用这种方式进行分析。<br><br>## Binder 结构体字典<br>因为 binder 的实现中涉及到非常多的数据结构，本来分析起来方法调用链就很长，临时再去分析数据结构会让分析变得不清楚，因此这里会列出遇到的所有的数据结构以便于读者查询。<strong>在后续的文章中，如果一个结构体列在这里，会标注出来，表明在字典中可查。</strong><br><br><strong>【注意】</strong> 这些结构体有的非常复杂，包含别的结构体；有的有些字段含义明确，有的则非常模糊；有的甚至只是与另外一个结构体保持同构。因此在字典中解释全部的字段不现实，更何况有些需要结合代码上下文进行分析，因此这里很多结构体只是简单的枚举，不存在分析。<br><br>### <code>binder_state</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">void</span> *mapped;</span><br><span class="line">    <span class="keyword">unsigned</span> mapsize;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个结构体有三个属性：fd 代表打开的 binder 驱动的文件描述符，mapped 是内存映射的其实地址，mapsize 是内存映射的大小。</p>
<h3 id="binder-proc"><a href="#binder-proc" class="headerlink" title="binder_proc"></a><code>binder_proc</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">proc_node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">threads</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">nodes</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">refs_by_desc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">refs_by_node</span>;</span></span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vma_vm_mm</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">deferred_work_node</span>;</span></span><br><span class="line">    <span class="keyword">int</span> deferred_work;</span><br><span class="line">    <span class="keyword">void</span> *buffer;</span><br><span class="line">    <span class="keyword">ptrdiff_t</span> user_buffer_offset;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">buffers</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">free_buffers</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">allocated_buffers</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> free_async_space;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> **<span class="title">pages</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> buffer_size;</span><br><span class="line">    <span class="keyword">uint32_t</span> buffer_free;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">todo</span>;</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> wait; <span class="comment">// Linux中很重要的数据结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_stats</span> <span class="title">stats</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">delivered_death</span>;</span></span><br><span class="line">    <span class="keyword">int</span> max_threads;</span><br><span class="line">    <span class="keyword">int</span> requested_threads;</span><br><span class="line">    <span class="keyword">int</span> requested_threads_started;</span><br><span class="line">    <span class="keyword">int</span> ready_threads;</span><br><span class="line">    <span class="keyword">long</span> default_priority;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">debugfs_entry</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个结构体非常重要，它实际和 Libraries 层的进程一一对应，除了记录进程相关的信息，还创建了很多的属性用于实现 binder 机制相关的功能，这个结构体将被保存在<code>filp-&gt;private_data</code>中，以后也可以从这个变量中取出 binder_proc 变量。它核心的一组属性是:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">threads</span>;</span> <span class="comment">// 记录属于该进程的所有线程</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">nodes</span>;</span> <span class="comment">// 记录属于该进程的所有 binder_node，表示该进程提供的服务</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">refs_by_desc</span>;</span> <span class="comment">// 记录属于该进程引用的服务，节点是 binder_ref，根据 handle 进行查找</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">refs_by_node</span>;</span> <span class="comment">// 同上，但是根据 binder_node 进行查找</span></span><br></pre></td></tr></table></figure>
<p>这是四棵红黑树，后面有注释。</p>
<h3 id="binder-thread"><a href="#binder-thread" class="headerlink" title="binder_thread"></a><code>binder_thread</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb_node</span>;</span></span><br><span class="line">	<span class="keyword">int</span> pid;</span><br><span class="line">	<span class="keyword">int</span> looper;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">transaction_stack</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">todo</span>;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> return_error; <span class="comment">/* Write failed, return error code in read buf */</span></span><br><span class="line">	<span class="keyword">uint32_t</span> return_error2; <span class="comment">/* Write failed, return error code in read */</span></span><br><span class="line">		<span class="comment">/* buffer. Used when sending a reply to a dead process that */</span></span><br><span class="line">		<span class="comment">/* we are also waiting on */</span></span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> wait;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_stats</span> <span class="title">stats</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>顾名思义，和<code>binder_proc</code>类似，这个结构体记录的其实是映射到一个 Libraries 线程。这里可以看到<code>binder_proc</code>结构属性，表明这个线程是属于哪个进程的；还有一个属性是 rb_node，还记得前面介绍<code>binder_proc</code>时说到它有四棵重要的红黑树么？其中一棵就叫做<code>threads</code>，记录的是属于这个进程的所有线程，这里的 rb_node 属性就是指向其中的一个节点；另外 looper 属性记录的是当前线程的状态。</p>
<h3 id="binder-node"><a href="#binder-node" class="headerlink" title="binder_node"></a><code>binder_node</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> debug_id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> <span class="title">work</span>;</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb_node</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">dead_node</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">refs</span>;</span></span><br><span class="line">    <span class="keyword">int</span> internal_strong_refs;</span><br><span class="line">    <span class="keyword">int</span> local_weak_refs;</span><br><span class="line">    <span class="keyword">int</span> local_strong_refs;</span><br><span class="line">    <span class="keyword">void</span> __user *ptr;</span><br><span class="line">    <span class="keyword">void</span> __user *cookie;</span><br><span class="line">    <span class="keyword">unsigned</span> has_strong_ref:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> pending_strong_ref:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> has_weak_ref:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> pending_weak_ref:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> has_async_transaction:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> accept_fds:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> min_priority:<span class="number">8</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">async_todo</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代表着一个 Service 服务在驱动层的实体节点，驱动层内部通过它便可以找到 Libraries 层的服务实体。它的 cookie 字段记录着服务在 Libraries 层的引用位置。proc则表示该节点所代表的服务属于那个进程。其余的属性主要是引用计数。</p>
<h3 id="binder-ref"><a href="#binder-ref" class="headerlink" title="binder_ref"></a><code>binder_ref</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Lookups needed: */</span></span><br><span class="line">    <span class="comment">/*   node + proc =&gt; ref (transaction) */</span></span><br><span class="line">    <span class="comment">/*   desc + proc =&gt; ref (transaction, inc/dec ref) */</span></span><br><span class="line">    <span class="comment">/*   node =&gt; refs + procs (proc exit) */</span></span><br><span class="line">    <span class="keyword">int</span> debug_id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb_node_desc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb_node_node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">node_entry</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> desc;</span><br><span class="line">    <span class="keyword">int</span> strong;</span><br><span class="line">    <span class="keyword">int</span> weak;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref_death</span> *<span class="title">death</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="binder-write-read"><a href="#binder-write-read" class="headerlink" title="binder_write_read"></a><code>binder_write_read</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> write_size; <span class="comment">/* bytes to write */</span>  </span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> write_consumed; <span class="comment">/* bytes consumed by driver */</span>  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   write_buffer;  </span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> read_size;  <span class="comment">/* bytes to read */</span>  </span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> read_consumed;  <span class="comment">/* bytes consumed by driver */</span>  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>   read_buffer;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个结构体并不复杂，只有六个对称的字段：既可以支持读的数据也可以支持写的数据，并且看注释，这个结构体最终应该会传递给 binder 驱动。实际上 <strong>这个结构体只负责数据传输，不负责数据语义，具体 write_buffer 和 read_buffer 里面承载什么数据，代表什么含义，是由上下文环境确定的</strong>。</p>
<h3 id="flat-binder-object"><a href="#flat-binder-object" class="headerlink" title="flat_binder_object"></a><code>flat_binder_object</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * This is the flattened representation of a Binder object for transfer </span><br><span class="line"> * between processes.  The &apos;offsets&apos; supplied as part of a binder transaction </span><br><span class="line"> * contains offsets into the data where these structures occur.  The Binder </span><br><span class="line"> * driver takes care of re-writing the structure type and data as it moves </span><br><span class="line"> * between processes. </span><br><span class="line"> */  </span><br><span class="line">struct flat_binder_object &#123;  </span><br><span class="line">    /* 8 bytes for large_flat_header. */  </span><br><span class="line">    unsigned long       type;  </span><br><span class="line">    unsigned long       flags;  </span><br><span class="line">  </span><br><span class="line">    /* 8 bytes of data. */  </span><br><span class="line">    union &#123;  </span><br><span class="line">        void        *binder;    /* local object */  </span><br><span class="line">        signed long handle;     /* remote object */  </span><br><span class="line">    &#125;;  </span><br><span class="line">  </span><br><span class="line">    /* extra data associated with local object */  </span><br><span class="line">    void            *cookie;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注释里面说的很清楚，这个对象就是代表一个 binder 对象，用于在进程之间传输的，在binder transaction中有一个”offsets”字段表明哪些地方存储着该结构体，binder 驱动负责重写结构体中的 type 字段和数据。另外，这个结构体中有一个很重要的 union，这个 union 中有两个字段，分别可以指向一个本地的binder和一个远程的binder，远程binder是通过handle字段来指向的。</p>
<blockquote>
<p>这段话现在听上去不大好理解，因为首先不知道binder transaction代表什么，其次也不明白 binder 为什么要重写这个结构内容。这个在具体分析 binder 驱动的时候会逐个解释。</p>
</blockquote>
<h3 id="binder-transaction-data"><a href="#binder-transaction-data" class="headerlink" title="binder_transaction_data"></a><code>binder_transaction_data</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> &#123;</span></span><br><span class="line">	<span class="comment">/* The first two are only used for bcTRANSACTION and brTRANSACTION,</span></span><br><span class="line"><span class="comment">	 * identifying the target and contents of the transaction.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">size_t</span>	handle;	<span class="comment">/* target descriptor of command transaction */</span></span><br><span class="line">		<span class="keyword">void</span>	*ptr;	<span class="comment">/* target descriptor of return transaction */</span></span><br><span class="line">	&#125; target;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">void</span>		*cookie;	<span class="comment">/* target object cookie */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	code;		<span class="comment">/* transaction command */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* General information about the transaction. */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>	flags;</span><br><span class="line">	<span class="keyword">pid_t</span>		sender_pid;</span><br><span class="line">	<span class="keyword">uid_t</span>		sender_euid;</span><br><span class="line">	<span class="keyword">size_t</span>		data_size;	<span class="comment">/* number of bytes of data */</span></span><br><span class="line">	<span class="keyword">size_t</span>		offsets_size;	<span class="comment">/* number of bytes of offsets */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If this transaction is inline, the data immediately</span></span><br><span class="line"><span class="comment">	 * follows here; otherwise, it ends with a pointer to</span></span><br><span class="line"><span class="comment">	 * the data buffer.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="comment">/* transaction data */</span></span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">void</span>	*buffer;</span><br><span class="line">			<span class="comment">/* offsets from buffer to flat_binder_object structs */</span></span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">void</span>	*offsets;</span><br><span class="line">		&#125; ptr;</span><br><span class="line">		<span class="keyword">uint8_t</span>	buf[<span class="number">8</span>];</span><br><span class="line">	&#125; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>有些字段是有注释的，这里最重要的一个字段赋值是<code>tr.target.handle = handle;</code>，这个 handle 就是我们需要调用的服务的句柄，当这个服务为 SM 的时候，handle 就为0__。</p>
<h3 id="binder-transaction"><a href="#binder-transaction" class="headerlink" title="binder_transaction"></a><code>binder_transaction</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> debug_id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> <span class="title">work</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">from</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">from_parent</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">to_proc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">to_thread</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">to_parent</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> need_reply:<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* unsigned is_dead:1; */</span>   <span class="comment">/* not used at the moment */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> *<span class="title">buffer</span>;</span> <span class="comment">/* 该结构体见下面所列 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    code;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>    flags;</span><br><span class="line">    <span class="keyword">long</span>    priority;</span><br><span class="line">    <span class="keyword">long</span>    saved_priority;</span><br><span class="line">    <span class="keyword">uid_t</span>   sender_euid;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="binder-buffer"><a href="#binder-buffer" class="headerlink" title="binder_buffer"></a><code>binder_buffer</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span> <span class="comment">/* free and allocated entries by address */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb_node</span>;</span> <span class="comment">/* free entry by size or allocated entry */</span></span><br><span class="line">                <span class="comment">/* by address */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="built_in">free</span>:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> allow_user_free:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> async_transaction:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> debug_id:<span class="number">29</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">transaction</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> data_size;</span><br><span class="line">    <span class="keyword">size_t</span> offsets_size;</span><br><span class="line">    <span class="keyword">uint8_t</span> data[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="binder-work"><a href="#binder-work" class="headerlink" title="binder_work"></a><code>binder_work</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        BINDER_WORK_TRANSACTION = <span class="number">1</span>,</span><br><span class="line">        BINDER_WORK_TRANSACTION_COMPLETE,</span><br><span class="line">        BINDER_WORK_NODE,</span><br><span class="line">        BINDER_WORK_DEAD_BINDER,</span><br><span class="line">        BINDER_WORK_DEAD_BINDER_AND_CLEAR,</span><br><span class="line">        BINDER_WORK_CLEAR_DEATH_NOTIFICATION,</span><br><span class="line">    &#125; type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="binder-txn"><a href="#binder-txn" class="headerlink" title="binder_txn"></a><code>binder_txn</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_txn</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *target;</span><br><span class="line">    <span class="keyword">void</span> *cookie;</span><br><span class="line">    <span class="keyword">uint32_t</span> code;</span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> sender_pid;</span><br><span class="line">    <span class="keyword">uint32_t</span> sender_euid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> data_size;</span><br><span class="line">    <span class="keyword">uint32_t</span> offs_size;</span><br><span class="line">    <span class="keyword">void</span> *data;</span><br><span class="line">    <span class="keyword">void</span> *offs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>binder_transaction_data 的同构体。</p>
<h3 id="binder-io"><a href="#binder-io" class="headerlink" title="binder_io"></a><code>binder_io</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_io</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *data;            <span class="comment">/* pointer to read/write from */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> *offs;        <span class="comment">/* array of offsets */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> data_avail;   <span class="comment">/* bytes available in data buffer */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> offs_avail;   <span class="comment">/* entries available in offsets array */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *data0;           <span class="comment">/* start of data buffer */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> *offs0;       <span class="comment">/* start of offsets buffer */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> unused;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这是一个定义很不明确的结构体，功能大体描述如下：可以定义该结构体可以容纳的数据大小、剩余量、起始位置；并可以定义一些特殊数据的偏移量，偏移量数据同样也有起始位置和数据大小。</p>
<h3 id="binder-object"><a href="#binder-object" class="headerlink" title="binder_object"></a><code>binder_object</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> type;</span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">void</span> *pointer;</span><br><span class="line">    <span class="keyword">void</span> *cookie;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>与 flat_binder_object 结构体对应，是它的反序列化结构体。</p>
<h3 id="svcinfo"><a href="#svcinfo" class="headerlink" title="svcinfo"></a><code>svcinfo</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_death</span> <span class="title">death</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> len;</span><br><span class="line">    <span class="keyword">uint16_t</span> name[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>ptr 记录的是系统service对应的binder句柄值</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JNI 简介]]></title>
      <url>http://www.timebridge.space/2016/05/14/jni/</url>
      <content type="html"><![CDATA[<p>从本章的介绍中可以看出来，Android 的上层使用 Java 语言来进行应用程序开发，但是本地库都是使用 C/C++ 来实现，这中间是需要粘合的，这种粘合方式就是 JNI 。</p>
<p>JNI 是 Java Native Interface 的缩写，它提供了若干的 API 实现了 Java 和其他语言的通信（主要是 C&amp;C++ ）。</p>
<p>在《 Android 技术内幕(系统卷)》这本书里面，有一幅图可以很好的展现这层关系：<a id="more"></a></p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/Android-JNI.png" height="300" alt="Android-JNI"></div>

<p>这个图可以映射到 Android 系统的框架图去看，可以明显看到：<strong>JNI 是粘合框架层和库层的重要组件</strong>。</p>
<h2 id="JNI的基础用法"><a href="#JNI的基础用法" class="headerlink" title="JNI的基础用法"></a>JNI的基础用法</h2><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>先来看一个 Android 上简单的JNI使用🌰。</p>
<p>先写如下这样一个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.footprint.littleshell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.EditText;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by liquanmin on 16/5/11.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> EditText et;</span><br><span class="line">    <span class="keyword">protected</span> Button button;</span><br><span class="line"></span><br><span class="line">	 <span class="keyword">static</span>&#123;</span><br><span class="line">		 System.loadLibrary(<span class="string">"test_jni"</span>);</span><br><span class="line">	 &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">getMessage</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.setContentView(R.layout.activity_test);</span><br><span class="line">        initView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (view.getId() == R.id.button) &#123;</span><br><span class="line">            et.setText(getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        et = (EditText) findViewById(R.id.et);</span><br><span class="line">        button = (Button) findViewById(R.id.button);</span><br><span class="line">        button.setOnClickListener(TestActivity.<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如代码所示，这个类声明了一个 native 方法<code>getMessage()</code>，然后编译这个类（在 IDE 里面可以简单的使用<code>Build-&gt;Rebuild Project</code>来进行）。</p>
<p>这个类是声明在<code>com.footprint.littleshell</code>，我们进入<code>com</code>所在目录，执行如下命令：<code>javah -jni com.footprint.littleshell.TestActivity</code>，就可在<code>com</code>所在目录下面得到如下文件：<code>com_footprint_littleshell_TestActivity.h</code>。</p>
<blockquote>
<p>一定要是包所在目录，而不是编译出来的 class 文件所在目录。</p>
<p>另外，在 Mac 下，命令执行可能会出现中文乱码，可以使用如下命令解决：<code>export JAVA_TOOL_OPTIONS=-Dfile.encoding=UTF-8</code>。</p>
<p>在 Android Studio 里面，可以通过选择对应的class文件，右击 -&gt; “Android tools” -&gt; “javah”生成头文件；</p>
</blockquote>
<p>这个<code>.h</code>文件内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Header for class com_footprint_littleshell_TestActivity */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _Included_com_footprint_littleshell_TestActivity</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Included_com_footprint_littleshell_TestActivity</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     com_footprint_littleshell_TestActivity</span></span><br><span class="line"><span class="comment"> * Method:    getMessage</span></span><br><span class="line"><span class="comment"> * Signature: ()Ljava/lang/String;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT jstring JNICALL Java_com_footprint_littleshell_TestActivity_getMessage</span><br><span class="line">  (JNIEnv *, jobject);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>在 Android 上，可以使用 NDK 来完成整个 JNI 的开发：</p>
<ol>
<li>右击 Module，选择”New” -&gt; “Folder” -&gt; “JNI Folder”。这样就会在对应的 Moudle 中与<code>java</code>同级目录处生成<code>jni</code>目录；</li>
<li>将刚刚生成的<code>.h</code>文件拷贝到这个目录下面；</li>
<li>在项目中的<code>local.properties</code>文件中配置 NDK 的位置，比如在我的电脑上，就需要增加如下一行:<code>ndk.dir=/Users/xxx/Documents/xxxx/Software/NDK/android-ndk-r10d</code>；</li>
</ol>
<p>完成以上步骤之后，在<code>jni</code>目录下面新建一个<code>.c</code>文件实现以上的<code>.h</code>文件，名字随意，比如<code>test_jni.c</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;jni.h&gt;</span><br><span class="line">#include "com_footprint_littleshell_TestActivity.h"</span><br><span class="line"></span><br><span class="line">JNIEXPORT jstring JNICALL Java_com_footprint_littleshell_TestActivity_getMessage</span><br><span class="line">  (JNIEnv *env, jobject obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (*env)-&gt;NewStringUTF(env, <span class="string">"Hello World! It's JNI"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：文件不要写成<code>cpp</code>文件，否则会发生错误，具体可以见<a href="http://stackoverflow.com/questions/15764948/error-base-operand-of-has-non-pointer-type-jnienv" target="_blank" rel="noopener">error: base operand of ‘-&gt;’ has non-pointer type ‘JNIEnv’</a>。</p>
</blockquote>
<p>之后，我们在该模块的<code>build.gradle</code>中进行 ndk 的配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">defaultConfig &#123;</span><br><span class="line">	applicationId <span class="string">"com.footprint.littleshell"</span></span><br><span class="line">	minSdkVersion <span class="number">14</span></span><br><span class="line">	targetSdkVersion <span class="number">22</span></span><br><span class="line">	versionCode <span class="number">1</span></span><br><span class="line">	versionName <span class="string">"1.0"</span></span><br><span class="line"></span><br><span class="line">	ndk&#123;</span><br><span class="line">		moduleName <span class="string">"test_jni"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，这里配置 moduleName 为”test_jni”——最后生成的<code>.so</code>分享库的名字，实际会在前面加上 lib ，后面加上 .so，即最终生成<code>libtest_jni.so</code>库。</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/Android-NDK.png" height="360" alt="Android-NDK"></div>

<p>如图，在上面方框的文件夹中就生成了对应的<code>.so</code>库，在与<code>java</code>同级的目录中建立 jniLibs 目录，把上面方框 lib 目录下面的文件夹全部拷贝过来(实际开发中以支持的CPU架构为标准)，这样，就完成了<code>.so</code>库的开发，在 Java 代码里面，加上如下代码即可使用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">	System.loadLibrary(<span class="string">"test_jni"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/jni-demo.png" height="320" alt="JNI demo"></div>

<blockquote>
<p>关于使用 Android Studio 进行 NDK 开发，也可以参考<a href="http://www.race604.com/android-studio-with-ndk/" target="_blank" rel="noopener">Android Studio中NDK开发</a>这篇文章。从例子看，还是很方便的。</p>
</blockquote>
<h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>生成的<code>.h</code>函数中有一个方法: <code>JNIEXPORT jstring JNICALL Java_com_footprint_littleshell_TestActivity_getMessage
  (JNIEnv *, jobject);</code>。这个方法是怎么来的呢？</p>
<p>首先是方法名：这个名字看着很眼熟：它是在 Java 声明的 native 方法名字前面加上了方法所在类的全限定名，并将包分隔符<code>.</code>换成<code>_</code>，最后在前面加上<code>Java_</code>来表示的，读者可以多写几个函数，就会发现这是一个普遍规律。</p>
<p>传进来的两个参数代表什么呢？</p>
<ol>
<li><code>JNIEnv *</code> 这代表一个 Java 虚拟机(JVM)所运行的环境，从它可以访问到 JVM 内部的各种对象；</li>
<li><code>jobject</code> 调用该函数的对象，例子中所指的就是<code>TestActivity</code>；</li>
</ol>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>本章说明说提到的三本书都有关于 JNI 的介绍。</p>
<h4 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h4><p>从前面的例子中可以看出，我们在 Java 中调用 native 方法<code>getMessage()</code>时，实际是被映射到了<code>Java_com_footprint_littleshell_TestActivity_getMessage</code>上，那么这种映射关系是如何建立的呢？</p>
<p>前面描述了<code>javah</code>命令生成的 native 函数名称的由来，这其实是一种规范，这种映射关系的建立称为静态映射：在<code>.h</code>文件生成时，就按照一定的规则生成本地方法名称，从而JVM也能根据这种规则在 Java 调用 native 函数时，找到对应的本地方法。</p>
<p>这种方式产生的 native 方法名字很长，不便于管理，因此 JNI 还可以进行动态注册——开发者可以任意命名 native 函数名称。</p>
<h4 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h4><p>静态注册生成的native函数名字冗长，自己去写太麻烦，而如果直接从 class 文件生成，则每一个 class 文件都要执行<code>javah</code>命令（虽然可能不是很多），这里提供另外一种选择：动态注册。使用这种技术，我们可以任意命名 native 函数名，手动建立 native 函数到 Java 函数的映射关系。</p>
<p>先来看看如何实现动态注册：大致做法和前面一致，只是不再需要执行<code>javah</code>命令生成头文件，在<code>jni</code>目录下面，我们只需要建立一个 test_jni.c 文件，其内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：这个方法一定要声明在gMethods之前，否则会报找不到方法的错误</span></span><br><span class="line"><span class="function">JNIEXPORT jstring  JNICALL <span class="title">getMessageNative</span><span class="params">(JNIEnv *env, jobject obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (*env)-&gt;NewStringUTF(env, <span class="string">"Hello World! It's JNI"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> JNINativeMethod gMethods[] = &#123;</span><br><span class="line">        &#123;<span class="string">"getMessage"</span>,  <span class="string">"()Ljava/lang/String;"</span>,  (<span class="keyword">void</span>*) getMessageNative&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM* vm, <span class="keyword">void</span> *reserved)</span> <span class="comment">//这是JNI_OnLoad的声明，必须按照这样的方式声明</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//注册时在JNIEnv中实现的，所以必须首先获取它</span></span><br><span class="line">	JNIEnv* env = <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//从JavaVM获取JNIEnv，一般使用1.4的版本</span></span><br><span class="line">	<span class="keyword">if</span>((*vm)-&gt;GetEnv(vm, (<span class="keyword">void</span>**)&amp;env, JNI_VERSION_1_4) != JNI_OK) </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	jclass clazz;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> clsName=<span class="string">"com/footprint/littleshell/TestActivity"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//这里可以找到要注册的类，前提是这个类已经加载到java虚拟机中。 这里说明，动态库和有native方法的类之间，没有任何对应关系。</span></span><br><span class="line">	clazz = (*env)-&gt;FindClass(env, clsName); </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(clazz == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"cannot get class:%s\n"</span>, clsName);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//这里就是关键了，把本地函数和一个java类方法关联起来。不管之前是否关联过，一律把之前的替换掉！</span></span><br><span class="line">	<span class="keyword">if</span>((*env)-&gt;RegisterNatives(env, clazz, gMethods, <span class="keyword">sizeof</span>(gMethods)/<span class="keyword">sizeof</span>(gMethods[<span class="number">0</span>]))!= JNI_OK)  &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"register native method failed!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> JNI_VERSION_1_4; <span class="comment">//必须返回版本，否则加载会失败。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置好 gradle（参见上面），build 工程，拷贝生成的<code>.so</code>文件，运行即可。下面我们来重点解析这个 c 文件的内容。</p>
<blockquote>
<p>PS: 例子内容以及注释来自<a href="http://blog.csdn.net/imyfriend/article/details/9117917" target="_blank" rel="noopener">Java JNI_OnLoad的妙用</a>。</p>
</blockquote>
<p>动态注册基于以下内容实现：</p>
<ol>
<li>当 Java 层通过<code>System.loadLibrary()</code>加载完JNI动态库后，紧接着会查找该库中一个叫<code>JNI_OnLoad()</code>的函数，如果有，就调用它，因此我们可以在这个方法里面进行一些预备工作，比如：静态注册（也可以手动暴露一个 init 方法出来，在加载完成之后手动调用）</li>
<li>Java 函数到 native 函数的映射可以由数据结构<code>JNINativeMethod</code>来表示。</li>
</ol>
<p><code>JNINativeMethod</code>结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">   	<span class="comment">//Java中native函数的名字，不用携带包的路径。例如“native_init“。</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* name;</span><br><span class="line">	<span class="comment">//Java函数的签名信息，用字符串表示，是参数类型和返回值类型的组合。</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* signature;</span><br><span class="line">	<span class="comment">//JNI层对应函数的函数指针，注意它是void*类型。</span></span><br><span class="line">	<span class="keyword">void</span>*  fnPtr;</span><br><span class="line">&#125; JNINativeMethod;</span><br></pre></td></tr></table></figure>
<p>这个结构的三个字段的含义都已经注释清楚，根据例子我们再解释一下：</p>
<ol>
<li><code>const char* name;</code> 在我们的例子中就是<code>getMessage</code>；</li>
<li><code>const char* signature;</code> 这个是 Java 函数的签名信息，如果要全面了解，建议读者可以去阅读《Java 虚拟机规范》，因为我们的 class 文件也使用同样的数据结构来描述一个方法，规范中有详细说明；</li>
<li><code>void*  fnPtr;</code> 指向本地方法的函数指针，把 fnPtr 换成 native 函数名称就好，这个名字不需要再遵循静态注册的规范；</li>
</ol>
<p>从这个关系就可以看出是要从 Java 的哪个函数映射到 native 的哪个函数。之后的事情很简单：<strong>通过 JNIEnv 的<code>RegisterNatives</code>方法告诉 JVM 虚拟机我要给某个类（通过类名指定）注册哪些函数映射（通过 JNINativeMethod 数组表示）。</strong></p>
<p>比对示例代码应该很好理解。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JNI学习重点：</p>
<ol>
<li>加载库——两种方法 &amp; 它们的区别；</li>
<li>方法映射——方法定义方式，方法映射方式；</li>
<li>数据类型映射——重点是字符串和数组；</li>
<li>反向调用——C++层调用Java层方法和属性，调用方法包括调用实例方法、静态方法、构造方法、父类方法等；</li>
<li>引用类型和管理——局部引用，全局引用，全局弱引用三种；</li>
<li>异常处理;</li>
</ol>
<p>这里推荐一个博客系列: <a href="http://blog.csdn.net/xyang81/article/category/2759987" target="_blank" rel="noopener">CSDN@xyang0917——JNI</a>。博客讲述比较全，而且有比较详细的例子，对于入门 &amp; 熟悉JNI有很大的帮助。当然最全面的教程还是在官网: <a href="https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/design.html" target="_blank" rel="noopener">JNI Interface Functions and Pointers</a>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android Framework学习预备]]></title>
      <url>http://www.timebridge.space/2016/05/14/Android-Framewok-Base/</url>
      <content type="html"><![CDATA[<p><img src="http://7xktd8.com1.z0.glb.clouddn.com/Android-Arc.png" alt="Android架构图"></p>
<blockquote>
<p>从<a href="http://www.webtag123.com/android/index.html" target="_blank" rel="noopener">这里</a>找到的这幅图，侵删。</p>
</blockquote>
<p>如上图，是Android系统的整体架构图，开发者日常主要是基于<strong>Application Framework</strong>提供的接口进行应用开发。<a id="more"></a></p>
<p>本章要研究的内容集中于<strong>Application Framework</strong>，也会涉及到一些<strong>Libraries</strong>的内容。参考资料:</p>
<h4 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h4><ol>
<li>《深入理解Android卷I》(邓凡平著)；</li>
<li>《Android技术内幕(系统卷)》（杨丰盛著）；</li>
<li>《Android内核剖析》（柯元旦著）；</li>
<li><a href="http://my.csdn.net/Luoshengyang" target="_blank" rel="noopener">老罗的CSDN博客</a>；</li>
</ol>
<h4 id="辅助参考"><a href="#辅助参考" class="headerlink" title="辅助参考"></a>辅助参考</h4><ol>
<li>《Linux程序设计（第4版）》（Neil Matthew &amp; Richard Stones著，陈健 &amp; 宋健建译）</li>
</ol>
<blockquote>
<p>邓凡平的CSDN博客在<a href="http://blog.csdn.net/innost" target="_blank" rel="noopener">这里</a>，同时这里也有《深入理解Android》卷I至卷III的全部内容，良心博客！</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Proguard]]></title>
      <url>http://www.timebridge.space/2016/05/12/Android-proguard/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>Proguard</strong> 主要提供以下功能：</p>
<ol>
<li>创建更加紧凑的代码，让最终的代码更加小巧，可以更快的在网络上传输、加载，运行时可以消耗更小的内存；</li>
<li>混淆代码，使得程序逆向工程起来更加困难；</li>
<li>列出无用的代码，以便于可以移除它们；</li>
<li>重新定位以及校验 Java 6 以及以上版本的 class 文件：添加预校验信息到class文件中去，减轻 ClassLoader 的校验负担——详细解释可见<a href="http://proguard.sourceforge.net/FAQ.html#preverification" target="_blank" rel="noopener">What is preverification?</a>；</li>
</ol>
<a id="more"></a><strong>Proguard</strong> 执行起来的速度非常快，效果显著，并且在 Ant、Gradle 等工具上已有插件实现。通过简单的模板化的配置加上简单的命令行选项，通常就足够对我们的代码做出出色的优化。<br><br>&gt;1. 具体的优化结果可以查看<a href="http://proguard.sourceforge.net/results.html" target="_blank" rel="noopener">这里</a>；<br>&gt;2. 通过删除无用的代码(包括优化库文件)以及将变量名类名简化，可以大幅度减小包的体积；<br>&gt;3. Proguard 专门为 Android 定制了一个优化和混淆版本: <strong>DexGuard</strong>。它专注于 App 的保护，另外提供诸如资源混淆、字符串加密、类加密、dex切分等功能。它直接创建 Dalvik 字节码。<br><br><strong>Proguard</strong>对代码的处理过程如下:<br><br><img src="http://7xktd8.com1.z0.glb.clouddn.com/Proguard优化过程.png" alt="Proguard优化过程"><br>如图所示，<strong>Proguard</strong> 读取 Input jars，经过一系列处理，最终得到一个 Output jars。优化过程是可以多次进行的。<br><br>Proguard 要求指明 Input jars 的 Library jars —— 它们是你用来编译代码的库文件。库文件始终保持不变。<br><br>### Entry points<br>为了确定哪些代码应该被保留，哪些应该被丢弃或者混淆，开发者应该为代码指定若干<strong><code>entry points</code></strong>。这些 entry points 通常是拥有 main 方法的类，或者是 applet，midlets，activities 等等。<br><br>1. 在压缩阶段，<strong>Proguard</strong> 从这些 entry points 出发，查找确认哪些类和变量是被使用的，所有其余的类以及变量都会被丢弃；<br>2. 在优化阶段，<strong>Proguard</strong> 进一步优化代码，那些不是 entry points 的类和方法可以被设置成 private、final 或者 static 的，没有被用到的参数会被移除，一些方法也会被内联；<br>3. 在混淆阶段，<strong>Proguard</strong> 重命名那些非 entry points 的类和成员变量，在整个过程中，都会保持它们的名字不变；<br>4. 预验证阶段是唯一一个不需要知道 entry points 的阶段；<br><br>### 反射<br>自动处理代码在面对反射和自省时都会出现一些问题。在使用<strong>Proguard</strong> 的时候，那些会被动态调用（即通过名字调用）的类和变量都应该被标记为 entry points。举个🌰 ：<code>Class.forName()</code>可能会指向任何的运行时的类，不太可能知道哪些类应该保持原来的名字以供这个方法调用（类名可能来源于任何地方）。因此开发者就必须在配置文件中通过<code>-keep</code>指定这个类。<br><br>但是，<strong>Proguard</strong>会自动探测并处理以下情况：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下类名或者变量名都是通过字符串写死，而不是一个随时可以改变的变量</span></span><br><span class="line">Class.forName(<span class="string">"SomeClass"</span>)</span><br><span class="line">SomeClass.class</span><br><span class="line">SomeClass.class.getField(<span class="string">"someField"</span>)</span><br><span class="line">SomeClass.class.getDeclaredField(<span class="string">"someField"</span>)</span><br><span class="line">SomeClass.class.getMethod(<span class="string">"someMethod"</span>, <span class="keyword">new</span> Class[] &#123;&#125;)</span><br><span class="line">SomeClass.class.getMethod(<span class="string">"someMethod"</span>, <span class="keyword">new</span> Class[] &#123; A.class &#125;)</span><br><span class="line">SomeClass.class.getMethod(<span class="string">"someMethod"</span>, <span class="keyword">new</span> Class[] &#123; A.class, B.class &#125;)</span><br><span class="line">SomeClass.class.getDeclaredMethod(<span class="string">"someMethod"</span>, <span class="keyword">new</span> Class[] &#123;&#125;)</span><br><span class="line">SomeClass.class.getDeclaredMethod(<span class="string">"someMethod"</span>, <span class="keyword">new</span> Class[] &#123; A.class &#125;)</span><br><span class="line">SomeClass.class.getDeclaredMethod(<span class="string">"someMethod"</span>, <span class="keyword">new</span> Class[] &#123; A.class, B.class &#125;)</span><br><span class="line">AtomicIntegerFieldUpdater.newUpdater(SomeClass.class, <span class="string">"someField"</span>)</span><br><span class="line">AtomicLongFieldUpdater.newUpdater(SomeClass.class, <span class="string">"someField"</span>)</span><br><span class="line">AtomicReferenceFieldUpdater.newUpdater(SomeClass.class, SomeType.class, <span class="string">"someField"</span>)</span><br></pre></td></tr></table></figure>
<p>类名或者变量的名字当然可能不同，但是这种构建模式<strong>Proguard</strong>是可以识别的，因此通过以上方式引用的类以及变量在压缩阶段会被保留，而String参数(指的是这些方法的参数)会在混淆阶段被替换。</p>
<blockquote>
<p>即<strong>Proguard</strong>会识别一些模式下对类和变量的引用，并机智的判断出哪些类和变量需要保留或者替换。</p>
</blockquote>
<p>另外，<strong>Proguard</strong>会对保留哪些类是有必要的给出意见。举个🌰：<strong>Proguard</strong>会注意到如下的构建过程:<code>(SomeClass)Class.forName(variable).newInstance()</code>，这有可能意味着<code>SomeClass</code>这个类/接口以及它的实现都应该被保留（注意，这里并不属于前面说到的<strong>Proguard</strong>可以自动识别的模式）。</p>
<blockquote>
<p>带有反射的代码还是要多加小心。</p>
</blockquote>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>使用<strong>Proguard</strong>通常需要一个配置文件，针对以上每一个步骤，<strong>Proguard</strong>都提供了丰富的配置项，具体的配置选项<a href="http://proguard.sourceforge.net/manual/usage.html" target="_blank" rel="noopener">这里</a>可以查询，同时也有很多<a href="http://proguard.sourceforge.net/manual/examples.html" target="_blank" rel="noopener">例子</a>可以参考。另外<strong>Proguard</strong>还有一个GUI组件可以使用，<a href="http://proguard.sourceforge.net/manual/gui.html" target="_blank" rel="noopener">这里</a>可查看详细。</p>
<p>遇到问题可以在<a href="http://proguard.sourceforge.net/manual/troubleshooting.html" target="_blank" rel="noopener">官网的问题列表</a>里面搜索一下。</p>
<h4 id="关于keep"><a href="#关于keep" class="headerlink" title="关于keep"></a>关于keep</h4><p>keep选项，总共有以下几种:</p>
<table>
<thead>
<tr>
<th>Keep</th>
<th>From being removed or renamed</th>
<th>From being renamed</th>
</tr>
</thead>
<tbody>
<tr>
<td>Classes and class members</td>
<td>-keep</td>
<td>-keepnames</td>
</tr>
<tr>
<td>Class members only</td>
<td>-keepclassmembers</td>
<td>-keepclassmembernames</td>
</tr>
<tr>
<td>Classes and class members, if class members present</td>
<td>-keepclasseswithmembers</td>
<td>-keepclasseswithmembernames</td>
</tr>
</tbody>
</table>
<p>如果不确认使用哪一个命令，可以使用<code>-keep</code>：这会保证指定的类以及类成员不会在压缩阶段被移除掉，在混淆阶段不会被重命名。</p>
<blockquote>
<p>【注意！！】  </p>
<ol>
<li>如果指定了一个类而没有指定keep它的类成员，那么<strong>Proguard</strong>仅仅会保留类以及它的无参构造方法作为entry points，它仍然可能会移除、优化或者混淆它的类成员；</li>
<li>如果指定了一个方法，那么<strong>Proguard</strong>只会保留方法为entry points，它的代码仍然可能被优化或者修改；</li>
</ol>
</blockquote>
<h4 id="Class-Specifications"><a href="#Class-Specifications" class="headerlink" title="Class Specifications"></a>Class Specifications</h4><p><code>keep</code>后面肯定跟的是一个类或者类成员的描述符，从而表达<code>keep</code>应该应用在哪些地方。这个描述符是有规范的（或者称为模板），即Class Specifications。</p>
<p>它的格式如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">@annotationtype</span>] [[!]<span class="keyword">public</span>|<span class="keyword">final</span>|<span class="keyword">abstract</span>|@ ...] [!]<span class="class"><span class="keyword">interface</span>|<span class="title">class</span>|<span class="title">enum</span> <span class="title">classname</span></span></span><br><span class="line">    [extends|implements [@annotationtype] classname]</span><br><span class="line">[&#123;</span><br><span class="line">    [<span class="meta">@annotationtype</span>] [[!]<span class="keyword">public</span>|<span class="keyword">private</span>|<span class="keyword">protected</span>|<span class="keyword">static</span>|<span class="keyword">volatile</span>|<span class="keyword">transient</span> ...] &lt;fields&gt; |</span><br><span class="line">                                                                      (fieldtype fieldname);</span><br><span class="line">    [<span class="meta">@annotationtype</span>] [[!]<span class="keyword">public</span>|<span class="keyword">private</span>|<span class="keyword">protected</span>|<span class="keyword">static</span>|<span class="keyword">synchronized</span>|<span class="keyword">native</span>|<span class="keyword">abstract</span>|<span class="keyword">strictfp</span> ...] &lt;methods&gt; |</span><br><span class="line">                                                                                           &lt;init&gt;(argumenttype,...) |</span><br><span class="line">                                                                                           classname(argumenttype,...) |</span><br><span class="line">                                                                                           (<span class="function">returntype <span class="title">methodname</span><span class="params">(argumenttype,...)</span>)</span>;</span><br><span class="line">    [<span class="meta">@annotationtype</span>] [[!]<span class="keyword">public</span>|<span class="keyword">private</span>|<span class="keyword">protected</span>|<span class="keyword">static</span> ... ] *;</span><br><span class="line">    ...</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<p>格式里面涉及到一些符号，解释如下:</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>[]</td>
<td>可选</td>
</tr>
<tr>
<td>…</td>
<td>前面列出的选项可能以任意数量出现</td>
</tr>
<tr>
<td>\</td>
<td></td>
<td>隔离一组可选项</td>
</tr>
<tr>
<td>()</td>
<td>把某一块说明组合到一块</td>
</tr>
</tbody>
</table>
<p><code>class</code>关键字指向任何的接口或者类，<code>interface</code>只指向接口。<code>enum</code>只指向枚举类，<code>interface</code>或者<code>enmu</code>加上<code>!</code>表示非接口或者非类。</p>
<p>每一个类都必须以全限定名出现，比如<code>java.lang.String</code>，内部类则以<strong>$</strong>分割，比如<code>java.lang.Thread$State</code>，类名的表达可以带有正则描述:</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>?</td>
<td>匹配任何一个单一字符，但是不包括包名分割符，即<code>.</code>，比如<code>mypackage.Test?</code>匹配<code>mypackage.Test1</code>，但是不匹配<code>mypackage.Test12</code></td>
</tr>
<tr>
<td>*</td>
<td>匹配类名的任何一部分，但不包括包名分隔符，即<code>.</code>，比如<code>mypackage.*Test*</code>匹配<code>mypackage.Test</code>和<code>mypackage.YourTestApplication</code>，但是不匹配<code>mypackage.mysubpackage.MyTest</code>，或者更简单的说，<code>mypackage.*</code>匹配<code>mypackage</code>下面的所有类，但不包括子package下面的类</td>
</tr>
<tr>
<td>**</td>
<td>匹配类名的任何一个部分，可以包含任何数量的包名分隔符，即<code>.</code>，比如<code>**.Test</code>匹配除了根包下面的所有的包中的<code>Test</code>类，<code>mypackage.**</code>匹配<code>mypackage</code>包以及子包下面的所有类。</td>
</tr>
</tbody>
</table>
<p>另外，单独的<code>*</code>可以表示任何类。</p>
<p><code>extends</code>和<code>implements</code>通常用于限定类，目前它们是等效的，用于表述只有继承/实现某个类/接口的类，但是这个接口/类本身不在这个描述以内。</p>
<p><code>@</code>描述符用于限定哪些使用特定的注解描述的类/类成员，<code>annotationtype</code>的描述和类名一致。</p>
<p>变量和方法的描述和Java中的很像，除了方法的参数列表不包括参数名（类似于Java Doc中的表述），描述符中可以包含以下通配符：</p>
<ol>
<li><strong><code>&lt;init&gt;</code></strong> 匹配任何一个构造函数；</li>
<li><strong><code>&lt;fields&gt;</code></strong> 匹配任何一个变量；</li>
<li><strong><code>&lt;methods&gt;</code></strong> 匹配任何的方法；</li>
<li><strong><code>*</code></strong> 匹配任何的变量和方法； </li>
</ol>
<p>以上这些描述不包含任何的返回值，只有<code>&lt;init&gt;</code>有一个参数列表。变量和方法名字可以使用正则表达式，可以包含<code>?</code>和<code>*</code>，含义和前面一致，描述符中的类型也可以包含以下通配符：</p>
<ol>
<li><strong><code>%</code></strong> 匹配任何一个原始类型（boolean、int等，但是不包括void）；</li>
<li><strong><code>?</code></strong> 在类（比如参数、返回值）名中匹配任何一个字符；</li>
<li><strong><code>*</code></strong> 也是用于类名，和前面类名的描述中关于<code>*</code>的描述一致；</li>
<li><strong><code>**</code></strong> 也是用于类名，和前面类名的描述中关于<code>**</code>的描述一致；</li>
<li><strong><code>***</code></strong> 匹配任何类型：原始类型、非原始类型、数组等；</li>
<li><strong><code>···</code></strong> 匹配任何数量的任何类型参数；</li>
</ol>
<p>要注意: <code>?</code>、<code>*</code>和<code>**</code>永远不会匹配原始类型，只有<code>***</code>可以匹配上任何维度的数组。举个例子：<code>** get*()</code>匹配<code>java.lang.Object getObject()</code>，但是不会匹配<code>float getFloat()</code>或者<code>java.lang.Object[] getObjects()</code>。</p>
<p>构造函数是可以直接只用类名或者全限定类名进行描述的，因为在Java中，构造函数有参数列表，却没有返回值。</p>
<p>类和变量访问控制符通常是用来给更严格的限制通配符——类和变量必须有一致的访问控制符，同样，也可以使用<code>!</code>来表示不能设置这样的访问控制符。</p>
<p>Proguard甚至支持只有编译器才可以设置的控制符：<code>synthetic</code>，<code>bridge</code>和<code>varargs</code>。</p>
<blockquote>
<p>【注】以上翻译自<a href="http://proguard.sourceforge.net/manual/usage.html" target="_blank" rel="noopener">官网Usage</a>。如有错误，欢迎指出。</p>
</blockquote>
<h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><p>在Android上，可以使用如下方式启用<strong>Proguard</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="keyword">true</span></span><br><span class="line">            shrinkResources <span class="keyword">true</span></span><br><span class="line">            <span class="function">proguardFiles <span class="title">getDefaultProguardFile</span><span class="params">(‘proguard-android.txt<span class="string">'),</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">                    '</span>proguard-rules.pro<span class="string">'</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">        &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">    &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">    ...</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">&#125;</span></span></span></span><br></pre></td></tr></table></figure>
<p>通过<code>minifyEnabled</code>的设置，可以对代码进行压缩优化；通过<code>shrinkResources</code>的设置，可以对代码进行资源优化；<code>proguardFiles</code>设置则用于提供压缩规则：</p>
<ol>
<li><code>getDefaultProguardFile(‘proguard-android.txt&#39;)</code>方法会从Android SDK下的<code>tools/proguard/</code>目录读取<strong>Proguard</strong>的默认配置，在这个目录下面还有一个文件<code>proguard-android-optimize.txt</code>，它不仅包含相同的规则，而且会在字节码层级对APK进行分析，进一步优化APK文件，可以尝试；</li>
<li><code>proguard-rules.pro</code>文件是开发者自定义规则的地方，该文件默认与<code>build.gradle</code>文件同级；</li>
</ol>
<p>资源优化在代码压缩之后，因为只有移除不需要的代码之后才可以判断哪些资源无用。</p>
<blockquote>
<p>目前资源优化对于<code>values/</code>文件夹下面的资源不做移除，因为AAPT（Android Asset Packaging Tool）不允许。</p>
</blockquote>
<p>以下这种方式可以为某种特殊的build variant添加新的混淆规则：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="keyword">true</span></span><br><span class="line">            <span class="function">proguardFiles <span class="title">getDefaultProguardFile</span><span class="params">(<span class="string">'proguard-android.txt'</span>)</span>,</span></span><br><span class="line"><span class="function">                   'proguard-rules.pro'</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    productFlavors </span>&#123;</span><br><span class="line">        flavor1 &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        flavor2 &#123;</span><br><span class="line">            proguardFile <span class="string">'flavor2-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Build Type  + Product Flavor = Build Variant</p>
<p>注意，这里在flavor2中设置的配置文件与buildTypes中的是追加关系，不是替代关系。</p>
</blockquote>
<h3 id="输出文件"><a href="#输出文件" class="headerlink" title="输出文件"></a>输出文件</h3><p>混淆后，会在<code>&lt;module-name&gt;/build/outputs/mapping/release/</code>目录下输出下面的文件：</p>
<ol>
<li><strong>dump.txt</strong> 描述apk文件中所有类文件间的内部结构；</li>
<li><strong>mapping.txt</strong> 提供了原始的类，方法，和字段名与混淆后代码之间的映射；</li>
<li><strong>seeds.txt</strong> 列出了未被混淆的类和成员；</li>
<li><strong>usage.txt</strong> 列出了从apk中删除的代码；</li>
</ol>
<h3 id="定义代码保留"><a href="#定义代码保留" class="headerlink" title="定义代码保留"></a>定义代码保留</h3><p>某些情况下，使用默认的<strong>Proguard</strong>配置文件<code>proguard-android.txt</code>就足够了，<strong>Proguard</strong>仅仅会移除所有的未使用代码，但是有些情况<strong>Proguard</strong>很难判断，可能会移除一些不该被移除的代码，比如:</p>
<ol>
<li>一个仅仅在<code>AndroidManifest.xml</code>文件中使用的类；</li>
<li>从JNI调用的方法；</li>
<li>运行时操作的代码（比如反射和自省）；</li>
</ol>
<p>这部分代码需要特别注意，可以使用以上提到的输出文件辅助排查。可以使用一下配置语句进行代码保留:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-keep <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br></pre></td></tr></table></figure>
<p>还有一种办法就是使用<code>@Keep</code>注解，在类上使用这个注解，整个类都会保持原样，在方法/变量上使用该注解，则被注解的方法/变量以及它们的所在类都会保持原封不动，不过这个使用这个注解需要添加<code>Annotations Support Library</code>依赖。</p>
<p>关于资源的优化，<a href="http://developer.android.com/intl/zh-cn/tools/help/proguard.html" target="_blank" rel="noopener">官网</a>上有比较详细的描述，比较复杂，这里不整理了。同代码一样，也可以对资源进行保留，但是对于重复的资源、多语言资源、通过Id引用的资源都有可选的配置。</p>
<p>下面给出一个配置例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">-injars      bin/classes</span><br><span class="line">-injars      libs</span><br><span class="line">-outjars     bin/classes-processed.jar</span><br><span class="line">-libraryjars /usr/local/java/android-sdk/platforms/android-<span class="number">9</span>/android.jar</span><br><span class="line"></span><br><span class="line">-dontpreverify</span><br><span class="line">-repackageclasses <span class="string">''</span></span><br><span class="line">-allowaccessmodification</span><br><span class="line">-optimizations !code/simplification/arithmetic</span><br><span class="line">-keepattributes *Annotation*</span><br><span class="line"></span><br><span class="line">-keep <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> * <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">app</span>.<span class="title">Activity</span></span></span><br><span class="line"><span class="class">-<span class="title">keep</span> <span class="title">public</span> <span class="title">class</span> * <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">app</span>.<span class="title">Application</span></span></span><br><span class="line"><span class="class">-<span class="title">keep</span> <span class="title">public</span> <span class="title">class</span> * <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">app</span>.<span class="title">Service</span></span></span><br><span class="line"><span class="class">-<span class="title">keep</span> <span class="title">public</span> <span class="title">class</span> * <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">content</span>.<span class="title">BroadcastReceiver</span></span></span><br><span class="line"><span class="class">-<span class="title">keep</span> <span class="title">public</span> <span class="title">class</span> * <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">content</span>.<span class="title">ContentProvider</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">-<span class="title">keep</span> <span class="title">public</span> <span class="title">class</span> * <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">view</span>.<span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;init&gt;(android.content.Context);</span><br><span class="line">    <span class="keyword">public</span> &lt;init&gt;(android.content.Context, android.util.AttributeSet);</span><br><span class="line">    <span class="keyword">public</span> &lt;init&gt;(android.content.Context, android.util.AttributeSet, <span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> set*(...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-keepclasseswithmembers <span class="class"><span class="keyword">class</span> * </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;init&gt;(android.content.Context, android.util.AttributeSet);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-keepclasseswithmembers <span class="class"><span class="keyword">class</span> * </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;init&gt;(android.content.Context, android.util.AttributeSet, <span class="keyword">int</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-keepclassmembers <span class="class"><span class="keyword">class</span> * <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">content</span>.<span class="title">Context</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> *(android.view.View);</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> *(android.view.MenuItem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-keepclassmembers <span class="class"><span class="keyword">class</span> * <span class="keyword">implements</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ** CREATOR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-keepclassmembers <span class="class"><span class="keyword">class</span> **.<span class="title">R</span>$* </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;fields&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-keepclassmembers <span class="class"><span class="keyword">class</span> * </span>&#123;</span><br><span class="line">    <span class="meta">@android</span>.webkit.JavascriptInterface &lt;methods&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="反混淆"><a href="#反混淆" class="headerlink" title="反混淆"></a>反混淆</h3><p>对于打印出的Crash Log等信息，因为被混淆的原因，导致这些信息阅读起来非常困难。因此我们需要一个工具<strong>翻译</strong>一下这些信息，可以使用如下命令进行:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retrace.bat|retrace.sh [-verbose] mapping.txt [&lt;stacktrace_file&gt;]</span><br></pre></td></tr></table></figure>
<p><code>retrace</code>是一个工具，位于<code>&lt;sdk-root&gt;/tools/proguard/</code>目录下面(在Windows上是<code>retrace.bat</code>，在Mac/Linux上是<code>retrace.sh</code>。)。</p>
<p><a href="http://proguard.sourceforge.net/" target="_blank" rel="noopener">官网</a>也有相关的文档，点击Retrace Manual下面的三个Tab就可以看到介绍、使用方式以及例子。</p>
<blockquote>
<p>Google Play自动在支持反混淆，可见<a href="https://support.google.com/googleplay/android-developer/answer/6295281" target="_blank" rel="noopener">帮助中心</a>。</p>
</blockquote>
<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>使用<strong>Proguard</strong>的时候，需要注意一些技术问题，它们都很容易规避或者解决:</p>
<ol>
<li><strong>Proguard</strong>的优化算法会假设被处理的代码不会故意抛出NPE/ArrayIndexOutOfBoundsExceptions/OutOfMemoryErrors/StackOverflowErrors来达到某个目的。举个例子，如果<code>myObject.myMethod()</code>这样的方法调用完全无效，它可能会移除它，它忽略<code>myObject</code>是null的可能性（也即：忽略开发者通过这种方式抛出NPE错误的意图）。某些时候这是一件好事，优化后的代码会抛出更少的异常。但如果这个假设是错误的，开发者应该使用<code>-dontoptimize</code>关闭优化功能；</li>
<li><strong>Proguard</strong>的优化算法也会假设被处理的代码不会有<code>busy-waiting loops without at least testing on a volatile field</code>(翻译不好，大概是说通过一个无限循环去检测一个非volatile变量)，因此它也会移除此类代码。如果这项假设是错误的，开发者应该使用<code>-dontoptimize</code>关闭优化功能；</li>
<li>如果Input jars和Library jars在有class在同一个包下面，则混淆后的Output jars有可能会包含一些与Library jars同名的类文件，尤其当Library jars之前就被混淆过。因此Input jars和Library jars不应该共享一个包；</li>
</ol>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>具体见<a href="http://proguard.sourceforge.net/FAQ.html" target="_blank" rel="noopener">官网</a>。这里整理几个重要的结论：</p>
<ol>
<li><strong>Proguard</strong>会自动处理<code>Class.forName(&quot;SomeClass&quot;)</code>和<code>SomeClass.class</code>的处理情况，在压缩阶段，这些类会被保留，在混淆阶段，这些类也会被替换掉；</li>
<li>对于资源、String以及流程控制的混淆，直接看官网；</li>
<li><strong>Proguard</strong>支持增量式混淆——即提供一个之前的mapping文件进行一次新的混淆；</li>
<li><strong>Proguard</strong>允许自定义混淆字典；</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Systrace]]></title>
      <url>http://www.timebridge.space/2016/05/10/Android-Systrace/</url>
      <content type="html"><![CDATA[<p>当我们开发应用，我们会希望应用使用起来非常顺畅，刷新页面的时候始终可以达到60帧每秒的速度。但是如果因为某些原因导致丢帧，我们要做的第一步事情就是搞清楚系统到底在做什么。</p>
<blockquote>
<p>Systrace允许获取Android系统的信息，称为<strong>trace</strong>。它会展现时间以及CPU时间片被用到了哪里，在给定的时间内，每个进程和线程在做什么事情，它还会高亮有问题的trace信息，并给出修复意见。<a id="more"></a></p>
</blockquote>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p><img src="http://7xktd8.com1.z0.glb.clouddn.com/systrace_overview.png" alt="An example Systrace, showing 5 seconds of scrolling an app when it is not performing well."></p>
<p>上图展示了一个渲染起来并不顺畅的App所被捕捉到的trace信息，展示的信息组有Kernel、SurfaceFlinger（Android的compositor进程），然后是App进程（可以看到进程名），每一个App进程都包含所有它所含有的线程的trace信号。</p>
<p>关于如何产生一个trace文件，可以直接查看<a href="http://developer.android.com/intl/zh-cn/tools/performance/systrace/index.html" target="_blank" rel="noopener">官网</a>。这里有个<a href="http://7xktd8.com1.z0.glb.clouddn.com/trace.html" target="_blank" rel="noopener">示例文件</a>，可以下载。</p>
<h2 id="Analyzing-a-Trace"><a href="#Analyzing-a-Trace" class="headerlink" title="Analyzing a Trace"></a>Analyzing a Trace</h2><p><img src="http://7xktd8.com1.z0.glb.clouddn.com/trace视图.png" alt="Trace文件视图"></p>
<p>当产生trace文件之后，就可以使用浏览器打开html文件了。</p>
<blockquote>
<p>实际使用chrome直接打开trace文件的时候，遇到如下错误: <code>Could not find an importer for the provided eventData.</code>。解决方案是:</p>
<ol>
<li>在chrome中打开链接<code>chrome://tracing</code>;</li>
<li>在打开的页面的左上角有一个Load按钮(见图中<code>A</code>处)，点击选择trace文件，打开即可；</li>
</ol>
<p>另外，看图的时候记住一句话： A well-behaved application executes many small operations quickly and with a regular rhythm, with individual operations completing within few milliseconds, depending on the device and the processes being performed。</p>
</blockquote>
<p>每一个渲染帧的App都会展现一行frame圆圈（见<code>C</code>处）——通常是绿色的，如果圆圈是黄色或者红色的，那就表明这一帧超过了16.6ms的帧渲染时间限制。放大视图就可以看清楚哪些影响App顺滑的帧了（见<code>D</code>处）。</p>
<blockquote>
<p><a href="http://developer.android.com/intl/zh-cn/tools/help/systrace.html" target="_blank" rel="noopener">官网</a>上列出了关于该工具的一些命令行和快捷键。</p>
</blockquote>
<p>点击某一个frame圆圈，这个圆圈就会被高亮，从而聚焦到绘制这一帧的时候所做的工作上。在运行着5.0以及更高版本系统的设备上，工作呗分为UI线程和Reader线程，在之前的版本上，创建帧的所有工作都是在UI线程上执行的。</p>
<p>在这一帧上点击不同的部分（即<code>D</code>处不同的色块），可以查看它们耗时多少。选中frame圆圈或者某一个部分，在<code>E</code>处都可以看到相关的有用信息，即Alert。</p>
<h3 id="Investigating-Alerts"><a href="#Investigating-Alerts" class="headerlink" title="Investigating Alerts"></a>Investigating Alerts</h3><p>Systrace会对trace中的信息做一些自动分析，然后将存在的性能问题作为alert展示出来，从而为解决问题提供指导。</p>
<p>当选中某个存在问题的帧之后，alert就可能在<code>E</code>处展现：如果是UI线程符合太重，就可以使用<a href="http://www.muzileecoding.com/androidoptimize/Android-traceview.html" target="_blank" rel="noopener">TraceView</a>来诊断具体是什么导致的问题。</p>
<p>在整个面板的右侧，还有一个Alert Tab，你可以通过它查看trace文件信息中的所有的Alert以及它的数量。如下:<br><img src="http://7xktd8.com1.z0.glb.clouddn.com/帧问题诊断.png" alt="帧问题诊断"><br>下面的红框展现了我所选当前问题帧暴露出来的三个Alert，而右侧红框则展现了当前trace文件中的所有alert的统计信息。</p>
<blockquote>
<p>这个非常有用，当操作比较集中时，可以很容易发现问题，配合TraceView可以比倨傲容易找出问题所在。官网建议把统计出来的问题当做Bug修掉。</p>
</blockquote>
<h2 id="Tracing-Application-Code"><a href="#Tracing-Application-Code" class="headerlink" title="Tracing Application Code"></a>Tracing Application Code</h2><p>framework定义的trace信号并不能全面展现app所做的所有事情，所以你可能需要添加你自己的信号，在Android4.3以及更高的版本上，开发者可以使用<code>Trace</code>类来给代码添加信号，这个技术可以帮助你观察任何时候App所做的工作。Trace开始和结束本身也会造成一定的影响。</p>
<p>下面是一个示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ProcessPeople</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Trace.beginSection(<span class="string">"ProcessPeople"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Trace.beginSection(<span class="string">"Processing Jane"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// code for Jane task...</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Trace.endSection(); <span class="comment">// ends "Processing Jane"</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Trace.beginSection(<span class="string">"Processing John"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// code for John task...</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Trace.endSection(); <span class="comment">// ends "Processing John"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.endSection(); <span class="comment">// ends "ProcessPeople"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>要注意: <code>beginSection()</code>和<code>endSection()</code>要成对出现。而且两个方法要在同一个线程出现。</p>
</blockquote>
<p>当使用App级别的trace，就必须要在用户UI或者命令行中使用<code>-a</code>/<code>--app=</code>指定包名。</p>
<p>当profile app的时候，最好打来app级别的trace功能，这样一些框架将通过trace提供一些非常重要的信息，比如<code>RecyclerView</code>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UI优化]]></title>
      <url>http://www.timebridge.space/2016/05/10/Android-ui-optimize/</url>
      <content type="html"><![CDATA[<h2 id="Overdraw-Debugger"><a href="#Overdraw-Debugger" class="headerlink" title="Overdraw Debugger"></a>Overdraw Debugger</h2><p>过度绘制的诊断可以直接使用手机的开发人员功能支持：</p>
<ol>
<li>打开设置——&gt;开发人员选项；</li>
<li>找到”Debug GPU Overdraw”；</li>
<li>点击该项，选择”Show ovedraw areas”；</li>
</ol>
<p>这个时候你的屏幕就变得五颜六色了：</p>
<ol>
<li>真实色彩：没有过度绘制；</li>
<li>蓝色：过度绘制一次；</li>
<li>绿色：过度绘制两次；</li>
<li>粉色：过度绘制三次；</li>
<li>红色：过度绘制四次以及以上；</li>
</ol>
<p>有些过度绘制是不可避免的，我们的目标就是尽量让我们的App展现真实色彩或者蓝色。<a id="more"></a></p>
<h2 id="Rendering-Profiler"><a href="#Rendering-Profiler" class="headerlink" title="Rendering Profiler"></a>Rendering Profiler</h2><p>Profile GPU Rendering使得开发者可以方便地知道系统是否正在以16ms每帧的速度绘制当前UI，并且可以查看是哪一个绘制的步骤超时。使用方式如下:</p>
<ol>
<li>打开设置——&gt;开发人员选项；</li>
<li>找到”Profile GPU Rendering”；</li>
<li>点击打开弹窗，选择”On screen as bars”；</li>
</ol>
<p>你的屏幕上底部就会出现彩色的线条:</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/gettingstarted_image002.png" height="320" alt="Screen when Profile GPU Rendering is on"></div>

<p>详细的含义如下:</p>
<p><div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/gettingstarted_image003.png" height="160" alt="Screen when Profile GPU Rendering is on"></div><br>绿色的横线代表16ms/帧的上限（所有的竖线都应该在这条线之下，超过这条线则可能意味着动画的卡顿），而每条竖线则包含着蓝色，紫色(只有4.0以及以上版本才有)，红色以及橙色，它们代表着一次绘制的几个过程</p>
<ol>
<li>蓝线代表用于创建/更新View的display list的时间，如果一根竖线的这部分很高，可能就意味着有很多的自定义View需要绘制，或者在<code>onDraw()</code>方法里面执行了太多的任务；</li>
<li>紫色(只有4.0以及以上版本才有)代表将资源传送到render线程所花费时间；</li>
<li>红色代表Android的2D render发送命令到OpenGL来绘制或者重绘display list所花费的时间，越多的display list意味着更高的红线；</li>
<li>橙色代表CPU等待GPU完成任务的时间，如果这段线很长，那就意味着App在GPU上做了太多的工作；</li>
</ol>
<blockquote>
<p>虽然这个工具叫做<code>Profile GPU Rendering</code>，但实际上监控的任务都在CPU上面，渲染是通过提交命令给GPU来实现的，GPU异步去渲染屏幕。在某些情况下，GPU有太多的任务需要去做，就需要CPU等待一段时间再去提交命令，当这种情况发生的时候，就可以看到很长的Process(橙色)和Execute(红色)线，命令的提交会阻塞，直到GPU命令队列里面有足够的空间容纳新的命令。</p>
</blockquote>
<p>优化通用手法：降低ViewTree层级。</p>
<h2 id="Hierarchy-Viewer"><a href="#Hierarchy-Viewer" class="headerlink" title="Hierarchy Viewer"></a>Hierarchy Viewer</h2><p>这个工具可以可视化App的View结构，并且标注每一个View的渲染速度。我们可以使用这个工具：</p>
<ol>
<li>降低层级，减少过度绘制；</li>
<li>找到潜在的渲染性能瓶颈；</li>
</ol>
<p>使用前提条件:</p>
<ol>
<li>必须使用真机来获得准确数据；</li>
<li>在机器上设置一个<code>ANDROID_HVPROTO</code>变量（<a href="http://developer.android.com/intl/zh-cn/tools/performance/hierarchy-viewer/setup.html" target="_blank" rel="noopener">配置文档</a>）；</li>
</ol>
<p>具体的过程参见<a href="http://developer.android.com/intl/zh-cn/tools/performance/hierarchy-viewer/profiling.html" target="_blank" rel="noopener">官网</a>。</p>
<p>每一个View都可以通过Profile产生三个小点，分别代表Draw、Layout、Execute三个过程。三个点都可以由三种颜色，绿色表示至少比其余一半的View快，黄色表示不是最慢的那一半View，红色表示是最慢的那一半View。</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>因为Hierarchy Viewer衡量的是相对性能，因此整个Tree中总是有红点，因此红色并不代表很慢。下面讲述一些处理红点View的办法:</p>
<ol>
<li>找到那些处于叶子节点或者拥有很少子View的ViewGroup，这类View很可能存在问题，使用Systrace或者TraceView可以获得更多信息；</li>
<li>如果一个ViewGroup带有很多的子View，并且显示红色，可以看一下子View的性能如何；</li>
<li>一个显示黄色甚至红色的View在设备上运行并不一定慢；</li>
<li>根View有一个红色的measure阶段，红色的layout阶段以及黄色的绘制阶段是很正常的；</li>
<li>如果一个叶子结点在一个有20个以上的View的Tree中显示红色，这很可能就意味着发生了问题，可以好好看一下<code>onDraw()</code>方法；</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Memory Profilers]]></title>
      <url>http://www.timebridge.space/2016/05/09/Android-Memory-Profilers/</url>
      <content type="html"><![CDATA[<p>关于内存，Android提供了三个工具：</p>
<ol>
<li>Memory Monitor: 可以找出是否有异常的GC操作导致性能问题； </li>
<li>Heap Viewer: 可以找出被意外分配或者内存泄露的对象；</li>
<li>Allocation Tracker: 找出存在内存问题的代码；</li>
</ol>
<p>现在Android Stuido的Android Monitor面板已经集成了这三个工具，比起使用Android Device Monitor来更加方便快捷。如下图:<a id="more"></a></p>
<p><img src="http://7xktd8.com1.z0.glb.clouddn.com/Android-Monitor.png" alt="Android Monitor"></p>
<blockquote>
<p>Android Monitor不仅可以查看内存分配，还可以查看CPU、GPU、Network活动。</p>
</blockquote>
<h2 id="Memory-Monitor"><a href="#Memory-Monitor" class="headerlink" title="Memory Monitor"></a>Memory Monitor</h2><p>这是一个很简单的工具，就在Android Studio的Android Monitor里面，也即上图中的<code>D</code>处。在<code>A</code>处选中设备，在<code>B</code>处选中进程，就可以在<code>D</code>处查看应用的内存使用情况。更详细的教程可以看<a href="http://developer.android.com/intl/zh-cn/tools/performance/memory-monitor/index.html" target="_blank" rel="noopener">官网文档</a>。</p>
<p>在<a href="http://www.csdn.net/article/2015-01-20/2823621-android-performance-patterns/2" target="_blank" rel="noopener">Android性能优化典范（一）</a>第九段中专门提到了一种内存现象，是可以从Memory Monitor中很容易看出来的——内存抖动：短时间发生了多次内存的涨跌。</p>
<h2 id="Heap-Viewer"><a href="#Heap-Viewer" class="headerlink" title="Heap Viewer"></a>Heap Viewer</h2><p>Heap Viewer展现了某一时刻内存分配的对象的快照，可以用于发现哪些对象发生了内存泄露。</p>
<p>在<a href="http://developer.android.com/intl/zh-cn/tools/performance/heap-viewer/index.html#WhatYouNeed" target="_blank" rel="noopener">官网</a>上是展示了该工具的使用步骤，简述如下：</p>
<ol>
<li>首先安装MAT(<a href="http://www.eclipse.org/mat/downloads.php" target="_blank" rel="noopener">下载地址</a>)；</li>
<li>在Android Studio中打开Android Device Monitor或者DDMS；</li>
<li>选择需要测试的进程；</li>
<li>在进程列表上方点击Update Heap按钮；</li>
<li>在右边的面板中选择Heap Tab；</li>
<li>点击Cause GC；</li>
<li>点击进程列表上方的Dump HPROF按钮，保存HPROF文件；</li>
<li>运行命令进行文件转换：<code>./hprof-conv path/file.hprof exitPath/heap-converted.hprof</code>（hprof-conv命令在sdk的platform-tools目录下面）</li>
<li>使用MAT打开这个文件；</li>
</ol>
<blockquote>
<p>翻译自: <a href="http://stackoverflow.com/questions/24547555/how-to-analyze-memory-using-android-studio" target="_blank" rel="noopener">How to analyze memory using android studio-StackOverFlow</a></p>
</blockquote>
<p>但是Android Studio 1.2.x已经将该功能集合到Android Monitor面板中了：<code>C</code>处有三个按钮，第一个按钮就可以触发GC操作，第二个按钮就是Dump Java Heap。生成的文件是上面第7步生成的文件，但是转换不需要进行第8步，如图:</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/hprof.png" height="160" alt="HPROF"></div>

<p>只需要点击Captures边栏，选中生成的原始hprof文件，右击选择”Export to standard .hprof”文件即可生成标准的hprof文件，然后在用MAT打开文件即可。</p>
<p>具体的分析过程可以参见:</p>
<ol>
<li><a href="http://wiki.eclipse.org/MemoryAnalyzer" target="_blank" rel="noopener">MemoryAnalyzer</a></li>
<li><a href="http://www.jianshu.com/p/d8e247b1e7b2" target="_blank" rel="noopener">MAT使用入门</a></li>
<li><a href="http://kohlerm.blogspot.jp/" target="_blank" rel="noopener">Markus Kohler博客</a></li>
<li><a href="http://android-developers.blogspot.jp/2011/03/memory-analysis-for-android.html" target="_blank" rel="noopener">Memory Analysis for Android Applications</a></li>
<li><a href="http://eclipsesource.com/blogs/2013/01/21/10-tips-for-using-the-eclipse-memory-analyzer/" target="_blank" rel="noopener">10 Tips for using the Eclipse Memory Analyzer</a></li>
</ol>
<p>使用这个工具找寻内存泄露问题是没有一个准则的，需要对自己的程序比较了解（参见<a href="https://www.youtube.com/watch?v=_CruQY55HOk" target="_blank" rel="noopener">Google I/O视频</a>）。从实际开发经验来说，遵循一定的开发规则，在使用异步线程、静态变量、内部类等技术的时候多加注意是更好的办法。</p>
<h2 id="Allocation-Tracker"><a href="#Allocation-Tracker" class="headerlink" title="Allocation Tracker"></a>Allocation Tracker</h2><p>一大利器，可以做的事情如下：</p>
<ol>
<li>展示在什么时候什么地方分配了什么样子的对象，对象的大小，分配的线程以及栈信息；</li>
<li>通过重复进行分配、释放动作帮助分析内存抖动；</li>
<li>可以和Heap Viewer结合分析内存泄露；</li>
</ol>
<p>但是是需要时间来学习分析统计数据和报表的。</p>
<p>它的使用同样是既可以在Android Monitor中进行，也可以在Android Device Monitor中进行的。前者只需要两次点击<code>C</code>处的第三个按钮即可，后者则稍微麻烦一些。具体可参考:</p>
<ol>
<li><a href="http://developer.android.com/intl/zh-cn/tools/performance/allocation-tracker/index.html" target="_blank" rel="noopener">官网</a></li>
<li><a href="http://blog.csdn.net/p106786860/article/details/9248693" target="_blank" rel="noopener">使用Allocation tracker跟踪Android应用内存分配</a></li>
</ol>
<p>在Android Device Monitor中查看数据，个人感觉比较清晰：</p>
<p><img src="http://7xktd8.com1.z0.glb.clouddn.com/Allocaition-TrackerB.png" alt="Android Monitor"><br>可以看到中间红框展现了所有分配的对象，对象的分配顺序、大小、类型、所属线程，在哪个类的哪个方法中被分配，都非常清楚。</p>
<p>选中一行之后，就可以在下面看到详细的堆栈信息。而关于Android Monitor的图标解析，可以查看<a href="http://blog.csdn.net/itfootball/article/details/48750849" target="_blank" rel="noopener">Android性能专项测试之Allocation Tracker(Android Studio)</a>。</p>
<h2 id="内存使用分析"><a href="#内存使用分析" class="headerlink" title="内存使用分析"></a>内存使用分析</h2><p>具体可以参考<a href="http://developer.android.com/intl/zh-cn/tools/debugging/debugging-memory.html" target="_blank" rel="noopener">官网文章</a>，这里还有<a href="http://android.jobbole.com/80926/" target="_blank" rel="noopener">翻译</a>。</p>
<p>总结一下，主要分析手段有：</p>
<ol>
<li>解析GC日志信息：主要关注<code>&lt;Heap_stats&gt;</code>，如果值一直增大并且不会减小下来，那么就可能有内存泄露了；</li>
<li>查看堆的更新：Heap视图显示了堆内存使用的基本状况，每次垃圾回收后会更新，可以看分配的内存是否在增长；</li>
<li>跟踪内存分配：查看对象的分配情况；</li>
<li>查看总体内存分配：通过命令<code>adb shell dumpsys meminfo &lt;package_name|pid&gt; [-d]</code>可以查看进程中活动的根视图的数量和当前驻留在进程中的Context和Activity对象的数量；</li>
<li>获取堆转储：查看持久引用，费静态内部类以及不必要的对象缓存；</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[性能优化总览]]></title>
      <url>http://www.timebridge.space/2016/05/09/Android-Performance-Outline/</url>
      <content type="html"><![CDATA[<p>今天在整理Systrace的时候看到了一句话:</p>
<p><strong>After building features, eliminating bugs and cleaning up your code, you should spend some time looking at the performance of your application.</strong></p>
<p>道出了程序猿从始至终的工作啊。</p>
<p><a href="http://developer.android.com/intl/zh-cn/tools/performance/index.html" target="_blank" rel="noopener">官网</a>上提供了一些列工具用于辅助提高程序的性能，主要包含以下方面:<a id="more"></a></p>
<ol>
<li>UI；</li>
<li>内存；</li>
<li>电量；</li>
</ol>
<p>虽然没有提及流量，但是实际上在Android Monitor上已经有所支持，且在<a href="http://www.muzileecoding.com/android/Android-performance.html" target="_blank" rel="noopener">Android性能优化系列视频</a>中也提到相关工具，比如<a href="http://developer.android.com/intl/zh-cn/tools/debugging/ddms.html#network" target="_blank" rel="noopener">Network Traffic tool</a>。</p>
<p>从实际开发的角度，UI和内存是比较重要的两块，Android在这两块提供的支持也最多:</p>
<ol>
<li>UI上的过度绘制，嵌套层次过深，会导致页面的卡顿，进而影响用户体验；</li>
<li>内存使用不合理，诸如内存泄露、抖动等问题会导致程序不稳定；</li>
</ol>
<p>以下是提供的工具图：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/Android调优工具汇总.png" height="188" alt="Android调优工具汇总"></div>

<p>关于流量，遵循一定的策略（比如数据压缩，数据缓存），问题不会很大——重要的是请求的时间。</p>
<p>关于电量，<a href="http://www.muzileecoding.com/android/Android-performance.html" target="_blank" rel="noopener">Android性能优化系列视频</a>中也有所提及——比如不要采用轮询机制与服务端保持通信，因为网络请求会唤醒无线电通信模块，这是非常耗电的操作，还有通过WakeLock唤醒屏幕等操作，也需要慎重。</p>
<blockquote>
<p>当出现卡顿问题，这些工具可以作为一个入口发现问题所在：锁定超时函数。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[TraceView]]></title>
      <url>http://www.timebridge.space/2016/05/09/Android-traceview/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="http://developer.android.com/intl/zh-cn/tools/debugging/debugging-tracing.html" target="_blank" rel="noopener">官网介绍</a></p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p><img src="http://7xktd8.com1.z0.glb.clouddn.com/TraceView.png" alt="TraceView操作页面"></p>
<p>如图所示，我们可以按照以下步骤完成数据获取和展示：<a id="more"></a></p>
<ol>
<li>点击<code>A</code>处的Android小人Icon打开TraceView操作页面；</li>
<li>在<code>C</code>处选择需要监控的进程，选择完毕后，<code>B</code>处的Icon就会亮起；</li>
<li>准备好应用程序，点击<code>B</code>处的按钮，操作应用程序，再次点击<code>B</code>处的按钮，即可生成trace文件；</li>
<li>Android Studio自动在操作页面的右边打开trace文件；</li>
</ol>
<p>执行完毕后就可以见到如图所示的界面。另外，能翻墙的童鞋可以查看<a href="http://developer.android.com/intl/zh-cn/tools/performance/traceview/index.html" target="_blank" rel="noopener">官网指导</a>。</p>
<blockquote>
<p>还有一种办法是通过插入Debug代码获取trace文件，详细可参考<a href="http://www.cnblogs.com/devinzhang/archive/2011/12/18/2291592.html" target="_blank" rel="noopener">Android调试工具之Traceview</a>。</p>
<p>在问题没有确定，不知道具体出问题的代码在哪里时，使用这种方法定位比较繁琐。可以使用图形化操作方式大致确定函数（这种方式监控的函数很多，分析起来比较困难），然后再通过代码插入方式进一步分析。</p>
</blockquote>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>从上图打开的trace视图来看，主要分为两个部分：</p>
<ol>
<li>上半部分称为”Timeline Panel”：描述了每一个线程的每一个方法的启动和结束时间；</li>
<li>下半部分称为”Profile Panel”：分析了每一个方法所做的事情以及耗费的时间；</li>
</ol>
<p><code>E</code>处列出了主线程这段时间执行的所有函数，点击最左边的箭头可以展开，看到该函数是被谁唤起调用的(Parents)，又调用了哪些子函数（Children）。</p>
<p><code>F</code>处则展现了各个统计维度下的值。下面就详细来说说这块。</p>
<h3 id="统计维度"><a href="#统计维度" class="headerlink" title="统计维度"></a>统计维度</h3><p>Profile Panel共展现了一个方法的以下统计数据:</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>Incl Cpu Time</td>
<td>函数本身运行占用的CPU时间，包括子函数</td>
</tr>
<tr>
<td>Excl Cpu Time</td>
<td>函数运行占用的CPU时间，不包括子函数</td>
</tr>
<tr>
<td>Incl Real Time</td>
<td>函数本身运行的真实时间，包括子函数</td>
</tr>
<tr>
<td>Excl Real Time</td>
<td>函数运行的真实时间，不包括子函数</td>
</tr>
<tr>
<td>Call+Recur Calls/Total</td>
<td>函数被调用的总次数以及递归调用占总次数的百分比</td>
</tr>
<tr>
<td>Cpu Time/Call</td>
<td>函数平均每次调用所用的CPU时间</td>
</tr>
<tr>
<td>Real Time/Call</td>
<td>函数平均每次调用所用的真实时间</td>
</tr>
</tbody>
</table>
<blockquote>
<p>关于CPU时间和真实时间之间的区别，可以看StackOverFlow上的一个<a href="http://stackoverflow.com/questions/15760447/what-is-the-meaning-of-incl-cpu-time-excl-cpu-time-incl-real-cpu-time-excl-re" target="_blank" rel="noopener">帖子</a>: 真实时间其实包括了诸如I/O等待时间，线程上下文切换时间等待等。</p>
<p>从数据看，这个推断是成立的，第一个论据就是所有函数的CPU时间都小于真实时间。另外一个证据，后面再说。</p>
</blockquote>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>按照这个解释，我们来看一个🌰。我在主线程中调用了一个如下方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testForPer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Thread.sleep(<span class="number">300</span>);</span><br><span class="line">		Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">"Done"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显，这个写法是有问题的。那么我们怎么找出它呢？根据真实时间和CPU时间的差别，很容易确定一点：这个方法虽然真实时间很长，达300ms+，但是CPU时间很短，因为有300ms处于睡眠状态。所以要捕捉这样一个方法，应该从真实时间出发。</p>
<p>这个方法执行时间长，是因为调用了Thread的<code>sleep()</code>方法，这个方法300ms才返回，因此应当选择包含子函数的维度，否则该方法没有特殊的地方。</p>
<p>符合以上判断的指标有: Incl Real Time、Real Time/Call。<br>在上图的<code>E</code>处选择到这两个维度，点击Header，使得其中一项是递减排列的。</p>
<p><img src="http://7xktd8.com1.z0.glb.clouddn.com/TraceView分析.png" alt="TraceView分析"><br>如图很快就可以抓出这个函数。再看下面这个图，有全部维度的数据：</p>
<p><img src="http://7xktd8.com1.z0.glb.clouddn.com/TraceView分析2.png" alt="TraceView分析"><br>可以看到Incl Real Time(303.390ms)比Incl CPU Time(2.285)大约就长了300ms，正是sleep的时间，佐证了前面关于真实时间和CPU时间的猜测。</p>
<blockquote>
<p>PS：这个例子中的真实时间和CPU时间的差距比较靠谱是因为此时CPU时间比较充裕，读者可以考虑一下如果当前有数十个线程会发生什么情况？</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面的实战是一个倒推的过程，也就是说我们先知道了问题的所在，再去捕捉它，但实际开发中我们无法得知问题所在，更不能做出如上的判断，那么该如何下手呢？</p>
<p>实际上开发中常见的两类问题函数如下：</p>
<ol>
<li>调用次数非常频繁的函数——这类函数必须关注效率，并且防止过多的分配内存；</li>
<li>执行时间很长的函数——比如我们的例子中展现的<code>testForPer()</code>；</li>
</ol>
<p>前者我们是可以通过Call + Recur Calls/Total维度去看，查找出调用次数非常多的函数，找出这些函数后，如果它们占用的CPU时间非常多（可以通过Incl CPU Time判断），则需要优化，另外内存这块可能需要手动check代码，或者通过别的工具检测。</p>
<p>第二种情况稍微复杂一点，除了例子中展现的这类函数，的的确确是有另外一类函数，自身执行时间非常耗时，比如解析一个超长的文本文件就会导致函数本身耗时很久，这个时候就可以使用CPU时间来判断了。</p>
<blockquote>
<p>可以结合前面的问题进行思考。</p>
</blockquote>
<p>因为无法判断具体问题所在，所以可能需要从多个维度对函数进行排序，观察是否有函数出现“不正常”情况，并做出相应的处理。</p>
<p>最后这里也有一篇文章写的比较清晰: <a href="http://bxbxbai.github.io/2014/10/25/use-trace-view/" target="_blank" rel="noopener">正确使用Android性能分析工具——TraceView</a>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android性能优化系列阅读笔记]]></title>
      <url>http://www.timebridge.space/2016/05/03/Android-performance/</url>
      <content type="html"><![CDATA[<blockquote>
<p>感谢<a href="http://hukai.me" target="_blank" rel="noopener">@胡凯</a>的辛勤劳动。</p>
</blockquote>
<h3 id="第一季"><a href="#第一季" class="headerlink" title="第一季"></a>第一季</h3><h5 id="1-Render-Performance"><a href="#1-Render-Performance" class="headerlink" title="1.Render Performance"></a>1.Render Performance</h5><p>UI这块直接看<a href="http://www.csdn.net/article/2015-01-20/2823621-android-performance-patterns" target="_blank" rel="noopener">原文</a>。</p>
<h5 id="2-Memory-Churn-and-performance"><a href="#2-Memory-Churn-and-performance" class="headerlink" title="2.Memory Churn and performance"></a>2.Memory Churn and performance</h5><p>导致GC频繁执行有两个原因：</p>
<ol>
<li>Memory Churn内存抖动，内存抖动是因为大量的对象被创建又在短时间内马上被释放。</li>
<li>瞬间产生大量的对象会严重占用Young Generation的内存区域，当达到阀值，剩余空间不够的时候，也会触发GC。即使每次分配的对象占用了很少的内存，但是他们叠加在一起会增加Heap的压力，从而触发更多其他类型的GC。这个操作有可能会影响到帧率，并使得用户感知到性能问题。</li>
</ol>
<a id="more"></a>解决上面的问题有简洁直观方法，如果你在Memory Monitor里面查看到短时间发生了多次内存的涨跌，这意味着很有可能发生了内存抖动。可以通过Heap和Allocation Tracker工具来查看此时内存中分配的到底有哪些对象。<br><div align="center"><img src="http://img.ptcms.csdn.net/article/201501/20/54bdcc0ed72c1.jpg" width="320" alt="内存抖动"></div><br><br>比如在for循环中执行了创建对象的操作。<br><br>##### 3.Understanding Battery Drain on Android<br>从Android 5.0开始发布了Battery History Tool，它可以查看程序被唤醒的频率，又谁唤醒的，持续了多长的时间，这些信息都可以获取到。<br><br>要注意WakeLock的用法。<br><br>### 第二季<br>&gt;包括的内容大致有：电量优化、网络优化、Android Wear上如何做优化、使用对象池来提高效率、LRU Cache、Bitmap的缩放、缓存、重用、PNG压缩、自定义View的性能、提升设置alpha之后View的渲染性能，以及Lint、StictMode等工具的使用技巧。<br><br>##### 1.To Index or Iterate?<br>循环遍历的方式：1）for；2）for…each…；3）Iterator三种的效率不一样，for效率更高，但是这个和编译器有关，需要实际检验。<br><br>##### 2.Hidden Cost of Transparency<br>alpha会要求View进行Blend混色处理，触发了额外的绘制任务，这样会导致不少性能问题。<br><br>如何渲染才能够得到我们想要的效果呢？我们可以先按照通常的方式把View上的元素按照从后到前的方式绘制出来，但是不直接显示到屏幕上，而是使用GPU预处理之后，再又GPU渲染到屏幕上，GPU可以对界面上的原始数据直接做旋转，设置透明度等等操作。使用GPU进行渲染，虽然第一次操作相比起直接绘制到屏幕上更加耗时，可是一旦原始纹理数据生成之后，接下去的操作就比较省时省力。<br><br>如何才能够让GPU来渲染某个View呢？我们可以通过setLayerType的方法来指定View应该如何进行渲染，从SDK 16开始，我们还可以使用ViewPropertyAnimator.alpha().withLayer()来指定。<br><br>另外一个例子是<strong>包含阴影区域的View</strong>，这种类型的View并不会出现我们前面提到的问题，因为他们并不存在层叠的关系。为了能够让渲染器知道这种情况，避免为这种View占用额外的GPU内存空间，我们通过设置View的<code>hasOverlappingRendering()</code>方法返回false来实现。<br><br>##### 3.Custom Views and Performance<br>通常来说，针对自定义View，我们可能犯下面三个错误：<br><br>1. Useless calls to onDraw()：我们知道调用View.invalidate()会触发View的重绘，有两个原则需要遵守，第1个是仅仅在View的内容发生改变的时候才去触发invalidate方法，第2个是尽量使用ClipRect等方法来提高绘制的性能。<br>2. Useless pixels：减少绘制时不必要的绘制元素，对于那些不可见的元素，我们需要尽量避免重绘。<br>3. Wasted CPU cycles：对于不在屏幕上的元素，可以使用Canvas.quickReject把他们给剔除，避免浪费CPU资源。另外尽量使用GPU来进行UI的渲染，这样能够极大的提高程序的整体表现性能。<br><br>总的来说：尽量少绘制，绘制的时候尽量降低成本。<br><br>### 第三季<br>&gt;包括的内容大致有：更高效的ArrayMap容器，使用Android系统提供的特殊容器来避免自动装箱，避免使用枚举类型，注意onLowMemory与onTrimMemory的回调，避免内存泄漏，高效的位置更新操作，重复layout操作的性能影响，以及使用Batching，Prefetching优化网络请求，压缩传输数据等等使用技巧。<br><br>##### 1. Fun with ArrayMaps<br>和SpareArray等容器一样，是在空间与时间之间做的一个权衡：它们速度不如HashMap(采取的是折半查找)，但占用更少的内存。<br><br>对象个数也最好比较少，原文说的是千以内：过多的话，由于实现问题，会导致效率下降。<br><br>这些容器顺带着也照顾了自动装箱拆箱问题——也会导致一些性能问题，并且会创建出很多的对象。<br><br>##### 2.The price of ENUMs<br>官方原文:<br>&gt;Enums often require more than twice as much memory as static constants. You should strictly avoid using enums on Android.<br><br>枚举会大大增加包体积大小，产生额外的内存消耗，官网强烈建议不要再Android程序中使用枚举。<br><br>##### 3.Trimming and Sharing Memory<br>可以参考<a href="http://hukai.me/android-training-managing_your_app_memory/" target="_blank" rel="noopener">Android Training - 管理应用的内存</a>。<br><br>从Android 4.4开始，ActivityManager提供了isLowRamDevice()的API，通常指的是Heap Size低于512M或者屏幕大小&lt;=800*480的设备。<br><br>##### 4.Location &amp; Battery Drain<br>凡是请求耗资源的资源，都可以通过历史的数据改变请求间隔，尽量减少请求次数。<br><br>定位可以通过<code>LocationRequest.setPriority()</code>在耗电量和精确性之间做出权衡。<br><br>##### 5.Double Layout Taxation<br>1. 尽量保持View Hierarchy的层级比较浅，这样即使发生重复layout，也不会因为布局的层级比较深而增大了重复layout的倍数;<br>2. 在任何时候都请避免调用requestLayout()的方法，因为一旦调用了requestLayout，会导致该layout的所有父节点都发生重新layout的操作;<br><br>##### 6.Network Performance 101<br>两个原则:<br><br>1. 减少移动网络被激活的时间与次数;<br>2. 压缩传输数据;<br><br>生网络行为可以划分为三种类型:<br><br>1. 用户主动触发的请求;<br>2. 被动接收服务器的返回数据;<br>3. 最后一个是数据上报，行为上报，位置更新等等自定义的后台操作;<br><br>应该遵循下面的规则来处理数据同步的问题:<br><br>1. 在某些必须做同步的场景下，需要避免使用固定的间隔频率来进行更新操作，我们应该在返回的数据无更新的时候，使用双倍的间隔时间来进行下一次同步（策略调整）;<br>2. 使用Batching(批处理)的方式来集中发出请求，避免频繁的间隔请求;<br>3. 使用Prefetching（预取）的技术提前把一些数据拿到，避免后面频繁再次发起网络请求;<br>4. 对网络行为进行分类，区分需要立即更新数据的行为和其他可以进行延迟的更新行为，为不同的场景进行差异化处理；<br>5. 要避免客户端对服务器的轮询操作，这样会浪费很多的电量与带宽流量。解决这个问题，我们可以使用Google Cloud Message来对更新的数据进行推送；<br>6. 还可以通过判断当前设备的状态来决定同步的频率，例如判断设备处于休眠，运动等不同的状态设计各自不同时间间隔的同步频率；<br>7. 可以通过判断设备是否连接上Wi-Fi，是否正在充电来决定更新的频率。为了能够方便的实现这个功能，Android为我们提供了GCMNetworkManager来判断设备当下的状态，从而设计更加高效的网络同步操作；<br><br>##### 7.Effective Network Batching<br>发起网络请求与接收返回数据都是比较耗电的，在网络硬件模块被激活之后，会继续保持几十秒的电量消耗，直到没有新的网络操作行为之后，才会进入休眠状态。前面一个段落介绍了使用Batching的技术来捆绑网络请求，从而达到减少网络请求的频率。那么如何实现Batching技术呢？通常来说，我们可以会把那些发出的网络请求，先暂存到一个PendingQueue里面，等到条件合适的时候再触发Queue里面的网络请求。<br><br>可是什么时候才算是条件合适了呢？最简单粗暴的，例如我们可以在Queue大小到10的时候触发任务，也可以是当手机开始充电，或者是手机连接到WiFi等情况下才触发队列中的任务。手动编写代码去实现这些功能会比较复杂繁琐，Google为了解决这个问题，为我们提供了GCMNetworkManager来帮助实现那些功能，仅仅只需要调用API，设置触发条件，然后就OK了。<br><br>预取以及网络行为还要考虑当前的网络状态是否良好——根据网络状态调整行为。<br><br>Android官方为了帮助我们设计自己的网络请求策略，提供了模拟器的网络流量控制功能来对实际环境进行模拟测量，或者还可以使用AT&amp;T提供的<a href="http://developer.att.com/developer/legalAgreementPage.jsp?passedItemId=14500040" target="_blank" rel="noopener">AT&amp;T Network Attenuator</a>来帮助预估网络延迟。<br><br>使用<a href="http://developer.android.com/intl/zh-cn/tools/debugging/ddms.html#network" target="_blank" rel="noopener">Network Traffic tool</a>可以查看网络请求发生的时间，每次请求的数据量等等信息。<br><br>##### 8.Effective Prefetching<br>预先获取多少数据量是很值得考量的，因为如果预取数据量偏少，就起不到减少频繁请求的作用，可是如果预取数据过多，就会造成资源的浪费。<br><br>我们可以参考在WiFi，4G，3G等不同的网络下设计不同大小的预取数据量，也可以是按照图片数量或者操作时间来作为阀值。这需要我们需要根据特定的场景，不同的网络情况设计合适的方案。<br><br>### 第四季<br>&gt;涉及的内容有：优化网络请求的行为，优化安装包的资源文件，优化数据传输的效率，性能优化的几大基础原理等等。<br><br>##### 1.Cachematters for networking<br>Android系统上关于网络请求的Http Response Cache是默认关闭的，这样会导致每次即使请求的数据内容是一样的也会需要重复被调用执行，效率低下。我们可以通过下面的代码示例开启HttpResponseCache。<br><br>开启Http Response Cache之后，Http操作相关的返回数据就会缓存到文件系统上，不仅仅是主程序自己编写的网络请求相关的数据会被缓存，另外引入的library库中的网络相关的请求数据也会被缓存到这个Cache中。<br><br>Http自己有缓存机制，但是有可能失效（不是每一个服务端都会返回正常的缓存Header），因此有时候我们需要自己管理缓存，开源框架这个时候就比较有用了。<br><br>可以使用Android Studio里面的Network Traffic Tools来查看网络数据的请求与返回情况，另外我们还可以使用<a href="https://developer.att.com/application-resource-optimizer" target="_blank" rel="noopener">AT&amp;T ARO工具</a>来抓取网络数据包进行分析查看。<br><br>##### 2.Optimizing Network Request Frequencies<br>这部分集中到第三季有关网络的部分。<br><br>##### 3.Minimizing Asset Payload<br>主要是图片个序列化数据。<br><br>图片可以从格式入手:<br><div align="center"><img src="http://img.blog.csdn.net/20160112164609185" width="160" alt="PNG,JPEG,WEBP三种主流格式在占用空间与图片质量之间的对比"></div><br><br>&gt;Webp，它是由Google推出的一种既保留png格式的优点，又能够减少图片大小的一种新型图片格式。关于Webp的更多细节<br><br>尽量减少PNG图片的大小是Android里面很重要的一条规范。相比起JPEG，PNG能够提供更加清晰无损的图片，但是PNG格式的图片会更大，占用更多的磁盘空间。到底是使用PNG还是JPEG，需要设计师仔细衡量，对于那些使用JPEG就可以达到视觉效果的，可以考虑采用JPEG即可。我们可以通过Google搜索到很多关于PNG压缩的工具。<br><br>另外：服务器应该支持到为不同的使用场景分别准备多套清晰度不一样的图片，以便在对应的场景下能够获取到最适合自己的图片。<br><br>&gt;了解Bitmap的4种解码格式，inBitmap属性。<br><br>Google介绍了一个开源的加载bitmap的库：<strong>Glide</strong>，这里面包含了各种对bitmap的优化技巧。<br><br>数据可以从序列化方式入手，应该使用Protocal Buffers，Nano-Proto-Buffers，FlatBuffer来减小序列化的数据的大小。<br><br>1. <strong>【Protocal Buffers】</strong>强大，灵活，但是对内存的消耗会比较大，并不是移动终端上的最佳选择。<br>2. <strong>【Nano-Proto-Buffers】</strong>基于Protocal，为移动终端做了特殊的优化，代码执行效率更高，内存使用效率更佳。<br>3. <strong>【FlatBuffers】</strong>这个开源库最开始是由Google研发的，专注于提供更优秀的性能。<br><br>对比数据如下:<br><div align="center"><img src="http://img.blog.csdn.net/20160112165416290" width="320" alt="性能对比数据"></div><br><br><div align="center"><img src="http://img.blog.csdn.net/20160112165503594" width="320" alt="性能对比数据"></div><br><br>另外：<strong>数据呈现的顺序以及结构会对序列化之后的空间产生不小的影响（这一点建议看原文，很重要！）。</strong><br><br>##### 4.APK瘦身<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">buildTypes&#123;</span><br><span class="line">	release&#123;</span><br><span class="line">		minifyEnabled <span class="keyword">true</span> <span class="comment">//删除无用的代码</span></span><br><span class="line">		shrinkResource <span class="keyword">true</span> <span class="comment">//删除无用的资源</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过tools:keep或者是tools:discard标签来实现对特定资源的保留与废弃——和Proguard的keep一样。</p>
<h3 id="第五季"><a href="#第五季" class="headerlink" title="第五季"></a>第五季</h3><blockquote>
<p>涉及的内容有：多线程并发的性能问题，介绍了AsyncTask、HandlerThread、IntentService与ThreadPool分别适合的使用场景以及各自的使用注意事项。</p>
<div align="center"><img src="http://img.blog.csdn.net/20160429192507841" width="160" alt="GPU Profiling原步骤"></div>

</blockquote>
<p>从Android M系统开始，系统更新了GPU Profiling的工具来帮助我们定位UI的渲染性能问题。早期的CPU Profiling工具只能粗略的显示出Process、Execute、Update三大步骤的时间耗费情况。</p>
<p>但是仅仅显示三大步骤的时间耗费情况，还是不太能够清晰帮助我们定位具体的程序代码问题，所以在Android M版本开始，GPU Profiling工具把渲染操作拆解成如下8个详细的步骤进行显示。</p>
<p><div align="center"><img src="http://img.blog.csdn.net/20160429192539045" width="160" alt="GPU Profiling步骤"></div><br>旧版本中提到的Process、Execute、Update还是继续得到了保留，他们的对应关系如下：</p>
<p><div align="center"><img src="http://img.blog.csdn.net/20160429192645858" width="160" alt="旧版本步骤"></div><br>其他5个步骤分别代表了什么含义：</p>
<ol>
<li><strong>【Sync &amp; Upload】</strong>通常表示的是准备当前界面上有待绘制的图片所耗费的时间，为了减少该段区域的执行时间，我们可以减少屏幕上的图片数量或者是缩小图片本身的大小。</li>
<li><strong>【Measure &amp; Layout】</strong>这里表示的是布局的onMeasure与onLayout所花费的时间，一旦时间过长，就需要仔细检查自己的布局是不是存在严重的性能问题。</li>
<li><strong>【Animation】</strong>表示的是计算执行动画所需要花费的时间，包含的动画有ObjectAnimator，ViewPropertyAnimator，Transition等等。一旦这里的执行时间过长，就需要检查是不是使用了非官方的动画工具或者是检查动画执行的过程中是不是触发了读写操作等等。</li>
<li><strong>【Input Handling】</strong>表示的是系统处理输入事件所耗费的时间，粗略等于对于的事件处理方法所执行的时间。一旦执行时间过长，意味着在处理用户的输入事件的地方执行了复杂的操作。</li>
<li><strong>【Misc/Vsync Delay】</strong>如果稍加注意，我们可以在开发应用的Log日志里面看到这样一行提示：I/Choreographer(691): Skipped XXX frames! The application may be doing too much work on its main thread。这意味着我们在主线程执行了太多的任务，导致UI渲染跟不上vSync的信号而出现掉帧的情况。</li>
</ol>
<p>其余都是有关线程的，不作整理。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Instant Run 简介]]></title>
      <url>http://www.timebridge.space/2016/05/03/Android-instantrun/</url>
      <content type="html"><![CDATA[<p>翻译自: <a href="http://tools.android.com/tech-docs/instant-run" target="_blank" rel="noopener">Instant Run</a></p>
<blockquote>
<p>Instant Run并不支持<a href="https://source.android.com/source/jack.html" target="_blank" rel="noopener">Jack</a>，Jack需要Android N提供的对Java 8的语言特性的支持。关于Java 8和Jack，可以看<a href="http://developer.android.com/intl/zh-cn/preview/j8-jack.html" target="_blank" rel="noopener">这里</a>。</p>
</blockquote>
<p>Instant Run在Android Studio 2.0正式进入生产环境，主要目的是为了减少通过<code>Run</code>和<code>Debug</code>部署App的时间。Instant Run不会在项目有更改之后重新打包APK，而是会把代码和资源的变化直接Push到机器上，因此变化几乎是瞬时反应在设备上的。<a id="more"></a></p>
<p>当配置好项目并运行一次之后，<code>Run</code>的箭头Icon左边就会出现一个黄色的闪电Icon（<code>Debug</code>也是一样，需要先跑一次），这就表示Instant Run已经准备好为你更新目标应用了——某些时候它甚至不需要重启你的Activity来反映变化，更改的效果会立刻显示出来。</p>
<blockquote>
<p>【注意】Instant Run会暂时性地关闭了JaCoCo和Proguard。但是因为Instant Run只对debug构建有效，因此这种行为不会影响你的release构建。</p>
</blockquote>
<p>Instant Run有三种方式可以将更新后的项目Push到设备上：Hot Swap，Warm Swap和Cold Swap，它会自动选择一种方式进行更新。下面的表格描述了项目发生变化之后Instant Run会如何Push更新:</p>
<table>
<thead>
<tr>
<th>代码变化</th>
<th>Instant Run行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>实例方法或者静态方法代码变化</td>
<td>Hot Swap: 最快的Push变化的方法，几乎可以立即看到变化，应用程序会继续运行，下次调用这个方法的时候，新的方法就会被调用</td>
</tr>
<tr>
<td>更改或者移除资源</td>
<td>Warm Swap: 这种方式依然很快，但是在Push变化的时候要求Activity重新启动，App本身不会重启</td>
</tr>
<tr>
<td>代码结构变更，比如: 1)增加、删除或者改动注解、实例变量、静态变量、静态方法签名、实例方法签名；2）改变继承的父类；3）改变实现的接口；4）变更静态构造器；5）使用动态Id重新构建Layout</td>
<td>Code Swap(API Level 21以及以上才支持): Instant Run会将变化的结构代码Push到目标设备上，并重启整个App； API Level 20以及以下会重新构建APK。</td>
</tr>
<tr>
<td>1）更改Manifest文件；2）更改Manifest文件引用的资源；3）更改widget的UI元素(需要执行<code>Clean and Rerun</code>)</td>
<td>对于前两者，Android Studio会自动重新构建，这是因为诸如icon、名字、intent-filter是在APK安装的时候就确定了。如果构建过程默认更改了Manifest文件，那么你就不会获得任何Instant Run带来的好处，因此不建议在构建中自动更改任何的Manifest文件内容。</td>
</tr>
</tbody>
</table>
<p>Android Studio默认会在Hot Swap之后保持App运行并重启当前的Activity，这个设置可以更改:</p>
<ol>
<li>打开Settings或者Prefereneces面板；</li>
<li>打开Build, Execution, Deployment &gt; Instant Run；</li>
<li>取消选中<code>Restart activity on code changes</code>；</li>
</ol>
<p>当这个设置被取消之后，开发者可以在菜单栏的Run菜单中选择<code>Restart Activity</code>来手动重启当前的Activity。</p>
<h4 id="使用Rerun"><a href="#使用Rerun" class="headerlink" title="使用Rerun"></a>使用<code>Rerun</code></h4><p>当诸如<code>onCreate()</code>方法发生变化后，你可能会需要重启App来反应变化，这个时候可以点击<code>Rerun</code>命令(Icon是一个右下角一个方块，左边一个向上弯曲的箭头)来停止App运行、执行增量构建并重启App。</p>
<p>如果需要进行一个Clean构建，可以选择<code>Run &gt; Clean and Rerun &#39;app&#39;</code>命令进行，或者按住<code>Shift</code>键的同时按下<code>Rerun</code>命令。这个动作会停止当前运行的App，执行一个全新的构建，然后将新的APK部署到目标设备上去。</p>
<h2 id="为项目配置Instant-Run"><a href="#为项目配置Instant-Run" class="headerlink" title="为项目配置Instant Run"></a>为项目配置Instant Run</h2><p>当使用2.0.0或者更高版本的Android Gradle插件时，Android Studio自动应用Instant Run。为了让已有项目支持Gradle插件的最新版本，可以做以下配置:</p>
<ol>
<li>打开Settings或者Preferences面板；</li>
<li>跳转到Build, Execution, Deployment &gt; Instant Run，点击<code>Update Projec</code>，如果没有出现这个选项，那就说明这个项目已经支持最新的插件了；</li>
</ol>
<h2 id="需要知道的事情"><a href="#需要知道的事情" class="headerlink" title="需要知道的事情"></a>需要知道的事情</h2><p>Instant Run是设计来加速大多数情况下的构建部署过程的，下面是一些需要注意的地方。</p>
<h4 id="Legacy-Multidex-with-Android-5-0-or-higher"><a href="#Legacy-Multidex-with-Android-5-0-or-higher" class="headerlink" title="Legacy Multidex with Android 5.0 or higher"></a>Legacy Multidex with Android 5.0 or higher</h4><p>如果项目是Multidex的，即build.gradle里面配置了<code>multiDexEnabled true</code>和<code>minSdkVersion 20</code>或者更低版本，且目标设备运行的是Android 5.0(API Level 21)或者更高版本，那么部署一个Clean构建的效率可能会下降。当初始化部署完成之后，增量构建就会显著加快。</p>
<p>这里通过引用涉及到另外一处<a href="http://developer.android.com/intl/zh-cn/tools/building/multidex.html#mdex-pre-l" target="_blank" rel="noopener">文档</a>。引用的文档描述的很清楚:</p>
<blockquote>
<p>如果你项目是Multidex的，同时minSdkVersion配置的是20或者更低，并且目标设备运行的是Android 4.4(API Level 20)或者更低版本，Android Studio是不支持Instant Run的。</p>
</blockquote>
<p>解决办法是新建一个Product Flavor，将<code>minSdkVerion</code>提高到20以上。</p>
<h4 id="超出64K方法限制"><a href="#超出64K方法限制" class="headerlink" title="超出64K方法限制"></a>超出64K方法限制</h4><p>Instant Run会在每一个Debug APK中增加额外的方法，数量如下:</p>
<blockquote>
<p>approximately 140 plus three times the number of classes and their local dependencies。</p>
<p>恕我英语渣…</p>
</blockquote>
<p>因此可能会造成一些APK超出方法数限制，解决办法可以参考<a href="http://developers.android.com/tools/building/multidex.html#mdex-gradle" target="_blank" rel="noopener">configuring apps for Multidex</a>。</p>
<h4 id="部署到多设备"><a href="#部署到多设备" class="headerlink" title="部署到多设备"></a>部署到多设备</h4><p>因为Instant Run在选择更新方式的时候使用了不同的技术，这依赖于目标设备的API Level，因为这个原因，在一次部署到多个设备的时候，Android Studio会暂时关闭掉Instant Run。</p>
<h4 id="Instrumentation测试"><a href="#Instrumentation测试" class="headerlink" title="Instrumentation测试"></a>Instrumentation测试</h4><p>当运行Instrumentation测试的时候，Android Studio会关闭这个特性，不会插入额外的代码。</p>
<p>当分析一个App的时候，Instant Run会造成一定的性能影响，这些影响会干扰性能分析工具提供的信息，另外它也会使得stack trace更加复杂，因此这个时候需要关闭掉Instant Run。</p>
<h2 id="关闭Instant-Run"><a href="#关闭Instant-Run" class="headerlink" title="关闭Instant Run"></a>关闭Instant Run</h2><ol>
<li>打开Settings或者Preferences面板；</li>
<li>跳转到Build, Execution, Deployment &gt; Instant Run；</li>
<li>取消勾选<code>Enable Instant Run</code>；</li>
</ol>
<hr>
<blockquote>
<p><strong>今天是2016-05-03，上面描述的内容可以作为参考，实际情况已经有所变化。</strong></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android官方MVX项目解析]]></title>
      <url>http://www.timebridge.space/2016/04/22/google-android-mvx/</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>设计</strong>, 即根据问题当前的情况以及未来可预见的变化，提供优雅的解决方案。何谓优雅，不是投机取巧，而是简单易懂，成本低。</p>
</blockquote>
<p>前段时间Google官方推出了<strong><a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="noopener">“Android Architecture Blueprints”</a></strong>项目。正如项目介绍中所说，虽然Android平台对于如何组织项目结构提供了很大的自由度，但这种自由度也造成了混乱，使得项目的测试、维护以及扩展遇到困难。</p>
<p>在这个项目里面，Google针对同一个应用使用不同的架构和技术进行实现，以帮助开发者解决问题。它的重点在于<strong>代码结构，项目架构，测试以及可维护性</strong>。研究这个项目要注意以下几件事情：</p>
<ol>
<li>架构以及架构的实现由很多种选择，取决于你的现实情况，因此这些例子只是一个指引，并不能作为规范；</li>
<li>这个项目还处于beta状态，后期可能会出现影响所有例子的改动；<a id="more"></a></li>
</ol>
<h2 id="项目目前状态"><a href="#项目目前状态" class="headerlink" title="项目目前状态"></a>项目目前状态</h2><p>第一期已经完成近二分之一了：</p>
<ol>
<li><strong>todo-mvp/</strong> 基础项目，使用MVP架构；</li>
<li><strong>todo-mvp-loaders/</strong> 基于mvp项目，但是是使用Loaders加载数据；</li>
<li><strong>todo-mvp-databinding/</strong> 基于mvp项目，使用Data Binding库实现；</li>
</ol>
<p>剩余的还有几种技术的组合，目前还在开发中。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>直接clone项目即可，分支如下：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/android-architecture.png" height="250" alt="One Piece"></div><br>从分支命名可以看出目前该项目所做的一些工作以及所使用的技术。<br><br>## MVP<br>todo-mvp是所有例子的基础，它没有依赖任何的其余框架实现了MVP架构。这里重点分析<code>origin/todo-mvp</code>分支代码。<br><br>### 项目结构<br><div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/mvp项目结构.png" width="500" alt="One Piece"></div>

<p>如图所示，除了源码文件夹，还有四个文件夹是专门为测试建立的，关于测试这里不分析，但会阐述一下MVP结构对于测试的支持。</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/MVP项目结构-Detail.png" width="500" alt="One Piece"></div>

<p>在这里可以看到项目的分包特点：<strong>整体分包是按照页面功能分的，从外部并不能显示的看出是MVP模式</strong>。</p>
<p>我们展开详细看一下：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/mvp项目结构-Expand.png" width="500" alt="One Piece"></div>

<p><code>A</code>处是添加Task的页面，这里面有四个类，可以清晰的看到P的存在，每个类具体的含义下一节细说，<code>B</code>从包名以及类名可以推测出是数据源，也就是Model。<code>C</code>处定义了基本的V和P的接口。</p>
<blockquote>
<p>这个项目的UI都是由Activity + Fragment组成的，Activity和Fragment扮演的角色并不一样。</p>
</blockquote>
<h3 id="项目细说——职责和组装"><a href="#项目细说——职责和组装" class="headerlink" title="项目细说——职责和组装"></a>项目细说——职责和组装</h3><p>首先我们先看一下V和P的基本接口定义，如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BasePresenter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseView</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPresenter</span><span class="params">(T presenter)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简单，P里面只有一个<code>start()</code>方法，表示初始加载数据。V中也只有一个方法<code>setPresenter()</code>，用于给V设置对应的P。</p>
<p>接着我们看A中圈出的四个类（这四个类对应实现了一个界面，这里拉出来作为例子，其余的界面实现也是一致的），这几个类的关系如下：</p>
<ol>
<li><strong><code>AddEditTaskContract</code></strong> 扩展BaseView和BasePresenter接口，定义该页面V和P需要实现的接口；</li>
<li><strong><code>AddEditTaskFragment</code></strong> V接口的实现；</li>
<li><strong><code>AddEditTaskPresenter</code></strong> P接口的实现；</li>
<li><strong><code>AddEditTaskActivity</code></strong> M、V、P三者的组装；</li>
</ol>
<p><code>AddEditTaskActivity</code>的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">	setContentView(R.layout.addtask_act);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set up the toolbar.</span></span><br><span class="line">	Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);</span><br><span class="line">	setSupportActionBar(toolbar);</span><br><span class="line">	ActionBar actionBar = getSupportActionBar();</span><br><span class="line">	actionBar.setDisplayHomeAsUpEnabled(<span class="keyword">true</span>);</span><br><span class="line">	actionBar.setDisplayShowHomeEnabled(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建View</span></span><br><span class="line">	AddEditTaskFragment addEditTaskFragment = (AddEditTaskFragment) getSupportFragmentManager().findFragmentById(R.id.contentFrame);</span><br><span class="line"></span><br><span class="line">	String taskId = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (addEditTaskFragment == <span class="keyword">null</span>) &#123;</span><br><span class="line">		addEditTaskFragment = AddEditTaskFragment.newInstance();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (getIntent().hasExtra(AddEditTaskFragment.ARGUMENT_EDIT_TASK_ID)) &#123;</span><br><span class="line">		taskId = getIntent().getStringExtra(AddEditTaskFragment.ARGUMENT_EDIT_TASK_ID);</span><br><span class="line">		actionBar.setTitle(R.string.edit_task);</span><br><span class="line">		Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">		bundle.putString(AddEditTaskFragment.ARGUMENT_EDIT_TASK_ID, taskId);</span><br><span class="line">			addEditTaskFragment.setArguments(bundle);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			actionBar.setTitle(R.string.add_task);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ActivityUtils.addFragmentToActivity(getSupportFragmentManager(), addEditTaskFragment, R.id.contentFrame);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建Presenter并将View传递给Presenter</span></span><br><span class="line">	<span class="keyword">new</span> AddEditTaskPresenter(taskId, </span><br><span class="line">	<span class="comment">// 创建M</span></span><br><span class="line">	Injection.provideTasksRepository(getApplicationContext()), addEditTaskFragment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如注释所描述，Activity创建了V、P、M，并将M、V传递给了P，<code>AddEditTaskPresenter</code>的构造函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AddEditTaskPresenter</span><span class="params">(@Nullable String taskId, @NonNull TasksDataSource tasksRepository, @NonNull AddEditTaskContract.View addTaskView)</span> </span>&#123;</span><br><span class="line">	mTaskId = taskId;</span><br><span class="line">	<span class="comment">//获取到M</span></span><br><span class="line">	mTasksRepository = checkNotNull(tasksRepository);</span><br><span class="line">	mAddTaskView = checkNotNull(addTaskView);</span><br><span class="line">	<span class="comment">//组装M和P</span></span><br><span class="line">	mAddTaskView.setPresenter(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一行，P将自己设置为V的Presenter。即Activity的<code>onCreate()</code>方法执行完毕后，M、V、P三个部分组装完毕。<strong>除了组装，Activity还负责一件很重要的事情:初始化数据环境</strong>。从<code>onCreate()</code>方法可以看到，Activity获取了对应的taskId，并传递给了<code>AddEditTaskFragment</code>和<code>AddEditTaskPresenter</code>两者，这样在编辑一个Task的时候，Presenter才知道具体的编辑对象。</p>
<blockquote>
<p>这里taskId应该传入到<code>AddEditTaskFragment</code>中么？从实现上看，这个taskId在<code>AddEditTaskFragment</code>用于判断是在编辑一个Task还是在创建一个Task，这个逻辑应该放在P层更加合适。</p>
</blockquote>
<p><strong>组装完毕之后，整个页面是在哪里启动的呢？在V中，由V的生命周期触发。</strong><code>AddEditTaskFragment</code>的<code>onResume()</code>方法实现如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.onResume();</span><br><span class="line">	mPresenter.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法里面触发了mPresenter的<code>start()</code>方法加载数据(正因为Activity初始化了数据环境，因此<code>start()</code>函数不需要任何的参数）。</p>
<p><code>start()</code>方法会加载数据，我们来看逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	openTask();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">null</span> == mTaskId || mTaskId.isEmpty()) &#123;</span><br><span class="line">		mTaskDetailView.showMissingTask();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mTaskDetailView.setLoadingIndicator(<span class="keyword">true</span>);</span><br><span class="line">	mTasksRepository.getTask(mTaskId, <span class="keyword">new</span> TasksDataSource.GetTaskCallback() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTaskLoaded</span><span class="params">(Task task)</span> </span>&#123;</span><br><span class="line">			<span class="comment">// The view may not be able to handle UI updates anymore</span></span><br><span class="line">			<span class="keyword">if</span> (!mTaskDetailView.isActive()) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			mTaskDetailView.setLoadingIndicator(<span class="keyword">false</span>);</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">null</span> == task) &#123;</span><br><span class="line">				mTaskDetailView.showMissingTask();</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				showTask(task);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataNotAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// The view may not be able to handle UI updates anymore</span></span><br><span class="line">			<span class="keyword">if</span> (!mTaskDetailView.isActive()) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			mTaskDetailView.showMissingTask();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法是用于打开一个Task，它是通过<code>mTasksRepository</code>来加载数据的。<code>TasksRepository</code>是一个很重要的类，它实现了<code>TasksDataSource</code>接口：这个接口中定义了很多的有关Task操作的方法，有增删改查等。<code>TasksRepository</code>是<code>TasksDataSource</code>的一个实现，其余实现类如下：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/TasksDataSource实现类.png" height="100" alt="TasksDataSource实现类"></div>

<p>这四个实现的关系如下：</p>
<ol>
<li><code>TasksLocalDataSource</code>和<code>TasksRemoteDataSource</code>分别通过<code>TasksDataSource</code>定义的API实现了Task的本地（数据库）保存和远端保存（代码里面是一段假实现，Mock了一下从服务器上操作Task资源的过程）；</li>
<li><code>TasksRepository</code>通过以上两个类实现了<code>TasksDataSource</code>:把相关的请求直接代理给以上两个类；</li>
<li><code>FakeTasksRemoteDataSource</code>则是一个完全的Mock类，用于给自动化测试提供数据源；</li>
</ol>
<p>关于第2点，可以看<code>TasksRepository</code>中的一个方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveTask</span><span class="params">(@NonNull Task task)</span> </span>&#123;</span><br><span class="line">	checkNotNull(task);</span><br><span class="line">	mTasksRemoteDataSource.saveTask(task);</span><br><span class="line">	mTasksLocalDataSource.saveTask(task);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Do in memory cache update to keep the app UI up to date</span></span><br><span class="line">	<span class="keyword">if</span> (mCachedTasks == <span class="keyword">null</span>) &#123;</span><br><span class="line">		mCachedTasks = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">	mCachedTasks.put(task.getId(), task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在这个MVP的实现中，M对上是暴露出接口的（即<code>TasksDataSource</code>），并且整个App的数据接口都定义在一个接口中，这样在进行测试的时候便于提供Fake数据源。M层加载完数据之后是通过回调来告诉P层的，在<code>TasksDataSource</code>中我们可以看到两个回调接口的定义:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">LoadTasksCallback</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onTasksLoaded</span><span class="params">(List&lt;Task&gt; tasks)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onDataNotAvailable</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GetTaskCallback</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onTaskLoaded</span><span class="params">(Task task)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onDataNotAvailable</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PS: <code>TasksRepository</code>是单例设计。</p>
</blockquote>
<p>以上，我们知道了最基本的MVP的实现中各个类的大体作用、位置以及它们的关系。</p>
<h2 id="MVP-Loader"><a href="#MVP-Loader" class="headerlink" title="MVP-Loader"></a>MVP-Loader</h2><p>这个分支演示的是如何通过Loader实现MVP架构。前面介绍的基本结构以及各个类的职责都没有变化。Loader主要是用于数据异步加载的，因此在Model这块变化比较大。</p>
<blockquote>
<p>关于Loader如果有疑问，可以阅读文章：<a href="http://www.muzileecoding.com/androidsource/Android-loader-and-loadermanager.html" target="_blank" rel="noopener">Loader &amp; LoaderManager</a>。</p>
</blockquote>
<p>下面我们来看变化。首先在组装上不太一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create the loader and presenter</span></span><br><span class="line">TaskLoader taskLoader = <span class="keyword">new</span> TaskLoader(taskId, getApplicationContext());</span><br><span class="line"><span class="keyword">new</span> AddEditTaskPresenter(taskId, Injection.provideTasksRepository(getApplicationContext()), addEditTaskFragment, taskLoader, getSupportLoaderManager());</span><br></pre></td></tr></table></figure>
<p>这里在创建P的时候，还创建了Loader并将它传入给了P，P怎么使用这个Loader呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddEditTaskPresenter</span> <span class="keyword">implements</span> <span class="title">AddEditTaskContract</span>.<span class="title">Presenter</span>,</span></span><br><span class="line"><span class="class">        <span class="title">LoaderManager</span>.<span class="title">LoaderCallbacks</span>&lt;<span class="title">Task</span>&gt; </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		mLoaderManager.initLoader(TASK_QUERY, <span class="keyword">null</span>, <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>P的<code>start()</code>方法直接代理给了Loader，并且P自身实现了LoaderCallbacks回调。</p>
<p>在整个App里面总共实现了两个Loader，一个用于加载单个Task，一个用于加载所有的Task。前面提到过原始的MVP实现中<code>TasksDataSource</code>有两个回调接口来告诉P层数据加载完毕，这两个接口在这种实现中已经被Loader代替掉。</p>
<p>这种实现的另外一个有意思的地方是：<code>TasksRepository</code>里面可以设置观察者，而每一个Loader都实现了接口，成为相应的观察者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TasksRepositoryObserver</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onTasksChanged</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TasksLoader</span> <span class="keyword">extends</span> <span class="title">AsyncTaskLoader</span>&lt;<span class="title">List</span>&lt;<span class="title">Task</span>&gt;&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">TasksRepository</span>.<span class="title">TasksRepositoryObserver</span></span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是利用了Loader的特性：Loader在监听到数据变化之后，可以通过<code>forceLoad()</code>方法重新加载数据并回调通知上层，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTasksChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (isStarted()) &#123;</span><br><span class="line">		forceLoad();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种组合看上去也非常棒，整个结构流转如下：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/mvp-loader.png" height="400" alt="mvp-loader"></div>

<p>因为<code>TasksRepository</code>是单例的，页面只要通过Loader从数据源中加载数据，就等于是在数据源中设置了一个监听：因此这种设计可以监听所有数据的变化。</p>
<h3 id="TODO：继续分析其余实现方式"><a href="#TODO：继续分析其余实现方式" class="headerlink" title="TODO：继续分析其余实现方式"></a>TODO：继续分析其余实现方式</h3>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[反编译APK]]></title>
      <url>http://www.timebridge.space/2016/04/21/Apk-reverse-engineering/</url>
      <content type="html"><![CDATA[<p>以下是在Mac环境下进行的操作。</p>
<p>如果只是想看代码，准备以下两个工具即可:</p>
<ol>
<li><strong>dex2jar</strong> <a href="https://sourceforge.net/projects/dex2jar/" target="_blank" rel="noopener">下载地址</a></li>
<li><strong>jd-gui</strong> <a href="http://jd.benow.ca/" target="_blank" rel="noopener">下载地址</a></li>
</ol>
<p>这两个工具前者是为了把Android解压缩出来的<code>classes.dex</code>文件解析成jar文件，后者则是查看转化出的jar文件，即源码文件的。<a id="more"></a></p>
<h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><ol>
<li>将APK文件重命名为.zip文件，并解压。在解压文件夹下面可以看到一个<code>classes.dex</code>文件（有的会有多个dex文件）；</li>
<li>将下载下来的dex2jar压缩包解压，里面有一个<code>dex2jar.sh</code>脚本文件，执行如下命令：<strong><code>sh sh ./dex2jar.sh classes.dex文件地址</code></strong>即可生成对应的jar文件。</li>
<li>打开jd-gui应用，打开生成的jar文件，就可以看到反编译出来的代码了；</li>
</ol>
<p>以上可以反编译出对应的代码，但是资源文件，比如xml文件都不读，如果想要看这部分内容，需要用到另外一个工具:<br><strong>apktool</strong> <a href="http://ibotpeaches.github.io/Apktool/" target="_blank" rel="noopener">下载地址</a><br>它的作用就是用于将资源文件反解析成接近原始格式的样子的，并且可以在修改后重新build文件；可以一行行debug smali代码。相关资料：</p>
<ol>
<li><a href="http://ibotpeaches.github.io/Apktool/install/" target="_blank" rel="noopener">安装教程</a>;</li>
<li><a href="http://ibotpeaches.github.io/Apktool/documentation/" target="_blank" rel="noopener">使用教程</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ButterKnife 源码分析]]></title>
      <url>http://www.timebridge.space/2016/03/27/ButterKnife/</url>
      <content type="html"><![CDATA[<h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/logo_butterknife.png" width="188" alt="ButterKnife Logo"></div>

<p><strong>ButterKnife</strong> 是一个注解框架，项目地址: <a href="http://jakewharton.github.io/butterknife/" target="_blank" rel="noopener">ButterKnife</a> 。 简单使用🌰如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Bind</span>(R.id.title) TextView title;</span><br><span class="line">	<span class="meta">@Bind</span>(R.id.subtitle) TextView subtitle;</span><br><span class="line">	<span class="meta">@Bind</span>(R.id.footer) TextView footer;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.simple_activity);</span><br><span class="line">		ButterKnife.bind(<span class="keyword">this</span>);</span><br><span class="line">		<span class="comment">// TODO Use fields...</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@OnClick</span>(R.id.footer)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  		<span class="comment">// TODO submit data to server...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上这段代码可以代替以下这段代码:<a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(ExampleActivity activity)</span> </span>&#123;</span><br><span class="line">	activity.subtitle = (android.widget.TextView) activity.findViewById(<span class="number">2130968578</span>);</span><br><span class="line">	activity.footer = (android.widget.TextView) activity.findViewById(<span class="number">2130968579</span>);</span><br><span class="line">	activity.title = (android.widget.TextView) activity.findViewById(<span class="number">2130968577</span>);</span><br><span class="line">	</span><br><span class="line">	activity.footer..setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">			submit();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到，使用ButterKnife后可以不用再去写<code>findViewById</code>、<code>setOnClickListener</code>这样重复繁琐代码，通过<code>@Bind</code>、<code>@OnClick</code>注解就可以达到效果，代码简洁不少。</p>
<p>更多的例子和功能可以参见<a href="http://jakewharton.github.io/butterknife/" target="_blank" rel="noopener">官网示例</a>。</p>
<p>本文重点分析两个内容：</p>
<ol>
<li>ButterKnife的注解定义方式；</li>
<li>ButterKnife是如何运用编译时注解来提高效率的（在Android上，反射的效率较低）； </li>
</ol>
<h1 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h1><p>研究ButterKnife要具备一定的注解知识，CodeKK上有篇文章推荐阅读: <a href="http://a.codekk.com/detail/Android/Trinea/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%20Java%20%E6%B3%A8%E8%A7%A3%20Annotation" target="_blank" rel="noopener">《公共技术点之 Java 注解 Annotation》</a>。</p>
<p>关于运行时注解的开发，可以看这篇文章:<a href="http://www.race604.com/annotation-processing/" target="_blank" rel="noopener">Java注解处理器</a>。ButterKnife使用的是<code>com.google.auto.service:auto-service</code>包，通过其<code>AutoService</code>注解来实现编译时注解的开发。</p>
<p>另外也可以关注一下这个项目: <a href="https://bitbucket.org/hvisser/android-apt" target="_blank" rel="noopener">android-apt</a>。</p>
<h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><p>如下是ButterKnife的项目结构:</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/ButterKnife项目.png" width="250" alt="ButterKnife项目"></div>

<p>ButterKnife项目分为四个Module: Module butterknife-annotations中定义的是ButterKnife所支持的注解，butterknife-compiler中主要是编译时注解Processor。butterknife-sample则是一个使用例子。</p>
<p>下面我们就来逐步分析整个注解框架的实现。</p>
<h1 id="注解定义解析"><a href="#注解定义解析" class="headerlink" title="注解定义解析"></a>注解定义解析</h1><p>ButterKnife支持的注解主要分为四类:</p>
<ol>
<li>资源绑定。通过Id引用Array、Bitmap、Bool、Color、Dimen、Drawable、Int、String等几类资源；</li>
<li>事件绑定。包括onCheckedChanged、onClick、onItemClick、onItemLongClick等几种事件监听；</li>
<li>视图绑定。通过id实例化xml中的View；</li>
<li>Mark注解。Unbinder和Optional；</li>
</ol>
<h2 id="资源绑定注解定义"><a href="#资源绑定注解定义" class="headerlink" title="资源绑定注解定义"></a>资源绑定注解定义</h2><p>这类注解都以<code>BindXXX</code>的形式来命名，由于资源注解都只需要指定资源的id，因此定义的形式非常一致。下面以String资源为例，展示一下定义内容:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Bind a field to the specified string resource ID.</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;&lt;code&gt;</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@literal</span> @&#125;BindString(R.string.username_error) String usernameErrorText;</span></span><br><span class="line"><span class="comment"> * &lt;/code&gt;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention</span>(CLASS) <span class="meta">@Target</span>(FIELD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> BindString &#123;</span><br><span class="line">	<span class="comment">/** String resource ID to which the field will be bound. */</span></span><br><span class="line">	<span class="meta">@StringRes</span> <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里还用到了Android提供的资源注解，以保证返回的Id符合特定的资源。注解是编译时注解(CLASS)，适用于属性(FIELD)。</p>
<h2 id="事件绑定注解"><a href="#事件绑定注解" class="headerlink" title="事件绑定注解"></a>事件绑定注解</h2><p>事件绑定注解比较复杂，主要是因为以下三个方面:</p>
<ol>
<li>为View添加监听的方法是不一样的，比如<code>setOnClickListener</code>、<code>addTextChangedListener</code>、<code>setOnFocusChangeListener</code>等，方法名字本身不一致，且无规律可言；</li>
<li>这些方法只能绑定在特定的View上面；</li>
<li>监听需要实现的方法有很大的差别，具体可以参考<code>OnLongClickListener</code>和<code>TextWatcher</code>需要实现的方法的区别；</li>
</ol>
<p>因此在ButterKnife内部专门为此建立两个注解:<code>ListenerClass</code>和<code>ListenerMethod</code>（可以认为是ButterKnife支持事件绑定注解的元注解）。</p>
<h3 id="事件元注解"><a href="#事件元注解" class="headerlink" title="事件元注解"></a>事件元注解</h3><p>首先我们来看一下<code>ListenerMethod</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RUNTIME) <span class="meta">@Target</span>(FIELD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ListenerMethod &#123;</span><br><span class="line">	<span class="comment">/** Name of the listener method for which this annotation applies. */</span></span><br><span class="line">	<span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** List of method parameters. If the type is not a primitive it must be fully-qualified. */</span></span><br><span class="line">	String[] parameters() <span class="keyword">default</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Primitive or fully-qualified return type of the listener method. May also be &#123;<span class="doctag">@code</span> void&#125;. */</span></span><br><span class="line">	<span class="function">String <span class="title">returnType</span><span class="params">()</span> <span class="keyword">default</span> "<span class="keyword">void</span>"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** If &#123;<span class="doctag">@link</span> #returnType()&#125; is not &#123;<span class="doctag">@code</span> void&#125; this value is returned when no binding exists. */</span></span><br><span class="line">	<span class="function">String <span class="title">defaultReturn</span><span class="params">()</span> <span class="keyword">default</span> "<span class="keyword">null</span>"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个注解主要是定义一个方法的签名(方法名字、方法的参数、方法的返回类型)以及默认返回值。</p>
<p>再来看<code>ListenerClass</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RUNTIME) <span class="meta">@Target</span>(ANNOTATION_TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ListenerClass &#123;</span><br><span class="line">	<span class="function">String <span class="title">targetType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Name of the setter method on the &#123;<span class="doctag">@link</span> #targetType() target type&#125; for the listener. */</span></span><br><span class="line">	<span class="function">String <span class="title">setter</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Fully-qualified class name of the listener type. */</span></span><br><span class="line">	<span class="function">String <span class="title">type</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Enum which declares the listener callback methods. Mutually exclusive to &#123;<span class="doctag">@link</span> #method()&#125;. */</span></span><br><span class="line">	Class&lt;? extends Enum&lt;?&gt;&gt; callbacks() <span class="keyword">default</span> NONE.class;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Method data for single-method listener callbacks. Mutually exclusive with &#123;<span class="doctag">@link</span> #callbacks()&#125;</span></span><br><span class="line"><span class="comment">    * and an error to specify more than one value.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	ListenerMethod[] method() <span class="keyword">default</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Default value for &#123;<span class="doctag">@link</span> #callbacks()&#125;. */</span></span><br><span class="line">	<span class="keyword">enum</span> NONE &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个注解主要定义如下内容:</p>
<ol>
<li><strong>setter():</strong> 监听的设置方法全称；</li>
<li><strong>type():</strong> 监听类的类名全称；</li>
<li><strong>method():</strong> 监听类中有哪些方法；</li>
<li><strong>callback():</strong> 当一个监听有多个回调时，指定当前方法在哪个回调中调用，后面有详细阐述；</li>
</ol>
<p>注意，这两个注解都是用来修饰注解的：可以看到<code>@Target</code>都是<code>ANNOTATION_TYPE</code>类型的。</p>
<h3 id="事件注解"><a href="#事件注解" class="headerlink" title="事件注解"></a>事件注解</h3><p>由于事件的复杂性，注解定义本身差距比较大，先看一个简单的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(CLASS)</span><br><span class="line"><span class="meta">@ListenerClass</span>(</span><br><span class="line">    targetType = <span class="string">"android.widget.CompoundButton"</span>,</span><br><span class="line">    setter = <span class="string">"setOnCheckedChangeListener"</span>,</span><br><span class="line">    type = <span class="string">"android.widget.CompoundButton.OnCheckedChangeListener"</span>,</span><br><span class="line">    method = <span class="meta">@ListenerMethod</span>(</span><br><span class="line">        name = <span class="string">"onCheckedChanged"</span>,</span><br><span class="line">        parameters = &#123;</span><br><span class="line">            <span class="string">"android.widget.CompoundButton"</span>,</span><br><span class="line">            <span class="string">"boolean"</span></span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> OnCheckedChanged &#123;</span><br><span class="line">	<span class="comment">/** View IDs to which the method will be bound. */</span></span><br><span class="line">	<span class="meta">@IdRes</span> <span class="keyword">int</span>[] value() <span class="keyword">default</span> &#123; View.NO_ID &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，该注解同样是编译时注解，并且是用于修饰一个方法的。<br>其次，使用“元注解”修饰该注解：该注解是用于为ComPoundButton通过<code>setOnCheckedChangeListener</code>添加<code>OnCheckedChangeListener</code>监听的，该监听有一个需要实现的方法<code>onCheckedChanged</code>，该方法传入一个CompoundButton对象和布尔值作为参数。</p>
<p>最后我们关注一下这个注解本身：它只需要返回设置一组id即可，默认返回的是<code>View.NO_ID</code>。</p>
<p>这样就完成了一个事件注解的定义。这样看上去很抽象，我们看一个官网对<code>OnClick</code>注解的使用例子就清楚了:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OnClick</span>(&#123; R.id.door1, R.id.door2, R.id.door3 &#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pickDoor</span><span class="params">(DoorView door)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (door.hasPrizeBehind()) &#123;</span><br><span class="line">		Toast.makeText(<span class="keyword">this</span>, <span class="string">"You win!"</span>, LENGTH_SHORT).show();</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		Toast.makeText(<span class="keyword">this</span>, <span class="string">"Try again"</span>, LENGTH_SHORT).show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，就是为三个door View添加<code>onClickListener</code>监听。</p>
<p>那么如果一个监听有多个方法需要回调，又应该怎么办呢？比如ViewPager的<code>OnPageChangeListener</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">viewPager.setOnPageChangeListener(<span class="keyword">new</span> ViewPager.OnPageChangeListener() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageScrolled</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">float</span> v, <span class="keyword">int</span> i1)</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageSelected</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageScrollStateChanged</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果像<code>@onClick</code>那样绑定，我怎么知道绑定的是哪个方法呢？也就是说，是在哪个回调里面执行这个方法呢？这个是通过<code>callback</code>来实现的，我们看一下<code>@OnPageChange</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(CLASS)</span><br><span class="line"><span class="meta">@ListenerClass</span>(</span><br><span class="line">    targetType = <span class="string">"android.support.v4.view.ViewPager"</span>,</span><br><span class="line">    setter = <span class="string">"setOnPageChangeListener"</span>,</span><br><span class="line">    type = <span class="string">"android.support.v4.view.ViewPager.OnPageChangeListener"</span>,</span><br><span class="line">    callbacks = OnPageChange.Callback.class</span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> OnPageChange &#123;</span><br><span class="line">	<span class="comment">/** View IDs to which the method will be bound. */</span></span><br><span class="line">	<span class="meta">@IdRes</span> <span class="keyword">int</span>[] value() <span class="keyword">default</span> &#123; View.NO_ID &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Listener callback to which the method will be bound. */</span></span><br><span class="line">	<span class="function">Callback <span class="title">callback</span><span class="params">()</span> <span class="keyword">default</span> Callback.PAGE_SELECTED</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** &#123;<span class="doctag">@code</span> ViewPager.OnPageChangeListener&#125; callback methods. */</span></span><br><span class="line">	<span class="keyword">enum</span> Callback &#123;</span><br><span class="line">		<span class="comment">/** &#123;<span class="doctag">@code</span> onPageSelected(int)&#125; */</span></span><br><span class="line">		<span class="meta">@ListenerMethod</span>(</span><br><span class="line">			name = <span class="string">"onPageSelected"</span>,</span><br><span class="line">			parameters = <span class="string">"int"</span></span><br><span class="line">		PAGE_SELECTED,</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** &#123;<span class="doctag">@code</span> onPageScrolled(int, float, int)&#125; */</span></span><br><span class="line">		<span class="meta">@ListenerMethod</span>(</span><br><span class="line">			name = <span class="string">"onPageScrolled"</span>,</span><br><span class="line">			parameters = &#123;</span><br><span class="line">				<span class="string">"int"</span>,</span><br><span class="line">				<span class="string">"float"</span>,</span><br><span class="line">				<span class="string">"int"</span></span><br><span class="line">			&#125;</span><br><span class="line">		)</span><br><span class="line">		PAGE_SCROLLED,</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** &#123;<span class="doctag">@code</span> onPageScrollStateChanged(int)&#125; */</span></span><br><span class="line">    	<span class="meta">@ListenerMethod</span>(</span><br><span class="line">        	name = <span class="string">"onPageScrollStateChanged"</span>,</span><br><span class="line">        	parameters = <span class="string">"int"</span></span><br><span class="line">    	)</span><br><span class="line">    	PAGE_SCROLL_STATE_CHANGED,</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>callback其实是个枚举值，是一组ListenerMethod，映射到监听类的若干个方法，<code>@OnPageChange</code>注解就定义了三组，callback默认是<code>Callback.PAGE_SELECTED</code>，这个值代表的方法是<code>onPageSelected</code>，即如果按照下面的用法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OnPageChange</span>(R.id.example_pager) <span class="function"><span class="keyword">void</span> <span class="title">onPageSelected</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">	Toast.makeText(<span class="keyword">this</span>, <span class="string">"Selected "</span> + position + <span class="string">"!"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么就是当<code>onPageSelected</code>回调时，该方法会被调用。如果我想绑定到另外一个回调接口里面去，应该怎么办呢？可以如下使用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OnPageChange</span>(value = R.id.example_pager, callback = PAGE_SCROLL_STATE_CHANGED)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onPageStateChanged</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">	Toast.makeText(<span class="keyword">this</span>, <span class="string">"State changed: "</span> + state + <span class="string">"!"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以在<code>onPageScrollStateChanged</code>回调中调用这个方法了。</p>
<h2 id="视图绑定注解"><a href="#视图绑定注解" class="headerlink" title="视图绑定注解"></a>视图绑定注解</h2><p>和资源绑定注解很像，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Bind a field to the view for the specified ID. The view will automatically be cast to the field</span></span><br><span class="line"><span class="comment"> * type.</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;&lt;code&gt;</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@literal</span> @&#125;Bind(R.id.title) TextView title;</span></span><br><span class="line"><span class="comment"> * &lt;/code&gt;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention</span>(CLASS) <span class="meta">@Target</span>(FIELD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Bind &#123;</span><br><span class="line">	<span class="comment">/** View ID to which the field will be bound. */</span></span><br><span class="line">	<span class="meta">@IdRes</span> <span class="keyword">int</span>[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只不过这里返回的是一个int[]数组，因为<code>@Bind</code>实际支持将一组id绑定到一个数组或者List属性上。</p>
<h2 id="其余注解"><a href="#其余注解" class="headerlink" title="其余注解"></a>其余注解</h2><ol>
<li><strong>Unbinder</strong> 这个注解是为了给类生成一个Unbinder实例，这样可以将之前<code>bind</code>的变量全部解绑，后面有例子；</li>
<li><strong>Optional</strong> 可选项，有时候有些View、资源找不到，所以有些注入必须可选，否则就会Crash；</li>
</ol>
<h1 id="注解解析大致过程"><a href="#注解解析大致过程" class="headerlink" title="注解解析大致过程"></a>注解解析大致过程</h1><p>定义注解只是注解框架的一部分，代表着注解框架所支持的功能，解析注解是注解框架的另一个核心部分。下面我们来看看ButterKnife是如何实现编译时注解的。我们就从使用的例子上切入开始分析整个注解的运作过程。</p>
<h2 id="运行时解析"><a href="#运行时解析" class="headerlink" title="运行时解析"></a>运行时解析</h2><p>运行时解析源于ButterKnife的一行代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ButterKnife.bind(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<p>在任何需要使用ButterKnife的类中，这行代码都需要调用。我们看看这个方法做了什么:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(@NonNull Activity target)</span> </span>&#123;</span><br><span class="line">    bind(target, target, Finder.ACTIVITY);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(@NonNull Object target, @NonNull Object source, @NonNull Finder finder)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; targetClass = target.getClass();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">"Looking up view binder for "</span> + targetClass.getName());</span><br><span class="line">        ViewBinder&lt;Object&gt; viewBinder = findViewBinderForClass(targetClass);</span><br><span class="line">        viewBinder.bind(finder, target, source);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to bind views for "</span> + targetClass.getName(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>bind()</code>方法有很多重载方法，但是最终都会调用到方法<code>bind(@NonNull Object target, @NonNull Object source, @NonNull Finder finder)</code>。这个方法接受三个参数，我们关注一下第三个参数<code>Finder</code>，这个其实是一个枚举类，用于编译时生成的代码中，非常重要（后面就可以见到了），它主要的功能如下:<br><strong>为Activity、View、Dialog三种情景提供Context以及findViewById功能，并自带强制转换。</strong></p>
<p>这个方法会对targetClass进行解析，调用的方法是<code>findViewBinderForClass()</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, ViewBinder&lt;Object&gt;&gt; BINDERS = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ViewBinder&lt;Object&gt; NOP_VIEW_BINDER = <span class="keyword">new</span> ViewBinder&lt;Object&gt;() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ViewBinder&lt;Object&gt; <span class="title">findViewBinderForClass</span><span class="params">(Class&lt;?&gt; cls)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">    ViewBinder&lt;Object&gt; viewBinder = BINDERS.get(cls);</span><br><span class="line">    <span class="keyword">if</span> (viewBinder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">"HIT: Cached in view binder map."</span>);</span><br><span class="line">        <span class="keyword">return</span> viewBinder;</span><br><span class="line">    &#125;</span><br><span class="line">    String clsName = cls.getName();</span><br><span class="line">    <span class="keyword">if</span> (clsName.startsWith(<span class="string">"android."</span>) || clsName.startsWith(<span class="string">"java."</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">"MISS: Reached framework class. Abandoning search."</span>);</span><br><span class="line">        <span class="keyword">return</span> NOP_VIEW_BINDER;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class&lt;?&gt; viewBindingClass = Class.forName(clsName + <span class="string">"$$ViewBinder"</span>);</span><br><span class="line">        <span class="comment">//noinspection unchecked</span></span><br><span class="line">        viewBinder = (ViewBinder&lt;Object&gt;) viewBindingClass.newInstance();</span><br><span class="line">        <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">"HIT: Loaded view binder class."</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">"Not found. Trying superclass "</span> + cls.getSuperclass().getName());</span><br><span class="line">        viewBinder = findViewBinderForClass(cls.getSuperclass());</span><br><span class="line">    &#125;</span><br><span class="line">    BINDERS.put(cls, viewBinder);</span><br><span class="line">    <span class="keyword">return</span> viewBinder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里其实是为一个类创建一个ViewBinder<object>对象，并通过BINDERS做出缓存。这里注意一点: 当检测到时android或者java框架库中的类，则立即返回，否则就会默认去读取类中的<code>clsName + &quot;$$ViewBinder&quot;</code>类，并由这个类创建出ViewBinder<object>对象（可以猜测出这个类就是ViewBinder<object>类型的）。</object></object></object></p>
<p>可是我们在使用ButterKnife类的时候，并没有创建这个奇怪的类，那么这个类来自哪里呢？这个下一节再解释，我们继续往下分析，在<code>findViewBinderForClass</code>之后，调用的就是下面的方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">viewBinder.bind(finder, target, source);</span><br></pre></td></tr></table></figure>
<p>ViewBinder只是一个接口，框架里面没有相关实现，根据前面的分析，具体的实现应该在<code>clsName + &quot;$$ViewBinder&quot;</code>类中。</p>
<p>所以，我们去找<code>clsName + &quot;$$ViewBinder&quot;</code>类吧。</p>
<h2 id="编译时注解——代码生成"><a href="#编译时注解——代码生成" class="headerlink" title="编译时注解——代码生成"></a>编译时注解——代码生成</h2><p>研究编译时注解，我们需要找到Processor类，ButterKnife类的Processor类叫做<code>ButterKnifeProcessor</code>，它的<code>process</code>方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env)</span> </span>&#123;</span><br><span class="line">    Map&lt;TypeElement, BindingClass&gt; targetClassMap = findAndParseTargets(env);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;TypeElement, BindingClass&gt; entry : targetClassMap.entrySet()) &#123;</span><br><span class="line">        TypeElement typeElement = entry.getKey();</span><br><span class="line">        BindingClass bindingClass = entry.getValue();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bindingClass.brewJava().writeTo(filer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            error(typeElement, <span class="string">"Unable to write view binder for type %s: %s"</span>, typeElement,</span><br><span class="line">            e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个关键点是调用<code>findAndParseTargets</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Map&lt;TypeElement, BindingClass&gt; <span class="title">findAndParseTargets</span><span class="params">(RoundEnvironment env)</span> </span>&#123;</span><br><span class="line">    Map&lt;TypeElement, BindingClass&gt; targetClassMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; erasedTargetNames = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process each @Bind element.</span></span><br><span class="line">    <span class="keyword">for</span> (Element element : env.getElementsAnnotatedWith(Bind.class)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!SuperficialValidation.validateElement(element)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            parseBind(element, targetClassMap, erasedTargetNames);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logParsingError(element, Bind.class, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process each annotation that corresponds to a listener.</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;? extends Annotation&gt; listener : LISTENERS) &#123;</span><br><span class="line">        findAndParseListener(env, listener, targetClassMap, erasedTargetNames);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process each @BindArray element.</span></span><br><span class="line">    <span class="keyword">for</span> (Element element : env.getElementsAnnotatedWith(BindArray.class)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!SuperficialValidation.validateElement(element)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             parseResourceArray(element, targetClassMap, erasedTargetNames);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logParsingError(element, BindArray.class, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process each @BindBitmap element.</span></span><br><span class="line">    <span class="comment">// Process each @BindBool element.</span></span><br><span class="line">    <span class="comment">// Process each @BindColor element.</span></span><br><span class="line">    <span class="comment">// Process each @BindDimen element.</span></span><br><span class="line">    <span class="comment">// Process each @BindDrawable element.</span></span><br><span class="line">    <span class="comment">// Process each @BindInt element.</span></span><br><span class="line">    <span class="comment">// Process each @BindString element.    </span></span><br><span class="line">    <span class="comment">// Process each @Unbinder element.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try to find a parent binder for each.</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;TypeElement, BindingClass&gt; entry : targetClassMap.entrySet()) &#123;</span><br><span class="line">        String parentClassFqcn = findParentFqcn(entry.getKey(), erasedTargetNames);</span><br><span class="line">        <span class="keyword">if</span> (parentClassFqcn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            entry.getValue().setParentViewBinder(parentClassFqcn + BINDING_CLASS_SUFFIX);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">      </span><br><span class="line">     <span class="keyword">return</span> targetClassMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>粗略一看，这个方法就是遍历并且整理所有使用ButterKnife注解的元素，详细暂时略去不表。</p>
<p>继续往下看：在遍历这些元素之后再遍历<code>targetClassMap</code>，然后调用<code>bindingClass.brewJava().writeTo(filer);</code>方法创建文件，这就算生成处理完了，那么到底生成了什么东西呢？</p>
<h3 id="编译时注解运行结果"><a href="#编译时注解运行结果" class="headerlink" title="编译时注解运行结果"></a>编译时注解运行结果</h3><p>这里偷个懒，也是为了更快捷的达到目标：因为有module butterknife-sample，所以ButterKnife可以直接当做应用运行。我们run一下，然后在该下面目录结构下就可以看到一些文件:</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/Butter-Knife生成类.png" height="250" alt="Butter-Knife生成类"></div>

<p>如图，在这里就可以看到运行时注解自动生成的类——类名是以<code>$$ViewBinder</code>结尾的，以<code>SimpleActivity$$ViewBinder</code>为例，它的内容如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleActivity</span>$$<span class="title">ViewBinder</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SimpleActivity</span>&gt; <span class="keyword">implements</span> <span class="title">ViewBinder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> SimpleActivity$$ViewBinder() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(Finder finder, <span class="keyword">final</span> T target, Object source)</span> </span>&#123;</span><br><span class="line">        SimpleActivity$$ViewBinder.Unbinder unbinder = <span class="keyword">new</span> SimpleActivity$$ViewBinder.Unbinder(target);</span><br><span class="line">        View view = (View)finder.findRequiredView(source, <span class="number">2130968576</span>, <span class="string">"field \'title\'"</span>);</span><br><span class="line">        target.title = (TextView)finder.castView(view, <span class="number">2130968576</span>, <span class="string">"field \'title\'"</span>);</span><br><span class="line">        view = (View)finder.findRequiredView(source, <span class="number">2130968577</span>, <span class="string">"field \'subtitle\'"</span>);</span><br><span class="line">        target.subtitle = (TextView)finder.castView(view, <span class="number">2130968577</span>, <span class="string">"field \'subtitle\'"</span>);</span><br><span class="line">        view = (View)finder.findRequiredView(source, <span class="number">2130968578</span>, <span class="string">"field \'hello\', method \'sayHello\', and method \'sayGetOffMe\'"</span>);</span><br><span class="line">        target.hello = (Button)finder.castView(view, <span class="number">2130968578</span>, <span class="string">"field \'hello\'"</span>);</span><br><span class="line">        unbinder.view2130968578 = view;</span><br><span class="line">        view.setOnClickListener(<span class="keyword">new</span> DebouncingOnClickListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doClick</span><span class="params">(View p0)</span> </span>&#123;</span><br><span class="line">                target.sayHello();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        view.setOnLongClickListener(<span class="keyword">new</span> OnLongClickListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onLongClick</span><span class="params">(View p0)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> target.sayGetOffMe();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        view = (View)finder.findRequiredView(source, <span class="number">2130968579</span>, <span class="string">"field \'listOfThings\' and method \'onItemClick\'"</span>);</span><br><span class="line">        target.listOfThings = (ListView)finder.castView(view, <span class="number">2130968579</span>, <span class="string">"field \'listOfThings\'"</span>);</span><br><span class="line">        unbinder.view2130968579 = view;</span><br><span class="line">        ((AdapterView)view).setOnItemClickListener(<span class="keyword">new</span> OnItemClickListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(AdapterView&lt;?&gt; p0, View p1, <span class="keyword">int</span> p2, <span class="keyword">long</span> p3)</span> </span>&#123;</span><br><span class="line">                target.onItemClick(p2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        view = (View)finder.findRequiredView(source, <span class="number">2130968580</span>, <span class="string">"field \'footer\'"</span>);</span><br><span class="line">        target.footer = (TextView)finder.castView(view, <span class="number">2130968580</span>, <span class="string">"field \'footer\'"</span>);</span><br><span class="line">        target.headerViews = Utils.listOf(<span class="keyword">new</span> View[]&#123;(View)finder.findRequiredView(source, <span class="number">2130968576</span>, <span class="string">"field \'headerViews\'"</span>), (View)finder.findRequiredView(source, <span class="number">2130968577</span>, <span class="string">"field \'headerViews\'"</span>), (View)finder.findRequiredView(source, <span class="number">2130968578</span>, <span class="string">"field \'headerViews\'"</span>)&#125;);</span><br><span class="line">        target.unbinder = unbinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Unbinder</span> <span class="keyword">implements</span> <span class="title">butterknife</span>.<span class="title">ButterKnife</span>.<span class="title">Unbinder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> SimpleActivity target;</span><br><span class="line">        View view2130968578;</span><br><span class="line">        View view2130968579;</span><br><span class="line"></span><br><span class="line">        Unbinder(SimpleActivity target) &#123;</span><br><span class="line">            <span class="keyword">this</span>.target = target;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unbind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Bindings already cleared."</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.target.title = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">this</span>.target.subtitle = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">this</span>.view2130968578.setOnClickListener((OnClickListener)<span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">this</span>.view2130968578.setOnLongClickListener((OnLongClickListener)<span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">this</span>.target.hello = <span class="keyword">null</span>;</span><br><span class="line">                ((AdapterView)<span class="keyword">this</span>.view2130968579).setOnItemClickListener((OnItemClickListener)<span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">this</span>.target.listOfThings = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">this</span>.target.footer = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">this</span>.target.headerViews = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">this</span>.target.unbinder = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">this</span>.target = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类就是我们要找的类，也是 <strong>注解解析</strong> 一节中调用<code>Binder.bind()</code>方法时用于绑定的类，注意这个类：它实现了ViewBinder接口。再看一下<code>bind</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(@NonNull Object target, @NonNull Object source, @NonNull Finder finder)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; targetClass = target.getClass();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">"Looking up view binder for "</span> + targetClass.getName());</span><br><span class="line">        ViewBinder&lt;Object&gt; viewBinder = findViewBinderForClass(targetClass);</span><br><span class="line">        viewBinder.bind(finder, target, source);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to bind views for "</span> + targetClass.getName(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>viewBinder.bind(finder, target, source);</code>调用的就是生成类中的<code>bind</code>方法。我们取方法中的一小段来看:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">View view = (View)finder.findRequiredView(source, <span class="number">2130968576</span>, <span class="string">"field \'title\'"</span>);</span><br><span class="line">target.title = (TextView)finder.castView(view, <span class="number">2130968576</span>, <span class="string">"field \'title\'"</span>);</span><br></pre></td></tr></table></figure>
<p>这里就通过finder的<code>findRequiredView</code>和<code>castView</code>两个方法来为target的title属性来赋值了。这里其实略有多余，不需要再添加<code>(TextView)</code>强转，看一下<code>castView</code>方法的实现就好了:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">castView</span><span class="params">(View view, <span class="keyword">int</span> id, String who)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (T) view;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">   		<span class="keyword">if</span> (who == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">		&#125;</span><br><span class="line">      	String name = getResourceEntryName(view, id);</span><br><span class="line">      	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"View '"</span></span><br><span class="line">          + name</span><br><span class="line">          + <span class="string">"' with ID "</span></span><br><span class="line">          + id</span><br><span class="line">          + <span class="string">" for "</span></span><br><span class="line">          + who</span><br><span class="line">          + <span class="string">" was of the wrong type. See cause for more info."</span>, e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里已经使用泛型进行强转了。</p>
<p>到这里，我们大致可以明白ButterKnife的实现原理了:<br><strong>为注解类生成一个对应的ViewBinder类，自动生成<code>findViewById</code>等模板代码，在运行的时候，反射实例化ViewBinder类，调用它的<code>bind()</code>方法完成注解——这里只有在生成ViewBinder对象的时候使用了反射，其余代码均是正常的调用。</strong></p>
<p>从生成的代码里面还可以看到Unbinder这个内部类：生成它是因为SimpleActivity里面有这样的用法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Unbinder</span> ButterKnife.Unbinder unbinder;</span><br></pre></td></tr></table></figure>
<p>在<code>unbinder()</code>方法里面，我们可以看到把注入的内容全部删除了，这也就是<code>@Unbinder</code>注解的使用方法。</p>
<p>好了，到了这里，我们大致能知道ButterKnife是怎么玩的了，但是具体如何生成类这一块还不是很清楚。<strong>下一节我们来重点分析：ButterKnife是如何生成一个类的。</strong></p>
<h1 id="生成类"><a href="#生成类" class="headerlink" title="生成类"></a>生成类</h1><p>讲解这个需要我们基于前面的分析，在<code>findAndParseTargets</code>方法中，有很多的<code>parseXXX</code>方法调用。根据前面的分析，基本可以确定一个注解类XXX会对应生成<code>XXX$$ViewBinder</code>类，那么我们先确定：ButterKnife如何确定需要生成哪些类，属性又是如何规整到这些类里面去的？即：怎么知道生成一个类的所有信息。</p>
<h2 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h2><p>我们来看一个<code>parseResourceInt</code>方法，这是处理所有的Int资源的类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseResourceInt</span><span class="params">(Element element, Map&lt;TypeElement, BindingClass&gt; targetClassMap,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  Set&lt;String&gt; erasedTargetNames)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">boolean</span> hasError = <span class="keyword">false</span>;</span><br><span class="line">	<span class="comment">// A</span></span><br><span class="line">	TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Verify that the target type is int.</span></span><br><span class="line">	<span class="keyword">if</span> (element.asType().getKind() != TypeKind.INT) &#123;</span><br><span class="line">		error(element, <span class="string">"@%s field type must be 'int'. (%s.%s)"</span>, BindInt.class.getSimpleName(),</span><br><span class="line">		enclosingElement.getQualifiedName(), element.getSimpleName());</span><br><span class="line">		hasError = <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Verify common generated code restrictions.</span></span><br><span class="line">	hasError |= isInaccessibleViaGeneratedCode(BindInt.class, <span class="string">"fields"</span>, element);</span><br><span class="line">	hasError |= isBindingInWrongPackage(BindInt.class, element);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (hasError) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Assemble information on the field.</span></span><br><span class="line">	String name = element.getSimpleName().toString();</span><br><span class="line">	<span class="keyword">int</span> id = element.getAnnotation(BindInt.class).value();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// B</span></span><br><span class="line">	BindingClass bindingClass = getOrCreateTargetClass(targetClassMap, enclosingElement);</span><br><span class="line">	FieldResourceBinding binding = <span class="keyword">new</span> FieldResourceBinding(id, name, <span class="string">"getInteger"</span>, <span class="keyword">false</span>);</span><br><span class="line">	bindingClass.addResource(binding);</span><br><span class="line"></span><br><span class="line">	erasedTargetNames.add(enclosingElement.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看A处，这里调用了一个<code>getEnclosingElement()</code>方法，这个方法是干啥的呢？官网文档解释如下:</p>
<blockquote>
<p>返回此元素直接封装（非严格意义上）的元素。 类或接口被认为用于封装它直接声明的字段、方法、构造方法和成员类型。这包括所有（隐式）默认构造方法和枚举类型的隐式 values 和 valueOf 方法。 包封装位于其中的顶层类和接口，但不认为它封装了子包。 当前不认为其他种类的元素封装了任何元素；但是，随着此 API 或编程语言的发展，这种情况可能发生改变。</p>
</blockquote>
<p>从ButterKnife的注解定义来看，注解使用在方法或者属性上面，那么通过这个方法就可以获取到封装这些元素的类。接下来我们看B处，先看一下<code>getOrCreateTargetClass</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BINDING_CLASS_SUFFIX = <span class="string">"$$ViewBinder"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> BindingClass <span class="title">getOrCreateTargetClass</span><span class="params">(Map&lt;TypeElement, BindingClass&gt; targetClassMap, TypeElement enclosingElement)</span> </span>&#123;</span><br><span class="line">	BindingClass bindingClass = targetClassMap.get(enclosingElement);</span><br><span class="line">	<span class="keyword">if</span> (bindingClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">		String targetType = enclosingElement.getQualifiedName().toString();</span><br><span class="line">		String classPackage = getPackageName(enclosingElement);</span><br><span class="line">		String className = getClassName(enclosingElement, classPackage) + BINDING_CLASS_SUFFIX;</span><br><span class="line"></span><br><span class="line">		bindingClass = <span class="keyword">new</span> BindingClass(classPackage, className, targetType);</span><br><span class="line">		targetClassMap.put(enclosingElement, bindingClass);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bindingClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很清楚：这里会往targetClassMap里面存储一个Entry，Key为enclosingElement（即外部类），Value为BindingClass。BindingClass初始化记录了三样东西: 原先的注解类类名、原先的注解类所在包名和要生成的注解类类名（<code>XXX$$ViewBinder</code>）。</p>
<p>我们继续看B处，在获取到这个BindingClass之后，就执行如下代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FieldResourceBinding binding = <span class="keyword">new</span> FieldResourceBinding(id, name, <span class="string">"getInteger"</span>, <span class="keyword">false</span>);</span><br><span class="line">bindingClass.addResource(binding);</span><br></pre></td></tr></table></figure>
<p>这个代码生成一个FieldResourceBinding对象然后添加到BindingClass中。</p>
<p>由此我们可以看到整个解析过程: <strong>遍历所有的注解元素，并通过<code>getEnclosingElement()</code>获取声明这些元素的类，所有需要创建的类信息都维护在<code>targetClassMap</code>Map数据结构中，Key为注解使用类，Value为BindingClass——后续将根据这个BindingClass生成代码。所有的注解元素都将经过解析存储到BindingClass中（类似FieldResourceBinding这样的属性），最终解析完成，所有需要生成的类都可以通过<code>targetClassMap</code>索引到</strong>。</p>
<h2 id="写入过程"><a href="#写入过程" class="headerlink" title="写入过程"></a>写入过程</h2><p>写入过程是这样的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;TypeElement, BindingClass&gt; entry : targetClassMap.entrySet()) &#123;</span><br><span class="line">	TypeElement typeElement = entry.getKey();</span><br><span class="line">	BindingClass bindingClass = entry.getValue();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		bindingClass.brewJava().writeTo(filer);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		error(typeElement, <span class="string">"Unable to write view binder for type %s: %s"</span>, typeElement, e.getMessage());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就是遍历所有的BindingClass，调用<code>brewJava()</code>，这个方法涉及到的知识以及后面<code>writeTo()</code>方法均来自于<a href="https://github.com/square/javapoet" target="_blank" rel="noopener">javapoet项目</a>，这个项目可以很方便的根据一些信息生成一个Java类，此处不赘述。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ButterKnife不但使用方便，而且通过编译时注解，减少了反射的使用，提高了注解解析的效率，确实非常赞。</p>
<p>最后推荐一个Android Studio插件用于生成ButterKnife代码，地址如下: <a href="https://github.com/avast/android-butterknife-zelezny" target="_blank" rel="noopener">android-butterknife-zelezny</a>，可以用于快速生成ButterKnife注解代码。</p>
<p>鉴于某些项目由于方法数问题或者其余原因没有使用ButterKnife，程序员们被逼要写<code>findViewById</code>这样的代码，还得去XML里面翻找id，我基于以上插件，改写了另外一个插件，地址如下：<a href="https://github.com/BigFootprint/AndroidViewGenerator" target="_blank" rel="noopener">AndroidViewGenerator</a>，欢迎使用。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MVC，MVP，MVVM]]></title>
      <url>http://www.timebridge.space/2016/03/24/mvc-mvp-mvvm/</url>
      <content type="html"><![CDATA[<p>本来想写一篇从MVC -&gt; MVP -&gt; MVVM演变过程的文章，介绍一下各自的不同点和适用常场景。但是查了一些资料之后，觉得对于MVC和MVP的理解是仁者见仁智者见智的，很多文章看上去叙述都是比较靠谱的，但是在一些细节上有所不同。本文不打算深究这些不同，而是思考一下为什么会出现这样的划分。</p>
<p>这里推荐一些文章，可以帮助理解这些这几个模式:</p>
<ol>
<li><a href="http://www.wildcrest.com/Potel/Portfolio/mvp.pdf" target="_blank" rel="noopener">MVP: Model-View-Presenter<br>he Taligent Programming Model for C++ and Java</a></li>
<li><a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller" target="_blank" rel="noopener">Model–view–controller</a></li>
<li><a href="https://medium.com/hacking-and-gonzo/flux-vs-mvc-design-patterns-57b28c0f71b7#.in4m1jpvu" target="_blank" rel="noopener">Flux vs. MVC (Design Patterns)</a></li>
<li><a href="http://www.tutorialspoint.com/design_pattern/mvc_pattern.htm" target="_blank" rel="noopener">Design Patterns - MVC Pattern</a> </li>
<li><a href="http://martinfowler.com/eaaDev/SeparatedPresentation.html" target="_blank" rel="noopener">Separated Presentation</a></li>
<li><a href="http://www.infragistics.com/community/blogs/todd_snyder/archive/2007/10/17/mvc-or-mvp-pattern-whats-the-difference.aspx" target="_blank" rel="noopener">MVC or MVP Pattern – Whats the difference?</a></li>
</ol>
<p><a id="more"></a>如果一个应用很小，那么以什么样子的方式写问题都是不大的，比如以前上学的时候做的课堂作业，功能简单，不需要后期维护，从没想过设计的问题。</p>
<p>当应用大了以后，功能变得复杂起来：可能需要修改原有的功能，可能新开发的功能与原有的功能有交集，那不管是几个人写，有些问题都需要注意起来。</p>
<blockquote>
<p>不要逞强，觉得一个人维护的应用可以按照自己的性子写，写得多了也扛不住，有血泪教训的。</p>
</blockquote>
<p>比如不要重复代码，保持类或者模块的职责单一，高内聚低耦合，一开始可能不觉得有什么，但是一旦复杂起来就会发现注意这些点是多么的可贵。</p>
<blockquote>
<p>遇到过因为Copy代码导致出Bug的情况，因为只记得修改一个地方。也遇到过因为类的职责过于庞大，导致修改的时候小心翼翼，因为连变量名字取起来都觉得要重复了，后期相关功能的开发都需要去修改这个类。</p>
</blockquote>
<p>看了一些资料，感觉这几个模式都在试图践行以下两个原则:</p>
<ol>
<li>保持职责单一: 一个模块一个目的，该干啥干啥；</li>
<li>分离易变和不易变的部分: 不易变化的部分相对稳定，维护起来既不容易分心，也容易复用，变化的部分将以最小的代价变化；</li>
</ol>
<p>实际上MVC/MVP模式设计还有一个很重要的目的: 方便测试。UI测试比业务逻辑测试要难的多，而且业务逻辑的测试相对而言更加重要。MVC/MVP其实就是建立在这几点基础上，不信我们下面来慢慢分析。</p>
<p>基于以上这些目的，MVC/MVP首先要做的事情就是分离出UI层(因为UI层不不容易进行测试且易变)。那么应该怎么分离呢？</p>
<p>关于这一点，【推荐5】里面说的非常详细，并且给出了一个很好的例子，读者可以去仔细揣摩一下，应该可以很直观的感受到如何做以及这样做的好处。作者还给出了一个分离的标准，这个标准非常非常好，这样可以把View很彻底的拉出去:</p>
<p><strong>假设我要为这个应用重写一个UI层，使用的也是同样的设计方式，那么新的UI层和旧有的UI层之间会有相同代码么？如果有，那么极有可能这段代码应该放到业务层去。</strong>  </p>
<p>分层之后就会产生一个问题: 两层之间如何交互。我们遵循【推荐5】的叫法，把这两层称为Presentation层和Domain层。交互分为两个方向:  </p>
<ol>
<li><strong>Presentation层-&gt;Domain层</strong> Presentation层主动触去调用业务层的方法处理业务逻辑，就像【推荐5】中的例子，这样没啥问题；</li>
<li><strong>Domain层-&gt;Presentation层</strong> 要Domain层能主动更新Presentation层，有两个办法，第一个是Domain层持有Presentation层的引用，第二个办法是Presentation层在Domain层设置观察者。</li>
</ol>
<p>Presentation层-&gt;Domain层问题不大，问题主要出现在Domain层-&gt; Presentation层这个方向上，第一种办法肯定不行，这样Domain层依赖于Presentation层，还怎么单独做测试？第二个办法比较靠谱，这种办法和MVP推崇的P和V之间的交互类似，V和P之间是通过接口交互的，V实现该接口，P引用该接口(面向接口编程)。</p>
<p>为什么说这样靠谱呢？因为这样就可以很容易的撇开Presentation层进行单元测试了。通过逻辑分离+面向接口，我们完全可以在测试的时候Mock一个“Presentation”，来对Presentation层调用的所有接口进行测试。</p>
<p>接着我们设想一下真实的开发场景，如果Domain层就这样做成一块，那么随着业务的复杂化，Domain层会变得越来越庞大(Presentation层一般不会，后面会提到如果出现了应该怎么办)。</p>
<p>那么如何维护Domain层呢？我们遵循目标2再进行分层。对于一个应用来说，它的数据基础相对稳定，即数据对象模型比较稳定，可以单独将这块抽出来成一个模块，稳定的为App提供所需的数据支持，比如加载、保存等，暂时称之为数据层。Domain层剥离掉数据层，剩下的就是业务逻辑，暂时称这一层为业务层。</p>
<blockquote>
<p>到这里，其实就已经看到了MVP模型了。</p>
</blockquote>
<p>我们可以将业务逻辑独立到另外一个模块中去，这个模块有如下特性：易变而且复杂。这个模块和其余两个模块什么关系呢？</p>
<p>首先我们牢记一点，分离Presentation层是为了测试剩余的业务代码，那么我们决不能将Presentation层的东西、概念引入到数据层和业务层中去。其次数据层是提供较原始数据的地方，它必须经过处理才可以丢给Presentation显示，Presentation层的操作也需要映射成一些方法的调用和逻辑操作才能传到数据层进行相关的保存操作，而这一层处理、映射就是交给业务层来实现的。</p>
<p>因此可以看到MVP模式下，View(UI层)和Model(数据层)之间是没有交互的，一切都是通过Presenter(业务层)来中转的。这样的设计，将最易变的部分放在业务层中，通过业务层隔离Presentation层和数据层，能够较大限度的使这两个部分变得灵活。</p>
<p>这种模式设计也解决了之前我们遇到的问题: 即一个业务层支持多个Presentation层。MVP里面是主张一个View对应一个或者多个Presenter的，这时的既可以重用也可以多样化，为什么呢？因为我们把不变的Model层抽离出去了，如果业务层需要变化，那么一定是不带重复的变化。Presenter变成了仅仅处理业务逻辑的地点，粒度上也更好控制。</p>
<p>举个🌰，比如我写一个Android Activity，这个Activity上有多个Fragment。我可以为这些Fragment配置一个统一的Presenter，但是我也可以为每一个Fragment配置一个Presenter。甚至因为一个Fragment上显示的元素之间相对独立，比如我有一个广告位，这个广告位和页面的其余元素毫无关系，并且广告位还可以在其余页面上重用，那我就可以单独为这个广告位View配置一个Presenter，这样一个Fragment也可以对应多个Presenter了。这种粒度控制变得相当灵活。如下图，View和Model之间可以任意拼接合适的Presenter:</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/MVP模式.png" width="250" alt="MVP模式"></div>

<p>应用说白了其实就是通过UI展示数据，修改数据的工具。举个例子: 你下一个外卖单，首先浏览附近的商户，这就是展示数据，最后下单，其实就是为这个账户在数据库中插入一条订单数据。整个应用就是在干这件事。因此数据本身是相对稳定的，而UI呢，很灵活易变（显示内容会变化，形式也会变化，比如以H5的形式显示）。这两块都应当独立出去，剩下的就是业务逻辑，还是以下外卖单为例，创建订单前，可能需要校验配送距离，是否能参加立减活动，这些东西非常易变，理应单独抽离出来。</p>
<p>通过以上职责分配，我们大致可以将应用分为三个模块:</p>
<ol>
<li><strong>View层</strong> 负责显示，没有任何的业务逻辑；</li>
<li><strong>Model层</strong> 负责提供数据，也没有复杂的业务逻辑，只负责简单的操作数据；</li>
<li><strong>Presenter层</strong> 负责业务逻辑，是View和Model的中间中转层；</li>
</ol>
<p>这种分层分块，是满足我们的三个目标的。【推荐6】里面也指出，这样的分配有助于各个模块的单独发展。比如Model层的ORM，View层的注解，Presenter层的也有IOC框架支持。</p>
<p>以上，就是为什么一个App可以划分出三个大块的原因。每一个大块本身也可以做出更细粒度的划分，比如数据层也可以划分出Service层，这些内部的划分很大程度上也是为了实现前面所说的两个目标，使得代码更好维护。</p>
<blockquote>
<p>以上是结合日常开发和这三种模式设计的一些思考，后期有所实践再做补充。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[观影《荒野猎人》]]></title>
      <url>http://www.timebridge.space/2016/03/20/the-revenant/</url>
      <content type="html"><![CDATA[<p>小李子的大片: <a href="https://movie.douban.com/subject/5327268/?source=new_aladdin" target="_blank" rel="noopener">荒野猎人</a></p>
<p>说实话，看的好累，情节好普通，不过小李演得很卖力。</p>
<p>一直不明白欧美这类电视剧是怎么拍的，或许我该去知乎上提个问题。就像《斯巴达克斯》和《冰与火之歌》一样，这类剧拍摄的世界，充斥着脏水和淤泥，生活在那里的人仿佛这个年代的乞丐，处处透露着原始生活的气息。一方面好心疼演员，一方面也感叹就这样的原始人，在他们茹毛饮血的年代，我们已经诗词歌赋、亭台楼阁，然区区两三百年就翻身成为文明人，看来不光复仇之剑掌握在上帝手中，命运之秤也掌握在上帝手中啊。<a id="more"></a></p>
<p>这部剧就像拍摄的那个世界一样，静悄悄的，直到最后雪崩了一下，小李耍了点手段干掉了坏蛋，没有宏大的场面，没有男女主角的激情戏，和我印象里面的欧美大片相去甚远（小李躲进🐴肚子的情节被我猜到了，都忘了在哪里看到过类似的场景了）。但我必须赞一下这部电影拍摄的自然风光，啊啊啊！！我都要称赞这部电影为壁纸电影——我觉得太多太多的画面，摄影师都花费了巨大的心思拍摄构图，以至于这些画面充当电脑桌面绰绰有余，时时刻刻都想静下来欣赏一下风光（PS：看过Mac自带壁纸的人感触应该更深）。</p>
<p>有一个印象比较深刻的场面就是小李和熊的搏斗：我终于明白什么叫完虐…怪不得有人说小李被熊强了，那个动作确实有点像…另外，装死真的管用？</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ADB 介绍]]></title>
      <url>http://www.timebridge.space/2016/02/29/Android-adb/</url>
      <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>ADB，全称Android Debug Bridge</strong>，是一个集成了与调试机器(真机/模拟器)通信丰富功能的命令行工具，它是client-server模式的，包括三个部分:</p>
<ol>
<li><strong>Client</strong> 运行在你的开发机器上(例如电脑)，开发者可以通过在shell中运行adb命令来调用client，另外像DDMS这样的工具也会创建一个adb client；</li>
<li><strong>Daemon</strong> 运行在真机或者模拟器上，接受并处理adb命令； </li>
<li><strong>Server</strong> 在你的开发机上运行的后台进程，它负责管理Client和Daemon之间的交互；<a id="more"></a>
adb命令工具可以在 <strong><sdk>/platform-tools</sdk></strong> 下面可以找到。</li>
</ol>
<p>当一个Client启动的时候，Client会检测有没有adb Server进程在运行，如果没有，它就会启动一个。当Server启动起来后，它就会绑定到本地机器的5037端口监听从adb Client发来的命令。所有的adb Client都使用5037端口与Server通信。</p>
<p>adb Server负责建立与所有的模拟器/真机的连接。它会扫描所有模拟器/真机在[5555, 5585]之间的奇数端口去寻找adb Daemon，一旦找到就会连接到该端口。连接建立后，就可以通过adb命令来操作模拟器/真机。因为Server维护着到这些模拟器/真机的所有的实例，同时也处理所有的adb Client的命令，因此开发者可以从任何一个Client控制任何一台模拟器/真机(Server其实是一个消息转发中心)。</p>
<h2 id="ADB命令"><a href="#ADB命令" class="headerlink" title="ADB命令"></a>ADB命令</h2><h3 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h3><p>adb命令的格式是这样的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb [-d|-e|-s &lt;serialNumber&gt;] &lt;command&gt;</span><br></pre></td></tr></table></figure>
<p>其中 <strong>[-d|-e|-s <serialnumber>]</serialnumber></strong> 是用于在多设备状态下选择命令目标设备的，含义分别如下:</p>
<blockquote>
<p><code>-d</code> : Direct an adb command to the only attached USB device.<br><code>-e</code> : Direct an adb command to the only running emulator instance.<br><code>-s &lt;serialNumber&gt;</code> : Direct an adb command a specific emulator/device instance, referred to by its adb-assigned serial number (such as “emulator-5556”).</p>
</blockquote>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>即 <code>&lt;command&gt;</code> 部分。</p>
<h4 id="1-devices"><a href="#1-devices" class="headerlink" title="1. devices"></a>1. <code>devices</code></h4><p>Prints a list of all attached emulator/device instances.打印格式如下 : [serialNumber] [state]。state有三种: </p>
<ol>
<li><strong>offline</strong> 机器没有连接或者不响应adb命令</li>
<li><strong>device</strong> 机器连接正常</li>
<li><strong>no device</strong> 没有任何机器连接</li>
</ol>
<p>使用如下命令即可以指定一个设备运行命令，示例如下：<br><code>adb -s [serialNumber] shell wm size</code></p>
<h4 id="2-logcat-option-filter-specs"><a href="#2-logcat-option-filter-specs" class="headerlink" title="2. logcat [option] [filter-specs]"></a>2. <code>logcat [option] [filter-specs]</code></h4><p>Prints log data to the screen.</p>
<h4 id="3-install-lt-path-to-apk-gt"><a href="#3-install-lt-path-to-apk-gt" class="headerlink" title="3. install &lt;path-to-apk&gt;"></a>3. <code>install &lt;path-to-apk&gt;</code></h4><p>Pushes an Android application (specified as a full path to an .apk file) to an emulator/device.</p>
<h4 id="4-pull-lt-remote-gt-lt-local-gt"><a href="#4-pull-lt-remote-gt-lt-local-gt" class="headerlink" title="4. pull &lt;remote&gt; &lt;local&gt;"></a>4. <code>pull &lt;remote&gt; &lt;local&gt;</code></h4><p>Copies a specified file from an emulator/device instance to your development computer.</p>
<h4 id="5-push-lt-local-gt-lt-remote-gt"><a href="#5-push-lt-local-gt-lt-remote-gt" class="headerlink" title="5.push &lt;local&gt; &lt;remote&gt;"></a>5.<code>push &lt;local&gt; &lt;remote&gt;</code></h4><p>Copies a specified file from your development computer to an emulator/device instance.</p>
<h4 id="6-start-server"><a href="#6-start-server" class="headerlink" title="6. start-server"></a>6. <code>start-server</code></h4><p>Checks whether the adb server process is running and starts it, if not.</p>
<h4 id="7-kill-server"><a href="#7-kill-server" class="headerlink" title="7. kill-server"></a>7. <code>kill-server</code></h4><p>Terminates the adb server process.</p>
<h4 id="8-get-serialno"><a href="#8-get-serialno" class="headerlink" title="8. get-serialno"></a>8. <code>get-serialno</code></h4><p>Prints the adb instance serial number string.</p>
<h4 id="9-shell"><a href="#9-shell" class="headerlink" title="9. shell"></a>9. <code>shell</code></h4><p>Starts a remote shell in the target emulator/device instance.</p>
<h4 id="10-adb-shell-dumpsys-activity-top"><a href="#10-adb-shell-dumpsys-activity-top" class="headerlink" title="10. adb shell dumpsys activity top"></a>10. <code>adb shell dumpsys activity top</code></h4><p>打印栈顶Activity的信息（类名、布局信息）。</p>
<blockquote>
<p>PS: 这个命令是<code>adb shell dumpsys</code>的子集，<code>adb shell dumpsys</code>可以dump整个系统的信息，曾经用来追踪注册到系统的广播，非常有用，但是信息量大的时候速度比较慢，后面加上别的参数可以更有针对性的dump信息。</p>
</blockquote>
<h4 id="11-adb-shell-pm-list-instrumentation"><a href="#11-adb-shell-pm-list-instrumentation" class="headerlink" title="11. adb shell pm list instrumentation"></a>11. <code>adb shell pm list instrumentation</code></h4><p>打印所有的intrumentation包。</p>
<h4 id="12-adb-logcat-c"><a href="#12-adb-logcat-c" class="headerlink" title="12. adb logcat -c"></a>12. <code>adb logcat -c</code></h4><p>清空日志。</p>
<h4 id="13-adb-shell-wm-size"><a href="#13-adb-shell-wm-size" class="headerlink" title="13. adb shell wm size"></a>13. <code>adb shell wm size</code></h4><p>打印屏幕尺寸。</p>
<h4 id="14-adb-shell-wm-density"><a href="#14-adb-shell-wm-density" class="headerlink" title="14. adb shell wm density"></a>14. <code>adb shell wm density</code></h4><p>打印屏幕密度。</p>
<h4 id="15-adb-shell-dumpsys-window-displays"><a href="#15-adb-shell-dumpsys-window-displays" class="headerlink" title="15. adb shell dumpsys window displays"></a>15. <code>adb shell dumpsys window displays</code></h4><p>显示屏幕参数。</p>
<h3 id="无线调试"><a href="#无线调试" class="headerlink" title="无线调试"></a>无线调试</h3><p>Android还支持无线调试，步骤如下:</p>
<ol>
<li>连接到同一个Wifi上；</li>
<li>用USB线连接手机和电脑，并通过<code>adb tcpip 5555</code>命令设置设备在5555端口上监听TCP/IP连接，之后拔出USB线；</li>
<li>找到手机的IP地址，使用<code>adb connect &lt;device-ip-address&gt;</code>命令连接设备；</li>
<li>使用<code>adb devices</code>命令查看设备是否被连接；</li>
</ol>
<p>官网上也有提到有关防火墙的设置，需要支持ADB无线调试才行。我在公司试了一下，是不行的。断开无线连接的命令是<code>adb disconnect &lt;device-ip-address&gt;</code>。</p>
<h3 id="Shell命令"><a href="#Shell命令" class="headerlink" title="Shell命令"></a>Shell命令</h3><p>ADB提供了一个Unix Shell，以便于可以在连接的设备上执行一些命令，相关的命令二进制数据存储在设备文件系统下面，地址是 <strong>/system/bin/…</strong></p>
<p>执行shell命令有两种办法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不进入shell，而是直接运行一个shell命令</span></span><br><span class="line">adb [-d|-e|-s &lt;serialNumber&gt;] shell &lt;shell_command&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进入shell模式后再执行</span></span><br><span class="line">adb [-d|-e|-s &lt;serialNumber&gt;] shell</span><br></pre></td></tr></table></figure>
<h3 id="am命令"><a href="#am命令" class="headerlink" title="am命令"></a>am命令</h3><p><strong>am，即activity manager</strong>。我们可以使用这个工具来触发一些系统行为，比如启动Activity，停止进程，发送广播，修改屏幕属性(在Nexus5 + 6.0上尝试有关命令，发现找不到)等。在shell里使用 <code>am &lt;command&gt;</code> 即可。常见易用的命令如下:</p>
<h4 id="1-force-stop-lt-PACKAGE-gt"><a href="#1-force-stop-lt-PACKAGE-gt" class="headerlink" title="1. force-stop &lt;PACKAGE&gt;"></a>1. <code>force-stop &lt;PACKAGE&gt;</code></h4><p>Force stop everything associated with <package> (the app’s package name).</package></p>
<h4 id="2-start-options-lt-INTENT-gt"><a href="#2-start-options-lt-INTENT-gt" class="headerlink" title="2. start [options] &lt;INTENT&gt;"></a>2. <code>start [options] &lt;INTENT&gt;</code></h4><p>Start an Activity specified by <a href="https://developer.android.com/intl/zh-cn/tools/help/shell.html#IntentSpec" target="_blank" rel="noopener"><intent></intent></a>.可以携带Url等参数打开一个Acitivity，由此可以攻击别人的应用。</p>
<h4 id="3-broadcast-options-lt-INTENT-gt"><a href="#3-broadcast-options-lt-INTENT-gt" class="headerlink" title="3. broadcast [options] &lt;INTENT&gt;"></a>3. <code>broadcast [options] &lt;INTENT&gt;</code></h4><p>Issue a broadcast intent.</p>
<h3 id="pm命令"><a href="#pm命令" class="headerlink" title="pm命令"></a>pm命令</h3><p><strong>pm，即package manager</strong>。看一些比较易用的命令吧。</p>
<h4 id="1-adb-shell-pm-clear-lt-PACKAGE-gt"><a href="#1-adb-shell-pm-clear-lt-PACKAGE-gt" class="headerlink" title="1. adb shell pm clear &lt;PACKAGE&gt;"></a>1. <code>adb shell pm clear &lt;PACKAGE&gt;</code></h4><p>Deletes all data associated with a package.</p>
<h4 id="2-adb-shell-pm-list-packages"><a href="#2-adb-shell-pm-list-packages" class="headerlink" title="2. adb shell pm list packages"></a>2. <code>adb shell pm list packages</code></h4><p>列出所有的应用。</p>
<h4 id="3-enable-disable-lt-PACKAGE-OR-COMPONENT-gt"><a href="#3-enable-disable-lt-PACKAGE-OR-COMPONENT-gt" class="headerlink" title="3. enable|disable &lt;PACKAGE_OR_COMPONENT&gt;"></a>3. <code>enable|disable &lt;PACKAGE_OR_COMPONENT&gt;</code></h4><p>Enable/Disable the given package or component (written as “package/class”).</p>
<h4 id="4-grant-revoke-lt-PACKAGE-NAME-gt-lt-PERMISSION-gt"><a href="#4-grant-revoke-lt-PACKAGE-NAME-gt-lt-PERMISSION-gt" class="headerlink" title="4. grant/revoke &lt;PACKAGE_NAME&gt; &lt;PERMISSION&gt;"></a>4. <code>grant/revoke &lt;PACKAGE_NAME&gt; &lt;PERMISSION&gt;</code></h4><p>Grant/Revoke a permission to an app. On devices running Android 6.0 (API level 23) and higher, may be any permission declared in the app manifest. On devices running Android 5.1 (API level 22) and lower, must be an optional permission defined by the app.(可以收回权限，测试的时候非常有用)</p>
<p><strong>pm</strong>下面还有几个列举设备支持的feature、library、permissoon等特性的命令，直接查阅<a href="https://developer.android.com/intl/zh-cn/tools/help/shell.html#IntentSpec" target="_blank" rel="noopener">文档</a>吧，有很多选项。</p>
<h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><h4 id="1-screencap-lt-filename-gt"><a href="#1-screencap-lt-filename-gt" class="headerlink" title="1. screencap &lt;filename&gt;"></a>1. <code>screencap &lt;filename&gt;</code></h4><p>具体执行如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell screencap /sdcard/screen.png</span><br></pre></td></tr></table></figure>
<p>用于给当前屏幕截图，非常有用，主要是导出图片非常方便，使用pull即可。</p>
<h4 id="2-screenrecord-options-lt-filename-gt"><a href="#2-screenrecord-options-lt-filename-gt" class="headerlink" title="2. screenrecord [options] &lt;filename&gt;"></a>2. <code>screenrecord [options] &lt;filename&gt;</code></h4><p>具体执行如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell screenrecord /sdcard/demo.mp4</span><br></pre></td></tr></table></figure>
<p>用于录制操作视频。默认是3分钟后停止录制，可以使用Ctrl-C命令终止录制，或者使用<code>--time--limit</code>来设置录制时间。导出方法和图片一致。</p>
<p><br><hr></p>
<h3 id="一篇整理的更加详细的文章：Awesome-ADB。"><a href="#一篇整理的更加详细的文章：Awesome-ADB。" class="headerlink" title="一篇整理的更加详细的文章：Awesome ADB。"></a>一篇整理的更加详细的文章：<a href="https://github.com/mzlogin/awesome-adb" target="_blank" rel="noopener">Awesome ADB</a>。</h3>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java 动态代理实现]]></title>
      <url>http://www.timebridge.space/2016/02/28/Java-bitset/</url>
      <content type="html"><![CDATA[<h2 id="介绍和使用"><a href="#介绍和使用" class="headerlink" title="介绍和使用"></a>介绍和使用</h2><p>在Java中是不能像C/C++那样直接以bit为单位操作数据的，必须想办法替代: </p>
<ol>
<li>使用整数数组来模拟bit；</li>
<li>通过已有数据类型，使用位移操作来达到操作bit的效果；</li>
</ol>
<p>第一种办法虽然简单，但是很耗空间。Java自带的工具类BitSet采用的是第二种方案。</p>
<p>BitSet选取的基础类型是long，内部保存了一个long数组，通过and等操作设置long的某一位的值来模拟bit操作。<a id="more"></a></p>
<p>BitSet的用法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BitSet set = <span class="keyword">new</span> BitSet(<span class="number">1024</span>);</span><br><span class="line">set.set(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>以上表示建立一个可以容纳1024个bit的BitSet，并将第2位置为1。BitSet本身自带扩容功能，实现了大量的与bit位相关的操作API，详见<a href="https://docs.oracle.com/javase/7/docs/api/java/util/BitSet.html" target="_blank" rel="noopener">Doc</a>。</p>
<h2 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h2><p>我们来看一下内部实现。首先看一下实例化过程:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> ADDRESS_BITS_PER_WORD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BitSet</span><span class="params">(<span class="keyword">int</span> nbits)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// nbits can't be negative; size 0 is OK</span></span><br><span class="line">   <span class="keyword">if</span> (nbits &lt; <span class="number">0</span>)</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> NegativeArraySizeException(<span class="string">"nbits &lt; 0: "</span> + nbits);</span><br><span class="line"> </span><br><span class="line">   initWords(nbits);</span><br><span class="line">   sizeIsSticky = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initWords</span><span class="params">(<span class="keyword">int</span> nbits)</span> </span>&#123;</span><br><span class="line">   words = <span class="keyword">new</span> <span class="keyword">long</span>[wordIndex(nbits-<span class="number">1</span>) + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">wordIndex</span><span class="params">(<span class="keyword">int</span> bitIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bitIndex &gt;&gt; ADDRESS_BITS_PER_WORD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我把实例化涉及到的相关方法和变量都已经贴出来了，我们看到它实际上就是通过initWords实例化了一个long数组，而数组的大小是通过算式<strong>wordIndex(nbits-1) + 1</strong>算出来的，该算式可以保证计算出来的数组的大小正好可以容纳nbits位数的bit值。</p>
<p>接下来我们讲一些重要的方法。</p>
<h3 id="set-方法"><a href="#set-方法" class="headerlink" title="set()方法"></a><code>set()</code>方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> bitIndex)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (bitIndex &lt; <span class="number">0</span>)</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"bitIndex &lt; 0: "</span> + bitIndex);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">int</span> wordIndex = wordIndex(bitIndex);</span><br><span class="line">   expandTo(wordIndex);</span><br><span class="line"> </span><br><span class="line"> 	<span class="comment">//A</span></span><br><span class="line">   words[wordIndex] |= (<span class="number">1L</span> &lt;&lt; bitIndex); <span class="comment">// Restores invariants</span></span><br><span class="line"> </span><br><span class="line">   checkInvariants();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法就是设置某一个bit为为1。这里分为以下几个步骤:</p>
<ol>
<li>确定bit位映射到数组中的哪一位，即哪一个long值；</li>
<li>通过expandTo方法(下面会有详细解释)保证long数组的长度可以容纳这一位；</li>
<li>将long的这一位置为1；</li>
</ol>
<p>其中A处的表达式就是在设置位数，java中的移位操作会模除位数，也就是说，long类型的移位会模除64。例如对long类型的值左移65位，实际是左移了65%64=1位。所以这行代码就等于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> transderBits = bitIndex % <span class="number">64</span>;</span><br><span class="line">words[wordsIndex] |= (<span class="number">1L</span> &lt;&lt; transferBits);</span><br></pre></td></tr></table></figure>
<h3 id="clear-方法"><a href="#clear-方法" class="headerlink" title="clear()方法"></a><code>clear()</code>方法</h3><p>这个方法和set()相对，它的实现是这样的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> bitIndex)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (bitIndex &lt; <span class="number">0</span>)</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"bitIndex &lt; 0: "</span> + bitIndex);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">int</span> wordIndex = wordIndex(bitIndex);</span><br><span class="line">   <span class="keyword">if</span> (wordIndex &gt;= wordsInUse)</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">   words[wordIndex] &amp;= ~(<span class="number">1L</span> &lt;&lt; bitIndex);</span><br><span class="line"> </span><br><span class="line">   recalculateWordsInUse();</span><br><span class="line">   checkInvariants();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和set()方法的步骤类似，只有在设置位的时候是不一样的，不多解释。</p>
<h3 id="expandTo-方法"><a href="#expandTo-方法" class="headerlink" title="expandTo()方法"></a><code>expandTo()</code>方法</h3><p>这个方法是用来对BitSet内部的long数组扩容的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of words in the logical size of this BitSet.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> wordsInUse = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expandTo</span><span class="params">(<span class="keyword">int</span> wordIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> wordsRequired = wordIndex+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (wordsInUse &lt; wordsRequired) &#123;</span><br><span class="line">        ensureCapacity(wordsRequired);</span><br><span class="line">        wordsInUse = wordsRequired;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>wordsInUse表示逻辑上words的大小，当我们传进一个wordIndex的时候，首先需要判断这个逻辑大小与wordIndex的大小关系，如果小于它，我们就调用方法ensureCapacity():</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> wordsRequired)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (words.length &lt; wordsRequired) &#123;</span><br><span class="line">		<span class="comment">// Allocate larger of doubled size or required size</span></span><br><span class="line">		<span class="keyword">int</span> request = Math.max(<span class="number">2</span> * words.length, wordsRequired);</span><br><span class="line">		words = Arrays.copyOf(words, request);</span><br><span class="line">		sizeIsSticky = <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里判断是否words数组确实小了不够用，不够的话就新建一个两倍大的或者和wordsRequired一样大的数组并copy原来的数据。</p>
<h3 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a><code>get()</code>方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> bitIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bitIndex &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"bitIndex &lt; 0: "</span> + bitIndex);</span><br><span class="line"> </span><br><span class="line">    checkInvariants();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> wordIndex = wordIndex(bitIndex);</span><br><span class="line">    <span class="keyword">return</span> (wordIndex &lt; wordsInUse)</span><br><span class="line">        &amp;&amp; ((words[wordIndex] &amp; (<span class="number">1L</span> &lt;&lt; bitIndex)) != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有当wordIndex没有越界，并且wordIndex上的wordIndex上的bit不为0的时候，我们才说这一位是true.</p>
<h3 id="size-方法"><a href="#size-方法" class="headerlink" title="size()方法"></a><code>size()</code>方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> ADDRESS_BITS_PER_WORD = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> BITS_PER_WORD = <span class="number">1</span> &lt;&lt; ADDRESS_BITS_PER_WORD;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> words.length * BITS_PER_WORD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，这里返回的是实际数组可以容纳的bit位数，它永远是64的倍数，而不一定是我们传进来实例化的那个nbits大小，比如你传入1020，这里返回的应该也是1024。</p>
<h3 id="length-方法"><a href="#length-方法" class="headerlink" title="length()方法"></a><code>length()</code>方法</h3><p>这个方法看上去和size()很类似，但是实际的逻辑却不一样:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the "logical size" of this &lt;code&gt;BitSet&lt;/code&gt;: the index of</span></span><br><span class="line"><span class="comment"> * the highest set bit in the &lt;code&gt;BitSet&lt;/code&gt; plus one. Returns zero</span></span><br><span class="line"><span class="comment"> * if the &lt;code&gt;BitSet&lt;/code&gt; contains no set bits.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  the logical size of this &lt;code&gt;BitSet&lt;/code&gt;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (wordsInUse == <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> BITS_PER_WORD * (wordsInUse - <span class="number">1</span>) +</span><br><span class="line">		(BITS_PER_WORD - Long.numberOfLeadingZeros(words[wordsInUse - <span class="number">1</span>]));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>方法虽然短小，却比较难以理解，细细分析一下：根据注释，这个方法法返回的是BitSet的逻辑大小，比如说你声明了一个129位的BitSet,设置了第23，45，67位，那么其逻辑大小就是67，也就是说逻辑大小其实是的是在你设置的所有位里面最高位的Index。</p>
<p>这里有一个方法，Long.numberOfLeadingZeros，网上没有很好的解释，做实验如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">long</span> test = <span class="number">1</span>;</span><br><span class="line">System.out.println(Long.numberOfLeadingZeros(test&lt;&lt;<span class="number">3</span>));</span><br><span class="line">System.out.println(Long.numberOfLeadingZeros(test&lt;&lt;<span class="number">40</span>));</span><br><span class="line">System.out.println(Long.numberOfLeadingZeros(test&lt;&lt;<span class="number">40</span> | test&lt;&lt;<span class="number">4</span>));</span><br></pre></td></tr></table></figure>
<p>打印结果如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">60</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">23</span></span><br></pre></td></tr></table></figure>
<p>也就是说，这个方法是输出一个64位二进制字符串前面0的个数的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>BitSet通过操作long数组来模拟bit操作，虽然可能并没有直接操作bit数组那么快速(毕竟要做一些计算)，但已经是一个很不错的方案了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android 的键盘收起展开]]></title>
      <url>http://www.timebridge.space/2016/02/28/Android-keyboard-show-and-hide/</url>
      <content type="html"><![CDATA[<h2 id="介绍和使用"><a href="#介绍和使用" class="headerlink" title="介绍和使用"></a>介绍和使用</h2><p>键盘的展开和收起主要使用到类 <a href="http://developer.android.com/reference/android/view/inputmethod/InputMethodManager.html" target="_blank" rel="noopener">InputMethodManager</a> 。使用方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//隐藏键盘</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hideKeyboard</span><span class="params">(Context context, View view)</span> </span>&#123;</span><br><span class="line">        InputMethodManager inputMethodManager = (InputMethodManager) context.getSystemService(Activity.INPUT_METHOD_SERVICE);</span><br><span class="line">        inputMethodManager.hideSoftInputFromWindow(view.getWindowToken(), InputMethodManager.HIDE_NOT_ALWAYS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示键盘</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyboard</span><span class="params">(Context context, View view)</span> </span>&#123;</span><br><span class="line">        InputMethodManager inputMethodManager = (InputMethodManager) context.getSystemService(Activity.INPUT_METHOD_SERVICE);</span><br><span class="line">        inputMethodManager.showSoftInput(view, InputMethodManager.SHOW_IMPLICIT);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="参数问题"><a href="#参数问题" class="headerlink" title="参数问题"></a>参数问题</h2><p>在调用hideSoftInputFromWindow()和showSoftInput()方法的时候，都要求传入第二个参数，这个参数在官网上的解释并不清楚，比如hideSoftInputFromWindow()方法上关于这个参数的解释如下:</p>
<blockquote>
<p>int: Provides additional operating flags. Currently may be 0 or have the HIDE_IMPLICIT_ONLY bit set.</p>
</blockquote>
<p>从官网上看，这个参数总共有以下四个常量，加上0:</p>
<p>在展开和收起方法调用的时候，都要求传入第二个参数。大致有以下四种：</p>
<ol>
<li>HIDE_IMPLICIT_ONLY：indicate that the soft input window should only be hidden if it was not explicitly shown by the user.</li>
<li>HIDE_NOT_ALWAYS：to indicate that the soft input window should normally be hidden, unless it was originally shown with SHOW_FORCED</li>
<li>SHOW_FORCED：indicate that the user has forced the input method open (such as by long-pressing menu) so it should not be closed until they explicitly do so.</li>
<li>SHOW_IMPLICIT：indicate that this is an implicit request to show the input window, not as the result of a direct request by the user.</li>
</ol>
<p>1和2是用于收起键盘的，3和4是用于展开键盘的。</p>
<h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><ol>
<li>如果用户是点击输入框弹出的键盘，则调用1）是无法隐藏的，系统此时判断使用户有意呼唤键盘的！调用2）则可以收起键盘；</li>
<li>如果用户是使用3）作为参数显示键盘的，则1）和2）都是无法隐藏键盘的，此时需要用参数0，强制隐藏一切键盘；</li>
<li>如果用户是使用4）作为参数显示键盘的，则1）和2）都是可以隐藏键盘的。</li>
</ol>
<p>总结下来就是: <strong>Forced &gt; Explicit &gt; Implicit</strong>。</p>
<p>对于隐藏键盘，其中1）是属于implicit，2）是属于explicit，0则是属于force；对于显示键盘，则4）是属于implicit，输入框呼出属于explicit，3）则是属于force；</p>
<p><strong>只有隐藏的级别&gt;=展开的级别，才能将键盘隐藏掉。</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android 的 Activity 生命周期]]></title>
      <url>http://www.timebridge.space/2016/02/28/Android-activity-lifecycle/</url>
      <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>【环境】测试手机为Nexus 5，系统为4.4和6.0。</p>
<blockquote>
<p>PS: 最早测试是在4.4下进行，当时用的还是Eclipse，因此截图都是Eclipse下面的。最新在6.0 + Android Studio下验证，结果完全一致。<a href="http://www.cnblogs.com/lqminn/p/3856089.html" target="_blank" rel="noopener">原文地址</a></p>
</blockquote>
<a id="more"></a>
<h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.androidalarm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.res.Configuration;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.AttributeSet;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    Button addButton, cancelButton;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Log.d(<span class="string">"BigFootprint"</span>, <span class="string">"onCreate"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigurationChanged</span><span class="params">(Configuration newConfig)</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">"BigFootprint"</span>, <span class="string">"onConfigurationChanged"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onConfigurationChanged(newConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(String name, Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">"BigFootprint"</span>, <span class="string">"onCreateView"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onCreateView(name, context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">"BigFootprint"</span>, <span class="string">"onDestroy"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">"BigFootprint"</span>, <span class="string">"onPause"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onPause();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRestart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">"BigFootprint"</span>, <span class="string">"onRestart"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onRestart();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRestoreInstanceState</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">"BigFootprint"</span>, <span class="string">"onRestoreInstanceState"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onRestoreInstanceState(savedInstanceState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">"BigFootprint"</span>, <span class="string">"onResume"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">"BigFootprint"</span>, <span class="string">"onSaveInstanceState"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onSaveInstanceState(outState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">"BigFootprint"</span>, <span class="string">"onStart"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="string">"BigFootprint"</span>, <span class="string">"onStop"</span>);</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>XML配置:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">"com.example.androidalarm"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:versionCode</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:versionName</span>=<span class="string">"1.0"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-sdk</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:minSdkVersion</span>=<span class="string">"8"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:targetSdkVersion</span>=<span class="string">"18"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_launcher"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"com.example.androidalarm.MainActivity"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="正常情况的生命周期"><a href="#正常情况的生命周期" class="headerlink" title="正常情况的生命周期"></a>正常情况的生命周期</h2><h3 id="常见的打开退出"><a href="#常见的打开退出" class="headerlink" title="常见的打开退出"></a>常见的打开退出</h3><p>运行项目，当项目启动，MainActivity显示出来的时候，Console的打印如下:</p>
<p><img src="http://7xktd8.com1.z0.glb.clouddn.com/没有配置-启动.jpg" alt="没有配置-启动"><br>几个主流的生命周期方法和文档描述的一样，但是onCreatView()方法则会多次调用(从实验两次来看，次数不固定)，虽然这个方法不常用，但是用到的时候要注意。</p>
<p>接下去我们按Back键退出:</p>
<p><img src="http://7xktd8.com1.z0.glb.clouddn.com/没有配置-退出.jpg" alt="没有配置-退出"><br>生命周期方法调用正常。</p>
<h3 id="屏幕暗下亮起"><a href="#屏幕暗下亮起" class="headerlink" title="屏幕暗下亮起"></a>屏幕暗下亮起</h3><p>然后我们打开Activity，等着屏幕自己暗掉，这个时候的Log是这样的:</p>
<p><img src="http://7xktd8.com1.z0.glb.clouddn.com/没有配置-屏幕暗掉.jpg" alt="没有配置-屏幕暗掉"><br>没有调用onDestroy()方法，但是在onPause()和onStop()之间调用了onSaveInstanceState()方法。</p>
<p>我们按下电源键，亮起屏幕:</p>
<p><img src="http://7xktd8.com1.z0.glb.clouddn.com/没有配置-屏幕亮起.jpg" alt="没有配置-屏幕亮起"><br>没有onCreate()方法(因为Activity没有被杀死)，但是调用了onRestart()方法，这也是一个不常用的方法。</p>
<h3 id="Home键退出"><a href="#Home键退出" class="headerlink" title="Home键退出"></a>Home键退出</h3><p>我们按下Home键退出MainActivity:</p>
<p><img src="http://7xktd8.com1.z0.glb.clouddn.com/没有配置-Home退出.jpg" alt="没有配置-Home退出"><br>和屏幕暗调的Log完全一致。</p>
<p>再点击应用图标进入:</p>
<p><img src="http://7xktd8.com1.z0.glb.clouddn.com/没有配置-Home进入.jpg" alt="没有配置-Home进入"></p>
<h2 id="横竖屏切换的生命周期"><a href="#横竖屏切换的生命周期" class="headerlink" title="横竖屏切换的生命周期"></a>横竖屏切换的生命周期</h2><p>在以上代码不变的情况下，我们将手机切换为横屏(注:因为onCreateView调用次数太多，而且不是重点研究对象，后面的实验去除了它的Log):</p>
<p><img src="http://7xktd8.com1.z0.glb.clouddn.com/没有配置-竖横.jpg" alt="没有配置-竖横"></p>
<p>这里可以看到，Activity是被杀掉后重建的，并且调用了onSaveInstanceState()和onRestoreInstanceState()两个方法做了数据恢复和保存。</p>
<p>将屏幕从横屏切换为竖屏，Log如下:</p>
<p><img src="http://7xktd8.com1.z0.glb.clouddn.com/没有配置-横竖.jpg" alt="没有配置-横竖"><br>和切换为横屏是一样的。</p>
<p>接下来我们为Activity的XML声明添加如下配置:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:configChanges="orientation"</span><br></pre></td></tr></table></figure>
<p>我们来一次竖屏 -&gt; 横屏 —&gt; 竖屏的切换，其Log如下:</p>
<p><img src="http://7xktd8.com1.z0.glb.clouddn.com/配置orientation-切换.jpg" alt="配置orientation-切换"></p>
<p>和没有配置是一样的。我们将配置改为:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:configChanges="orientation|keyboardHidden"</span><br></pre></td></tr></table></figure>
<p>打印的Log没有变化。再将配置改为:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:configChanges="orientation|screenSize"</span><br></pre></td></tr></table></figure>
<p>这个时候切换打印的Log就如下:</p>
<p><img src="http://7xktd8.com1.z0.glb.clouddn.com/配置orientation|screenSize-切换.jpg" alt="配置orientation|screenSize-切换"></p>
<p>这样的配置，在横竖屏切换的时候就只会调用onConfigurationChanged()方法，而不会引起Activity重建。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从以上实验中可以得到以下结论。</p>
<h3 id="Android什么时候认为Activity可能会被意外关闭"><a href="#Android什么时候认为Activity可能会被意外关闭" class="headerlink" title="Android什么时候认为Activity可能会被意外关闭?"></a>Android什么时候认为Activity可能会被意外关闭?</h3><p>这个是以onSaveInstanceState方法被调用作为标志的，很明显有三种情况:</p>
<ol>
<li>屏幕暗下去；</li>
<li>按下Home键退出Activity；</li>
<li>横竖屏切换；</li>
</ol>
<p>因为实验的问题，这里给出的三个情景并不完整，其实还有一个很重要的情景：当前Activity启动别的Activity的时候。它们有一个共同的特点: 用户离开了这个Activity，但没有主动关闭它。Android系统这个时候判定这个Activity有意外被关闭的可能性，因此需要保存数据。</p>
<h3 id="onConfigurationChanged-方法什么时候被调用"><a href="#onConfigurationChanged-方法什么时候被调用" class="headerlink" title="onConfigurationChanged()方法什么时候被调用?"></a>onConfigurationChanged()方法什么时候被调用?</h3><p>这个方法和Activity的<strong>android:configChanges</strong>配置息息相关，我们先看一下官网的解释。</p>
<p>关于onConfigurationChanged()方法，其 <a href="http://developer.android.com/intl/zh-cn/reference/android/app/Activity.html#onConfigurationChanged(android.content.res.Configuration" target="_blank" rel="noopener">注释</a> 是这样的:</p>
<blockquote>
<p>Called by the system when the device configuration changes while your activity is running. Note that this will only be called if you have selected configurations you would like to handle with the configChanges attribute in your manifest. If any configuration change occurs that is not selected to be reported by that attribute, then instead of reporting it the system will stop and restart the activity (to have it launched with the new configuration).<br>At the time that this function has been called, your Resources object will have been updated to return resource values matching the new configuration.</p>
</blockquote>
<p>也就是说：这个方法只有在你的应用程序运行且配置发生变化的时候被调用，但并不是所有的配置变化都会调用这个方法，必须通过<strong>configChanges</strong>属性进行配置，如果一个配置发生了变化，但你没有在<strong>configChanges</strong>属性中进行配置，那么系统会重新创建这个Activity。在这个方法调用的时候，该配置对应的资源文件已经被更新。</p>
<p>关于<strong>android:configChanges</strong>的 <a href="http://developer.android.com/intl/zh-cn/guide/topics/manifest/activity-element.html#config" target="_blank" rel="noopener">解释</a> 是这的:</p>
<blockquote>
<p>Lists configuration changes that the activity will handle itself. When a configuration change occurs at runtime, the activity is shut down and restarted by default, but declaring a configuration with this attribute will prevent the activity from being restarted. Instead, the activity remains running and its onConfigurationChanged() method is called.</p>
</blockquote>
<p>翻译一下: 列举了Activty自己会处理的配置变化选项。当程序运行且一个配置发生变化的时候，Activity默认是重新创建的，但是如果在这里声明了这个配置，Activity就不会被重新创建，而是调用它的onConfigurationChanged()方法。</p>
<p>一般来说，我们最常关注的配置变化就是<strong>orientation</strong>。那么为什么我们单独配置<strong>android:configChanges=”orientation”</strong>没有达到预期效果呢？官网上关于这个配置有解释:</p>
<blockquote>
<p>The screen orientation has changed — the user has rotated the device.</p>
<blockquote>
<p>Note: If your application targets API level 13 or higher (as declared by the minSdkVersion and targetSdkVersion attributes), then you should also declare the “screenSize” configuration, because it also changes when a device switches between portrait and landscape orientations.</p>
</blockquote>
</blockquote>
<p>在API Level 13以及更高的版本上，这里必须加上<strong>screenSize</strong>配置才行。因为切换横竖屏的时候会导致屏幕尺寸变化(宽高不一致)，而如果没有配置这个，那系统会认为你不会去处理<strong>screenSize</strong>配置，自然就会重新创建Activity。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>官网上有一篇 <a href="http://developer.android.com/intl/zh-cn/guide/topics/resources/runtime-changes.html#HandlingTheChange" target="_blank" rel="noopener">API指南</a> ，指导开发者如何处理运行时配置变更，有几个重要的点整理如下:</p>
<ol>
<li>配置变化有两种处理办法，一种是直接重启Activity，这种办法成本较高，因为要进行大量的数据保存和恢复，一种是选择自行处理配置变更；</li>
<li>使用Bundle保存数据会很麻烦，要经过序列化反序列化操作且一些对象并不能被序列化反序列化，一些对象例如Bitmap，重新实例化的成本很大，这个时候我们可以通过Fragment来保存数据(当Android系统因配置变更而关闭Activity时，不会销毁您已标记为要保留的Activity的Fragment。您可以将此类片段添加到Activity以保留有状态的对象。)；</li>
<li>自行处理配置变更可能导致备用资源的使用更为困难，因为系统不会为您自动应用这些资源，开发者有责任重置为所有元素设置新的资源(如果需要变化的话)。 只能在您必须避免Activity因配置变更而重启这一万般无奈的情况下，才考虑采用自行处理配置变更这种方法，而且对于大多数应用并不建议使用此方法；</li>
</ol>
<p>这里再备注两个方法: <strong>onRetainNonConfigurationInstance()</strong>和<strong>getLastNonConfigurationInstance()</strong>，具体的方法解释可以看<a href="http://developer.android.com/intl/zh-cn/reference/android/app/Activity.html" target="_blank" rel="noopener">文档</a>。</p>
<p>这两个方法原本也是用于处理Configuration变化的情况的，和2的使用情况是一致的。在onRetainNonConfigurationInstance ()方法的注释中特别说明了以下几点:</p>
<blockquote>
<p>This function is called purely as an optimization, and you must not rely on it being called(不一定会被调用). When it is called, a number of guarantees will be made to help optimize configuration switching:</p>
<ol>
<li>The function will be called between onStop() and onDestroy().在这两个方法之间调用。</li>
<li>A new instance of the activity will always be immediately created after this one’s onDestroy() is called. In particular, no messages will be dispatched during this time (when the returned object does not have an activity to be associated with).注意使用的场景，必须保证在重建的间隙中没有消息传送处理。</li>
<li>The object you return here will always be available from the getLastNonConfigurationInstance() method of the following activity instance as described there.可以通过getLastNonConfigurationInstance()获取数据</li>
</ol>
</blockquote>
<p>但是在API Level 13上，这个放弃已经被废弃了，官网建议通过Fragment的setRetainInstance(boolean)方法来替代这种方案。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ThreadLocal源码剖析]]></title>
      <url>http://www.timebridge.space/2016/02/27/Java-threadlocal/</url>
      <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>当一个资源可能被多个线程同时访问的时候，我们就需要对资源加以保护，以确定在该资源上的操作是线程安全的。常见的方法就是加锁(synchronized或者Lock)，或者将操作原子化(比如AtomicInteger)。</p>
<p>ThreadLocal是解决这类问题的另外一种方案: 既然资源在线程间共享会有安全问题，那么就不用共享了，每一个线程有一份资源副本就好了。<a id="more"></a></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>下面是一个🌰:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.footprint.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; intLocal = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.get();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.set(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; <span class="number">3</span>; index ++)</span><br><span class="line">            <span class="keyword">new</span> MyThread(index).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; <span class="number">5</span>; index ++)&#123;</span><br><span class="line">            <span class="keyword">int</span> value = ThreadLocalTest.intLocal.get();</span><br><span class="line">            System.out.println(<span class="string">"Thread-"</span> + id + <span class="string">" : "</span> + value);</span><br><span class="line">            ThreadLocalTest.intLocal.set(++value);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep((<span class="keyword">int</span>)(<span class="number">100</span> * Math.random()));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子基于一个很典型的问题: 银行存钱取钱问题。我们知道当多线程并发操作一个int值的加减操作的时候，最后的数值会产生很大的不确定性，得不到最终正确的结果。这里我们将操作的“存款”对象由普通的int值转变为ThreadLocal<integer>对象，我们看一下运行结果:</integer></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span> : <span class="number">0</span></span><br><span class="line">Thread-<span class="number">2</span> : <span class="number">0</span></span><br><span class="line">Thread-<span class="number">1</span> : <span class="number">0</span></span><br><span class="line">Thread-<span class="number">0</span> : <span class="number">1</span></span><br><span class="line">Thread-<span class="number">1</span> : <span class="number">1</span></span><br><span class="line">Thread-<span class="number">1</span> : <span class="number">2</span></span><br><span class="line">Thread-<span class="number">2</span> : <span class="number">1</span></span><br><span class="line">Thread-<span class="number">1</span> : <span class="number">3</span></span><br><span class="line">Thread-<span class="number">0</span> : <span class="number">2</span></span><br><span class="line">Thread-<span class="number">1</span> : <span class="number">4</span></span><br><span class="line">Thread-<span class="number">2</span> : <span class="number">2</span></span><br><span class="line">Thread-<span class="number">0</span> : <span class="number">3</span></span><br><span class="line">Thread-<span class="number">2</span> : <span class="number">3</span></span><br><span class="line">Thread-<span class="number">2</span> : <span class="number">4</span></span><br><span class="line">Thread-<span class="number">0</span> : <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>虽然5个线程操作的是同一个ThreadLocal对象，但每一个线程的数字都是在自我递增，线程之间互不干扰，这就是ThreadLocal的作用。</p>
<p>ThreadLocal类中可重载的方法只有四个：</p>
<ol>
<li>set()：设置值，也就是说，我们选择将某个值设置为ThreadLocal类型的；</li>
<li>get()：将设置进去的值取出来；</li>
<li>remove()：我们不想将某个值设置为ThreadLocal了，移除掉；</li>
<li>initialValue()：如果get的时候还没有设置值，就使用这个方法进行初始化；</li>
</ol>
<p>一般重载initialValue()提供一个初始值就可以了，其余方法不需要重载。</p>
<h2 id="ThreadLocal源码剖析"><a href="#ThreadLocal源码剖析" class="headerlink" title="ThreadLocal源码剖析"></a>ThreadLocal源码剖析</h2><p>本节从源码角度看一下四个方法是如何配合运作的，又是如何做到为每一个线程分配一个资源副本的。</p>
<p>我们首先从get()方法入手:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//获取当前线程</span></span><br><span class="line">	Thread t = Thread.currentThread();</span><br><span class="line">	ThreadLocalMap map = getMap(t);</span><br><span class="line">	<span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">		ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">		<span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> (T)e.value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getMap方法返回的是线程的threadLocals对象，这个对象是什么含义呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<p>如上所示，它是一个ThreadLocalMap对象，专门为ThreadLocal而生且实现和维护都在ThreadLocal中进行，只不过Thread对它有一个引用。它的注释如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ThreadLocalMap is a customized hash map suitable only for</span></span><br><span class="line"><span class="comment"> * maintaining thread local values. No operations are exported</span></span><br><span class="line"><span class="comment"> * outside of the ThreadLocal class. The class is package private to</span></span><br><span class="line"><span class="comment"> * allow declaration of fields in class Thread.  To help deal with</span></span><br><span class="line"><span class="comment"> * very large and long-lived usages, the hash table entries use</span></span><br><span class="line"><span class="comment"> * WeakReferences for keys. However, since reference queues are not</span></span><br><span class="line"><span class="comment"> * used, stale entries are guaranteed to be removed only when</span></span><br><span class="line"><span class="comment"> * the table starts running out of space.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>它是一个定制的HashMap容器，它只能在ThreadLocal内部使用，所有的Key都是WeakReferences，我们来看一下这个Map的Entry:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&gt; </span>&#123;</span><br><span class="line">	<span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">	Object value;</span><br><span class="line"></span><br><span class="line">	Entry(ThreadLocal k, Object v) &#123;</span><br><span class="line">		<span class="keyword">super</span>(k);</span><br><span class="line">		value = v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过Entry可以很清楚的了解到ThreadLocalMap维护的是一个从ThreadLocal到对应值的映射，每一个线程内部都有一个这样的变量，这意味着一个Thread可以维护很多的ThreadLocal，也就是说可以维护很多资源的副本。</p>
<p>我们回到get()方法。getMap()方法就是获取当前线程的ThreadLocalMap对象，剩下的步骤如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">	ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">	<span class="keyword">return</span> (T)e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有当当前线程的Map中维护着当前ThreadLocal映射的值的时候，才会正常返回结果，否则就会去调用setInitialValue()方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Variant of set() to establish initialValue. Used instead</span></span><br><span class="line"><span class="comment"> * of set() in case user has overridden the set() method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the initial value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	T value = initialValue();<span class="comment">//调用方法初始化值</span></span><br><span class="line">	Thread t = Thread.currentThread();</span><br><span class="line">	ThreadLocalMap map = getMap(t);</span><br><span class="line">	<span class="keyword">if</span> (map != <span class="keyword">null</span>)<span class="comment">//Map已经存在直接设置值</span></span><br><span class="line">		map.set(<span class="keyword">this</span>, value);</span><br><span class="line">	<span class="keyword">else</span><span class="comment">//否则创建Map</span></span><br><span class="line">		createMap(t, value);</span><br><span class="line">	<span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为当前线程创建ThreadLocalMap</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">	t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Construct a new map initially containing (firstKey, firstValue).</span></span><br><span class="line"><span class="comment"> * ThreadLocalMaps are constructed lazily, so we only create</span></span><br><span class="line"><span class="comment"> * one when we have at least one entry to put in it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ThreadLocalMap(ThreadLocal firstKey, Object firstValue) &#123;</span><br><span class="line">	table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">	<span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">	<span class="comment">//传入的Key-Value会被立刻创建为Entry保存起来</span></span><br><span class="line">	table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">	size = <span class="number">1</span>;</span><br><span class="line">	setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理解了ThreadLocalMap的含义以及它与Thread的关系，这里就很好理解了，详见注释。</p>
<p>到这里，get()和initialValue()方法都已经涉及到，剩下的set()和remove()也很好理解，不再赘述。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>分析至此，我们来讨论一个问题: ThreadLocal会不会造成内存泄露？</p>
<p>问题的起因是这样的: Thead通过ThreadLocalMap引用着TheadLocal到一个变量值的映射，假设如果一个线程有A、B两个方法，A方法调用的时候初始化了一个ThreadLocal资源，然后线程一直在执行B方法，并且B不会再去操作ThreadLocal资源了，那么会不会引起这个ThreadLocal资源不能释放呢？</p>
<p>ThreadLocal的实现很容易让人觉得不会，比如ThreadLocalMap的Entry实现。读者应该注意到Entry的Key也就是对ThreadLocal的引用是WeakReference的！这样保证了当外部类(ThreadLocalTest)被销毁后，一旦ThreadLocal变量(intLocal)不再有强引用，ThreadLocal就会立刻被回收掉，即Entry中的Key会被回收掉。但TheadlLocal仅仅是一个桥梁，真正的资源是Value，它还是被Entry引用着，保存在Thread的ThreadLocalMap中。</p>
<p>所以，类似于代码🌰中给出的实现，是有风险的。当我们确认线程中不会再使用一个资源的时候，我们应当主动去remove，比如在前面的例子中，A方法就应该调用remove方法，这样可以使得不使用的资源尽早释放掉，而不是如注释中所说:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Each thread holds an implicit reference to its copy of a thread-local</span></span><br><span class="line"><span class="comment"> * variable as long as the thread is alive and the &lt;tt&gt;ThreadLocal&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * instance is accessible; after a thread goes away, all of its copies of</span></span><br><span class="line"><span class="comment"> * thread-local instances are subject to garbage collection (unless other</span></span><br><span class="line"><span class="comment"> * references to these copies exist).</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>等到Thread死亡之后才把资源副本全部释放掉。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>日常开发中并不常用到这个类，但是她提供了解决资源安全的一种方案，便利且优雅，对于其使用，Android开发者可以去研习一下<a href="http://www.muzileecoding.com/androidsource/Android-Handler.html" target="_blank" rel="noopener">Handler的实现</a>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android开发One Piece]]></title>
      <url>http://www.timebridge.space/2016/02/27/Android-One-Piece/</url>
      <content type="html"><![CDATA[<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/onepiece2.png" height="188" alt="One Piece"></div>

<h2 id="工具相关"><a href="#工具相关" class="headerlink" title="工具相关"></a>工具相关</h2><h3 id="TraceView"><a href="#TraceView" class="headerlink" title="TraceView"></a>TraceView</h3><ol>
<li><a href="http://tech.meituan.com/android_custom_lint.html" target="_blank" rel="noopener">Android自定义Lint实践</a>。看上去很强大的样子，可以用于定制一些工具。</li>
<li><a href="http://laobie.github.io/android/2016/02/14/android-studio-tips.html" target="_blank" rel="noopener">Android Studio 小技巧合集</a>。调试器技巧分类下很有用。</li>
<li><a href="https://segmentfault.com/a/1190000004461614" target="_blank" rel="noopener">Android分享：代码混淆那些事</a>。跟Proguard相关的基本知识，也有一些不错的文章链接。<a id="more"></a>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&amp;mid=404234343&amp;idx=1&amp;sn=b297b01ee7c656b900417f14a2a0ccae&amp;scene=1&amp;srcid=0303KKfAyLlCyDJT1Sutn26i&amp;key=710a5d99946419d9c72026bcf5c728d9f9fb967dc032ffe2a60669550d6677ace7cadcf6453d69de28540dcbdceefb49&amp;ascene=0&amp;uin=MTYzMjY2MTE1&amp;devicetype=iMac+MacBookPro10%2C1+OSX+OSX+10.11.3+build(15D21" target="_blank" rel="noopener">TRIM：提升磁盘性能，缓解Android卡顿</a>&amp;version=11020201&amp;pass_ticket=VbRCYWXa6oXQkbEbGqIqO1z%2BRQ8XRpmC8IJJVBb2EJ8%3D)。这篇文章提到了Android系统上长期读写文件造成的磁盘碎片化对Android系统流畅度的影响。</li>
</ol>
<blockquote>
<p>Android手机大多采用NAND Flash架构的闪存卡。虽然 NAND Flash 的优点多多，但是为了延长驱动器的寿命，它的读写操作均是以 Page 为单位进行的，但擦除操作却是按 Block 为单位进行的。这会造成“写入放大”（Write Amplification）问题。这一点可以使用TRIM技术解决:</p>
<blockquote>
<p>TRIM 是一条 ATA 指令，由操作系统发送给闪存主控制器，告诉它哪些数据占的地址是“无效”的。在 TRIM 的帮助下，闪存主控制器就可以提前知道哪些 Page 是“无效”的，便可以在适当的时机做出优化，从而改善性能。</p>
</blockquote>
<p>后面用实验证明了这种猜想，以及Android系统确实使用该技术对系统做出了优化，结论如下:</p>
<ol>
<li>在 TRIM 无效的情况下，长期使用 SD 卡，磁盘写入速度会受到明显影响;</li>
<li>TRIM 对因闲置数据块造成的 I/O 性能下降有一定的恢复作用;</li>
<li>大量的读写操作对 SD 卡造成了一定量的不可恢复的损耗;</li>
</ol>
</blockquote>
<ol>
<li><a href="http://blog.csdn.net/UsherFor/article/details/46827587" target="_blank" rel="noopener">如何做到将apk大小减少6M</a>。讲了一组与缩小APK大小相关的优化措施，挺全面。</li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI1NjEwMTM4OA==&amp;mid=2651232233&amp;idx=1&amp;sn=03d9858ac451f2768b804d2604a8e12e" target="_blank" rel="noopener">PNG图片压缩对比分析</a>。调研了目前常用的PNG压缩工具和第三方库，在决定使用pngquant的基础上开发Gradle插件，完成PNG的自动打包压缩，非常具有实践性。</li>
</ol>
<h2 id="知识整理"><a href="#知识整理" class="headerlink" title="知识整理"></a>知识整理</h2><ol>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzA4MjU5NTY0NA==&amp;mid=404530070&amp;idx=1&amp;sn=e2580b69d6ec73dabf8160216aa6702a&amp;scene=1&amp;srcid=0322dGvv5B4miLg3vt0q2rK2&amp;key=710a5d99946419d9e5ab07eaa09e546952524b770e8a63c46c223b7588209d3a542fe4a0827571ac73b03cb78b404289&amp;ascene=0&amp;uin=MTYzMjY2MTE1&amp;devicetype=iMac+MacBookPro10%2C1+OSX+OSX+10.11.4+build(15E65" target="_blank" rel="noopener">Android Bitmap面面观</a>&amp;version=11020201&amp;pass_ticket=Sqb%2BpOLTrZ0wixoScJ8flYxFV4tOFnBa7NFos1uIG8U%3D)</p>
</li>
<li><p><a href="http://ztelur.github.io/2016/03/16/Android-MotionEvent%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">Android MotionEvent详解</a>。里面有着对Index、Pointer、Id的讨论。</p>
</li>
<li><p><a href="http://jijiaxin89.com/2015/08/30/Android-s-Runtime-Permission/" target="_blank" rel="noopener">Android M 新的运行时权限开发者需要知道的一切</a></p>
</li>
<li><p><a href="http://mp.weixin.qq.com/s?__biz=MzA4MjU5NTY0NA==&amp;mid=404388098&amp;idx=1&amp;sn=8bbbba7692dca68cdda2212dec4d86c0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">你应该知道的那些Android小经验</a></p>
</li>
<li><p><a href="http://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&amp;mid=403263974&amp;idx=1&amp;sn=b0315addbc47f3c38e65d9c633a12cd6&amp;scene=4#wechat_redirect" target="_blank" rel="noopener">Android 开发绕不过的坑：你的 Bitmap 究竟占多大内存？</a>。详细探究了关于图片放置在不同分辨率文件夹下面生成Bitmap后所占内存大小的计算方法，清楚明白。</p>
<blockquote>
<p>整理出来的公式分为两部分：</p>
<p>1）内存图片实际的宽高计算：内存宽/高 = (int)(文件实际宽/高 * 屏幕分辨率 / 文件夹分辨率 + 0.5)</p>
<p>2）内存占用计算：内存大小 = 内存宽 <em> 内存高 </em> 每个像素占用值。</p>
<p>每个像素占用值可以参见：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">SkColorTypeBytesPerPixel</span><span class="params">(SkColorType ct)</span> </span>&#123;</span><br><span class="line">&gt;    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint8_t</span> gSize[] = &#123;</span><br><span class="line">&gt;     <span class="number">0</span>,  <span class="comment">// Unknown</span></span><br><span class="line">&gt;     <span class="number">1</span>,  <span class="comment">// Alpha_8</span></span><br><span class="line">&gt;     <span class="number">2</span>,  <span class="comment">// RGB_565</span></span><br><span class="line">&gt;     <span class="number">2</span>,  <span class="comment">// ARGB_4444</span></span><br><span class="line">&gt;     <span class="number">4</span>,  <span class="comment">// RGBA_8888</span></span><br><span class="line">&gt;     <span class="number">4</span>,  <span class="comment">// BGRA_8888</span></span><br><span class="line">&gt;     <span class="number">1</span>,  <span class="comment">// kIndex_8</span></span><br><span class="line">&gt;   &#125;;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>粗略的看，<strong>图片占用内存大小与解析格式、存放目录以及手机屏幕密度相关</strong>。</p>
</blockquote>
</li>
<li><p>待补充。</p>
</li>
</ol>
<h2 id="黑科技"><a href="#黑科技" class="headerlink" title="黑科技"></a>黑科技</h2><ol>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzAxNjI3MDkzOQ==&amp;mid=405919721&amp;idx=1&amp;sn=fdad21c0bc74d90e66443d488e8cdc8f&amp;scene=0&amp;key=710a5d99946419d977ba9c54e81b348f298b6edd533df2290bf866f6dc83684af4956d4748ed17fc4b79f57bd5c02431&amp;ascene=0&amp;uin=MTYzMjY2MTE1&amp;devicetype=iMac+MacBookPro10%2C1+OSX+OSX+10.11.3+build(15D21" target="_blank" rel="noopener">一种为 Apk 动态写入信息的方案</a>&amp;version=11020201&amp;pass_ticket=obnYCpEe4OrQ6yNew2Dy2ncIZX%2B8wffXKUYSyIB2KVY%3D)<br>挺有意思的手法，这篇文章基于分享场景介绍了一种动态为APK写入信息的方法——从Zip文件格式入手，在文件尾部插入一小段信息，利用这段信息完成分享场景的完整性。赞！</li>
<li><a href="http://blog.csdn.net/xieyuooo/article/details/7068216" target="_blank" rel="noopener">如何精确地测量java对象的大小-底层instrument API</a>和<a href="http://my.oschina.net/xianggao/blog/362495" target="_blank" rel="noopener">java.lang.Instrument 代理Agent使用</a>。主要介绍了<code>Agent</code>的存在以及Instrument测量Java对象大小的使用方式。</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HandlerThread & IntentService源码分析]]></title>
      <url>http://www.timebridge.space/2016/02/26/Android-HandlerThread-And-IntentService/</url>
      <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>【环境】代码分析基于 API-23。</p>
<h2 id="介绍和使用"><a href="#介绍和使用" class="headerlink" title="介绍和使用"></a>介绍和使用</h2><p>本文将介绍两个类：HandlerThread和IntentService，后者使用到了前者，两个类都短小精悍，放在一起分析很nice。</p>
<p>在学习Service的时候，我们一定会知道IntentService:，官方文档不止一次强调: Service本身是运行在主线程中的，而主线程中是不适合进行耗时任务的，因而官方文档叮嘱我们一定要在Service中另开线程进行耗时任务处理。IntentService正是为这个目的而诞生的一个优雅设计，让程序员不用再管理线程的开启和运行。</p>
<p>两个类具体的使用例子见下面的分析。<a id="more"></a></p>
<h2 id="HandlerThread源码剖析"><a href="#HandlerThread源码剖析" class="headerlink" title="HandlerThread源码剖析"></a>HandlerThread源码剖析</h2><p>HandlerThread是一个很简单的类，在<a href="http://www.muzileecoding.com/androidsource/Android-Handler.html" target="_blank" rel="noopener">Handler一文</a>中，我们描述了创建一个带Looper(消息循环机制)的线程的做法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          Looper.prepare();</span><br><span class="line"></span><br><span class="line">          mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                 <span class="comment">// process incoming messages here</span></span><br><span class="line">              &#125;</span><br><span class="line">         &#125;;</span><br><span class="line">         Looper.loop();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个模板，而且对于Looper.prepare()，Looper.loop()以及Handler的创建顺序是有相应要求的，HandlerThread是对这个创建过程的一个封装——直接提供一个带有Looper机制的Thread。</p>
<p>HandlerThread的完整源码只有149行，删除注释和License之后，只有71行，如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mPriority;</span><br><span class="line">    <span class="keyword">int</span> mTid = -<span class="number">1</span>;</span><br><span class="line">    Looper mLooper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        mPriority = Process.THREAD_PRIORITY_DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name, <span class="keyword">int</span> priority)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        mPriority = priority;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">//回调方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLooperPrepared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mTid = Process.myTid();</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            mLooper = Looper.myLooper();</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        Process.setThreadPriority(mPriority);</span><br><span class="line">        onLooperPrepared();</span><br><span class="line">        Looper.loop();</span><br><span class="line">        mTid = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Looper <span class="title">getLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isAlive()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// If the thread has been started, wait until the looper has been created.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive() &amp;&amp; mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mLooper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper looper = getLooper();</span><br><span class="line">        <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            looper.quit();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">quitSafely</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper looper = getLooper();</span><br><span class="line">        <span class="keyword">if</span> (looper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            looper.quitSafely();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getThreadId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mTid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HandlerThread是Thread的一个子类，之前的创建过程都被放到了run()方法中，看过<a href="http://www.muzileecoding.com/androidsource/Android-Handler.html" target="_blank" rel="noopener">Handler一文</a>的读者应该对此非常熟悉。run()方法中有几行代码比较奇特:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">	mLooper = Looper.myLooper();</span><br><span class="line">	notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里为什么要加上<strong>synchronized</strong>关键字呢？答案在于getLooper()方法。</p>
<p>getLooper()方法是将HandlerThread的Looper暴露到外面以便于其余的线程建立这个Thread的Handler与之交互。如果其余线程在HandlerThread启动之前(即run()方法执行之前，即Looper.prepare()执行之前)调用getLooper()方法，那么这个时候HandlerThread是没有可用的Looper的，所以在getLooper()方法中，这样的外部线程就会被wait()。</p>
<p>而等到run()方法运行到Looper.prepare()之后，Looper已经完备，此时应该通知所有的wait线程获取Looper——这里是需要做同步的。</p>
<p>解释到此，对于Handler熟悉的读者一定知道HandlerThread是如何使用的，如果不知道，下面的IntentService提供了完美的例子。</p>
<blockquote>
<p>线程，是可以设置优先级的。</p>
</blockquote>
<h2 id="IntentService源码剖析"><a href="#IntentService源码剖析" class="headerlink" title="IntentService源码剖析"></a>IntentService源码剖析</h2><p>IntentService也很短小，只有164行，真是的代码则只有70行不到:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IntentService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Looper mServiceLooper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ServiceHandler mServiceHandler;</span><br><span class="line">    <span class="keyword">private</span> String mName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mRedelivery;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ServiceHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(looper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            onHandleIntent((Intent)msg.obj);</span><br><span class="line">            stopSelf(msg.arg1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IntentService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        mName = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntentRedelivery</span><span class="params">(<span class="keyword">boolean</span> enabled)</span> </span>&#123;</span><br><span class="line">        mRedelivery = enabled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> It would be nice to have an option to hold a partial wakelock</span></span><br><span class="line">        <span class="comment">// during processing, and to have a static startService(Context, Intent)</span></span><br><span class="line">        <span class="comment">// method that would launch the service &amp; hand off a wakelock.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        HandlerThread thread = <span class="keyword">new</span> HandlerThread(<span class="string">"IntentService["</span> + mName + <span class="string">"]"</span>);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        mServiceLooper = thread.getLooper();</span><br><span class="line">        mServiceHandler = <span class="keyword">new</span> ServiceHandler(mServiceLooper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(Intent intent, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        Message msg = mServiceHandler.obtainMessage();</span><br><span class="line">        msg.arg1 = startId;</span><br><span class="line">        msg.obj = intent;</span><br><span class="line">        mServiceHandler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        onStart(intent, startId);</span><br><span class="line">        <span class="keyword">return</span> mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mServiceLooper.quit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@WorkerThread</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(Intent intent)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大致看上去是这样的: IntentService在内部建立了一个HandlerThread，每一个被发送到Service的Handler都被抛到Handlerthread中执行，回调方法: onHandlerIntent()。下面我们来仔细分析一下。</p>
<p>首先贴一下类的注释:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * IntentService is a base class for &#123;<span class="doctag">@link</span> Service&#125;s that handle asynchronous</span></span><br><span class="line"><span class="comment"> * requests (expressed as &#123;<span class="doctag">@link</span> Intent&#125;s) on demand.  Clients send requests</span></span><br><span class="line"><span class="comment"> * through &#123;<span class="doctag">@link</span> android.content.Context#startService(Intent)&#125; calls; the</span></span><br><span class="line"><span class="comment"> * service is started as needed, handles each Intent in turn using a worker</span></span><br><span class="line"><span class="comment"> * thread, and stops itself when it runs out of work.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This "work queue processor" pattern is commonly used to offload tasks</span></span><br><span class="line"><span class="comment"> * from an application's main thread.  The IntentService class exists to</span></span><br><span class="line"><span class="comment"> * simplify this pattern and take care of the mechanics.  To use it, extend</span></span><br><span class="line"><span class="comment"> * IntentService and implement &#123;<span class="doctag">@link</span> #onHandleIntent(Intent)&#125;.  IntentService</span></span><br><span class="line"><span class="comment"> * will receive the Intents, launch a worker thread, and stop the service as</span></span><br><span class="line"><span class="comment"> * appropriate.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;All requests are handled on a single worker thread -- they may take as</span></span><br><span class="line"><span class="comment"> * long as necessary (and will not block the application's main loop), but</span></span><br><span class="line"><span class="comment"> * only one request will be processed at a time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;div class="special reference"&gt;</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;Developer Guides&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;For a detailed discussion about how to create services, read the</span></span><br><span class="line"><span class="comment"> * &lt;a href="&#123;<span class="doctag">@docRoot</span>&#125;guide/topics/fundamentals/services.html"&gt;Services&lt;/a&gt; developer guide.&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/div&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> android.os.AsyncTask</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>注释里面有几个很重要的点:</p>
<ol>
<li>Client是通过startService(Intent)来向Service发送请求的，请求被包装在Intent里面；</li>
<li>在有任务的时候，Service会自己启动，没有任务的时候自己Stop；</li>
<li>这个类实现了所谓的”work queue processor”模式，类似于主线程处理消息的机制，也就是串行的执行队列任务；</li>
<li>使用IntentService只需要继承该类，并实现<code>onHandleIntent(Intent intent)</code>方法即可；</li>
</ol>
<p>接下来我们关注几个重要的方法:</p>
<ol>
<li><strong>onStartCommand():</strong> 这个方法每次在startService()方法调用的时候都会被执行，它可以根据一个boolean值决定返回值（这里可以去查看一下Service该方法返回值的含义，它决定了Service被杀死之后如何复苏），这里我们可以通过setIntentRedelivery()方法控制返回值；</li>
<li><strong>onStart():</strong> 这个方法在包装消息的时候是把startId包装到了消息里面。这个startId很有用，影响到了前面说的第2点（自动启动、停止）的实现；</li>
</ol>
<p>关于startId的用处:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">However, <span class="function"><span class="keyword">if</span> your service handles multiple requests to <span class="title">onStartCommand</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">concurrently, then you shouldn't stop the service when you're done </span></span><br><span class="line"><span class="function">processing a start request, because you might have since received a new </span></span><br><span class="line"><span class="function">start <span class="title">request</span> <span class="params">(stopping at the end of the first request would terminate the </span></span></span><br><span class="line"><span class="function"><span class="params">second one)</span>. To avoid <span class="keyword">this</span> problem, you can use <span class="title">stopSelf</span><span class="params">(<span class="keyword">int</span>)</span> to ensure </span></span><br><span class="line"><span class="function">that your request to stop the service is always based on the most recent </span></span><br><span class="line"><span class="function">start request. That is, when you call <span class="title">stopSelf</span><span class="params">(<span class="keyword">int</span>)</span>, you pass the ID of the </span></span><br><span class="line"><span class="function">start <span class="title">request</span> <span class="params">(the startId delivered to onStartCommand()</span>) to which your </span></span><br><span class="line"><span class="function">stop request corresponds. Then <span class="keyword">if</span> the service received a new start request </span></span><br><span class="line"><span class="function">before you were able to call <span class="title">stopSelf</span><span class="params">(<span class="keyword">int</span>)</span>, then the ID will not match and </span></span><br><span class="line"><span class="function">the service will not stop.</span></span><br></pre></td></tr></table></figure>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><ol>
<li>The IntentService internally handles the two start types <code>START_NOT_STICKY</code> and <code>START_REDELIVER_INTENT</code>. The first is default, so the latter needs to be set with <code>setIntentRedelivery(true)</code>.</li>
<li>There is no need to stop the IntentService with <code>stopSelf()</code>, because that is done internally.</li>
</ol>
<blockquote>
<p>BroadcastReceiver中有一个<code>BroadcastReceiver.goAsync()</code>方法，用于维持BroadcastReceiver的生命周期。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Android上为了将耗时操作剥离出主线程做了很多的工作，为此也为线程间调度做了很多的努力。</p>
<p>所有的线程消息调度都是基于<a href="http://www.muzileecoding.com/androidsource/Android-Handler.html" target="_blank" rel="noopener">Handler机制</a>，Android还基于Handler做了更多高级的封装，最经典的就是 <strong>AsyncTask</strong>，这些类都有相似的特点：短小精悍，便于开发。同时也是非常不错的学习材料。</p>
<p>IntentService专门用于处理串行化处理任务，一旦复杂性超过这种需求，IntentService就不大适用了，比如并发处理任务。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android开发笔记]]></title>
      <url>http://www.timebridge.space/2016/02/22/Android-develop-note/</url>
      <content type="html"><![CDATA[<p><strong>【1】空格问题</strong><br>如何在字符串中添加正确的空格，问题源自于如何添加一个中文空格。<br>方案: <a href="http://stackoverflow.com/questions/1587056/android-string-concatenate-how-to-keep-the-spaces-at-the-end-and-or-beginnin" target="_blank" rel="noopener">StackOverFlow</a></p>
<p><strong>【2】No Debuggable Applications</strong><br>在Android Studio的菜单栏中选择Tools -&gt; Android -&gt; Enable ADB Integration。</p>
<p>PS:需要关闭DDMS。<a id="more"></a></p>
<p>关于原因，<a href="http://stackoverflow.com/questions/9242148/what-is-the-purpose-of-tools-android-enable-adb-service" target="_blank" rel="noopener">StackoverFlow上这个问题</a>下面有回答:</p>
<blockquote>
<p>The ADB (Andorid Debug Bridge) is a service that IDEA uses for debugging Android code on emulator or USB device. This service can be used by only one application in the same time. DDMS tool uses ADB too, so you need to disable ADB-IDEA connection if you want to use DDMS tool without closing IDEA. You won’t be able to debug Android applications in IDEA if this service is disabled, but note that if you try to launch debugging IDEA will notify you that ADB service is disabled and offer to enable it again. So there shouldn’t be any problems after disabling this service. You just need to do it before launching DDMS.</p>
</blockquote>
<p><strong>【3】生命周期问题</strong>  </p>
<ol>
<li>Activity的<code>onCreate()</code>会调用<code>mFragments.dispatchCreate()</code>;</li>
<li>Activity的<code>onStart()</code>会调用<code>mFragments.dispatchActivityCreated()</code>以及<code>mFragments.dispatchStart()</code>(前者保证只调用一次);</li>
<li>内存不足导致Activity被回收后，恢复的时候生命周期如下：<code>onCreate</code> -&gt; <code>onStart</code> -&gt; <code>onRestoreInstanceState</code> -&gt; <code>onActivityResult</code> -&gt; <code>onResume</code>;</li>
<li><code>onActivityResult</code>是在<code>onResume</code>之前被调用的，这一点无论是不是数据恢复，都是一样的，因此在数据回收的情况下，如果要在<code>onActivityResult</code>中使用<code>onResume</code>方法实例化的对象，则务必要小心 —— StackOverFlow上有一个问题<a href="http://stackoverflow.com/questions/6468319/onactivityresult-onresume" target="_blank" rel="noopener">onActivityResult() &amp; onResume()</a>，关注一下其中的高票答案;</li>
</ol>
<p>第三点保证<code>onActivityResult</code>调用的时候数据都恢复成应有的样子了。</p>
<h4 id="持续更新···"><a href="#持续更新···" class="headerlink" title="持续更新···"></a><em>持续更新···</em></h4>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Groovy 安装和 Eclipse 插件安装]]></title>
      <url>http://www.timebridge.space/2016/01/29/Groovy-install-and-ide-plugin/</url>
      <content type="html"><![CDATA[<h2 id="Groovy的安装"><a href="#Groovy的安装" class="headerlink" title="Groovy的安装"></a>Groovy的安装</h2><p>Groovy的安装可以参考<a href="http://www.groovy-lang.org/download.html" target="_blank" rel="noopener">官网上的教程</a>，我是在Mac上安装的，所以可以很偷懒的直接执行命令：<strong>brew install groovy</strong>。</p>
<p>在本地安装后需要配置一下环境变量，就和Java一样。在命令行里面执行如下命令：<strong>vi ~/.bash_profile</strong>。单独加入如下这行:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export GROOVY_HOME=/usr/local/opt/groovy/libexec</span><br></pre></td></tr></table></figure>
<p>然后退出保存，接着执行 <strong>source ~/.bash_profile</strong> 即可。在命令行里面输入 <strong>groovy -v</strong> 命令，有类似如下输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Groovy Version: <span class="number">2.4</span>.3 JVM: <span class="number">1.6</span>.0_65 Vendor: Apple Inc. OS: Mac OS X</span><br></pre></td></tr></table></figure>
<p>就表示安装成功了。<a id="more"></a></p>
<h2 id="IDE的插件集成"><a href="#IDE的插件集成" class="headerlink" title="IDE的插件集成"></a>IDE的插件集成</h2><p>首先说明两点:<br>1）groovy自己是有一个简单GUI组件可以实现编码的，如果怕麻烦，可以直接使用，方法是在命令行里面执行 <strong>groovyConsole</strong> 命令，你就可以看见下面的UI：</p>
<p><img src="http://7xktd8.com1.z0.glb.clouddn.com/GroovyGUI.png" alt="Groovy自带GUI"><br>这个简单的编辑器基本可以满足联系的需要，上半部分是编码的，下半部分是输出，编写完成之后执行Cmd+R即可运行程序。另外字体也可以放大缩小，考虑的还是比较全面的。读者可以研究一下菜单栏，命令不多，可以很快的过一遍；<br>2）虽然平时使用Intellij比较多，但这里只讲一下如何在Eclipse中配置插件，原因是我对这个比较熟悉；</p>
<p>看到这里，先不要急着去下载Eclipse，Groovy的安装对Eclipse的版本有要求。插件是一个<a href="https://github.com/groovy/groovy-eclipse/wiki" target="_blank" rel="noopener">Github项目</a>，它的<a href="https://github.com/groovy/groovy-eclipse/wiki" target="_blank" rel="noopener">Wiki</a>里面写了支持的Eclipse和对应的插件下载链接，比如写这篇文章的时候，它最新支持到4.4，而Eclipse已经到4.6了，Wiki里面有如下描述：</p>
<p><img src="http://7xktd8.com1.z0.glb.clouddn.com/Eclipse和Groovy插件版本对应图.png" alt="Eclipse和Groovy插件版本对应图"><br>看着这个，去下载一个4.4(Luna)版本的Eclipse并安装完成。打开Eclipse，在菜单栏中依次点击：Help-&gt;Install New Software…，就看到如下界面：</p>
<p><img src="http://7xktd8.com1.z0.glb.clouddn.com/Eclipse安装Groovy插件.png" alt="Eclipse安装Groovy插件"><br>点击Add，弹出Add Resposity框，随便取一个名字，之后将前面表格中对应版本的插件下载链接填到Location里面，点击OK，点击Next，在拉下来的组件中，只有一个是Required，其余的可以不选，之后一路Accept &amp; Next，直到完成安装。</p>
<p>最后Eclipse会要求重启，重启之后，插件安装完成。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Loader & LoaderManager源码分析]]></title>
      <url>http://www.timebridge.space/2015/12/17/Android-loader-and-loadermanager/</url>
      <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>【环境】代码分析基于 supportv4包。</p>
<h2 id="Loader的介绍和使用"><a href="#Loader的介绍和使用" class="headerlink" title="Loader的介绍和使用"></a>Loader的介绍和使用</h2><p>加载器: 用于在Activity和Fragment中异步加载数据，它有以下特性:</p>
<ol>
<li><strong>异步数据管理</strong> 除了可以异步加载数据，还能在数据源更新的时候通知上层;</li>
<li><strong>生命周期管理</strong> 和Activity、Fragment的生命周期绑定，在Activity的配置变化的时候仍然能够继续在后台运行;</li>
<li><strong>缓存数据</strong> 如果有异步数据无法分发，它可以缓存数据直到有接收者出现，比如在Activity重建期间;</li>
<li><strong>防止内存泄露</strong> 不会影响Context对象的回收，因为它只依赖于Application Context;</li>
</ol>
<p>详细介绍和用法可以看<a href="http://developer.android.com/intl/zh-cn/guide/components/loaders.html" target="_blank" rel="noopener">官网文档</a>。<a id="more"></a></p>
<blockquote>
<p>开发官网已经逐步国际化了，现在能看中文版啦，唯一要求就是翻·个·墙。</p>
</blockquote>
<h2 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h2><p>我们从使用代码切入，调用一个Loader只需要如下代码即可:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数的具体类型见下面的方法</span></span><br><span class="line">getLoaderManager().initLoader(<span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<p>我们来看一下initLoader（位于LoaderManagerImpl中）:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;D&gt; <span class="function">Loader&lt;D&gt; <span class="title">initLoader</span><span class="params">(<span class="keyword">int</span> id, Bundle args, LoaderManager.LoaderCallbacks&lt;D&gt; callback)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mCreatingLoader) &#123;<span class="comment">//表示正在创建中</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Called while creating a loader"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	LoaderInfo info = mLoaders.get(id);</span><br><span class="line">        </span><br><span class="line">	<span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"initLoader in "</span> + <span class="keyword">this</span> + <span class="string">": args="</span> + args);</span><br><span class="line">	<span class="keyword">if</span> (info == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// Loader doesn't already exist; create.</span></span><br><span class="line">		info = createAndInstallLoader(id, args,  (LoaderManager.LoaderCallbacks&lt;Object&gt;)callback);</span><br><span class="line">		<span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"  Created new loader "</span> + info);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"  Re-using existing loader "</span> + info);</span><br><span class="line">		info.mCallbacks = (LoaderManager.LoaderCallbacks&lt;Object&gt;)callback;</span><br><span class="line">	&#125;</span><br><span class="line">   <span class="comment">//这个点要额外注意: 这里就是从已经存在的Loader中获取数据，比如Activity配置变化的时候——实现了前面说的第三点特性，数据缓存。</span></span><br><span class="line">	<span class="keyword">if</span> (info.mHaveData &amp;&amp; mStarted) &#123;</span><br><span class="line">		<span class="comment">// If the loader has already generated its data, report it now.</span></span><br><span class="line">		info.callOnLoadFinished(info.mLoader, info.mData);</span><br><span class="line">	&#125;</span><br><span class="line">        </span><br><span class="line">	<span class="keyword">return</span> (Loader&lt;D&gt;)info.mLoader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先看一下mLoaders变量:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> SparseArrayCompat&lt;LoaderInfo&gt; mLoaders = <span class="keyword">new</span> SparseArrayCompat&lt;LoaderInfo&gt;();</span><br></pre></td></tr></table></figure>
<p>它是一个从id到LoaderInfo的映射，从代码可以看出，如果没有对应的LoaderInfo，就createAndInstallLoader，否则，更新一下callback。如果LoadInfo记录这个Loader已经启动运行并且保存了之前的数据，那么直接调用回调函数，调用的是LoadInfo的callOnLoadFinished方法。最后返回创建出来的Loader。很明显重点在于createAndInstallLoader方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> LoaderInfo <span class="title">createAndInstallLoader</span><span class="params">(<span class="keyword">int</span> id, Bundle args, LoaderManager.LoaderCallbacks&lt;Object&gt; callback)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		mCreatingLoader = <span class="keyword">true</span>;<span class="comment">//1. 设置标志</span></span><br><span class="line">		LoaderInfo info = createLoader(id, args, callback);<span class="comment">//2. 创建</span></span><br><span class="line">		installLoader(info);<span class="comment">//3. install</span></span><br><span class="line">		<span class="keyword">return</span> info;</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		mCreatingLoader = <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里设置了一个标志位mCreatingLoader，表示正在创建Loader，整个过程分为create和install两步。</p>
<h3 id="Loader的create过程"><a href="#Loader的create过程" class="headerlink" title="Loader的create过程"></a>Loader的create过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> LoaderInfo <span class="title">createLoader</span><span class="params">(<span class="keyword">int</span> id, Bundle args, LoaderManager.LoaderCallbacks&lt;Object&gt; callback)</span> </span>&#123;</span><br><span class="line">	LoaderInfo info = <span class="keyword">new</span> LoaderInfo(id, args, callback);</span><br><span class="line">	Loader&lt;Object&gt; loader = callback.onCreateLoader(id, args);</span><br><span class="line">	info.mLoader = loader;</span><br><span class="line">	<span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建过程很简单，创建一个LoaderInfo，从回调的onCreateLoader中获取对应的Loader，再将Loader设置到LoaderInfo中，这样LoaderInfo将保存着有关Loader的所有信息：id，args以及Loader本身。</p>
<h3 id="Loader的install过程"><a href="#Loader的install过程" class="headerlink" title="Loader的install过程"></a>Loader的install过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">installLoader</span><span class="params">(LoaderInfo info)</span> </span>&#123;</span><br><span class="line">	mLoaders.put(info.mId, info);</span><br><span class="line">	<span class="keyword">if</span> (mStarted) &#123;</span><br><span class="line">		<span class="comment">// The activity will start all existing loaders in it's onStart(),</span></span><br><span class="line">		<span class="comment">// so only start them here if we're past that point of the activitiy's</span></span><br><span class="line">		<span class="comment">// life cycle</span></span><br><span class="line">		info.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先将LoaderInfo保存到mLoaders中，如果已经start过了，就调用LoaderInfo的start方法。注意方法内部这段注释：<strong>Activity在onStart()方法中会启动所有的loaders，所以只有在onStart()之后还没有启动的Loader才会在这里启动</strong>。</p>
<p>从官网例子中可以看到，我们只需要调用initLoader方法即可，并不需要手动启动加载过程，再加上上面的注释，我们可以猜测: Loader的数据加载是由Activity/Fragment的生命周期方法启动的，下面就来分析一下。</p>
<h3 id="Loader的启动过程"><a href="#Loader的启动过程" class="headerlink" title="Loader的启动过程"></a>Loader的启动过程</h3><p>在supportv4的FragmentActivity中，查看其onStart方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.onStart();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="comment">//最后三行代码</span></span><br><span class="line">	mFragments.doLoaderStart();</span><br><span class="line"></span><br><span class="line">	mFragments.dispatchStart();</span><br><span class="line">	mFragments.reportLoaderStart();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mFragments是FragmentManager类型，这里就调用了它的doLoaderStart()方法——这里表明：<strong>为了Loader在Activity和Fragment中都能使用，同时逻辑一致，Loader是通过FragmentManager进行管理的，Activity只是引用了FragmentManager的实例。</strong></p>
<blockquote>
<p>【特别注意】这里还调用了一个和Loader相关的方法:reportLoaderStart。这个方法后面讲retain的时候会用到，暂时不用关注。</p>
</blockquote>
<p>我们来看一下FragmentManager的doLoaderStart()方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doLoaderStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mLoadersStarted) &#123;<span class="comment">//只能Start一次</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mLoadersStarted = <span class="keyword">true</span>;<span class="comment">//标记开始</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mLoaderManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">		mLoaderManager.doStart();</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mCheckedForLoaderManager) &#123;</span><br><span class="line">		mLoaderManager = getLoaderManager(<span class="string">"(root)"</span>, mLoadersStarted, <span class="keyword">false</span>);</span><br><span class="line">		<span class="comment">// the returned loader manager may be a new one, so we have to start it</span></span><br><span class="line">		<span class="keyword">if</span> ((mLoaderManager != <span class="keyword">null</span>) &amp;&amp; (!mLoaderManager.mStarted)) &#123;</span><br><span class="line">			mLoaderManager.doStart();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	mCheckedForLoaderManager = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会初始化LoaderManager，并调用它的doStart()方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Starting in "</span> + <span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">if</span> (mStarted) &#123;</span><br><span class="line">		RuntimeException e = <span class="keyword">new</span> RuntimeException(<span class="string">"here"</span>);</span><br><span class="line">		e.fillInStackTrace();</span><br><span class="line">		Log.w(TAG, <span class="string">"Called doStart when already started: "</span> + <span class="keyword">this</span>, e);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//start之后就会设置标志位，还记得前面LoaderManager.installLoader方法对这个参数的使用么？</span></span><br><span class="line">	mStarted = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Call out to sub classes so they can start their loaders</span></span><br><span class="line">	<span class="comment">// Let the existing loaders know that we want to be notified when a load is complete</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = mLoaders.size()-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		mLoaders.valueAt(i).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里又看到了mStarted标志位，很明显，一个LoaderManager启动两次是会打印异常信息的(不会crash)。然后遍历mLoaders中的所有的LoaderInfo，调用start()方法启动。</p>
<h3 id="又见start-方法"><a href="#又见start-方法" class="headerlink" title="又见start()方法"></a>又见start()方法</h3><p>前面的分析中，不论Loader是在Activity的onStrat()方法之前还是之后调用的，最终启动都是调用的Loader的start()方法。下面我们来看LoaderInfo的start()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//A</span></span><br><span class="line">	<span class="keyword">if</span> (mRetaining &amp;&amp; mRetainingStarted) &#123;</span><br><span class="line">		<span class="comment">// Our owner is started, but we were being retained from a</span></span><br><span class="line">		<span class="comment">// previous instance in the started state...  so there is really</span></span><br><span class="line">		<span class="comment">// nothing to do here, since the loaders are still started.</span></span><br><span class="line">		mStarted = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//B</span></span><br><span class="line">	<span class="keyword">if</span> (mStarted) &#123;</span><br><span class="line">		<span class="comment">// If loader already started, don't restart.</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mStarted = <span class="keyword">true</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"  Starting: "</span> + <span class="keyword">this</span>);</span><br><span class="line">	<span class="comment">//Loader为Null则尝试去创建Loader</span></span><br><span class="line">	<span class="keyword">if</span> (mLoader == <span class="keyword">null</span> &amp;&amp; mCallbacks != <span class="keyword">null</span>) &#123;</span><br><span class="line">		mLoader = mCallbacks.onCreateLoader(mId, mArgs);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (mLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (mLoader.getClass().isMemberClass() &amp;&amp; !Modifier.isStatic(mLoader.getClass().getModifiers())) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Object returned from onCreateLoader must not be a non-static inner member class: "</span></span><br><span class="line">                            + mLoader);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!mListenerRegistered) &#123;</span><br><span class="line">			mLoader.registerListener(mId, <span class="keyword">this</span>);</span><br><span class="line">			mLoader.registerOnLoadCanceledListener(<span class="keyword">this</span>);</span><br><span class="line">			mListenerRegistered = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		mLoader.startLoading();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里在进入正常流程之前会做两个判断：</p>
<p><strong>A处</strong>  如果一个LoaderInfo已经被retain过，且retain之前已经start了，则标记一下mStarted为true，直接返回(<strong>关于retain的含义，见后面的解释，这里不需要纠结，知道有这个条件判断就好</strong>)；<br><strong>B处</strong>  如果Loader已经启动了，不需要打断或者做别的处理，直接返回；  </p>
<p><strong>如果Loader是成员类，并且不是static的，则会抛出异常（这里会直接抛异常，比handler更加严厉）。</strong>之后在Loader上注册监听，这两个监听是OnLoadCompleteListener和OnLoadCanceledListener(注: LoaderInfo类实现了这两个接口)，分别监听加载完成和加载取消两个事件。最后调用Loader的startLoading方法开始加载。</p>
<h3 id="Loader的load过程"><a href="#Loader的load过程" class="headerlink" title="Loader的load过程"></a>Loader的load过程</h3><p>Loader的startLoading方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startLoading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	mStarted = <span class="keyword">true</span>;</span><br><span class="line">	mReset = <span class="keyword">false</span>;</span><br><span class="line">	mAbandoned = <span class="keyword">false</span>;</span><br><span class="line">	onStartLoading();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Subclasses must implement this to take care of loading their data,</span></span><br><span class="line"><span class="comment"> * as per &#123;<span class="doctag">@link</span> #startLoading()&#125;.  This is not called by clients directly,</span></span><br><span class="line"><span class="comment"> * but as a result of a call to &#123;<span class="doctag">@link</span> #startLoading()&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStartLoading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码，设置flag之后，startLoading就调用了onStartLoading方法，根据注释，子类必须实现这个方法来加载数据。Loader本身是一个接近接口的具体类，实际的代码量很少，读者可以去看它的源码，与前面提到的异步过程没有关系，这是一个很原始的类，实际使用的时候，比较常用的类是<strong>AsyncTaskLoader</strong>，它的源码分析见另外一篇文章。</p>
<p>OK，到这里，Loader的初始化和启动加载过程已经讲完了。我们只需要在onStartLoading()中加载数据即可。先不要好奇数据怎么抛到调用层，前面说了，因为Loader很原始，方法之间的关系没有建立，这块需要去AsyncTaskLoader中体现。</p>
<h2 id="Loader的停止过程"><a href="#Loader的停止过程" class="headerlink" title="Loader的停止过程"></a>Loader的停止过程</h2><p>有了上述创建启动过程，分析停止过程的切入点就比较好找了。根据经验，在Activity的onStart()方法有创建方法，则在对应的onStop()方法中应该就停止方法。onStop()方法比较绕，但是追踪一下不难发现最终会调用到这个方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onReallyStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	mFragments.doLoaderStop(mRetaining);</span><br><span class="line">	mFragments.dispatchReallyStop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就调用了FragmentController的doLoaderStop方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doLoaderStop</span><span class="params">(<span class="keyword">boolean</span> retain)</span> </span>&#123;</span><br><span class="line">	mRetainLoaders = retain;</span><br><span class="line">	<span class="keyword">if</span> (mLoaderManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!mLoadersStarted) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	mLoadersStarted = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (retain) &#123;</span><br><span class="line">		mLoaderManager.doRetain();</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		mLoaderManager.doStop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里在LoaderManager不为null且已经启动的情况下，根据retain判断决定调用LoaderManager的方法。</p>
<h3 id="Loader的retain过程"><a href="#Loader的retain过程" class="headerlink" title="Loader的retain过程"></a>Loader的retain过程</h3><p>retain是从外部传出来的，Activity正常stop的时候，这个值为false，但是下面情况是true的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">onRetainNonConfigurationInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mStopped) &#123;</span><br><span class="line">		doReallyStop(<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//·····</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此比如转屏的时候，我们只是做retain，而不是stop。LoaderInfo的retain方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">retain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"  Retaining: "</span> + <span class="keyword">this</span>);</span><br><span class="line">	mRetaining = <span class="keyword">true</span>;</span><br><span class="line">	mRetainingStarted = mStarted;</span><br><span class="line">	mStarted = <span class="keyword">false</span>;</span><br><span class="line">	mCallbacks = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边只是这是一些标志位。并且将<strong>mCallbacks设置为Null</strong>(防止内存泄露)。这边涉及到两个flag——mRetainingStarted和mStarted。前面start()的时候用到了这两个参数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mRetaining &amp;&amp; mRetainingStarted) &#123;</span><br><span class="line">	mStarted = <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详细的retain情况后面补充介绍，了解主流程的话到这里就基本可以了。</p>
<h3 id="Loader的stop过程"><a href="#Loader的stop过程" class="headerlink" title="Loader的stop过程"></a>Loader的stop过程</h3><p>LoaderManager的doStop方法是这样的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Stopping in "</span> + <span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">if</span> (!mStarted) &#123;</span><br><span class="line">		RuntimeException e = <span class="keyword">new</span> RuntimeException(<span class="string">"here"</span>);</span><br><span class="line">		e.fillInStackTrace();</span><br><span class="line">		Log.w(TAG, <span class="string">"Called doStop when not started: "</span> + <span class="keyword">this</span>, e);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = mLoaders.size()-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		mLoaders.valueAt(i).stop();</span><br><span class="line">	&#125;</span><br><span class="line">	mStarted = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有start的时候，是不允许执行stop的，会打印异常信息(同样不会引起crash)。否则遍历所有的LoaderInfo，调用stop()方法，也就是执行下面的方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"  Stopping: "</span> + <span class="keyword">this</span>);</span><br><span class="line">	mStarted = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (!mRetaining) &#123;</span><br><span class="line">		<span class="keyword">if</span> (mLoader != <span class="keyword">null</span> &amp;&amp; mListenerRegistered) &#123;</span><br><span class="line">			<span class="comment">// Let the loader know we're done with it</span></span><br><span class="line">			mListenerRegistered = <span class="keyword">false</span>;</span><br><span class="line">			mLoader.unregisterListener(<span class="keyword">this</span>);</span><br><span class="line">			mLoader.unregisterOnLoadCanceledListener(<span class="keyword">this</span>);</span><br><span class="line">			mLoader.stopLoading();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在没有retain的情况下，主要是取消监听并且调用Loader的stopLoading方法，注意这边调用stopLoading的条件是很苛刻的(PS: 这边这个写法可能有些问题，注册动作和stop不应该有这么强的关系)。Loader里面的stop方法很简单:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopLoading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	mStarted = <span class="keyword">false</span>;</span><br><span class="line">	onStopLoading();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Subclasses must implement this to take care of stopping their loader,</span></span><br><span class="line"><span class="comment"> * as per &#123;<span class="doctag">@link</span> #stopLoading()&#125;.  This is not called by clients directly,</span></span><br><span class="line"><span class="comment"> * but as a result of a call to &#123;<span class="doctag">@link</span> #stopLoading()&#125;.</span></span><br><span class="line"><span class="comment"> * This will always be called from the process's main thread.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStopLoading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和startLoading()很像，同样子类需要去覆盖实现onStopLoading完成加载。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="Loader的retain过程-1"><a href="#Loader的retain过程-1" class="headerlink" title="Loader的retain过程"></a>Loader的retain过程</h3><p>前面说start的时候，留了一个和retain有关的方法:reportLoaderStart，我们看一下这个方法在做什么。这个方法最终会调用FragmentHostCallback的reportLoaderStart方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reportLoaderStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mAllLoaderManagers != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> N = mAllLoaderManagers.size();</span><br><span class="line">		LoaderManagerImpl loaders[] = <span class="keyword">new</span> LoaderManagerImpl[N];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=N-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">			loaders[i] = (LoaderManagerImpl) mAllLoaderManagers.valueAt(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">			LoaderManagerImpl lm = loaders[i];</span><br><span class="line">			lm.finishRetain();</span><br><span class="line">			lm.doReportStart();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里涉及到mAllLoaderManagers变量，它的声明是这样的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The loader managers for individual fragments [i.e. Fragment#getLoaderManager()] */</span></span><br><span class="line"><span class="keyword">private</span> SimpleArrayMap&lt;String, LoaderManager&gt; mAllLoaderManagers;</span><br></pre></td></tr></table></figure>
<p>是一个从String到LoaderManager的映射，另外从变量名称可以看出，这里应该集合了属于Activity的所有的LoaderManager。搜索它被使用的地方可以看到:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LoaderManagerImpl <span class="title">getLoaderManager</span><span class="params">(String who, <span class="keyword">boolean</span> started, <span class="keyword">boolean</span> create)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mAllLoaderManagers == <span class="keyword">null</span>) &#123;</span><br><span class="line">		mAllLoaderManagers = <span class="keyword">new</span> SimpleArrayMap&lt;String, LoaderManager&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">	LoaderManagerImpl lm = (LoaderManagerImpl) mAllLoaderManagers.get(who);</span><br><span class="line">	<span class="keyword">if</span> (lm == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (create) &#123;</span><br><span class="line">			lm = <span class="keyword">new</span> LoaderManagerImpl(who, <span class="keyword">this</span>, started);</span><br><span class="line">			mAllLoaderManagers.put(who, lm);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		lm.updateHostController(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> lm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是以一种putIfAbsent的方式在创建LoaderManagerImpl，这个方法是包内可见的，我在FragmentActivity和Fragment中getSupportLoaderManager方法和getLoaderManager方法，发现最终都是调用到这个方法获取属于Activity/Fragment的LoaderManager。读者细心的话，应该在doLoaderStart中就注意到它了:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mLoaderManager = getLoaderManager(<span class="string">"(root)"</span>, mLoadersStarted, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>
<p>而在Fragment中，这个方法调用的地方就更多了，比如onStart()中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	mCalled = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!mLoadersStarted) &#123;</span><br><span class="line">		mLoadersStarted = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (!mCheckedForLoaderManager) &#123;</span><br><span class="line">			mCheckedForLoaderManager = <span class="keyword">true</span>;</span><br><span class="line">			mLoaderManager = mHost.getLoaderManager(mWho, mLoadersStarted, <span class="keyword">false</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (mLoaderManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">			mLoaderManager.doStart();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而mWho的设置是这样的，其实可以认为是Fragment的一个Tag:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setIndex</span><span class="params">(<span class="keyword">int</span> index, Fragment parent)</span> </span>&#123;</span><br><span class="line">	mIndex = index;</span><br><span class="line">	<span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">		mWho = parent.mWho + <span class="string">":"</span> + mIndex;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		mWho = <span class="string">"android:fragment:"</span> + mIndex;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再往上就不追溯了，总之每一个Fragment自身都会有一个独有的mWho，而这个参数又被用来标识一个LoaderManager。因此这里不难猜测出Loader和Fragment、Activity的关系:</p>
<p><strong>在一个Activity中，可以有N个Fragment，Activity和每一个Fragment都有自己的LoaderManager，其中Activity是以(root)标记的(为什么root是Activity的？可以从FragmentActivity的onStart方法看到，是先调用doLoaderStart，不管onStart之前是否调用了getLoaderManager，这里都会建立一个root为标记的LoaderManager，这个LoaderManager就是属于Activity的)，Fragment则是以自己的mWho属性标记的，它们都被记录在FragmentHostCallback的mAllLoaderManagers属性中(这个属性被FragmentHostCallback引用，FragmentHostCallback属性被FragmentController引用，FragmentController又被FragmentActivity引用)。</strong></p>
<p>试想一下一个Fragment被移除的过程？所有在它内部被创建的Loader都会被销毁掉，而不会影响到其余的Loader。</p>
<p>上面解释了一下所有的LoaderManager都被mAllLoaderManagers变量使用一个String索引着。我们回到前面reportLoaderStart的代码，再贴一下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reportLoaderStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mAllLoaderManagers != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> N = mAllLoaderManagers.size();</span><br><span class="line">		LoaderManagerImpl loaders[] = <span class="keyword">new</span> LoaderManagerImpl[N];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=N-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">			loaders[i] = (LoaderManagerImpl) mAllLoaderManagers.valueAt(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">			LoaderManagerImpl lm = loaders[i];</span><br><span class="line">			lm.finishRetain();</span><br><span class="line">			lm.doReportStart();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里遍历所有的LoaderManager的实例，调用他们的finishRetain和doReportStart方法。LoaderManager再将这些分发到响应的Loader中去。LoaderInfo中两个方法的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finishRetain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mRetaining) &#123;</span><br><span class="line">		<span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"  Finished Retaining: "</span> + <span class="keyword">this</span>);</span><br><span class="line">		mRetaining = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (mStarted != mRetainingStarted) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!mStarted) &#123;</span><br><span class="line">				<span class="comment">// This loader was retained in a started state, but</span></span><br><span class="line">				<span class="comment">// at the end of retaining everything our owner is</span></span><br><span class="line">				<span class="comment">// no longer started...  so make it stop.</span></span><br><span class="line">				stop();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mStarted &amp;&amp; mHaveData &amp;&amp; !mReportNextStart) &#123;</span><br><span class="line">		<span class="comment">// This loader has retained its data, either completely across</span></span><br><span class="line">		<span class="comment">// a configuration change or just whatever the last data set</span></span><br><span class="line">		<span class="comment">// was after being restarted from a stop, and now at the point of</span></span><br><span class="line"> 		<span class="comment">// finishing the retain we find we remain started, have</span></span><br><span class="line">		<span class="comment">// our data, and the owner has a new callback...  so</span></span><br><span class="line">		<span class="comment">// let's deliver the data now.</span></span><br><span class="line">		callOnLoadFinished(mLoader, mData);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reportStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mStarted) &#123;</span><br><span class="line">		<span class="keyword">if</span> (mReportNextStart) &#123;</span><br><span class="line">			mReportNextStart = <span class="keyword">false</span>;</span><br><span class="line">			<span class="keyword">if</span> (mHaveData) &#123;</span><br><span class="line">				callOnLoadFinished(mLoader, mData);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>finishRetain的时候，如果之前retain了，则停止掉(mRetaining置为true)。接下来的判断比较难以理解。首先明确一下mStarted和mRetainingStarted的含义: mStarted标记的是当前Loader是否start的状态，而mRetainingStarted标记的是Loader在retain之前的start状态。所以这个判断的含义是，如果当前的start状态和retain之前的start状态不一致，且当前的状态是未启动的，换句话说，之前是启动的，retain恢复之后又不启动了，那么可以认为这个Loader不再被需要了，因此直接stop掉——读者应当注意FragmentActivity.onStart()方法里面doLoaderStart()和reportLoaderStart()方法的调用顺序，是先全部启动Loader，再report的。</p>
<p>之后，如果Loader已经开始了，数据也有了，而且callback已经被更新了(环境重建)，那么我们就可以调用callOnLoadFinished分发数据了。reportStart类似。</p>
<blockquote>
<p>补充：从代码看，当Fragment的performDestroyView方法被调用，即Fragment被销毁的时候，所有属于它的LoaderInfo的mReportNextStart都会被标为true，reportStart()之后都会被标为false，当然初始化的时候也是false。</p>
</blockquote>
<p>callOnLoadFinished代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callOnLoadFinished</span><span class="params">(Loader&lt;Object&gt; loader, Object data)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mCallbacks != <span class="keyword">null</span>) &#123;</span><br><span class="line">		String lastBecause = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (mHost != <span class="keyword">null</span>) &#123;</span><br><span class="line">			lastBecause = mHost.mFragmentManager.mNoTransactionsBecause;</span><br><span class="line">			mHost.mFragmentManager.mNoTransactionsBecause = <span class="string">"onLoadFinished"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"  onLoadFinished in "</span> + loader + <span class="string">": "</span> + loader.dataToString(data));</span><br><span class="line">			<span class="comment">//分发数据</span></span><br><span class="line"> 			mCallbacks.onLoadFinished(loader, data);</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (mHost != <span class="keyword">null</span>) &#123;</span><br><span class="line">				mHost.mFragmentManager.mNoTransactionsBecause = lastBecause;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		mDeliveredData = <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果mCallbacks不为null，那么调用它的onLoadFinished分发数据。</p>
<h3 id="Loader的Restart过程"><a href="#Loader的Restart过程" class="headerlink" title="Loader的Restart过程"></a>Loader的Restart过程</h3><p>Loader的restart过程是通过<code>LoaderManager.restartLoader()</code>方法实现的。方法注释中说，重新创建一个ID指向的Loader，如果这个ID已经有绑定的Loader，那么这个Loader会被cancel、stop或者destroy，然后使用新的arguments创建一个Loader。这就是它与<code>LoaderManager.initLoader()</code>方法的区别——<strong>不存在重用</strong>。</p>
<p>因此，如果在组件的生命周期之间使用缓存数据(即数据不会变化)，则应该使用<code>LoaderManager.initLoader()</code>，如果可能变化，则应该使用<code>LoaderManager.restartLoader()</code>方法。</p>
<p>Restart过程从<code>LoaderManager.restartLoader()</code>方法切入即可，基于前面的解释，看懂这个方法并不困难，其中可以看到一些重要的方法是如何调用的，比如：LoaderCallbacks的<code>onLoaderReset()</code>方法，Loader的<code>onAbandon()</code>方法。请读者自行解析。</p>
<h2 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h2><ol>
<li>可以通过<code>Loader.forceLoad()</code>方法强制重新加载数据，数据加载完成会调用<code>onLoadFinished()</code>回调，也可以调用<code>Loader.cancelLoad()</code>取消回调，将不会受到任何回调;</li>
<li>在Activity、Fragment销毁的时候或者手动调用了<code>LoaderManager.destroyLoader(id)</code>方法的时候，Loader会被销毁，回调方法<code>onLoaderReset(Loader)</code>会被调用，表示数据失效，需要重置;</li>
<li>前面说了Loader可以监测数据的变化，但有时候数据变化过快，导致UI持续刷新，可以通过如下方法降低刷新频率: <code>setUpdateThrottle(long delayMs)</code>;</li>
</ol>
<p>Loader数据加载相关方法执行流程如下:<br><img src="http://7xktd8.com1.z0.glb.clouddn.com/Loader数据加载.png" alt="Loader数据加载"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上解析了Loader是如何初始化并启动的，整个数据的加载和停止又是如何绑定到Activity和Fragment的生命周期的。</p>
<p>然而Loader本身的用处并不大，因为Loader本身没有任何的异步调度，直接使用Loader进行开发显得太过原始，开发中一般会使用<strong>AsyncTaskLoader</strong>。AsyncTaskLoader结合了<a href="http://www.muzileecoding.com/androidsource/Android-AsyncTask.html" target="_blank" rel="noopener">AsyncTask</a>和Loader的机制，将数据加载方到了异步任务中(源码里是通过LoadTask实现的)，并重新声明了一些回调函数，有力的支持了Activity和Fragment的异步加载数据任务。</p>
<blockquote>
<p><strong>AsyncTaskLoader</strong>并不依赖于平台的AsyncTask，因为平台的AsyncTask并行或者串行执行任务是随着平台版本变化的。</p>
<p><strong>AsyncTaskLoader</strong>会尽可能的减少任务的数量，如果我们调用<code>forceLoader()</code>方法，前面的相同任务会被取消掉，是不会有任何回调的。</p>
</blockquote>
<p>对于数据库查询，Loader还有一个子类叫做：CursorLoader，读者有兴趣也可以去看一下。</p>
<h3 id="自定义Loader"><a href="#自定义Loader" class="headerlink" title="自定义Loader"></a>自定义Loader</h3><p>如总结所说，Loader本身的功能很弱，虽然有AsyncTaskLoader和CursorLoader等具体类支持，但是开发者仍可能有需求需要自定义一个Loader，这时候参考实现如下特性:</p>
<ol>
<li>Loader的生命周期;</li>
<li>后台数据加载;</li>
<li>数据管理;</li>
<li>发送缓存结果;</li>
</ol>
<p>Loader的生命周期方法轮转如下:</p>
<p><img src="http://7xktd8.com1.z0.glb.clouddn.com/Loader状态.png" alt="Loader状态"><br>这其中涉及到一些重要方法的实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startLoading</span><span class="params">()</span> -&gt; <span class="keyword">void</span> <span class="title">onStartLoading</span><span class="params">()</span> <span class="keyword">void</span> <span class="title">stopLoading</span><span class="params">()</span> -&gt; <span class="keyword">void</span> <span class="title">onStopLoading</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> -&gt; <span class="keyword">void</span> <span class="title">onReset</span><span class="params">()</span><span class="keyword">void</span> <span class="title">abandon</span><span class="params">()</span> -&gt; <span class="keyword">void</span> <span class="title">onAbandon</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<p>以及<code>forceLoad ()</code>方法的实现，这些方法在Loader类中都有详细的注释，具体实现可以参考注释以及AsyncTaskLoader的实现。</p>
<h3 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h3><p>监控数据变化的方式: </p>
<ol>
<li>使用Java的Observable和Observer;</li>
<li>广播告知;</li>
<li>FileObserver——监控一个路径上的文件变化;</li>
</ol>
<blockquote>
<p>PS: 自定义的时候可以仔细研究一下AsyncTaskLoader的实现。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android适配之UED标注转换]]></title>
      <url>http://www.timebridge.space/2015/12/14/Android-adapt-ued-mark-convert/</url>
      <content type="html"><![CDATA[<p>适配基础知识可以参见：<a href="http://blog.csdn.net/zhaokaiqiang1992/article/details/45419023" target="_blank" rel="noopener">《Android屏幕适配全攻略(最权威的官方适配指导)》</a></p>
<p>如果UED出了一张UI设计图并标注了相应元素的尺寸和间距px值，作为Android开发者，如何在程序中将标注值转换为相应的dp值呢？<a id="more"></a></p>
<h2 id="目标效果"><a href="#目标效果" class="headerlink" title="目标效果"></a>目标效果</h2><p>要确定转换的方法，首先需要明确转换的效果。</p>
<p><strong>在手机上，我们应当注重的是元素的横向排列，而非纵向排列——元素横向应当等比缩放，纵向可以选择与横向等比缩放或者保持固定尺寸。</strong></p>
<p>元素横向的等比缩放是指：加入手机A的宽度是1080px，屏幕上有一条线的宽度是540px，那么这同样“尺寸”的线在宽度为540px的屏幕上宽度就应该为270px。这也正是Android引入<a href="http://developer.android.com/intl/zh-cn/guide/practices/screens_support.html" target="_blank" rel="noopener">dp</a>的目的:</p>
<p><img src="http://7xktd8.com1.z0.glb.clouddn.com/density-test-good.png" alt="DP对不同分辨率屏幕的支持"></p>
<p>这张图非常经典，但是注意，Button看上去一样大小的前提是：屏幕的宽度是一致的。而现实生活中，手机的宽度往往有差异，因此同一个dp值的元素在这些手机上显示出来的物理尺寸并不一致，但是屏幕截图后在Photoshop上拉至同一个宽度，就可以看出尺寸是同样大小的。</p>
<p>为什么要注重元素的横向显示而非纵向？元素横向等比缩放有助于元素更好的排列，高度与之等比缩放可以使得长宽比越大的手机在纵向上显示更多的元素，从而体现大屏手机的优势，而且手机页面的上下滚动是非常自然的操作，所以，注重元素横向可以使同一个界面在任何手机上体验更好。</p>
<h2 id="转换方式"><a href="#转换方式" class="headerlink" title="转换方式"></a>转换方式</h2><p>确定效果的目的一方面是确立转换目标，一方面也是下面转换的前提：<strong>我们将注重元素的横向比例拉伸。</strong></p>
<p>OK，我们看如何转换UED的视觉标注，才能得到合理的dp值。这里需要另外假设很多的变量，含义如下：</p>
<blockquote>
<ol>
<li>假设UED出的视觉稿宽度是Spx，有一个标注是 B px，UED的这份视觉稿使用的dpi是 P dpi，即一英寸里面有 P 个像素。</li>
<li>假设我们开发的手机宽度是Apx，屏幕密度是D，即dpi=160D，我们从标注转换过来的值是X，即最终写入程序的是 X dp，即最终屏幕上显示出来的是XD个像素。</li>
</ol>
</blockquote>
<p>基于以上假设和目标，我们想象，将我们写出的界面(为了便于想象，假设标注是用于一个元素的宽度)等比例缩放，和UED出的视觉图重叠，根据效果，此时元素的宽度与UED视觉稿上的宽度应该完全一致。根据假设值，可以得到以下参数:</p>
<ol>
<li>设计视觉稿的物理宽度：S/P——记为M；</li>
<li>设计视觉稿上元素的物理宽度：B/P——记为N；</li>
<li>实际运行程序的手机屏幕物理宽度：A/160D——记为X；<ol>
<li>实际运行程序的手机上元素的物理宽度：XD/160D——记为Y；</li>
</ol>
</li>
</ol>
<p>根据目标，应该有 <strong>N/Y=M/X</strong> ，化简后可以得到 <strong>X = AB/DS</strong>——这就是我们应当正确写入程序的dp值，它是一个与程序实际运行手机宽度、屏幕密度、视觉稿设计所用宽度以及标注值相关的变量。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>根据上面的公式，实验结果是符合的。但是这四个变量的组合非常奇怪，如果说最终值与标注值相关，那是理所当然的，但是怎么会和屏幕密度有关(dp值不就是用于解决这个问题么?)，还和视觉稿设计所用宽度、手机宽度相关？手机宽度还是一个不确定值！</p>
<p>实际上视觉稿所用宽度并不会影响最终的计算，因为这个值的比例变化会和标注值相抵消。设想设计师在一个1000px宽度的视觉稿上画一条占满半屏幕的线，需要500px，因此他的标注也是500px，那么在500px的屏幕上呢？他会标注250px，一般公司里面出视觉稿，视觉稿宽度值是固定的：640p或者720p，因此最终值确实和视觉稿所用宽度有关，另外也可以知道B/S实际上是这个元素的宽度与屏幕宽度的比例。</p>
<p>除去B和S，A(开发的手机宽度像素值)和D(屏幕密度)又怎么解释呢？根据前面的结论，我们修改一下公式: <strong>B/S=XD/A</strong> 。前面说了B/S的含义，XD则是元素实际显示的物理尺寸，A是手机实际的物理宽度，那么这个比展现的就是我们之前的目标。</p>
<p>问题来了，AB/DS到底怎么算？实际上B和S很容易得到，B是标注，S一般为640或者720，A和D却一直在变化，<strong>BUT！！!</strong> 它们的比却相对固定——目前主流手机(三星、小米、中兴等)这两个值基本是(720,2)或者(1080,3)的配比，除一下很容易得到360这个结果（Nexus 5也是这个值），部分手机在此上下浮动（比如魅族，383），在此基础上，如果UED出图的标准宽度是720px，很容易得到 <strong>X = 0.5B</strong> 这个结果，即将UED的标注除以2就可以了，如果是640px，则需要乘以1.125才能得到正确的值。</p>
<blockquote>
<p>备注: 很多手机的ppi实际上不是160的整数倍，也不是x.5倍，在官网上，hdpi、mdpi、xhdpi等的定义是对应一个范围的，手机系统在这里会做一个换算，使得从手机上获取的屏幕密度值基本上是一个整数或者x.5值，比如2.0，3.0，1.5。比如我的Nexus 5手机，屏幕密度是3.0，实际的ppi是445，并不是160 * 3.0 = 480ppi。</p>
</blockquote>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>720p的图标注除以2，640p的则还要乘以1.125，公司UED一直有这个”奇怪”的规定，但是在某些情况下，他们并不适用。以上分析可以看出，这个结论是基于一些事实的，当A/D不是360并且浮动比较大的时候，这个规则就不再成立。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java动态代理实现]]></title>
      <url>http://www.timebridge.space/2015/12/13/dynamic-proxy/</url>
      <content type="html"><![CDATA[<p>本文整理自《Thinking In Java》和 IBM 技术博客<a href="https://www.ibm.com/developerworks/cn/java/j-lo-proxy1/" target="_blank" rel="noopener">Java 动态代理机制分析及扩展</a>，对动态类的生成部分做了补充。<a id="more"></a></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>例子来自《Thinking In Java》。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodSelector</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> Object proxied;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">MethodSelector</span><span class="params">(Object proxied)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.proxied = proxied;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(method.getName().equals(<span class="string">"interesting"</span>))</span><br><span class="line">               print(<span class="string">"Proxy detected the interesting method"</span>);</span><br><span class="line">          <span class="keyword">return</span> method.invoke(proxied, args);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SomeMethods</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">boring1</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">boring2</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">interesting</span><span class="params">(String arg)</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">boring3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implementation</span> <span class="keyword">implements</span> <span class="title">SomeMethods</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">boring1</span><span class="params">()</span> </span>&#123; print(<span class="string">"boring1"</span>); &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">boring2</span><span class="params">()</span> </span>&#123; print(<span class="string">"boring2"</span>); &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interesting</span><span class="params">(String arg)</span> </span>&#123;</span><br><span class="line">          print(<span class="string">"interesting "</span> + arg);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">boring3</span><span class="params">()</span> </span>&#123; print(<span class="string">"boring3"</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelectingMethods</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          SomeMethods proxy= (SomeMethods)Proxy.newProxyInstance(</span><br><span class="line">               SomeMethods.class.getClassLoader(),</span><br><span class="line">               <span class="keyword">new</span> Class[]&#123; SomeMethods.class &#125;,</span><br><span class="line">               <span class="keyword">new</span> MethodSelector(<span class="keyword">new</span> Implementation()));</span><br><span class="line">          proxy.boring1();</span><br><span class="line">          proxy.boring2();</span><br><span class="line">          proxy.interesting(<span class="string">"bonobo"</span>);</span><br><span class="line">          proxy.boring3();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">boring1</span><br><span class="line">boring2</span><br><span class="line">Proxy detected the interesting method</span><br><span class="line">interesting bonobo</span><br></pre></td></tr></table></figure>
<p>它的使用非常简单，重点就在于InvocationHandler的实现。这里可以对方法的调用做出转发，很像APO？</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="分析前提"><a href="#分析前提" class="headerlink" title="分析前提"></a>分析前提</h3><p>【环境】JDK 1.6<br>【代码】<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b27/java/lang/reflect/Proxy.java#Proxy.newProxyInstance%28java.lang.ClassLoader%2Cjava.lang.Class%5B%5D%2Cjava.lang.reflect.InvocationHandler%29" target="_blank" rel="noopener">Proxy.java</a></p>
<h3 id="代理机制及其特点"><a href="#代理机制及其特点" class="headerlink" title="代理机制及其特点"></a>代理机制及其特点</h3><p>首先让我们来了解一下如何使用 Java 动态代理。具体有如下四步骤：</p>
<ol>
<li>通过实现 InvocationHandler 接口创建自己的调用处理器；</li>
<li>通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类；</li>
<li>通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型；</li>
<li>通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入；</li>
</ol>
<p>而实际使用的时候，我们只需要做如下两步:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InvocationHandlerImpl 实现了 InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发</span></span><br><span class="line">InvocationHandler handler = <span class="keyword">new</span> InvocationHandlerImpl(..); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 Proxy 直接创建动态代理类实例</span></span><br><span class="line">Interface proxy = (Interface)Proxy.newProxyInstance( classLoader, <span class="keyword">new</span> Class[] &#123; Interface.class &#125;, handler );</span><br></pre></td></tr></table></figure>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 映射表：用于维护类装载器对象到其对应的代理类缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map loaderToCache = <span class="keyword">new</span> WeakHashMap(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记：用于标记一个动态代理类正在被创建中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Object pendingGenerationMarker = <span class="keyword">new</span> Object(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步表：记录已经被创建的动态代理类类型，主要被方法 isProxyClass 进行相关的判断</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map proxyClasses = Collections.synchronizedMap(<span class="keyword">new</span> WeakHashMap()); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 关联的调用处理器引用</span></span><br><span class="line"><span class="keyword">protected</span> InvocationHandler h;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理类实例化构建参数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Class[] constructorParams =</span><br><span class="line">        &#123; InvocationHandler.class &#125;;</span><br></pre></td></tr></table></figure>
<p>由变量可以猜测，代理的创建过程中是使用了很多的缓存的。</p>
<h3 id="静态构造方法"><a href="#静态构造方法" class="headerlink" title="静态构造方法"></a>静态构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, </span></span></span><br><span class="line"><span class="function"><span class="params">            Class&lt;?&gt;[] interfaces, </span></span></span><br><span class="line"><span class="function"><span class="params">            InvocationHandler h)</span> </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IllegalArgumentException </span>&#123; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查 h 不为空，否则抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (h == <span class="keyword">null</span>) &#123; </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得与制定类装载器和一组接口相关的代理类类型对象</span></span><br><span class="line">    Class cl = getProxyClass(loader, interfaces); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过反射获取构造函数对象并生成代理类实例</span></span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        Constructor cons = cl.getConstructor(constructorParams); </span><br><span class="line">        <span class="keyword">return</span> (Object) cons.newInstance(<span class="keyword">new</span> Object[] &#123; h &#125;); </span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString()); </span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString()); </span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException e) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString()); </span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString()); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法很简单，主要是调用getProxyClass方法获取一个cl，然后通过反射创建出代理类的实例。很明显，核心在于getProxyClass到底做了什么？</p>
<h3 id="getProxyClass方法"><a href="#getProxyClass方法" class="headerlink" title="getProxyClass方法"></a>getProxyClass方法</h3><p>这个方法比较长，分为四个主体部分:</p>
<p>【1】对这组接口进行一定程度的安全检查，包括检查接口类对象是否对类装载器可见并且与类装载器所能识别的接口类对象是完全相同的，还会检查确保是 interface 类型而不是 class 类型。这个步骤通过一个循环来完成，检查通过后将会得到一个包含所有接口名称的字符串数组，记为 String[] interfaceNames。总体上这部分实现比较直观，所以略去大部分代码，仅保留留如何判断某类或接口是否对特定类装载器可见的相关代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    <span class="comment">// 指定接口名字、类装载器对象，同时制定 initializeBoolean 为 false 表示无须初始化类</span></span><br><span class="line">    <span class="comment">// 如果方法返回正常这表示可见，否则会抛出 ClassNotFoundException 异常表示不可见</span></span><br><span class="line">    interfaceClass = Class.forName(interfaceName, <span class="keyword">false</span>, loader); </span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的目的是保证代理类创建的时候，和它所有需要代理的接口都在一个ClassLoader上可见。并且禁止传入类（后面解释），禁止重复传入。</p>
<p>【2】从 loaderToCache 映射表中获取以类装载器对象为关键字所对应的缓存表，如果不存在就创建一个新的缓存表并更新到 loaderToCache。缓存表是一个 HashMap 实例，正常情况下它将存放键值对（接口名字列表，动态生成的代理类的类对象引用）。当代理类正在被创建时它会临时保存（接口名字列表，pendingGenerationMarker）。标记 pendingGenerationMarke (其实是一个对象)的作用是通知后续的同类请求（接口数组相同且组内接口排列顺序也相同）代理类正在被创建，请保持等待直至创建完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 以接口名字列表作为关键字获得对应 cache 值</span></span><br><span class="line">    Object value = cache.get(key); </span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Reference) &#123; </span><br><span class="line">        proxyClass = (Class) ((Reference) value).get(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (proxyClass != <span class="keyword">null</span>) &#123; </span><br><span class="line">        <span class="comment">// 如果已经创建，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> proxyClass; </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value == pendingGenerationMarker) &#123; </span><br><span class="line">        <span class="comment">// 代理类正在被创建，保持等待</span></span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            cache.wait(); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 等待被唤醒，继续循环并通过二次检查以确保创建完成，否则重新等待</span></span><br><span class="line">        <span class="keyword">continue</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// 标记代理类正在被创建</span></span><br><span class="line">        cache.put(key, pendingGenerationMarker); </span><br><span class="line">        <span class="comment">// break 跳出循环已进入创建过程</span></span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<p>【3】动态创建代理类的类对象。首先是确定代理类所在的包，其原则如前所述，如果都为 public 接口，则包名为空字符串表示顶层包；如果所有非 public 接口(package可见)都在同一个包，则包名与这些接口的包名相同；如果有多个非 public 接口且不同包，则抛异常终止代理类的生成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">String proxyPkg = <span class="keyword">null</span>;     <span class="comment">// package to define proxy class in</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Record the package of a non-public proxy interface so that the</span></span><br><span class="line"><span class="comment">	 * proxy class will be defined in the same package.  Verify that</span></span><br><span class="line"><span class="comment">	 * all non-public proxy interfaces are in the same package.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interfaces.length; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> flags = interfaces[i].getModifiers();</span><br><span class="line">		<span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">			String name = interfaces[i].getName();</span><br><span class="line">			<span class="keyword">int</span> n = name.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">			String pkg = ((n == -<span class="number">1</span>) ? <span class="string">""</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span><br><span class="line">			<span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">				proxyPkg = pkg;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"non-public interfaces from different packages"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;     <span class="comment">// if no non-public proxy interfaces,</span></span><br><span class="line">		proxyPkg = <span class="string">""</span>;          <span class="comment">// use the unnamed package</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>确定了包后，就开始生成代理类的类名，同样如前所述按格式“$ProxyN”生成。类名也确定了，接下来就是见证奇迹的发生 —— 动态生成代理类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Choose a name for the proxy class to generate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">long</span> num;</span><br><span class="line"><span class="keyword">synchronized</span> (nextUniqueNumberLock) &#123;</span><br><span class="line">	num = nextUniqueNumber++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Verify that the class loader hasn't already</span></span><br><span class="line"><span class="comment"> * defined a class with the chosen name.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Generate the specified proxy class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	proxyClass = defineClass0(loader, proxyName,</span><br><span class="line">	proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment"> 	 * A ClassFormatError here means that (barring bugs in the</span></span><br><span class="line"><span class="comment"> 	 * proxy class generation code) there was some other</span></span><br><span class="line"><span class="comment"> 	 * invalid aspect of the arguments supplied to the proxy</span></span><br><span class="line"><span class="comment"> 	 * class creation (such as virtual machine limitations</span></span><br><span class="line"><span class="comment"> 	 * exceeded).</span></span><br><span class="line"><span class="comment">  	 */</span></span><br><span class="line"> 	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里通过proxyPkg + proxyClassNamePrefix + num拼接出代理类的名字，一般proxyPkg为空，proxyClassNamePrefix是一个final字符串”$Proxy”，num则是一个递增数字，可以看做是创建的第N个代理类。最后调用ProxyGenerator的generateProxyClass生成代理类的byte[]数组，以一个native方法defineClass0生成最终的代理类class对象。</p>
<p>【4】代码生成过程进入结尾部分，根据结果更新缓存表，如果成功则将代理类的类对象引用更新进缓存表，否则清楚缓存表中对应关键值，最后唤醒所有可能的正在等待的线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We must clean up the "pending generation" state of the proxy</span></span><br><span class="line"><span class="comment"> * class cache entry somehow.  If a proxy class was successfully</span></span><br><span class="line"><span class="comment"> * generated, store it in the cache (with a weak reference);</span></span><br><span class="line"><span class="comment"> * otherwise, remove the reserved entry.  In all cases, notify</span></span><br><span class="line"><span class="comment"> * all waiters on reserved entries in this cache.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">synchronized</span> (cache) &#123;</span><br><span class="line">	<span class="keyword">if</span> (proxyClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">		cache.put(key, <span class="keyword">new</span> WeakReference(proxyClass));</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		cache.remove(key);</span><br><span class="line">	&#125;</span><br><span class="line">	cache.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上四步展现了创建一个代理类的主体，到现在只剩下ProxyGenerator未描述了。<br>在IBM的原博客中说:</p>
<blockquote>
<p>当你尝试去探索这个类时，你所能获得的信息仅仅是它位于并未公开的 sun.misc 包，有若干常量、变量和方法以完成这个神奇的代码生成的过程，但是 sun 并没有提供源代码以供研读。</p>
</blockquote>
<p>但是到我写这篇博客的时候，ProxyGenerator.java已经可以看到了，可以在这里<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b27/sun/misc/ProxyGenerator.java#ProxyGenerator" target="_blank" rel="noopener">下载</a>。</p>
<h2 id="ProxyGenerator类"><a href="#ProxyGenerator类" class="headerlink" title="ProxyGenerator类"></a>ProxyGenerator类</h2><h3 id="generateProxyClass方法"><a href="#generateProxyClass方法" class="headerlink" title="generateProxyClass方法"></a>generateProxyClass方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] generateProxyClass(<span class="keyword">final</span> String name, Class[] interfaces) &#123;</span><br><span class="line">ProxyGenerator gen = <span class="keyword">new</span> ProxyGenerator(name, interfaces);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span>[] classFile = gen.generateClassFile();</span><br><span class="line"><span class="comment">//...省略，这里是将byte持久化。</span></span><br></pre></td></tr></table></figure>
<p>继续追踪generateClassFile方法。</p>
<h3 id="generateClassFile方法"><a href="#generateClassFile方法" class="headerlink" title="generateClassFile方法"></a>generateClassFile方法</h3><p>从方法名字可以猜出，这个方法用于生成一个Class对象。这个方法也非常长，分为3步。</p>
<p>【1】收集创建Class对象的所有方法，并创建对应的ProxyMethod对象，以便于后面生成代理代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">addProxyMethod(hashCodeMethod, Object.class);</span><br><span class="line">addProxyMethod(equalsMethod, Object.class);</span><br><span class="line">addProxyMethod(toStringMethod, Object.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interfaces.length; i++) &#123;</span><br><span class="line">	Method[] methods = interfaces[i].getMethods();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; methods.length; j++) &#123;</span><br><span class="line">		addProxyMethod(methods[j], interfaces[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) &#123;</span><br><span class="line">	checkReturnTypes(sigmethods);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加了Object的基础方法和接口的所有方法。在添加方法的时候，会生成一个由方法名字+参数作为Key，List<proxymethod>作为值的map，添加完成后会做一次check，即checkReturnTypes。关于这个方法，注释如下：</proxymethod></p>
<blockquote>
<p>For a given set of proxy methods with the same signature, check that their return types are compatible according to the Proxy specification. Specifically, if there is more than one such method, then all of the return types must be reference types, and there must be one return type that is assignable to each of the rest of them.</p>
</blockquote>
<p>【2】收集产生类所需要的所有的MethodInfo和FieldInfo对象<br>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">methods.add(generateConstructor());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) &#123;</span><br><span class="line">	<span class="keyword">for</span> (ProxyMethod pm : sigmethods) &#123;</span><br><span class="line">		<span class="comment">// add static field for method's Method object</span></span><br><span class="line">		fields.add(<span class="keyword">new</span> FieldInfo(pm.methodFieldName,</span><br><span class="line">			<span class="string">"Ljava/lang/reflect/Method;"</span>,</span><br><span class="line">			ACC_PRIVATE | ACC_STATIC));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// generate code for proxy method and add it</span></span><br><span class="line">		methods.add(pm.generateMethod());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以看到，method中嗨添加了构造函数和静态初始化函数。</p>
<p>【3】写入最终的类文件<br>接下去代码的含义是：按照Java类文件编译后的格式，创建一个类出来。我们看一下重点(注意，下面贴的代码在原代码中不是连贯的，为了方便，特意截取几行展示)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** name of the superclass of proxy classes */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String superclassName = <span class="string">"java/lang/reflect/Proxy"</span>;</span><br><span class="line">    </span><br><span class="line">dout.writeInt(<span class="number">0xCAFEBABE</span>);</span><br><span class="line">dout.writeShort(cp.getClass(superclassName));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (MethodInfo m : methods) &#123;</span><br><span class="line">	m.write(dout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写入的第一个内容就是<strong>dout.writeInt(0xCAFEBABE);</strong>，而0xCAFEBABE就是标记 java class 文件的魔数。之后会写入superclassName，而这个类就是java/lang/reflect/Proxy，即Proxy类，所以所有自动生成的代理类都是Proxy的子类，这也就解释了为什么自动生成的代理类不能代理一个具体类，而只能代理一个接口：Java中没有多继承，后面会有更直接的证据。之后就是写入方法。写入方法这一块比较复杂，我们来采取一些特殊措施看看具体生成的文件是什么。接着最前面的使用例子，我们在main函数中写入如下代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Implementation implementation = <span class="keyword">new</span> Implementation();</span><br><span class="line">Class[] interfaces = implementation.getClass().getInterfaces();</span><br><span class="line"><span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(<span class="string">"MethodSelector"</span>, interfaces);</span><br><span class="line">File f = <span class="keyword">new</span> File(<span class="string">"/Users/muzileecoding/Desktop/MethodSelector.class"</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(f);</span><br><span class="line">	fos.write(proxyClassFile);</span><br><span class="line">	fos.flush();</span><br><span class="line">	fos.close();;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行之后就可以在相应的文件夹下面获取到MethodSelector.class文件，将文件反编译（拖入IDE打开即可），下面是完整的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.footprint.reflection.SomeMethods;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodSelector</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">SomeMethods</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m6;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m5;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MethodSelector</span><span class="params">(InvocationHandler var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ((Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;)).booleanValue();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">boring2</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m4, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">boring3</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m6, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">interesting</span><span class="params">(String var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m5, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ((Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>)).intValue();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">boring1</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, <span class="keyword">new</span> Class[]&#123;Class.forName(<span class="string">"java.lang.Object"</span>)&#125;);</span><br><span class="line">            m4 = Class.forName(<span class="string">"com.footprint.reflection.SomeMethods"</span>).getMethod(<span class="string">"boring2"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">            m6 = Class.forName(<span class="string">"com.footprint.reflection.SomeMethods"</span>).getMethod(<span class="string">"boring3"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">            m5 = Class.forName(<span class="string">"com.footprint.reflection.SomeMethods"</span>).getMethod(<span class="string">"interesting"</span>, <span class="keyword">new</span> Class[]&#123;Class.forName(<span class="string">"java.lang.String"</span>)&#125;);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">            m3 = Class.forName(<span class="string">"com.footprint.reflection.SomeMethods"</span>).getMethod(<span class="string">"boring1"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个就是最终写出的java动态代理类：</p>
<ol>
<li>动态生成类的时候生成了一个只需要InvocationHandler实例作为参数的构造函数的，结合前面创建出动态代理文件之后创建动态代理实例的反射代码，这里不难理解；</li>
<li>所有的方法体都变成了<strong>super.h.invoke(this, m4, (Object[])null);</strong>这样的调用，而m4代表着接口中的一个方法，从这里可以知道，实际生成的动态代理类，调用了我们创建代理时传入的InvocationHandler实例，并且将我们的返回结果直接返回，这就是动态代理的本质；</li>
</ol>
<p>至此，我们传入的三个参数如何转化为最终的动态代理类，已经比较清楚了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>动态代理的原理实际上就是：</strong>根据我们要代理的接口，在接口加载的ClassLoader上动态生成一个动态代理类（这个类原来不存在），动态代理类需要我们传入的InvocationHandler作为构造参数，这个代理类中会有所有我们需要代理的接口的方法实现，而这个实现，就是简单的调用我们传入的InvocationHandler的invoke方法。所以如果这样写:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object o, Method method, Object[] objects)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> method.invoke(o, objects);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就会造成循环调用，导致栈溢出。</p>
<p>Proxy.newProxyInstance方法的返回值只能强转为它代理的其中一个接口，原因很简单，因为生成的类签名是这样的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodSelector</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">SomeMethods</span></span></span><br></pre></td></tr></table></figure>
<p>以上两个点要注意一下。</p>
<p>最后，正如 IBM 博客中所说，也如前面分析的，Java自带的动态代理是不能实现代理实体类或者抽象类的，这一点美中不足，这意味着我一旦要代理一个类，就必须抽象出响应的方法。但实际上，应该有随意代理一个类的成熟实现了，因为AOP的实现就依赖于此。So:</p>
<blockquote>
<p>不完美并不等于不伟大，伟大是一种本质，Java 动态代理就是佐例。  </p>
<p>——<a href="https://www.ibm.com/developerworks/cn/java/j-lo-proxy1/" target="_blank" rel="noopener">Java 动态代理机制分析及扩展</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[观影《火星救援》]]></title>
      <url>http://www.timebridge.space/2015/12/05/mars-jiu-yuan/</url>
      <content type="html"><![CDATA[<p>不论处于什么样的困境，就算是被全世界的人丢弃在火星，你也要坚强，挣扎活下去，并保持逗比的心情，用自己的翔转换成自己的口粮，说不定你一不小心就会成为星球霸主，比哥伦布发现新大陆还要牛逼。</p>
<p>最后看到男主和中校大人在无垠的太空里面历经艰险终于碰撞在一起，还是蛮有感触的，想到了张爱玲的那句:<a id="more"></a></p>
<blockquote>
<p>于千万人之中遇见你所要遇见的人,于千万年之中,时间的无涯的荒野里,没有早一步,也没有晚一步,刚巧赶上了,没有别的话可说,惟有轻轻地问一声噢,你也在这里?</p>
<p>——张爱玲《爱》</p>
</blockquote>
<p>张爱玲说的是缘分，缘分天注定，男主和女主的是爱——在无垠的空间中改变彼此的轨迹，交错相携，爱是可以争取的。</p>
<p>看个电影迟到20分钟也是醉了，进去看的时候已经第36个太阳日了！！</p>
<p>公司屠大师在分享通信的时候说，地球和火星之间不太可能是使用TCP/IP协议进行传输的，因为来回传递时间是12分钟，TCP/IP的传输效率太低。不过看那个被埋汰的探测器，产自上世纪90年代，貌似只能使用TCP/IP协议啊。</p>
<p>后期的发展方向应该是寻求一种更稳健的传输介质，比如《三体》里面的引力波、中子束一类的。TCP/IP协议的传输起码是目前来说能想到的最低成本的保证质量的传输协议，确认包回传和丢包重传机制是保证数据传输成功的必要手段。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[AsyncTask 源码分析]]></title>
      <url>http://www.timebridge.space/2015/12/02/Android-AsyncTask/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>【环境】源码分析基于 6.0。<br>【知识】请读者自备FutureTask相关技能。</p>
<h2 id="AsyncTask的介绍和使用"><a href="#AsyncTask的介绍和使用" class="headerlink" title="AsyncTask的介绍和使用"></a>AsyncTask的介绍和使用</h2><p>如官网所述:</p>
<blockquote>
<p>AsyncTask enables proper and easy use of the UI thread. This class allows to perform background operations and publish results on the UI thread without having to manipulate threads and/or handlers.</p>
</blockquote>
<p>简而言之，AsyncTask是为了在后台线程和UI线程之间做任务调度而开发的一个类，使得这种常见的操作更加容易简练，而不用去操作线程本身以及Handler。详细介绍见官方文档: <a href="http://developer.android.com/intl/zh-cn/reference/android/os/AsyncTask.html" target="_blank" rel="noopener">AsyncTask</a>。<a id="more"></a></p>
<p>源码(类注释)中给出的🌰如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadFilesTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">URL</span>, <span class="title">Integer</span>, <span class="title">Long</span>&gt;</span>&#123;</span><br><span class="line">	<span class="comment">//在后台线程中执行</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Long <span class="title">doInBackground</span><span class="params">(URL... urls)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> count = urls.length;</span><br><span class="line">		<span class="keyword">long</span> totalSize = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">			totalSize += Downloader.downloadFile(urls[i]);</span><br><span class="line"> 			publishProgress((<span class="keyword">int</span>) ((i / (<span class="keyword">float</span>) count) * <span class="number">100</span>));</span><br><span class="line">			<span class="comment">// Escape early if cancel() is called</span></span><br><span class="line">			<span class="keyword">if</span> (isCancelled()) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> totalSize;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在UI线程中执行</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(Integer... progress)</span> </span>&#123;</span><br><span class="line">		setProgressPercent(progress[<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在UI线程中执行</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Long result)</span> </span>&#123;</span><br><span class="line">		showDialog(<span class="string">"Downloaded "</span> + result + <span class="string">" bytes"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行使用如下代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> DownloadFilesTask().execute(url1, url2, url3);</span><br></pre></td></tr></table></figure>
<p>使用过程非常方便，任务被分解成耗时的后端任务以及UI线程的回调两部分，开发者不需要手动进行任务的调度，只需要按照约定，将操作分解到对应的函数中，就可以完成任务，非常方便。下面我们就来探究一下，AsyncTask是如何实现这个功能的。</p>
<h2 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h2><p>如上示例所示，AsyncTask有几个重要的”生命周期”方法:</p>
<ol>
<li>onPreExecute()</li>
<li>doInBackground()</li>
<li>onProgressUpdate()</li>
<li>onPostExecute()</li>
<li>onCancelled()</li>
</ol>
<p>关于它们具体的作用和调用时间，在源码的类注释以及官方API文档里面都有详细的解释，此处不赘述。(懒得写…其实看名字就能猜出大概)</p>
<p>如🌰所示，我们看一下整个过程是如何发生的。</p>
<h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><p>首先是AsyncTask的创建过程，其代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">			mTaskInvoked.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">			Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">			<span class="comment">//noinspection unchecked</span></span><br><span class="line">			Result result = doInBackground(mParams);</span><br><span class="line">			Binder.flushPendingCommands();</span><br><span class="line">			<span class="keyword">return</span> postResult(result);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				postResultIfNotInvoked(get());</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				android.util.Log.w(LOG_TAG, e);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"An error occurred while executing doInBackground()"</span>,</span><br><span class="line">					e.getCause());</span><br><span class="line">			&#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">				postResultIfNotInvoked(<span class="keyword">null</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建过程只是实例化了两个变量: mWorker &amp; mFuture。mWorker是一个WorkerRunnable对象，这个类的定义如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerRunnable</span>&lt;<span class="title">Params</span>, <span class="title">Result</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Result</span>&gt; </span>&#123;</span><br><span class="line">        Params[] mParams;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继承了Callable对象，添加了Params实例，至于Params和Result的类型，在AsyncTask类签名中可以看到:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTask</span>&lt;<span class="title">Params</span>, <span class="title">Progress</span>, <span class="title">Result</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>是泛型，由使用者自己决定。因此<strong>WorkerRunnable其实是Callable的增强版，可以传递另外一个泛型参数进去</strong>。</p>
<p>mFuture是一个FutureTask对象，接受mWorker对象作为参数。要弄清楚这两个对象的作用，先撇下这两个对象的声明细节，继续往后看。</p>
<h3 id="执行开始"><a href="#执行开始" class="headerlink" title="执行开始"></a>执行开始</h3><p>使用示例中执行task调用的是execute方法，这个方法会调用另外一个方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">executeOnExecutor</span><span class="params">(Executor exec, Params... params)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mStatus != Status.PENDING) &#123;</span><br><span class="line">		<span class="keyword">switch</span> (mStatus) &#123;</span><br><span class="line">			<span class="keyword">case</span> RUNNING:</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span>	+ <span class="string">" the task is already running."</span>);</span><br><span class="line">			<span class="keyword">case</span> FINISHED: <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></span><br><span class="line">                            + <span class="string">" the task has already been executed "</span></span><br><span class="line">                            + <span class="string">"(a task can be executed only once)"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mStatus = Status.RUNNING;<span class="comment">//设置任务状态</span></span><br><span class="line">	onPreExecute();</span><br><span class="line">	mWorker.mParams = params;</span><br><span class="line">	exec.execute(mFuture);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里首先判断任务是否是未执行的状态，如果不是，则根据当前状态抛出异常，这段代码表明：<strong>一个AsyncTask只能执行一次(每次运行都得重新创建)。</strong></p>
<blockquote>
<p><strong>PENDING</strong>是创建好但没有执行的状态，FINISHED是终结态，可以通过<code>AsyncTask.getStatus()</code>方法来获知状态。</p>
</blockquote>
<p>onPreExecute()方法在一开始就会调用，执行在execute()方法的调用线程上。传递进来的参数会被赋值给mWorker的mParams属性，在线城池中执行任务。</p>
<h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>执行过程的代码就在mWorker的声明中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	mTaskInvoked.set(<span class="keyword">true</span>);</span><br><span class="line">	Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">	<span class="comment">//noinspection unchecked</span></span><br><span class="line">	Result result = doInBackground(mParams);</span><br><span class="line">	Binder.flushPendingCommands();</span><br><span class="line">	<span class="keyword">return</span> postResult(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mTaskInvoked是一个AtomicBoolean类，从名称看，是表示该任务是否被执行过，具体作用后面详述。</p>
<p>将线程的优先级设置为后台线程优先级，调用第二个重要的生命周期方法doInBackground执行任务。最后调用postResult方法返回结果，postResult方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Result <span class="title">postResult</span><span class="params">(Result result)</span> </span>&#123;</span><br><span class="line">	<span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">	Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,</span><br><span class="line">                <span class="keyword">new</span> AsyncTaskResult&lt;Result&gt;(<span class="keyword">this</span>, result));</span><br><span class="line">	message.sendToTarget();</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里从一个getHandler()方法中获取一个Message，同时将一个AsyncTaskResult对象放置到Meesage中，将消息分发到主线程中。下面看一下这段代码中的两个Key Point。</p>
<h4 id="AsyncTaskResult"><a href="#AsyncTaskResult" class="headerlink" title="AsyncTaskResult"></a>AsyncTaskResult</h4><p>顾名思义，是为AsyncTask执行结果声明的类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTaskResult</span>&lt;<span class="title">Data</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> AsyncTask mTask;</span><br><span class="line">	<span class="keyword">final</span> Data[] mData;</span><br><span class="line">	</span><br><span class="line">	AsyncTaskResult(AsyncTask task, Data... data) &#123;</span><br><span class="line">		mTask = task;</span><br><span class="line">		mData = data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类很简单，持有Task本身和mData——这是我们的任务执行结果。</p>
<h4 id="getHandler"><a href="#getHandler" class="headerlink" title="getHandler()"></a>getHandler()</h4><p>getHandler()返回的是一个InternalHandler实例，类声明如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">InternalHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(Looper.getMainLooper());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"RawUseOfParameterizedType"</span>&#125;)</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">		AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</span><br><span class="line">		<span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">			<span class="keyword">case</span> MESSAGE_POST_RESULT:</span><br><span class="line">				<span class="comment">// There is only one result</span></span><br><span class="line">				result.mTask.finish(result.mData[<span class="number">0</span>]);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> MESSAGE_POST_PROGRESS:</span><br><span class="line">				result.mTask.onProgressUpdate(result.mData);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，这是一个主线程的Handler——保证相关的函数被调度到UI线程执行；其次，处理两种消息：MESSAGE_POST_RESULT和MESSAGE_POST_PROGRESS，即线程执行进度更新和执行完成的回调。result.mTask就是我们当前的AsyncTask。读者可能疑惑MESSAGE_POST_PROGRESS消息是什么时候发出的，看publishProgress()就会明白，这个方法是开发者自己调用的，不是必经的生命周期，因此这里不作分析。</p>
<h3 id="执行结束"><a href="#执行结束" class="headerlink" title="执行结束"></a>执行结束</h3><p>执行结束之后的代码在一开始也看到了，就是mFuture的声明，执行代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		postResultIfNotInvoked(get());</span><br><span class="line">	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		android.util.Log.w(LOG_TAG, e);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"An error occurred while executing doInBackground()"</span>,</span><br><span class="line">		e.getCause());</span><br><span class="line">	&#125; <span class="keyword">catch</span> (CancellationException e) &#123;</span><br><span class="line">		postResultIfNotInvoked(<span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只调用了一个方法:postResultIfNotInvoked(get())。get()方法是FutureTask的方法，会阻塞直至任务执行完成。postResultIfNotInvoked方法的实现是这样的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postResultIfNotInvoked</span><span class="params">(Result result)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">boolean</span> wasTaskInvoked = mTaskInvoked.get();</span><br><span class="line">	<span class="keyword">if</span> (!wasTaskInvoked) &#123;</span><br><span class="line">		postResult(result);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里又出现了mTaskInvoked，配合方法名称postResultIfNotInvoked可以知道，这段代码是在任务没有被执行的时候才会被调用。前面看到call()方法的一开始就会把mTaskInvoked设置为true，这里有些奇怪:</p>
<ol>
<li>按道理一个任务执行起来之后，首先就会执行mTaskInvoked的set方法，那么这里postResult肯定不会被执行。但如果任务没有被Invoked，又怎么会执行到postResultIfNotInvoked方法呢？postResult以及postResultIfNotInvoked都是private的，只可能走这个流程调用；</li>
<li>在call()方法的最后，已经调用postResult了，为什么这里还要再次判断并分发结果？</li>
</ol>
<p>一步步来：要 <strong>!wasTaskInvoked</strong> 为true，则call方法不能被执行，否则mTaskInvoked肯定会被置为true，那么只有一种办法，就是call方法刚执行的时候就抛出了异常，而异常在FutureTask中是很常见的，至少有两种，就是InterruptedException和CancellationException。下面我们来看第5个生命周期方法，看完就知道如何解释这个判断了。</p>
<h3 id="取消执行"><a href="#取消执行" class="headerlink" title="取消执行"></a>取消执行</h3><p>AsyncTask是可以取消的，调用方法cancel()就好:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">	mCancelled.set(<span class="keyword">true</span>);</span><br><span class="line">	<span class="keyword">return</span> mFuture.cancel(mayInterruptIfRunning);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> mCancelled.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mCancelled也是一个AtomicBoolean对象，标识任务是否被取消，我们看一下这个变量有什么影响。</p>
<p>在任务结束的时候，调用的是AsyncTask.finsh()方法(可以查看InternalHandler对MESSAGE_POST_RESULT类型消息的处理):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(Result result)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">		onCancelled(result);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		onPostExecute(result);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//注意，不论任务是正常完成还是取消，状态都标记为FINISHED</span></span><br><span class="line">	mStatus = Status.FINISHED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会做出判断，如果被取消了，是回调生命周期方法onCancelled，否则调用onPostExecute。</p>
<p>到此还没有回答前面的问题，但是取消是很关键的。熟悉FutureTask的人应该知道CancellationException发生的情况：如果有人在AsyncTask运行之前，即call执行之前调用cancel方法，那么只要AsyncTask一运行，就会立刻抛出CancellationException异常，进入done()方法执行。</p>
<p><strong>postResultIfNotInvoked()方法就是为了防止在这种情况下不回调onCancelled()设置的: 如果正常执行，不发生任何的异常，则会执行call最后的postResult()方法直接分发结果，但如果发生了异常，则会直接进入done()函数，done函数可以保证，如果是因为CancellationException异常发生执行错误，一定会回调onCancelled()方法。并且call()和done()方法虽然都会去调用postResult()方法，但条件上互斥，即结果不会分发两次。</strong></p>
<p>可以参见这个<a href="https://android.googlesource.com/platform/frameworks/base/+/5ba812b9e9c886425a5736c2ae6fbe0fc94afd8b%5E%21/#F0" target="_blank" rel="noopener">【Bug】</a></p>
<p>关于Cancel方法的几个影响，可以参见下列表格: </p>
<p><img src="http://7xktd8.com1.z0.glb.clouddn.com/AsyncTask-Cancel方法.png" alt="AsyncTask-Cancel方法"><br>以上，相关方法都分析完毕。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>AsyncTask本身其实是调度后台线程执行耗时任务，底层是使用线程池管理后台线程的——这也就意味着，大量的AsyncTask并不会无限制的创建后台线程。在AsyncTask内部，有两种线程池，一个是默认的，一个是串行线程池。</p>
<h3 id="默认线程池"><a href="#默认线程池" class="headerlink" title="默认线程池"></a>默认线程池</h3><p>默认线程池的声明是这样的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CPU_COUNT = Runtime.getRuntime().availableProcessors();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = CPU_COUNT + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_POOL_SIZE = CPU_COUNT * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEEP_ALIVE = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">128</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor THREAD_POOL_EXECUTOR</span><br><span class="line">            = <span class="keyword">new</span> ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,</span><br><span class="line">                    TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);</span><br></pre></td></tr></table></figure>
<p>根据CPU核数量设置线程池的运行能力，缓存队列中最多存储128个任务，一般来说，这个数量应该够用了。但是开发者还是要注意管理，任务超过128 + CPU_COUNT * 2 + 1，AsyncTask就会报错，这是线程池的机制。</p>
<h3 id="串行线程池"><a href="#串行线程池" class="headerlink" title="串行线程池"></a>串行线程池</h3><p>串行线程池是AsyncTask自己实现的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();</span><br><span class="line">	Runnable mActive;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</span><br><span class="line">		mTasks.offer(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					r.run();</span><br><span class="line">				&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">					scheduleNext();<span class="comment">//执行下一个</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="keyword">if</span> (mActive == <span class="keyword">null</span>) &#123;</span><br><span class="line">			scheduleNext();<span class="comment">//执行下一个</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> ((mActive = mTasks.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">			THREAD_POOL_EXECUTOR.execute(mActive);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它会不停的从队列中拉取Runnable对象，丢入默认线程池中执行，但是每次只会执行一个：execute()的时候会去检测有没有线程正在运行，没有的话会去队列中获取任务，或者在一个任务执行完成之后也会去队列中获取任务继续执行。通过这种方式，实现任务的串行。</p>
<p>AsyncTask默认到底是并行还是串行的，其实是不一定的，一下是串行还是并行与版本的关系:</p>
<p><img src="http://7xktd8.com1.z0.glb.clouddn.com/Asynctask-Execution-Differences.png" alt="Asynctask-Execution-Differences"><br>最终默认方式采用并行还是串行，是依据targetSdkVersion来的，targetSdkVersion<13的时候默认是串行的(即使运行的平台大于等于13)，targetsdkversion>=13的时候默认就是串行的。(现在这些问题都不需要担心了)。我们顺便看一下其余几个方法的情况:</13的时候默认是串行的(即使运行的平台大于等于13)，targetsdkversion></p>
<p><img src="http://7xktd8.com1.z0.glb.clouddn.com/Android-AsyncTask- Execution.png" alt="Android-AsyncTask- Execution"></p>
<blockquote>
<p>PS: <code>AsyncTask.execute(Runnable)</code>方法是一个很奇怪的方法，它执行在AsyncTask内部的线程池中，这个时候其实就是把AsyncTask当做线程池在使用。</p>
</blockquote>
<p>如果是使用默认的线程池，则AsyncTask全局使用的是同一个线程池，这在某些情况下可能会出现问题——我们可以通过自定义线程池来改善。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>AsyncTask本质是基于Java的FutureTask和Android的Handler做的一层封装，添加了后台线程和主线程之间的任务调度，精巧实用，下面是一些使用AsyncTask的参考点:</p>
<ol>
<li>如果我们创建了一个AsyncTask，执行它的时候不需要传递参数，或者只需要重载<code>AsyncTask.doInBackground()</code>方法，那么可以考虑别的手段，比如<a href="http://www.muzileecoding.com/androidsource/Android-HandlerThread-And-IntentService.html" target="_blank" rel="noopener">HandlerThread</a>。</li>
<li>AsyncTask自身是没有Looper的，所以不能实现消息的传递，理论上可以通过一些方法进行改造，但很明显这样做不值得，这个时候同样可以考虑<a href="http://www.muzileecoding.com/androidsource/Android-HandlerThread-And-IntentService.html" target="_blank" rel="noopener">HandlerThread</a>。</li>
<li>AsyncTask和Local Service是一组很好的搭配。因为Service的执行也是在主线程的，如果执行一些耗时任务，就需要开启背景线程，这个时候使用AsyncTask是一个不错的选择，但是最好自己起一个线程池。</li>
</ol>
<p>大部分时候AsyncTask使用起来都不会有什么问题，几个生命周期方法也非常好懂。但是通过刚刚的分析，<strong>要注意的是onPreExecute()方法的使用</strong>。这个方法并没有通过Handler强制调度到主线程执行，它是可能运行在后台线程上的——取决于AsyncTask的execute方法在什么线程上被执行。但就算这样也不必过于担心，我们绝大部分情况下都是在主线程上使用AsyncTask的，并且，这个方法用到的也不多。</p>
<p>下面是一个试验:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.footprint.littleshell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.os.AsyncTask;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.os.Looper;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                MyTask myTask = <span class="keyword">new</span> MyTask();</span><br><span class="line">                myTask.execute(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Integer</span>, <span class="title">Integer</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MyTask"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">doInBackground</span><span class="params">(Integer... params)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isMainThread())</span><br><span class="line">            Log.e(TAG, <span class="string">"【doInBackground】- Main"</span>);</span><br><span class="line">        <span class="keyword">else</span> Log.e(TAG, <span class="string">"【doInBackground】- Non-Main"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onPreExecute();</span><br><span class="line">        <span class="keyword">if</span> (isMainThread())</span><br><span class="line">            Log.e(TAG, <span class="string">"【onPreExecute】- Main"</span>);</span><br><span class="line">        <span class="keyword">else</span> Log.e(TAG, <span class="string">"【onPreExecute】- Non-Main"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isMainThread())</span><br><span class="line">            Log.e(TAG, <span class="string">"【onPostExecute】- Main"</span>);</span><br><span class="line">        <span class="keyword">else</span> Log.e(TAG, <span class="string">"【onPostExecute】- Non-Main"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isMainThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Looper.myLooper() != <span class="keyword">null</span> &amp;&amp; Looper.myLooper() == Looper.getMainLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">02</span>-<span class="number">29</span> <span class="number">21</span>:<span class="number">29</span>:<span class="number">41.959</span>     <span class="number">905</span>-<span class="number">2384</span>/com.footprint.littleshell E/MyTask﹕ 【onPreExecute】- Non-Main</span><br><span class="line"><span class="number">02</span>-<span class="number">29</span> <span class="number">21</span>:<span class="number">29</span>:<span class="number">42.389</span>     <span class="number">905</span>-<span class="number">2385</span>/com.footprint.littleshell E/MyTask﹕ 【doInBackground】- Non-Main</span><br><span class="line"><span class="number">02</span>-<span class="number">29</span> <span class="number">21</span>:<span class="number">29</span>:<span class="number">42.389</span>     <span class="number">905</span>-<span class="number">905</span>/com.footprint.littleshell E/MyTask﹕ 【onPostExecute】- Main</span><br></pre></td></tr></table></figure>
<p>结果验证了之前关于onPreExecute()方法的结论。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Handler 源码分析]]></title>
      <url>http://www.timebridge.space/2015/11/23/Android-Handler/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>【环境】源码分析基于 4.4.2_r1。</p>
<h2 id="Handler的使用"><a href="#Handler的使用" class="headerlink" title="Handler的使用"></a>Handler的使用</h2><p>日常开发中我们经常用到Handler，Handler用于向一个线程的消息队列中发送消息并负责处理。我们可以用它实现定时任务调度、将耗时任务放到异步线程执行并在执行完毕后通知主线程更新UI等功能。下面是一个小🌰：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Handler</span></span><br><span class="line">Handler myHandler = <span class="keyword">new</span> Handler() &#123; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;   </span><br><span class="line">		<span class="keyword">switch</span> (msg.what) &#123;  </span><br><span class="line">		&#125;   </span><br><span class="line">		<span class="keyword">super</span>.handleMessage(msg);   </span><br><span class="line">	&#125;   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Handler发送消息</span></span><br><span class="line">Message message = <span class="keyword">new</span> Message();      </span><br><span class="line">message.what = <span class="number">1</span>;      </span><br><span class="line">myHandler.sendMessage(message);</span><br></pre></td></tr></table></figure>
<p>这是一个使用Handler的经典过程：发出的消息会在时间到达的时候进入到Handler的handleMessage中被处理。下面我们就来探究一下Message从被创建到被处理到底经历了什么样的过程。<a id="more"></a></p>
<h2 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h2><p>如🌰所示，我们从new Handler()切入，然后追踪sendMessage方法，查看Message对象如何进入handleMessage方法，一步步剖析，解析整个流程。</p>
<h3 id="Handler片段——Handler创建"><a href="#Handler片段——Handler创建" class="headerlink" title="Handler片段——Handler创建"></a>Handler片段——Handler创建</h3><p>先看一下Handler的创建过程:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">		<span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">		<span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">				(klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">			Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> + klass.getCanonicalName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mLooper = Looper.myLooper();</span><br><span class="line">	<span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	mQueue = mLooper.mQueue;<span class="comment">//获取消息队列</span></span><br><span class="line">	mCallback = callback;</span><br><span class="line">	mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里重点是 <strong>mLooper = Looper.myLooper();</strong> 以及后面三行代码。我们看到，新建一个Handler的时候，如果Looper.myLooper为null，则会抛出异常；如果不为null，则获取Looper中的mQueue。其余两个参数不是重点，暂不分析。</p>
<h3 id="Looper片段——Looper创建"><a href="#Looper片段——Looper创建" class="headerlink" title="Looper片段——Looper创建"></a>Looper片段——Looper创建</h3><p>Android中提供了相关步骤，可以使得一个普通Thread也具备消息循环处理机制（因为主线程默认做了一些操作，因此不好分析，我们从普通线程入手，可以更清楚的看到整个创建过程）。示例代码可以在Looper源码(类注释)中找到:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          Looper.prepare();</span><br><span class="line"></span><br><span class="line">          mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                 <span class="comment">// process incoming messages here</span></span><br><span class="line">              &#125;</span><br><span class="line">         &#125;;</span><br><span class="line">         Looper.loop();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里涉及到另外一个重要的对象：<strong>Looper</strong>。首先来看一下 <strong>Looper.prepare();</strong> 方法，源码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Initialize the current thread as a looper.</span></span><br><span class="line"><span class="comment"> * This gives you a chance to create handlers that then reference</span></span><br><span class="line"><span class="comment"> * this looper, before actually starting the loop. Be sure to call</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #loop()&#125; after calling this method, and end it by calling</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #quit()&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	prepare(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们关注一下异常，异常消息的含义是：每一个线程只能有一个Looper。而判断的条件是，从sThreadLocal中获取的对象不为null——<a href="http://www.muzileecoding.com/java/Java-threadlocal.html" target="_blank" rel="noopener">ThreadLocal</a>控制每个线程只有一个Looper实例。<br>如果之前没有创建Looper，则会实例化一个Looper，看一下构造方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意：这个方法是私有的</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">	mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">	mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数分为两步：1）创建了一个MessageQueue；2）获取当前的线程。注意mQueue这个变量，就是上一节中Handler从Looper中获取的消息队列对象。</p>
<p>到这里，我们看到了Handler、Looper和MessageQueue三个对象的创建过程。我们知道以下几个重要的点:</p>
<ol>
<li>new Handler()之前，必须保证Looper.myLooper()方法的返回不为null；</li>
<li>Looper在新建的时候会建立对应的MessageQueue，并且prepare()方法会通过ThreadLocal保证每一个线程只会实例化一个Looper。</li>
<li>Handler既会持有Looper的引用，又会持有MessageQueue的引用；</li>
</ol>
<p>但是这几个类之间的关系我们却不是很清楚，下面解释。</p>
<h3 id="线程、Handler、Looper的联系"><a href="#线程、Handler、Looper的联系" class="headerlink" title="线程、Handler、Looper的联系"></a>线程、Handler、Looper的联系</h3><p>在消息机制里面，Looper只是负责管理消息队列，也就是取出消息进行处理，而Handler则是负责发送消息以及处理消息的，那么Handler和Looper又是如何绑定到一起的呢？从Handler的源码看，关键代码是:  <strong>mLooper = Looper.myLooper();</strong> ，源码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * null if the calling thread is not associated with a Looper.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里把注释也Copy过来了，myLooper方法是直接从sThreadLocal中读取的变量，注释说到：myLooper()方法在当前没有Looper绑定到调用线程时会返回null。搜索整个Looper类，会发现只有前面提到的prepare()方法中有sThreadLocal.set()调用。即在为一个线程实例化Handler之前，必须在该线程中调用Looper.prepare()方法：只有这样，才能为一个线程建立对应的Looper——这解释了前面LooperThread代码的构建逻辑。</p>
<p>到这里我们知道，通过调用Looper.prepare()方法一次，就可以将一个Looper对象绑定到方法调用线程上去(即设置到ThreadLocal中)。新建Handler的时候，Handler会直接调用Looper.myLoop()方法获取绑定到线程的Looper并通过这个Looper获取到对应的MessageQueue。</p>
<p>这就是这几个概念之间的关系。</p>
<h3 id="Looper片段——Looper-loop"><a href="#Looper片段——Looper-loop" class="headerlink" title="Looper片段——Looper.loop()"></a>Looper片段——Looper.loop()</h3><p>LooperThread构建的最后一步就是调用Loop.loop()方法，它的源码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Run the message queue in this thread. Be sure to call</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #quit()&#125; to end the loop.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">	<span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">	<span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">	Binder.clearCallingIdentity();</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">		<span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">		Printer logging = me.mLogging;</span><br><span class="line">			<span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">  				logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</span><br><span class="line">                        msg.callback + <span class="string">": "</span> + msg.what);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			msg.target.dispatchMessage(msg);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">				logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">			<span class="comment">// identity of the thread wasn't corrupted.</span></span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class="line">			<span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">				Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></span><br><span class="line">                        + Long.toHexString(ident) + <span class="string">" to 0x"</span></span><br><span class="line">                        + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></span><br><span class="line">                        + msg.target.getClass().getName() + <span class="string">" "</span></span><br><span class="line">                        + msg.callback + <span class="string">" what="</span> + msg.what);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			msg.recycle();<span class="comment">//回收消息，注意这个位置</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，同样要求myLooper不能为null（根据前面的分析，实现调用Looper.prepare（)方法即可）并从这个Looper中拿到相应的消息队列。之后我们进入一个无限循环，这个循环中最重要的事情就是queue.next()方法的调用，这个方法根据注释：可能会引起阻塞。相关的实现可以深入到MessageQueue中，这里涉及到Native代码，具体的理解不影响到原理讲述，暂且不表。</p>
<p>这里有一个很重要的判断：如果Message拿出来为空，则认为这个MessageQueue已经被丢弃了，整个循环会被打破返回，读者可以注意一下。</p>
<p>再之后就进入到msg.target.dispatchMessage方法。即消息的分发和处理。</p>
<h3 id="关系总结"><a href="#关系总结" class="headerlink" title="关系总结"></a>关系总结</h3><p>这里总结一下: </p>
<ol>
<li>我们在让一个线程具备消息循环调度能力的时候，首先需要在这个线程中调用Looper.prepare()，这个方法很重要，它会为一个线程绑定一个Looper，且只能绑定一个。创建Looper的同时，Looper会创建一个MessageQueue。之后在线程中创建Handler的时候，会从Looper中引用MessageQueue放到Handler实例中去。至此Handler、Looper、MessageQueue三个类的关系建立。</li>
<li>关系建立之后，调用Looper.loop()方法会让Loop运行起来：不断从MessageQueue中获取handler通过sendMessage发送的Message并dispatchMessage。至此，整个消息循环的核心部分构建完毕。</li>
</ol>
<h3 id="消息的分发和处理"><a href="#消息的分发和处理" class="headerlink" title="消息的分发和处理"></a>消息的分发和处理</h3><p>整个消息循环核心部分已经运行起来，剩下来的就是我们日常最长使用到的消息的发送和处理，接下来看看消息从发送到处理之间的流程。首先是sendMessage方法源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Enqueue a message into the message queue after all pending messages</span></span><br><span class="line"><span class="comment"> * before the absolute time (in milliseconds) &lt;var&gt;uptimeMillis&lt;/var&gt;.</span></span><br><span class="line"><span class="comment"> * &lt;b&gt;The time-base is &#123;<span class="doctag">@link</span> android.os.SystemClock#uptimeMillis&#125;.&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * You will receive it in &#123;<span class="doctag">@link</span> #handleMessage&#125;, in the thread attached</span></span><br><span class="line"><span class="comment"> * to this handler.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> uptimeMillis The absolute time at which the message should be</span></span><br><span class="line"><span class="comment"> *         delivered, using the</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@link</span> android.os.SystemClock#uptimeMillis&#125; time-base.</span></span><br><span class="line"><span class="comment"> *         </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Returns true if the message was successfully placed in to the </span></span><br><span class="line"><span class="comment"> *         message queue.  Returns false on failure, usually because the</span></span><br><span class="line"><span class="comment"> *         looper processing the message queue is exiting.  Note that a</span></span><br><span class="line"><span class="comment"> *         result of true does not mean the message will be processed -- if</span></span><br><span class="line"><span class="comment"> *         the looper is quit before the delivery time of the message</span></span><br><span class="line"><span class="comment"> *         occurs then the message will be dropped.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">	MessageQueue queue = mQueue;</span><br><span class="line">		<span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">			RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">			Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看源码就会发现，同名&amp;功能相似的有好几个方法，但最终都会调用sendMessageAtTime方法，首先获取mQueue：注意这个方法在Handler新建的时候就获取了。之后调用了一个enqueueMessage方法，源码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">	msg.target = <span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">		msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，将msg.target赋值为本身，之后根据Handler新建时候传入的参数(前面忽略了它)设置msg属性，之后就调queue的enqueueMessage向队列中压入消息——<strong>完成消息的发送</strong>。</p>
<p>这里很重要的一点是<strong>msg.target = this;</strong>。查看Message的源码就可以看到，target是一个Handler变量。而在前面讲述的Looper.loop()方法实现中，取出消息后调用的方法是msg.target.dispatchMessage(msg);。嘿！这难道不是调用的Handler的dispatchMessage方法么？看源码果然发现一枚:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">		handleCallback(msg);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		handleMessage(msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们可以看到很多我们平时不常用的方法:</p>
<p>【 1 】Message是可以自带一个callback变量的，查看Meesgae源码可知这是一个Runnable变量，即我们可以使用一个Message实现post一个Runable对象的功能，因为handleCallback的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">	message.callback.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上读者可以查看Handler.postDelayed(Runnable)方法，内部正式做了这一层转换。</p>
<p>【 2 】如果实例化Handler的时候设置了mCallback对象（日常开发很少用，但的确存在这种用法），那么所有的小弟都先交给mCallback处理，mCallback是一个CallBack对象，这是一个接口:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边可以通过返回true来拦截handleMessage的执行。</p>
<p>【 3 】以上都绕过了，才轮到handleMessage方法执行——关于这个方法，就不多说了，写Handler的时候肯定会重载它。</p>
<p>到此，消息的处理分析完毕。</p>
<h2 id="剖析总结"><a href="#剖析总结" class="headerlink" title="剖析总结"></a>剖析总结</h2><p>到这里，对于整个消息处理发送、循环、发送的机制基本解释清楚。剩下一块比较模糊：MessageQueue的分析比较少，原因是这块涉及到一些Native代码，且对理解整个Handler机制的理解影响不大，在这篇文章中暂不分析。</p>
<p>我们用一张图来总结一下几个概念之间的关系:</p>
<p><img src="http://7xktd8.com1.z0.glb.clouddn.com/Handler原理图.png" alt="Handler消息流转图"></p>
<p>该图重点展示了几个问题：</p>
<ol>
<li>Handler直接向MessageQueue中发送消息；</li>
<li>Looper负责获取消息并作分发（但是具体分发到哪个Handler是由Message的target属性决定的）；</li>
<li><strong>一个线程只会有一个Looper和一个MessageQueue，不论该线程有多少个Handler，它们都公用这个Looper和MessageQueue；</strong></li>
</ol>
<p>HandlerThread是串行化执行任务，因此在里面执行任务是线程安全的(指的是任务之间，而不是和其余线程之间)，但是有时候也需要注意将耗时任务和非耗时任务区分在不同的队列里面，提高效率。这个类还很适合执行链式任务，比如编译任务。</p>
<h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><h3 id="主线程和主Handler"><a href="#主线程和主Handler" class="headerlink" title="主线程和主Handler"></a>主线程和主Handler</h3><p>在所有的线程中，主线程是非常特殊的，开发时在主线程中新建Handler的实例不需要走上面的流程，直接创建即可，官方文档给出的解释是，主线程本身就已经启动Looper了。其实在Looper中，是有一个专门的方法做这件事的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the current thread as a looper, marking it as an</span></span><br><span class="line"><span class="comment"> * application's main looper. The main looper for your application</span></span><br><span class="line"><span class="comment"> * is created by the Android environment, so you should never need</span></span><br><span class="line"><span class="comment"> * to call this function yourself.  See also: &#123;<span class="doctag">@link</span> #prepare()&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	prepare(<span class="keyword">false</span>);</span><br><span class="line">	<span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		sMainLooper = myLooper();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意看注释！！！这个方法就是创建主线程的Looper的。注释中说，这个创建是由Android Environment执行的，所以开发者<strong>从来不需要</strong>手动调用这个方法。而下面这个方法则是用于获取主Looper的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Returns the application's main looper, which lives in the main thread of the application.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Looper <span class="title">getMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">		<span class="keyword">return</span> sMainLooper;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消息的recycle"><a href="#消息的recycle" class="headerlink" title="消息的recycle"></a>消息的recycle</h3><p>Message内部维护着一个链表，所有被回收的Message都挂在这个链表上。关键的方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object sPoolSync = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Message sPool;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sPoolSize = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return a new Message instance from the global pool. Allows us to</span></span><br><span class="line"><span class="comment"> * avoid allocating new objects in many cases.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">			Message m = sPool;</span><br><span class="line">			sPool = m.next;</span><br><span class="line">			m.next = <span class="keyword">null</span>;</span><br><span class="line">			m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">			sPoolSize--;</span><br><span class="line">			<span class="keyword">return</span> m;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Message();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (isInUse()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (gCheckRecycle) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"This message cannot be recycled because it "</span></span><br><span class="line">                        + <span class="string">"is still in use."</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	recycleUnchecked();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Mark the message as in use while it remains in the recycled object pool.</span></span><br><span class="line">	<span class="comment">// Clear out all other details.</span></span><br><span class="line">	flags = FLAG_IN_USE;</span><br><span class="line">	what = <span class="number">0</span>;</span><br><span class="line">	arg1 = <span class="number">0</span>;</span><br><span class="line">	arg2 = <span class="number">0</span>;</span><br><span class="line">	obj = <span class="keyword">null</span>;</span><br><span class="line">	replyTo = <span class="keyword">null</span>;</span><br><span class="line">	sendingUid = -<span class="number">1</span>;</span><br><span class="line">	when = <span class="number">0</span>;</span><br><span class="line">	target = <span class="keyword">null</span>;</span><br><span class="line">	callback = <span class="keyword">null</span>;</span><br><span class="line">	data = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">		<span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">			next = sPool;</span><br><span class="line">			sPool = <span class="keyword">this</span>;</span><br><span class="line">			sPoolSize++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">updateCheckRecycle</span><span class="params">(<span class="keyword">int</span> targetSdkVersion)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (targetSdkVersion &lt; Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">		gCheckRecycle = <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到消息机制下面其实维护着一个消息链表，这个链表充当着对象池的角色，因此建议大家使用obtain()来“创建”消息，这样可以避免创建大量的Message对象。补充一点：消息会在被压入队列时置为FLAG_IN_USE。  </p>
<blockquote>
<p>【注意】在5.0以下的时候，gCheckRecycle开关是关闭的，这意味着回收时不会去检查Message是否在使用中。而在5.0以上就会检查，此处很坑爹的是：FLAG_IN_USE标志位的重置是在obtain的时候清除重置的，在进入消息队列则会被置位。从前面Looper.loop()方法可以看到，一个消息会在dispatchMessage之后立刻调用recycle方法，此时消息的FLAG_IN_USE还没有被重置，recycle必然导致异常抛出——这应该是SDK的一个Bug。</p>
</blockquote>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ol>
<li>以下方法被从MessageQueue暴露到Handler里面:<code>hasMeesgae()</code>，这个方法有好几个重载方法，可以关注一下，用于判断队列中有没有特定的消息;</li>
<li>Handler还有一个这样的方法: <code>Handler.postAtFrontOfQueue()</code>，可以让消息插队;</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java ConcurrentHashMap补充]]></title>
      <url>http://www.timebridge.space/2015/11/21/Java-ConcurrentHashMap/</url>
      <content type="html"><![CDATA[<p>基于<a href="https://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/" target="_blank" rel="noopener">《探索 ConcurrentHashMap 高并发性的实现机制》</a>做总结和补充。</p>
<p>前提: IBM 的这篇文章是基于 JDK 1.6 的，现在JDK已经到 1.8，读者可以分别下载 <a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b27/java/util/concurrent/ConcurrentHashMap.java#ConcurrentHashMap" target="_blank" rel="noopener">1.6</a> 和 <a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/java/util/concurrent/ConcurrentHashMap.java#ConcurrentHashMap" target="_blank" rel="noopener">1.8</a> 代码阅读。</p>
<h2 id="补充一：ConcurrentHashMap-和-Segment的建立"><a href="#补充一：ConcurrentHashMap-和-Segment的建立" class="headerlink" title="补充一：ConcurrentHashMap 和 Segment的建立"></a>补充一：ConcurrentHashMap 和 Segment的建立</h2><p>其实文章中已经讲述了该过程，不过条理不清晰。看一下ConcurrentHashMap的构造函数：<a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">		concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">	<span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">		++sshift;</span><br><span class="line">		ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">	segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">this</span>.segments = Segment.newArray(ssize);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">		initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">	<span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">		++c;</span><br><span class="line">	<span class="keyword">int</span> cap = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">		cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.segments.length; ++i)</span><br><span class="line">		<span class="keyword">this</span>.segments[i] = <span class="keyword">new</span> Segment&lt;K,V&gt;(cap, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接看代码以及文章注释可能都不是很清楚，该构造函数传进来三个参数，分别是什么作用呢？我将构造函数中代码提出来，做了一下实验，赋值和计算结果分别如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">concurrencyLevel:<span class="number">17</span></span><br><span class="line">initialCapacity:<span class="number">63</span></span><br><span class="line">sshift:<span class="number">5</span></span><br><span class="line">ssize:<span class="number">32</span></span><br><span class="line">segmentShift:<span class="number">27</span></span><br><span class="line">segmentMask:<span class="number">31</span></span><br><span class="line">cap:<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>这下子就很清楚了，当我们要求concurrencyLevel是17的时候，ssize的计算结果是32，而sssize最终是用于创建Segment数组的，也就是说程序会扩展（这个很常见，扩展成2的幂值），保证实际的Segment数量大于等于开发者设定的并发Level（一个Segment作为一个并发Level看待）。</p>
<p>而initialCapacity值为63的时候，cap的最终计算结果是2。这是因为，当我们分配了ssize数量的Segment之后，我们需要将开发者设定的initialCapacity分配到Segment中去，很明显，至少每个Segment存储2个HashEntry才能满足63的的初始容量设置，因此这个值等于2。</p>
<p>基于以上认识，配合注释，就不难理解代码逻辑了。下面这幅图很重要:</p>
<p><img src="http://7xktd8.com1.z0.glb.clouddn.com/ConcurrentHashMap结构图.jpg" alt="ConcurrentHashMap结构图"></p>
<p>通过将容器切分为多个Segment，降低锁的粒度，从而提高并发性——现在Segment之间是独立的，读写可以并发，具体的锁操作只有到了单个Segment内部才会发生。</p>
<h2 id="补充二：readValueUnderLock"><a href="#补充二：readValueUnderLock" class="headerlink" title="补充二：readValueUnderLock"></a>补充二：readValueUnderLock</h2><p>这个方法在两个方法被调用，一个是containsValue，一个是get。都是在获取某个HashEntry的value发现为null之后再去调用。文章中把它的解释和volatile放在一起，容易产生误解，这个方法的注释是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reads value field of an entry under lock. Called if value</span></span><br><span class="line"><span class="comment"> * field ever appears to be null. This is possible only if a</span></span><br><span class="line"><span class="comment"> * compiler happens to reorder a HashEntry initialization with</span></span><br><span class="line"><span class="comment"> * its table assignment, which is legal under memory model</span></span><br><span class="line"><span class="comment"> * but is not known to ever occur.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">V <span class="title">readValueUnderLock</span><span class="params">(HashEntry&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">	lock();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> e.value;</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		unlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据注释，发生这种情况很有可能是因为编译器重排序了一个HashEntry的初始化和赋值过程。即原本应该是先初始化再存入table，而实际上却因为重排序，导致HashEntry没有初始化完成就被存入了table(发生在get方法中)。</p>
<p>而在代码中，readValueUnderLock和put方法都是使用lock()包围的，因此根据happens-before原则使用readValueUnderLock可以强制和put确立先后关系，等待put完成之后再去获取相应的value。</p>
<p>正如文章后面所说:</p>
<blockquote>
<p>在实际的应用中，散列表一般的应用场景是：除了少数插入操作和删除操作外，绝大多数都是读取操作，而且读操作在大多数时候都是成功的。正是基于这个前提，ConcurrentHashMap针对读操作做了大量的优化——只有读到value域的值为null时，读线程才需要加锁后重读，极大的减少了持锁时间。通过HashEntry对象的不变性和用volatile型变量协调线程间的内存可见性，使得 大多数时候，读操作不需要加锁就可以正确获得值。这个特性使得ConcurrentHashMap 的并发性能在分离锁的基础上又有了近一步的提高。</p>
</blockquote>
<h2 id="补充三：结构性修改的操作"><a href="#补充三：结构性修改的操作" class="headerlink" title="补充三：结构性修改的操作"></a>补充三：结构性修改的操作</h2><p>在文章中提到了对散列表做非结构性修改的操作和对散列表做结构性修改的操作。非结构性修改的可见性由volatile字段完成，而结构性修改的操作，实际上作者讨论的并没有太大意义，因为put、remove、clear三个操作在发生对链表的修改时，都是在lock状态下进行的。</p>
<h2 id="补充四：为什么性能好？"><a href="#补充四：为什么性能好？" class="headerlink" title="补充四：为什么性能好？"></a>补充四：为什么性能好？</h2><p>降低锁的粒度和锁持有时间，并考虑到实际的使用情况，对集合读取的情况进行了优化，非常赞！</p>
<p>//TODO 研究JDK 1.8。JDK1.6中HashMap采用的是位桶+链表的方式，即我们常说的散列链表的方式，而JDK1.8中采用的是位桶+链表/红黑树的方式，也是非线程安全的。当某个位桶的链表的长度达到某个阀值的时候，这个链表就将转换成红黑树。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android单元测试(二)——Mock & Stub]]></title>
      <url>http://www.timebridge.space/2015/11/18/Android-unit-test-mock-and-stub/</url>
      <content type="html"><![CDATA[<p>本文翻译总结自Martin Fowler（不知道是谁？！！）的<a href="http://martinfowler.com/articles/mocksArentStubs.html" target="_blank" rel="noopener">《Mocks Aren’t Stubs》</a></p>
<p>Mock对象是在XP社区出现的，后面越来越多的出现在XP的开发测试流程中。Mock对象的概念一直很模糊，尤其经常会和stub——一个常见的测试环境辅助概念混淆起来，Martin Fowler在很长一段时间内也认为它们（mock和stub）是差不多的，但是通过和mock开发者的交流使得Martin Fowler意识到两者是有区别的。<a id="more"></a></p>
<p>两者的区别其实包含两部分:</p>
<ul>
<li>如何验证测试结果：状态验证(state verification) VS 行为验证(behavior verification)；</li>
<li>测试和设计如何协作：经典形式(classical)和Mock形式(mockist)（Martin Fowler的分类）；</li>
</ul>
<h2 id="普通测试"><a href="#普通测试" class="headerlink" title="普通测试"></a>普通测试</h2><p>Martin Fowler在文章中举了个🌰，这里原封不动的阐述。🌰是这样的：我们想要创建一个Order对象，这个对象会从一个Warehouse对象中获取资源（简单说就是Warehouse对象会根据Order对象分配物资），Order对象很简单，只有一个Product对象以及数量，Warehouse对象则包含着不同Product的存货清单。当我们要求Warehouse对象根据Order对象分配物资的时候，有两种情况:</p>
<ol>
<li>物资数量充足，可以正确分配，订单完成，相应的数量被从Warehouse对象的存货清单中减去；</li>
<li>物资数量不足，订单不能完成，Warehouse的存货清单不变动；</li>
</ol>
<p>这两种行为可以进行一些测试，下面是一种传统的JUnit测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderStateTester</span> <span class="keyword">extends</span> <span class="title">TestCase</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String TALISKER = <span class="string">"Talisker"</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String HIGHLAND_PARK = <span class="string">"Highland Park"</span>;</span><br><span class="line">	<span class="keyword">private</span> Warehouse warehouse = <span class="keyword">new</span> WarehouseImpl();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		warehouse.add(TALISKER, <span class="number">50</span>);</span><br><span class="line">		warehouse.add(HIGHLAND_PARK, <span class="number">25</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOrderIsFilledIfEnoughInWarehouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Order order = <span class="keyword">new</span> Order(TALISKER, <span class="number">50</span>);</span><br><span class="line">		order.fill(warehouse);</span><br><span class="line">		assertTrue(order.isFilled());</span><br><span class="line">		assertEquals(<span class="number">0</span>, warehouse.getInventory(TALISKER));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOrderDoesNotRemoveIfNotEnough</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Order order = <span class="keyword">new</span> Order(TALISKER, <span class="number">51</span>);</span><br><span class="line">		order.fill(warehouse);</span><br><span class="line">		assertFalse(order.isFilled());</span><br><span class="line">		assertEquals(<span class="number">50</span>, warehouse.getInventory(TALISKER));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个测试按照经典的四步进行：</p>
<ol>
<li><strong>setup</strong>  即setUp方法中执行的代码，还有部分在test方法中，主要是Order和Warehouse对象的建立；</li>
<li><strong>exercise</strong> order.fill是属于这个阶段的，对象开始执行一些我们需要测试的行为；</li>
<li><strong>verify</strong> assert代码属于验证阶段，来检测exercise的执行结果是否正确；</li>
<li><strong>teardown</strong> 这个测试中没有显示的teardown阶段，垃圾回收器悄悄地把这事儿给干了；</li>
</ol>
<blockquote>
<p>【一句话】测试的流程是这样的：首先创建对象，准备数据(setup)，让我们测试的对象在这种上下文环境中运行(exercise)，验证结果是否符合预期(verify)，最终清理测试环境(teardown)。</p>
</blockquote>
<p>在setup阶段，我们创建了两个对象——Order和Warehouse——Order是我们需要测试的类，但是在调用fill方法的时候，我们需要一个Warehouse对象，因此必须创建一个它的对象。Testing-oriented的人喜欢使用object-under-test或者system-under-test来称呼他们集中精力测试的类，在这里，就是我们的Order类，两个称呼在Martin Fowler看来都很丑陋，不过Martin Fowler仍然打算在接下来的描述中使用其中一个称呼，因为大家都这么用——System Under Test，缩写 <strong>SUT</strong> 。</p>
<p>所以在这个测试中我们需要一个SUT(Order)和一个Collaborator(可理解为辅助者、协作者，这里保持原汁原味儿)(Warehouse)。需要Warehouse有两个原因：一个是为了使得测试能够正常运行(Order.fill方法需要调用到Warehouse的方法)，第二个是为了验证(Order.fill会改变Warehouse的内部状态，因此需要通过验证Warehouse的状态来确认Order执行的正确性)。在接下来的讨论中，我们会看到SUT和Collaborator之间是有很多不同的(在这篇文章的之前版本中，Martin Fowler分别将两者成为primary object和secondary object，即主对象和次对象)。</p>
<p>上面的测试中使用的是状态验证方式，即：我们通过验证SUT和Collaborator在exercised之后的状态来确认测试的结果，后面我们将看到，mock对象给出了一种不同的验证方式。</p>
<h2 id="Mock对象测试"><a href="#Mock对象测试" class="headerlink" title="Mock对象测试"></a>Mock对象测试</h2><p>现在我们将使用mock对象进行相同的测试，在下面的代码中我们使用jMock框架来完成mock。jMock是一个Java上的mock库，也有很多其他类似的库(EasyMock、Mockito、powermock)，但是这个库是这项技术的创始人所写的最新库(看它的官网，目前至少有5位主要贡献者，排在最前面的是Steve Freeman)，所以选择它是合适的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderInteractionTester</span> <span class="keyword">extends</span> <span class="title">MockObjectTestCase</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String TALISKER = <span class="string">"Talisker"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFillingRemovesInventoryIfInStock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//setup - data</span></span><br><span class="line">		Order order = <span class="keyword">new</span> Order(TALISKER, <span class="number">50</span>);</span><br><span class="line">		Mock warehouseMock = <span class="keyword">new</span> Mock(Warehouse.class);</span><br><span class="line">		<span class="comment">//setup - expectations</span></span><br><span class="line">		warehouseMock.expects(once()).method(<span class="string">"hasInventory"</span>)</span><br><span class="line">				.with(eq(TALISKER),eq(<span class="number">50</span>))</span><br><span class="line">				.will(returnValue(<span class="keyword">true</span>));</span><br><span class="line">		warehouseMock.expects(once()).method(<span class="string">"remove"</span>)</span><br><span class="line">				.with(eq(TALISKER), eq(<span class="number">50</span>))</span><br><span class="line">				.after(<span class="string">"hasInventory"</span>);</span><br><span class="line">		<span class="comment">//exercise</span></span><br><span class="line">		order.fill((Warehouse) warehouseMock.proxy());</span><br><span class="line">		<span class="comment">//verify</span></span><br><span class="line">		warehouseMock.verify();</span><br><span class="line">		assertTrue(order.isFilled());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFillingDoesNotRemoveIfNotEnoughInStock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Order order = <span class="keyword">new</span> Order(TALISKER, <span class="number">51</span>);    </span><br><span class="line">		Mock warehouse = mock(Warehouse.class);</span><br><span class="line">		warehouse.expects(once()).method(<span class="string">"hasInventory"</span>)</span><br><span class="line">				.withAnyArguments()</span><br><span class="line">				.will(returnValue(<span class="keyword">false</span>));</span><br><span class="line">		order.fill((Warehouse) warehouse.proxy());</span><br><span class="line">		assertFalse(order.isFilled());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们来看testFillingRemovesInventoryIfInStock：setup阶段已经有明显的不同，它分为两部分：data和expecttions（见注释），即设置数据和期待行为。data部分用于建立我们需要用到的对象，这里和传统的srtup区别并不大，区别在于我们创建的对象，SUT是一样的，但是Collaborator完全不一样——它是一个Mock对象，一个Mock的Warehouse！！天呐！！技术上来说它是一个Mock类的实例。</p>
<p>setup的第二部分，也就是expecttions部分，是用于在Mock对象上创建期待行为的，这个部分在描述了SUT在exercised阶段，哪些方法会被调用，以及返回结果是什么样子的。实际的期待描述可以比这个更复杂，前面说的比较抽象，说白一点：这里可以定制一些行为，设置一些限制，比如方法调用次数，序列，返回值等，通过这些设置，可以描述测试者对测试流程的期待，创建一个稳定的环境，也便于后期认证。</p>
<p>一旦expectations建立好，我们就可以进入exercise阶段(这个阶段干啥的？看前面)。之后我们进入verify阶段，包括两个方面：和传统测试一样验证SUT，但同时又去验证Mock对象——验证我们的调用符合我们的expections(即setup阶段的第二部分的预设)。</p>
<p>这里与普通测试的最大不同就在于我们如何验证SUT和Collaborator的交互。通过状态验证，我们使用assert来确认Warehouse的状态符合预期，但是Mock对象则是使用行为验证——验证Order是否正确调用了Warehouse，验证的是调用这个行为！我们通过在setup阶段告诉Mock对象我们期望的调用行为来在最后让Mock对象进行验证，只有Order对象是进行assert验证，即状态验证的，如果整个exercise阶段没有改变Order对象的状态，那么这里没有任何的asserts。</p>
<p>在第二个测试(testFillingDoesNotRemoveIfNotEnoughInStock)中，我们做了一些不同的事情，首先我们使用mock而不是new方法来创建Mock对象，这是一个快捷方法，使用它可以不用显示的调用verify方法，任何通过这种方式创建的对象在方法执行后都会被自动验证。</p>
<p>第二个不同点在于我们通过使用withAnyArguments方法放宽了expectations的限制。这样在Order的逻辑被改变之后，这个test就不会失败，从而减轻了维护test的成本。实际上这里可以省略这个方法的调用，因为是默认的。</p>
<blockquote>
<p>【PS】Martin Fowler在文章中还举了一个EasyMock的例子，但是鉴于例子本身和我们理解本文核心阐述的概念不太相关，而我这么晚了也懒得翻译，因此省略。</p>
</blockquote>
<h2 id="Mock和Stub之间的区别"><a href="#Mock和Stub之间的区别" class="headerlink" title="Mock和Stub之间的区别"></a>Mock和Stub之间的区别</h2><p>当这两个概念刚刚出现的时候，很多人都会对它们感到迷惑，后来才逐渐了解到两者之间的区别。想要彻底理解什么是mock，理解mock和其他test double(一个术语，后面解释)的区别是很重要的。</p>
<p>当我们做上面那样的一个测试的时候，我们每次只能集中关注其中一个元素组件(unit)，这就是我们常说的单元测试。而问题在于在我们测试这单一组件的时候，我们经常需要其他的组件进行辅助，就像测试Order类需要Warehouse类一样。</p>
<p>在上面提到的两种测试风格中，第一种风格使用了一个真的Warehouse对象，第二种风格则使用了一个mock的Warehouse对象。通过Mock对象是来进行测试是不使用真实对象进行测试的一种方法，实际上还有很多别的方式可以替代真实对象。</p>
<p>用于描述这种情况的词汇很快变得混乱起来——各种词汇都被用到了：stub、mock、fake、dummy。在这里，Martin Fowler使用了Gerard Meszaros书中的词汇定义。</p>
<p>Meszaros使用 <strong>Test Double</strong> 来表示所有的替代真实对象进行测试的对象，这个名词来自电影中的Stunt Double(他的目的就是取一个没有被广泛使用的名字)。Meszaros随后又定义了四类Double:</p>
<ol>
<li><strong>Dummy对象</strong> 是那些被到处传递，但是从不被使用的对象。通常来说只是用来填充参数列表；</li>
<li><strong>Fake对象</strong> 有实际实现，但是经常会采用一些简单的方式，从而使得它们不能在最终的产品中使用；</li>
<li><strong>Stub对象</strong> 封装了一些测试中需要用到的调用响应数据。Stub也有可能会记录一些调用信息，比如一个email gate stub就会记录它发送的信息以及发送信息的次数；</li>
<li><strong>Mock对象</strong> 是提前编写有详细的关于收到调用方法的expectations的对象，好拗口，还是来句人话：这个对象用于描述自己期望得到什么样子的方法调用，还不了解的话，看看前面JMock示例中的Warehouse Mock对象，它就有expectations描述。</li>
</ol>
<p>在这几类对象中，只有mock对象需要行为验证，其余的几类只能做状态验证。Mock对象通常在exercise阶段也会扮演一些别的对象的角色，因为它需要是的SUT相信它自己正在和一个真正的Collaborator打交道——但是Mock对象在setup阶段和verify阶段和其余对象是绝对不同的。</p>
<p>为了更好的理解test double，我们需要延伸一下我们的例子。很多人只有在真实的对象用起来不方便的时候才会选择使用test double，一个更加经典的需求是：我们希望在Order不能完成的时候发一封邮件。这个时候我们在测试阶段并不希望真正的发送一封邮件出去，所以在这个时候我们希望为邮件系统创建一个test double——一个我们可以操控的邮件系统。</p>
<p>这里，我们可以看到mock和stub的区别，如果我们为邮件行为创建一个测试，我们可以使用如下这个简单的stub来实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MailService</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span> <span class="params">(Message msg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailServiceStub</span> <span class="keyword">implements</span> <span class="title">MailService</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> List&lt;Message&gt; messages = <span class="keyword">new</span> ArrayList&lt;Message&gt;();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span> <span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">		messages.add(msg);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberSent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> messages.size();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们可以在Stub上如下使用状态验证：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderStateTester</span>...</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">void</span> <span class="title">testOrderSendsMailIfUnfilled</span>() </span>&#123;</span><br><span class="line">    Order order = <span class="keyword">new</span> Order(TALISKER, <span class="number">51</span>);</span><br><span class="line">    MailServiceStub mailer = <span class="keyword">new</span> MailServiceStub();</span><br><span class="line">    order.setMailer(mailer);</span><br><span class="line">    order.fill(warehouse);</span><br><span class="line">    assertEquals(<span class="number">1</span>, mailer.numberSent());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然啦，这只是一个很简单的例子——只测试了一个消息被发送了，而没有测试邮件被发送到了正确的人，内容正确与否，但是这并不妨碍我们讲述清楚我们的关注点。</p>
<p>使用Mock的话，测试看上去会很不一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderInteractionTester</span>...</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">void</span> <span class="title">testOrderSendsMailIfUnfilled</span>() </span>&#123;</span><br><span class="line">    Order order = <span class="keyword">new</span> Order(TALISKER, <span class="number">51</span>);</span><br><span class="line">    Mock warehouse = mock(Warehouse.class);</span><br><span class="line">    Mock mailer = mock(MailService.class);</span><br><span class="line">    order.setMailer((MailService) mailer.proxy());</span><br><span class="line"></span><br><span class="line">    mailer.expects(once()).method(<span class="string">"send"</span>);</span><br><span class="line">    warehouse.expects(once()).method(<span class="string">"hasInventory"</span>)</span><br><span class="line">      .withAnyArguments()</span><br><span class="line">      .will(returnValue(<span class="keyword">false</span>));</span><br><span class="line"></span><br><span class="line">    order.fill((Warehouse) warehouse.proxy());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在两种情况下，我们都使用了一个test double来代替真正的mail服务——前者使用的是Stub，后者使用的是Mock，这里可以看出区别——前者进行的是状态验证，后者进行的是行为验证！</p>
<p>Mock对象总是使用行为验证，Stb也可以，Meszaros将使用行为验证的Stub称为Test Spy，区别就在于test double如何运行和验证。</p>
<h2 id="Classical和Mockist测试"><a href="#Classical和Mockist测试" class="headerlink" title="Classical和Mockist测试"></a>Classical和Mockist测试</h2><p>现在我们来看一下第二个不同点：classical和Mockist两种风格，区别点在于 <strong>什么时候使用Mock或者别的double</strong> 。</p>
<p>classical测试驱动开发者主张尽可能的使用真实的对象，只有在使用真是对象遇到问题的时候才会使用double。所以classical测试驱动开发者会使用一个真实的Warehouse对象和一个double的Mail服务对象。</p>
<p>Mockist测试驱动开发者则相反，他们总是会使用mock对象，也就是说，他们会使用一个Mock的Warehouse。Mockist的一个重要分支是BDD(Behavior Driven Development)，这里不赘述。</p>
<h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>在这篇文章中，阐述了两种区别：状态验证和行为验证，Classical和Mockist。那么到底应该怎么选择呢？首先我们来说一下状态验证和行为验证的选择。</p>
<p>首先要考虑的是上下文环境：我们面对的是一个很好创建的协作关系，比如Order和Warehouse，还是一个复杂难用的，比如Order和Mail服务？</p>
<p>如果是一个简单的，那么选择也是简单的，Classical测试者不会使用mock、stub或者其他任何的double，我直接使用一个真实的Object并进行状态验证；而Mockist也可以选择使用mock对象并进行行为验证。这个可以参考前面的例子，因为成本很小，选择什么都可以，因此没有太多需要考虑的。</p>
<p>如果是一个复杂的协作关系，name对于Mockist来说也没什么需要考虑的——使用mock和行为验证。但对于Classical来说，就需要做出一些选择了，但问题不大，通常来说他们会根据实际情况，选择最方面快捷的方式。</p>
<p>所以结论是：状态验证和行为验证并不是一个大问题，真正的问题在于Classical和Mockist之间的选择，也就是什么时候使用Mock对象的问题。但是状态和行为验证确实会影响到这个讨论，后面会集中阐述。Martin Fowler在这里抛出了另外一个情况：假设测试者遇到了一个非常难以进行状态验证的情况，即使他面对的是一个简单的写作关系，极佳的例子就是Cache，因为你不能从他的状态来确认Cache是否命中或者不命中，这个时候行为验证反而是一个非常明智的选择。Martin Fowler认为还有很多别的类似情况。</p>
<p>在我们进行决策讨论之前，我们先来讨论一下我们做出决策的时候需要考虑的因素。</p>
<h3 id="Driving-TDD"><a href="#Driving-TDD" class="headerlink" title="Driving TDD"></a>Driving TDD</h3><p>Mock对象诞生于XP社区，而XP的一个重要原则就是TDD——系统的迭代进化是由测试驱动进行的。因此mockists强调mockists对于设计的作用是很正常的，尤其是他们宣传一种称作需求驱动的开发方式，在这种方式下，开发者首先通过写测试来开发一个user story，理清楚SUT、对collaborators的expectations以及SUT和collaborator之间的交互关系，这样就可以有效地设计出SUT的外围接口。</p>
<p>一旦你的第一个测试运行起来，mock中携带的expectations就为下一步的开发和测试提供了一个出发点。开发者可以将每一个expectations转换成collaborator上的test，这样循环迭代，逐步开发建立SUT。这种风格也被称为outside-in，描述的非常到位。在分层系统中这种方式工作的很好，首先你可以开发UI，底层使用Mock实现，然后你可以为更底层写测试，逐步往下延伸，这是一个高度结构化的开发方式，很多人相信这对于OO和TDD的初学者都很有裨益。</p>
<p>经典的TDD给出的指导略有不同。你可以使用相同的开发步骤，但是是使用的stub，而不是mock。这样当你需要collaborator的协助的时候，你只需要将测试的需要的返回结果硬编码进去就好了，当你编码到这一段的时候，你可以将结果替换成实际运行的逻辑代码。</p>
<p>经典的TDD还可以做别的事情，一个流行的形式就是middle-out。在这种风格下面你需要考虑你开发的功能以及这个功能所需要的domain(不知道怎么翻译更加合适)，你可以首先获取到一个满足你需求的domain对象，一旦它可以工作了，你就可以在此之上进行开发。使用这种风格不需要你造假任何东西。因为一开始我们可以将精力集中在domain模型上，可以防止domain逻辑泄露到UI更上层，因此很多人喜欢这种风格。（看上去像是一种变种）</p>
<p>有很多的想法都是想要一层层构建应用，并且不是直到另外一层完成才开发下一层。Classicist和Mockist都有着敏捷背景并且青睐细粒度的迭代，因此他们都不会选择一层层开发，而是一个功能一个功能的去开发。</p>
<blockquote>
<p>【有话说】不使用TDD的团队是否就不需要考虑这个了？不过通过Stub或者Mock的方式实现快速迭代开发是一个不错的思路，可以短时间内让精力集中在某一个点上。</p>
</blockquote>
<h3 id="Fixture-Setup"><a href="#Fixture-Setup" class="headerlink" title="Fixture Setup"></a>Fixture Setup</h3><p>使用classic TDD，测试的时候不但需要创建SUT，还需要创建所有相关的collaborator，例子中我们只创建了很少几个对象，但是实际的测试中，我们会创建很多的collaborator，通常来说这些对象会随着一个test的执行被创建和销毁。</p>
<p>Mockist测试则不一样，它只需要创建SUT和它的直接关联对象，这能减少创建一些复杂对象带来的工作量。</p>
<p>实践中classic测试者会尽量复用复杂的collaborator，最简单的方式就是将这类collaborator放到xUnit的setup方法中，更为复杂的collaborator则可能需要被多个test类使用，所以在这种特殊情况下，你需要创建一个collaborator生成类。Martin Fowler将这中生成类称为Object Mothers。使用Object Mothers在大型的classic测试中非常重要，但是Object Mothers为整个测试添加了额外的需要维护的代码，任何的改动都会在整个测试中造成严重的影响。下面Martin Fowler所说的省略。</p>
<p>两种风格之间时常有所争辩。Mockists觉得创建真是的collaborator太过复杂，但是classicists认为这些collaborator都可以复用，但是每次测试都需要创建Mock对象。</p>
<blockquote>
<p>【有话说】看实际情况吧，对一个较完备的系统做测试，应该是classic方式比较快速，正如Martin Fowler所说，大部分情况下创建实际对象都是cheap的。但是不排除需要创建复杂对象的情况。</p>
</blockquote>
<h3 id="Test-Isolation"><a href="#Test-Isolation" class="headerlink" title="Test Isolation"></a>Test Isolation</h3><p>在Mockists测试情况下，如果在系统中引入了一个bug，通常只会导致包含这个Bug的SUT所在的test执行失败。但是如果使用classic方式，则会导致所有使用到这个bug对象的测试失败。</p>
<p>Mockists认为这种情况有很大的问题：会导致找到根本的错误需要很多的时间。但是classicists则不这么认为：通常来说，定位问题的发生点是比较简单的事情，而且如果经常测试的话，你是知道什么改动引起这种问题的（PS：现代的IDE以及版本控制工具使得这个更加简单）。</p>
<p>这里一个可能很重要的点在于测试的粒度。classic测试需要一次exercise很多个真实对象，经常会出现一个单独的primary test用于测试很多歌对象，而不是一个。如果这个test包含着很多个对象，找到bug的原因就比较困难了——原因就是测试太粗粒度了。</p>
<p>mockist测试则比较不容易出现这个问题，因为除了SUT，其余的对象都是Mock的。这里比较好的做法是：保证为了一个类创建细粒度的测试。但是比较大型集中的测试也是有存在意义的，但是只限于测试很少的一些对象。而且一旦你发现因为粒度太粗，导致测试的时候很难定位问题，你就应该创建更细粒度的测试区追踪问题。</p>
<p>其实经典的xUnit测试并不只是简单的单元测试，同时也是一个最小集成测试。因此很多人都期望单元测试可以发现一些单独对某个类进行测试时发现不了的问题，尤其是类之间交互时的问题。Mockist测试就缺乏这方面的能力，同时你还得关注你的expectations是否有错误，从而导致一些实际存在的错误漏掉。</p>
<p>不管你使用什么风格的测试，你必须综合使用粗粒度的验收测试，Martin Fowler遇到过一些因为验收测试太晚而追悔莫及的情况。</p>
<blockquote>
<p>【有话说】我倾向于classicists方式，为了创建细粒度的测试，感觉需要花费的精力是在太大，我的想法是真实对象 &gt; Stub对象 &gt; Mock对象。</p>
</blockquote>
<p>###Coupling Tests to Implementations<br>当使用mockist测试的时候，我们测试的是SUT是否和它的collaborator正常交互。classic则只关心最终的状态，而不关系状态是如何产生的。因此mockist测试和方法的实现耦合度就更高——更改collaborator的调用通常会导致mockist测试跑不过。</p>
<p>这种耦合引起了一些关注。最重要就是TDD。使用mockist是的你需要考虑行为的实现——实际上mockist测试者认为这是一个优点。而Classicists认为在测试的时候，只去考虑外部接口是很重要的，而具体的实现应该放在测试之后再去考虑。</p>
<p>这种情况在使用mock工具的时候变得更加糟糕，因为mock工具通常需要你很详细的描述方法的调用和参数，即使与特定的这个test无关。jMock工具的一个目标就是使得在描述expectation的时候变得更加灵活，使得它(expectation)在不关心的地方可以描述的更加宽泛。</p>
<blockquote>
<p>【有话说】论耦合的话两者都有，只是如Martin Fowler所说，mockist不仅需要考虑一些具体的实现（方法调用），还需要考虑返回值，而Classicists只耦合了最终的状态，后者相对而言更加轻便。</p>
</blockquote>
<h3 id="Design-Style"><a href="#Design-Style" class="headerlink" title="Design Style"></a>Design Style</h3><p>忽略。</p>
<blockquote>
<p>【有话说】忽略了还有话说？有。实际上这一小节是Martin Fowler最关注的部分，即对测试方式的选择会如何影响你的代码设计。但我认为这需要对这两种理念有足够的了解和实践经历才会有深刻的理解，从而去思考Martin Fowler的话。而我本身不具备这样的条件。</p>
</blockquote>
<h2 id="到底该用哪一个？"><a href="#到底该用哪一个？" class="headerlink" title="到底该用哪一个？"></a>到底该用哪一个？</h2><p>这个问题比较难回答，Martin Fowler是一个classic测试者，他认为目前没有任何理由改变成一个mockist测试者。他在观察到mockist编码者之后，这种想法就更加坚定了，因为在写expectation的时候需要殚精竭虑去思考实现和调用方式显得非常不自然。</p>
<p>同时Martin Fowler也说道：在很深入的使用一项技术之前，评价它很困难。所以如果读者对Mockist有兴趣，可以尝试一把。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>xUnit测试框架和TDD越来越火热，人们通常会不求甚解的去来哦接使用一个框架，而不知道其背后设计的理念和含义。不管你一开始学习到什么框架，从不同的角度去理解它和别的框架的不同都很重要——了解背后指导它们的理念非常重要！这篇文章的目的就是指出这些理念的区别以及如何在它们之间做出权衡。</p>
<h2 id="我言"><a href="#我言" class="headerlink" title="我言"></a>我言</h2><p>当初也是因为要对一个Android项目做单元测试，因此开始看一些单元测试方面的知识，从Google官网上看到了对Mockito的引用推荐，从而看到其官网上的示例，进而对expectations产生了疑问——我之前并不知道还有行为验证这种东西，因此对我而言行为验证的那段代码非常难以理解，在翻阅资料的时候无意中看到了Martin Fowler的这篇文章，遂译之。</p>
<p>读完这篇文章，最大的收获如下：</p>
<ol>
<li>理解了行为验证 &amp; 状态验证的区别；</li>
<li>了解了classic和mockist两种测试风格的区别；</li>
<li>了解了在这些区别之间做出决策需要考虑的一些因素；</li>
</ol>
<p>我对于决策因素的一些考虑也已经通过【有话说】写在下面了。后期我的单元测试应该会侧重于【状态验证+真实对象+Stub】的方式，诚如Martin Fowler所言，mockist的方式对我而言需要考虑维护的东西太多。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android单元测试(一)——测试分类和基础]]></title>
      <url>http://www.timebridge.space/2015/11/17/Android-unit-test/</url>
      <content type="html"><![CDATA[<p>翻译总结一篇讲述Android单元测试的文章，比官网的讲述更具条理。同时描述一些在实践中遇到的坑。</p>
<p><strong>官网文档入口</strong>  <a href="http://developer.android.com/intl/zh-cn/training/testing.html" target="_blank" rel="noopener">Best Practices for Testing</a><br><strong>英文原文地址</strong>  <a href="http://www.vogella.com/tutorials/AndroidTesting/article.html" target="_blank" rel="noopener">Developing Android unit and instrumentation tests</a></p>
<blockquote>
<p>【建议】读者最好先大致看一下官网文档，理清楚相关概念，然后再比对英文原文和本文的翻译，边阅读边实践。</p>
</blockquote>
<h2 id="为什么Android应用需要测试？"><a href="#为什么Android应用需要测试？" class="headerlink" title="为什么Android应用需要测试？"></a>为什么Android应用需要测试？</h2><h3 id="为什么测试Android应用尤其重要？"><a href="#为什么测试Android应用尤其重要？" class="headerlink" title="为什么测试Android应用尤其重要？"></a>为什么测试Android应用尤其重要？</h3><p>android应用在一种资源（内存，CPU，电量等）有限的情况下运行，并且运行情况依赖于外部因素，比如是否联网，使用情况等，因此测试优化android应用非常重要，对应用进行适当的测试有助于提高应用质量，增强可维护性。<a id="more"></a></p>
<h3 id="Android测试策略"><a href="#Android测试策略" class="headerlink" title="Android测试策略"></a>Android测试策略</h3><p>在所有不同配置的设备上测试一个应用是不大可能的，一般来说只能在典型的设备上进行测试——测试的时候应该选取一个尽可能低配置的设备和尽可能高配置的设备进行测试，所谓配置，是诸如屏幕分辨率，像素密度等。</p>
<h3 id="Android的测试支持"><a href="#Android的测试支持" class="headerlink" title="Android的测试支持"></a>Android的测试支持</h3><p>2015年用于Android应用的测试工具和框架得到了极大的提升。Android的整个测试支持系统被更新到基于JUnit4，单元测试代码既可以运行在JVM上，也可以运行在Android设备上。同时，Google引入了新的UI测试框架——Espresso，使得测试Android应用的UI变得更加容易。</p>
<h2 id="前置要求"><a href="#前置要求" class="headerlink" title="前置要求"></a>前置要求</h2><p>下面的描述基于如下假设：</p>
<ol>
<li>读者已经知道如何创建一个Android应用，读者可以阅读<a href="http://www.vogella.com/tutorials/Android/article.html" target="_blank" rel="noopener">Android Tutorial</a>获取更详细的消息;</li>
<li>读者了解Android的编译系统——Gradle，读者可以阅读<a href="http://www.vogella.com/tutorials/AndroidBuild/article.html" target="_blank" rel="noopener">Building Android applications with Gradle Tutorial</a>进行基本了解;</li>
<li>对JUnit测试框架有一定的了解，这个网上资料很多，推荐一篇<a href="http://thihy.iteye.com/blog/1771826" target="_blank" rel="noopener">Java单元测试(Junit+Mock+代码覆盖率)</a></li>
</ol>
<h2 id="Android自动化测试"><a href="#Android自动化测试" class="headerlink" title="Android自动化测试"></a>Android自动化测试</h2><h3 id="测试什么？"><a href="#测试什么？" class="headerlink" title="测试什么？"></a>测试什么？</h3><p>一般来说，我们测试的重点是应用的业务逻辑，以下的测试比例是比较合理的：</p>
<ol>
<li>70%~80%的单元测试用来保证底层代码的稳定性；</li>
<li>20%~30%的功能测试用来保证应用的确可以正常运行；</li>
<li>少量的功能测试用于测试你的应用和别的应用的交互——如果有的话；</li>
</ol>
<h3 id="测试前置条件"><a href="#测试前置条件" class="headerlink" title="测试前置条件"></a>测试前置条件</h3><p>在Android测试中为所有的测试声明一个 <strong>testPreconditions()</strong> 方法是一个很好的做法，如果这个方法执行失败了，你可以立即知道其他测试所依赖的前置条件不满足（换言之：通过这个方法保证为后续的测试提供一个稳定的测试环境）。</p>
<h3 id="测试单个App或者多个App"><a href="#测试单个App或者多个App" class="headerlink" title="测试单个App或者多个App"></a>测试单个App或者多个App</h3><p>测试另外一个重要考量标准就是你是单独测试你自己的应用还是测试你的应用和别的应用的集成（即两者的交互）。如果你只是测试你自己的应用，那么你可以使用一些需要了解应用内部信息的测试框架（比如viewId）——这涉及到测试框架的选择。</p>
<h2 id="Android普通单元和Instrumentation单元测试"><a href="#Android普通单元和Instrumentation单元测试" class="headerlink" title="Android普通单元和Instrumentation单元测试"></a>Android普通单元和Instrumentation单元测试</h2><h3 id="Android单元测试种类"><a href="#Android单元测试种类" class="headerlink" title="Android单元测试种类"></a>Android单元测试种类</h3><p>Android单元测试是基于JUnit的，可以分为两类：</p>
<ol>
<li>本地单元测试——测试运行在JVM上；</li>
<li>Instrumentation单元测试——测试需要运行在Android系统上；</li>
</ol>
<p>测试的时候应该尽可能使用本地单元测试，因为本地单元测试相较而言更快，Instrumentation单元测试需要部署应用并且在Android设备上运行测试。</p>
<h3 id="本地单元测试"><a href="#本地单元测试" class="headerlink" title="本地单元测试"></a>本地单元测试</h3><p>Android Gradle支持在JVM上运行Android单元测试，为了实现这个目标，Gradle创建了一个特殊版本的android.jar（也成为Android mockable jar）来提供单元测试需要的各种属性、方法、类。调用这个jar包中的任何函数都会导致异常。</p>
<p>因此，如果你的类没有调用任何的Android API或者只是有很简单的依赖，你可以毫无限制的使用JUnit测试框架（或者别的任何Java单元测试框架）。单元测试代码中任何对Android的依赖都应该被替换掉，可以使用诸如Mockito这样的Mock框架。</p>
<p>在JVM上运行测试case的好处就是速度——比起在Android机器上运行要快很多很多。</p>
<h3 id="使用Instrumented-test测试使用了Android-API的类"><a href="#使用Instrumented-test测试使用了Android-API的类" class="headerlink" title="使用Instrumented test测试使用了Android API的类"></a>使用Instrumented test测试使用了Android API的类</h3><p>如果你需要测试使用了Android API的代码，你需要在Android设备上运行测试代码（因为Android工具上mock出来的android.jar并不执行真正的Android代码，而只是简单的抛出异常），不幸的是，这使得测试的执行漫长了许多。</p>
<h2 id="Android的项目结构和测试文件夹的创建"><a href="#Android的项目结构和测试文件夹的创建" class="headerlink" title="Android的项目结构和测试文件夹的创建"></a>Android的项目结构和测试文件夹的创建</h2><h3 id="Android的测试项目结构"><a href="#Android的测试项目结构" class="headerlink" title="Android的测试项目结构"></a>Android的测试项目结构</h3><p>比较推荐的方式是按照约定组织source代码和测试代码（Gradle有自己的约定），你的应用项目结构应该按照下面的文件夹结构进行组织:</p>
<ul>
<li>app/src/main/java - 放置项目的源码</li>
<li>app/src/test/java - 放置运行在JVM上的单元测试代码</li>
<li>app/src/androidTest/java - 放置需要运行在Android设备上的测试代码</li>
</ul>
<p>如果你按照这个约定来，那么Android的编译系统（Gradle）会自动将对应的测试代码运行在JVM和Android设备上。</p>
<p>Gradle上可以配置这几个文件夹，读者在不熟悉Gradle的情况下并且没有特殊需求的情况下，不建议修改这个约定。</p>
<h2 id="编写本地单元测试并且运行"><a href="#编写本地单元测试并且运行" class="headerlink" title="编写本地单元测试并且运行"></a>编写本地单元测试并且运行</h2><p>先上图，让读者有个大致的了解:</p>
<p><img src="http://7xktd8.com1.z0.glb.clouddn.com/Android本地单元测试.png" alt="Android本地单元测试项目结构"></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在Android上我们使用术语单元测试来表示那些运行在本地JVM上的测试代码。单元测试应当被用来验证一个Activity的状态以及它与其余组件的交互，前提是在独立的环境下（与系统其余部分没有联系），它一般用来测试代码的一小部分，比如一个方法，一个类或者一个组件，且不依赖系统或者网络资源等外部环境。举个栗子，假设在Activity上有一个button是用来启动另外一个Activity的，单元测试应该被用来测试启动Activity对应的intent是否正确，而不是那个Activity是否被启动。</p>
<p>如前面所述，单元测试的执行基于一个被修改的android.jar包，所有的final修饰符都被移除掉了，这使得使用mock库成为现实——如果你需要依赖Android平台，你就使用mock的框架来代替那些调用。</p>
<blockquote>
<p>实践中发现这一点极大的限制了本地单测的应用。我们有一个业务使用了SparseArray，导致逻辑完全不可侧，因为Mock出来的对象完全不具备SparseArray功能。</p>
</blockquote>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>开发者官网上建议在build.gradle中添加如下依赖:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    // Unit testing dependencies</span><br><span class="line">    testCompile 'junit:junit:4.12'</span><br><span class="line">    // Set this dependency if you want to use Mockito</span><br><span class="line">    testCompile 'org.mockito:mockito-core:1.10.19'</span><br><span class="line">    // Set this dependency if you want to use Hamcrest matching</span><br><span class="line">    testCompile 'org.hamcrest:hamcrest-library:1.1'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个包的作用注释中都已经标出。注意！！！这里千万不要写成compile，然后去File——&gt;Project Structure——&gt;选中Module——&gt;Dependencies里面，再将这三个库的Scope改为Test Compile，实践中，这样操作这里会变成androidTestCompile。总之，请确保这里是testCompile。</p>
<h3 id="代码位置"><a href="#代码位置" class="headerlink" title="代码位置"></a>代码位置</h3><p>我的Android Studio版本是1.3.2，新建的Android项目下面自带androidTest目录，但是并没有test目录。按照前面所讲述的目录结构约定，我们将项目视图切换到Project下面，在src目录下面新建一个test目录。读者注意上图中的1，2，3三个部分，另外读者应该点击5，调出”Build Variants”视图，然后将Test Artifact设置为Unit Test。</p>
<h3 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h3><p>这里给出一个实例，读者可以直接Copy测试一把:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_First</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String test = <span class="string">"aa"</span>;</span><br><span class="line">        assertEquals(test, <span class="string">"aa"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_Second</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String test = <span class="string">"aa"</span>;</span><br><span class="line">        assertEquals(test, <span class="string">"aa"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_Third</span><span class="params">()</span></span>&#123;</span><br><span class="line">        assertEquals(NumberUtils.calculateSum(<span class="number">100</span>), <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写完类之后，请打开Run——&gt;Edit Configurations视图，然后确保整个视图是如下显示的:</p>
<p><img src="http://7xktd8.com1.z0.glb.clouddn.com/Android单元测试配置.png" alt="Android单元测试配置"></p>
<p>之所以要注意这里，是因为我第一次配置的时候，不知道因为什么原因，写了一个单元测试case，却配置成了Instrument测试case，导致每次运行case的时候都会要求启动Android设备，然后报下面的错误:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Running tests</span><br><span class="line">Test running startedTest running failed: </span><br><span class="line">Instrumentation run failed due to &apos;java.lang.RuntimeException&apos;</span><br><span class="line">Empty test suite.</span><br></pre></td></tr></table></figure>
<p>这个问题困扰了我很久。因此读者一定要注意。</p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>最后是运行，我们只需要右击你需要运行的测试Class，选择”Run FirstTest”即可运行，然后在图中7的部分可以看到测试执行的结果。6圈出的按钮可以点击，查看执行的全部case或者执行失败的case。</p>
<p>测试报告在<code>app/build/reports/tests/debug/</code>下面。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>在写本地单测的时候，会遇到<code>android.jar</code>某个方法没有被Mock的情况，此时可以通过如下配置:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  // ...</span><br><span class="line">  testOptions &#123; </span><br><span class="line">    unitTests.returnDefaultValues = true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让Gradle系统为该方法返回默认值。</p>
<h2 id="Instrumentation——Android底层测试API"><a href="#Instrumentation——Android底层测试API" class="headerlink" title="Instrumentation——Android底层测试API"></a>Instrumentation——Android底层测试API</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>Android测试API提供了一些深入Android组件和应用本身声明周期的钩子函数。这些钩子函数称为Instrumentation API——它们允许你控制生命周期和用户交互事件。</p>
<p>在正常情况下，Android应用只能对真正的生命周期和用户交互事件做出反应，比如：如果Android创建了一个Activity，那么onCreate()方法就会被调用，或者用户点击了一个按钮，一个按键，那么相应的监听方法就会被调用。但是通过Instrumentation，你可以在测试代码中控制这些事件。</p>
<p>只有基于Instrumentation的测试代码才能在测试环境下向你的应用发送事件。举个栗子：你可以在测试中调用getActivity()方法来唤起一个Activity并获得一个Activity的实例，然后你可以调用finish()方法结束它，然后再调用getActivity()，这样你就可以测试一个Activity能否正确恢复状态。</p>
<h3 id="Android系统如何执行测试"><a href="#Android系统如何执行测试" class="headerlink" title="Android系统如何执行测试"></a>Android系统如何执行测试</h3><p>InstrumentationTestRunner是Android单元测试的基础执行器（Runner，这个概念来自JUnit，前面推荐的文章中有提及），这个测试执行器会加载所有的测试方法，通过Instrumentation API来和Android系统交互。</p>
<p>如果你为Android应用启动了一个测试，Android系统会立刻终止被测试应用的进程，然后启动一个新的实例。它不会启动应用，这是测试方法的职责——测试方法控制应用组件的整个生命周期。</p>
<p>测试执行器在初始化界面的过程中，也会调用Application和Activity的onCreate()方法。（可以认为Instrumentation API提供了一个功能让测试代码扮演系统的角色）。</p>
<h3 id="Instrumentation框架的使用"><a href="#Instrumentation框架的使用" class="headerlink" title="Instrumentation框架的使用"></a>Instrumentation框架的使用</h3><p>有了运行在JVM上的Android单元测试和类似Espresso这样流行的UI测试框架，开发者很少需要直接调用Instrumentation API。</p>
<h2 id="Instrumented-unit-testing"><a href="#Instrumented-unit-testing" class="headerlink" title="Instrumented unit testing"></a>Instrumented unit testing</h2><h3 id="在Android上使用Instrumented-unit-testing"><a href="#在Android上使用Instrumented-unit-testing" class="headerlink" title="在Android上使用Instrumented unit testing"></a>在Android上使用Instrumented unit testing</h3><p>Instrumented unit testing是运行在Android真实设备或者模拟器上的测试代码，而不是JVM上。这些测试代码可以获取真实设备的资源，以便于测试那些不能被mock框架简单mock出来的功能模块。</p>
<p><a href="https://github.com/mockito/mockito" target="_blank" rel="noopener">Mockito框架</a>可以被用来模拟部分的Android系统环境（读者可以查看它的release note，1.9.5版本即支持这个功能），这也是google官方推荐的mock工具。</p>
<h3 id="Instrumentation测试代码的位置"><a href="#Instrumentation测试代码的位置" class="headerlink" title="Instrumentation测试代码的位置"></a>Instrumentation测试代码的位置</h3><p>如前面所述，Instrumentation测试代码应该放置在app/src/androidTest/java目录下面。</p>
<h3 id="在Gradle中配置依赖"><a href="#在Gradle中配置依赖" class="headerlink" title="在Gradle中配置依赖"></a>在Gradle中配置依赖</h3><p>和本地单元测试一样，使用Instrumentation测试也必须添加一些依赖，同时还必须添加默认的Android Instrumentation测试执行器配置:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">defaultConfig &#123;</span><br><span class="line">       ..... more stuff</span><br><span class="line">        testInstrumentationRunner <span class="string">"android.support.test.runner.AndroidJUnitRunner"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    <span class="comment">// Unit testing dependencies</span></span><br><span class="line">    androidTestCompile <span class="string">'junit:junit:4.12'</span></span><br><span class="line">    <span class="comment">// Set this dependency if you want to use the Hamcrest matcher library</span></span><br><span class="line">    androidTestCompile <span class="string">'org.hamcrest:hamcrest-library:1.3'</span></span><br><span class="line">    <span class="comment">// more stuff, e.g., Mockito</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="相关的类"><a href="#相关的类" class="headerlink" title="相关的类"></a>相关的类</h3><p>先来看Context测试类的重要基础类——AndroidTestCase。这个类最终的功能就是提供了getContext()功能，在实际测试中，它的返回值是可以当做测试App对象的Context使用的。这个类的子类如下:</p>
<ol>
<li>ApplicationTestCase;</li>
<li>ProviderTestCase;</li>
<li>ServiceTestCase</li>
<li>CustomTabsIntentCase;</li>
<li>LoaderTestCase;</li>
</ol>
<p>很容易发现，四大组件有两个组件在这里有对应的测试Case类，那么最重要的Activity呢？实际上确实有ActivityTestCase类，但这个类不属于AndroidTestCase继承树，它的父类是InstrumentationTestCase，直接子类是:</p>
<ol>
<li>ActivityInstrumentationTestCase</li>
<li>ActivityInstrumentationTestCase2</li>
<li>ActivityUnitTestCase</li>
</ol>
<p>其中第一个类已经被废弃，现在使用的都是ActivityInstrumentationTestCase2这个类。后面两个类就是<a href="http://developer.android.com/intl/zh-cn/training/activity-testing/preparing-activity-testing.html" target="_blank" rel="noopener">官网教程</a>的讲述重点。</p>
<p>以上所有的类都是junit.framework.TestCase的子类，继承关系如下：</p>
<p><img src="http://7xktd8.com1.z0.glb.clouddn.com/单测类继承关系.png" alt="Android单元测试配置"></p>
<h4 id="ActivityUnitTestCase和ActivityInstrumentationTestCase2的区别"><a href="#ActivityUnitTestCase和ActivityInstrumentationTestCase2的区别" class="headerlink" title="ActivityUnitTestCase和ActivityInstrumentationTestCase2的区别"></a>ActivityUnitTestCase和ActivityInstrumentationTestCase2的区别</h4><p>两者都能进行简单的UI测试，比如UI元素的布局、显示内容和点击动作，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MediumTest</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClickMeButton_clickButtonAndExpectInfoText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String expectedInfoText = mClickFunActivity.getString(R.string.info_text);</span><br><span class="line">    TouchUtils.clickView(<span class="keyword">this</span>, mClickMeButton);</span><br><span class="line">    assertTrue(View.VISIBLE == mInfoTextView.getVisibility());</span><br><span class="line">    assertEquals(expectedInfoText, mInfoTextView.getText());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是两者的侧重点不一样。</p>
<p>ActivityUnitTestCase创建的Activity会尽量少的和系统有联系，所有的依赖都可以通过Mock或者别的方式注入进去，你的测试对象Activity会在真实的系统上运行，并且不会和别的Activity产生交互。以下方法都不应该被调用，大部分都会抛出异常:</p>
<ol>
<li>createPendingResult(int, Intent, int)</li>
<li>startActivityIfNeeded(Intent, int)</li>
<li>startActivityFromChild(Activity, Intent, int)</li>
<li>startNextMatchingActivity(Intent)</li>
<li>getCallingActivity()</li>
<li>getCallingPackage()</li>
<li>createPendingResult(int, Intent, int)</li>
<li>getTaskId()</li>
<li>isTaskRoot()</li>
<li>moveTaskToBack(boolean)</li>
</ol>
<p>这些方法都是和环境进行交互的，需要完整的上下文。而</p>
<ol>
<li>startActivity</li>
<li>startActivityForResult</li>
</ol>
<p>这两个调用是没有效果的，可以使用getStartedActivityIntent()和getStartedActivityRequest()来获取调用参数。</p>
<ol>
<li>finish</li>
<li>finishActivity</li>
<li>finishFromChild</li>
</ol>
<p>这些调用也不会有任何的效果，同样有方法isFinishCalled()和getFinishedActivityRequest()来获取调用参数。</p>
<p>通过以上方式，一个ActivityUnitTestCase可以测试一些和其余组件的“Mock交互”。</p>
<p>但如果你需要进行功能测试，则建议使用ActivityInstrumentationTestCase2。ActivityInstrumentationTestCase2也是建立在真实的系统基础上的，调用的是InstrumentationTestCase.launchActivity()方法，你可以直接操纵Activity。单元测试一般不太适合用来测试复杂的UI交互动作，而ActivityInstrumentationTestCase2则非常适合，比如调用键盘向EditText中输入文字，真实的发起一个Activity并检测数据的传输。具体可以见官方案例：<a href="http://developer.android.com/intl/zh-cn/training/activity-testing/activity-functional-testing.html" target="_blank" rel="noopener">Creating Functional Tests</a>。大名鼎鼎的robotium就是基于这个类来实现的。</p>
<h4 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h4><ol>
<li>MoreAsserts类包含更多强大的断言方法，如assertContainsRegex(String, String)，可以作正则表达式的匹配。</li>
<li>ViewAsserts类包含关于Android View的有用断言方法，如assertHasScreenCoordinates(View, View, int, int)，可以测试View在可视区域的特定X、Y位置。这些Assert简化了UI中几何图形和对齐方式的测试。</li>
</ol>
<h3 id="运行Instrumentation测试"><a href="#运行Instrumentation测试" class="headerlink" title="运行Instrumentation测试"></a>运行Instrumentation测试</h3><p>执行命令 <strong>gradlew build connectedCheck</strong>  就可以了。</p>
<p>除了命令行的方式，还有一种就是直接从Android Studio执行。回到最上面那张图，在4部分，即Test Artifact里面，还有一个选择是”Android Instrumentation Tests”，切换到这个模式，然后选中需要执行的类，选择Run即可。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章主要目的是为了让读者初步了解Android单元测试的分类以及基本的测试知识。</p>
<p>从实际使用效果来看，本地普通单元测试和Instrumentation单元测试互相补足，基本满足了与四大组件无关的测试，但是仍然有很多的情况不能Cover:</p>
<ol>
<li>本地普通单元测试只能Cover与平台无关的代码；</li>
<li>Instrumentation测试虽然提供了Context，但是测试结果很多依赖于实际的运行环境，并且执行结果是反映在UI上的，因此效果有限；</li>
</ol>
<p>举几个🌰:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//与实际编译环境相关</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSdkVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Build.VERSION.class.getField(<span class="string">"SDK_INT"</span>).getInt(<span class="keyword">null</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与App本身相关</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getAppName</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> getAppName(context, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与设备相关</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasFeature</span><span class="params">(Context context, String feature)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> context.getPackageManager().hasSystemFeature(feature);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果反映在UI上</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hideSoftKeyboard</span><span class="params">(@NonNull View view)</span> </span>&#123;</span><br><span class="line">	InputMethodManager imm = (InputMethodManager) view.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);</span><br><span class="line">	imm.hideSoftInputFromWindow(view.getWindowToken(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上这些例子在客户端很难完成UT，因此它们是不应该使用UT的，必要性也不是很大。</p>
<p>综上，UT在客户端的使用范围和效果是很有限的。客户端开发人员应当熟知这几类测试手段（另外一种是UI自动化测试），在必要的时候根据需求，比如必不可免的复杂逻辑处，使用相应的测试，一定程度上保证客户端的稳定性。</p>
<p>后期待补充的相关知识：</p>
<ol>
<li>Mockito的使用；</li>
<li>Android Testing Support Library提供的一些新功能；</li>
<li>Android上对Activity、Service、ContentProvider、Application等组件的测试支持；</li>
<li>UI自动化测试框架；</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java 注解]]></title>
      <url>http://www.timebridge.space/2015/11/15/Java-annotation/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>注解的基本知识概念略去不表，读者应该知道：</p>
<ol>
<li>四个元注解： @Retention @Target @Document @Inherited；</li>
<li>对最常用的注解解析方式有所了解；</li>
</ol>
<p>Retention表示注解留存的阶段，有三个值：SOURCE，CLASS，RUNTIME。最常见的是RUNTIME，这类注解可以通过反射的方式进行解析。但是我们今天要说的是SOURCE和CLASS注解的解析。<a id="more"></a></p>
<h2 id="APT"><a href="#APT" class="headerlink" title="APT"></a>APT</h2><p>APT，即annotation processing tool，是Sun公司专门开发用来处理注解的。和javac一样，apt直接对Java源文件进行处理。apt工作的时候需要使用一个AnnotationProcessorFactory来处理它所遇到的Annotation，即APT需要为每一个它所遇到的注解找到对应的注解处理器。</p>
<p>注意，在使用apt处理注解的时候，不能使用反射，因为你是在处理源代码而不是编译之后的类。Mirror类补足了这一点。</p>
<p>在《Thinking In Java》中，作者在“Annotations”这一章最后展示了一个ExtractInterface编译时注解案例，案例很简单读者可以自行阅读并Coding，这里总结一下主要组成部分：</p>
<ol>
<li>定义注解；</li>
<li>定义一个类，使用注解；</li>
<li>实现AnnotationProcessor接口，该接口有一个process方法，处理注解的过程都在这里（最重要的就是写.java文件创建新类）</li>
<li>最重要的是实现AnnotationProcessorFactory接口，在这个接口中会建立注解和注解处理器的对应关系。</li>
<li>执行apt命令，告诉apt使用哪一个Factory，解析哪一个源码的注解</li>
</ol>
<p>下面给一下AnnotationProcessorFactory的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceExtractorProcessorFactory</span> <span class="keyword">implements</span> <span class="title">AnnotationProcessorFactory</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> AnnotationProcessor <span class="title">getProcessorFor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			Set&lt;AnnotationTypeDeclaration&gt; atds,</span></span></span><br><span class="line"><span class="function"><span class="params">			AnnotationProcessorEnvironment env)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> InterfaceExtractorProcessor(env);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">supportedAnnotationTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> Collections.singleton(<span class="string">"annotations.ExtractInterface"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">supportedOptions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>命令大致如下：<br>apt -factory annotations.InterfaceExtractorProcessorFactory Multiplier.java -s ../annotations</p>
<p>PS：在我Mac上死活运行不出来，报找不到InterfaceExtractorProcessorFactory错误，在网上搜了一圈都没有找到解决方案。不过看很多的blog，有很多《Thinking In Java》读者都应该运行成功。</p>
<h2 id="编译时注解框架"><a href="#编译时注解框架" class="headerlink" title="编译时注解框架"></a>编译时注解框架</h2><p>有很多的框架都是编译时注解的，我们在使用的过程中并没有去执行apt命令，那么这些框架是怎么实现运作的呢？</p>
<p><a href="http://www.cnblogs.com/avenwu/p/4173899.html" target="_blank" rel="noopener">这里</a>有一个很好的案例，作者给出了源码，读者可以下载运行。我在Android项目中运行这个案例是成功的。（PS：<a href="http://blog.csdn.net/lmj623565791/article/details/43452969" target="_blank" rel="noopener">这篇文章</a>是一个补充）。</p>
<p>重点在于目录结构中的resources目录。</p>
<p>我将案例中的注解处理类改造如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SupportedAnnotationTypes</span>(&#123;<span class="string">"com.avenwu.annotation.PrintMe"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SUFFIX = <span class="string">"Factory"</span>;</span><br><span class="line">    <span class="keyword">private</span> String qualifiedClassName = <span class="string">"com.dianping.littleshell"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env)</span> </span>&#123;</span><br><span class="line">        Messager messager = processingEnv.getMessager();</span><br><span class="line">        <span class="keyword">for</span> (TypeElement te : annotations) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Element e : env.getElementsAnnotatedWith(te)) &#123;</span><br><span class="line">                messager.printMessage(Diagnostic.Kind.NOTE, <span class="string">"Printing: "</span> + e.toString());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    JavaFileObject f = processingEnv.getFiler().</span><br><span class="line">                            createSourceFile(qualifiedClassName + <span class="string">".LittleShell"</span> + SUFFIX);</span><br><span class="line">                    processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE,</span><br><span class="line">                            <span class="string">"Creating "</span> + f.toUri());</span><br><span class="line">                    Writer w = f.openWriter();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        PrintWriter pw = <span class="keyword">new</span> PrintWriter(w);</span><br><span class="line">                        pw.println(<span class="string">"package "</span> + qualifiedClassName + <span class="string">";"</span>);</span><br><span class="line">                        pw.println(<span class="string">"public class LittleShellFactory&#123;"</span>);</span><br><span class="line">                        pw.println(<span class="string">"    public void print() &#123;"</span>);</span><br><span class="line">                        pw.println(<span class="string">"        System.out.println(\"Hello boss!\");"</span>);</span><br><span class="line">                        pw.println(<span class="string">"    &#125;"</span>);</span><br><span class="line">                        pw.println(<span class="string">"&#125;"</span>);</span><br><span class="line">                        pw.flush();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        w.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">                    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,</span><br><span class="line">                            x.toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SourceVersion <span class="title">getSupportedSourceVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SourceVersion.latestSupported();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后打包放入Android项目中运行，编译之后发现：</p>
<p><img src="http://7xktd8.com1.z0.glb.clouddn.com/注解生成类.png" alt="注解处理"></p>
<p>在编译之后的确生成了一个.java类，并且已经编译。那么这个类如何使用呢？或者能否在实际运行环境下获取呢？我尝试了一把：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.footprint.littleshell;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.os.Handler;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.avenwu.annotation.PrintMe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Handler().postDelayed(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Toast.makeText(MainActivity.<span class="keyword">this</span>, test(), Toast.LENGTH_LONG).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PrintMe</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class cls = Class.forName(<span class="string">"com.dianping.littleshell.LittleShellFactory"</span>);</span><br><span class="line">            <span class="keyword">if</span>(cls != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Method method = cls.getMethod(<span class="string">"print"</span>);</span><br><span class="line">                method.invoke(cls.newInstance());</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"AAAAAAAA"</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"BBBBBBBBB"</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"CCCCCCCCC"</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"DDDDDDDDD"</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"EEEEEEEEE"</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"FFFFFFFFF"</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"GGGGGGGGG"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（额，没有android机器，Genymotion坏了，环境真是艰辛）口述运行结果如下：</p>
<p>控制台的确打印出了”Hello boss!”，Toast显示的是”AAAAAAAA”，即通过反射可以获取该类，也就证明了注解产生的类最终被打包到了apk中。</p>
<p>试验中还发现：包名是任意的，如上，一开始我使用的是com.footprint.littltshell，后面改成com.dianping.littleshell，两者都没有问题。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后推荐一篇猛文:<a href="http://hannesdorfmann.com/annotation-processing/annotationprocessing101/" target="_blank" rel="noopener">ANNOTATION PROCESSING 101</a>，作者写的非常详细，并且有一个完整的例子，读者有兴趣可以研究琢磨一下。</p>
<blockquote>
<p>PS：博客讲述了TypeMirrors的用法和JavaWriter工具，并且提及了Butter Knife这个注解开源框架，项目使用maven管理，整体结构都很不错，值得读者学习。</p>
</blockquote>
<p>不过建议先把上面的示例演练一遍。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android App代码优化]]></title>
      <url>http://www.timebridge.space/2015/10/28/Android-App-code-optimization/</url>
      <content type="html"><![CDATA[<p>介绍几个可用于提高Android平台代码质量的工具。</p>
<h2 id="NO-1-StrictMode"><a href="#NO-1-StrictMode" class="headerlink" title="NO.1 StrictMode"></a>NO.1 StrictMode</h2><p><a href="http://developer.android.com/intl/zh-cn/reference/android/os/StrictMode.html" target="_blank" rel="noopener">官网介绍</a>在此。<br>推荐阅读文章：<a href="http://android-performance.com/android/2014/04/24/android-strict-mode.html" target="_blank" rel="noopener">StrictMode 详解</a> &amp; <a href="http://droidyue.com/blog/2015/09/26/android-tuning-tool-strictmode/" target="_blank" rel="noopener">Android性能调优利器StrictMode</a></p>
<p><strong>StrictMode有两大类策略：监控线程和VM。</strong> 线程方面，主要用于检测一些在主线程意外进行的耗时网络操作和磁盘读写操作，同时也提供方法用于检测开发者需要监控的耗时代码块。VM方面主攻内存泄露：包括Activity、SQLite等。<a id="more"></a>示例代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (DEVELOPER_MODE) &#123;</span><br><span class="line">		StrictMode.setThreadPolicy(<span class="keyword">new</span> StrictMode.ThreadPolicy.Builder()</span><br><span class="line">                        .detectAll()</span><br><span class="line">                        .penaltyLog()</span><br><span class="line">                        .build());</span><br><span class="line">		StrictMode.setVmPolicy(<span class="keyword">new</span> StrictMode.VmPolicy.Builder()</span><br><span class="line">                        .detectLeakedSqlLiteObjects()</span><br><span class="line">                        .detectLeakedClosableObjects()</span><br><span class="line">                        .penaltyLog()</span><br><span class="line">                        .penaltyDeath()</span><br><span class="line">                        .build());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标记比较慢的代码，可以使用如下方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StrictMode.noteSlowCall(<span class="string">"slowCallInCustomThread"</span>);</span><br></pre></td></tr></table></figure>
<p>被noteSlowCall标记的方法，如果执行过慢则会触发StrictMode报警，这个方法只有用在主线程调用的方法中时，才会有效果（实践证明）。</p>
<p>有时候有些特殊case可以绕过，不需要检测，比如主线程是可以进行一些快速简短的磁盘读写操作的，此时可以如下Coding:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StrictMode.ThreadPolicy old = StrictMode.getThreadPolicy();</span><br><span class="line">StrictMode.setThreadPolicy(<span class="keyword">new</span> StrictMode.ThreadPolicy.Builder(old)</span><br><span class="line">    .permitDiskWrites()</span><br><span class="line">    .build());</span><br><span class="line"><span class="comment">// 方法调用</span></span><br><span class="line">doCorrectStuffThatWritesToDisk();</span><br><span class="line">StrictMode.setThreadPolicy(old);</span><br></pre></td></tr></table></figure>
<p>PS：在开发者选项里面，也可以直接启用严格模式，如果主线程中有执行时间长的操作，屏幕则会闪烁。</p>
<h2 id="NO-2-Findbugs"><a href="#NO-2-Findbugs" class="headerlink" title="NO.2 Findbugs"></a>NO.2 Findbugs</h2><p><a href="http://findbugs.sourceforge.net/users.html" target="_blank" rel="noopener">官网介绍</a>在此。<br>它会给代码做一个全面的扫描，根据规则去判断代码中的一些不规范和潜在问题，比如多线程问题。</p>
<p>它的结果可以以xml和html展示出来。</p>
<h2 id="NO-3-PMD"><a href="#NO-3-PMD" class="headerlink" title="NO.3 PMD"></a>NO.3 PMD</h2><p><a href="http://pmd.sourceforge.net/pmd-5.1.1/" target="_blank" rel="noopener">官网介绍</a>在此。<br>和Findbugs差不多，也是代码静态扫描工具，并且两者有一些重复的功能。PMD的定制性比较强，而且有部分功能是专门用于检测Android项目（虽然很弱）：</p>
<ol>
<li>CallSuperFirst: 应该在方法第一行调用super方法；</li>
<li>CallSuperLast: 应该在方法最后一行调用super方法；</li>
<li>DoNotHardCodeSDCard: 不应该硬编码SDCard的路径；</li>
</ol>
<p>同样，它的结果也可以以xml和html展示。</p>
<h2 id="NO-4-CheckStyle"><a href="#NO-4-CheckStyle" class="headerlink" title="NO.4 CheckStyle"></a>NO.4 CheckStyle</h2><p><a href="http://checkstyle.sourceforge.net/" target="_blank" rel="noopener">官网介绍</a>在此。<br>检查代码风格的工具。CheckStyle插件使用需要一个配置文件，定义具体的代码风格，可以参考StackOverFlow上的<a href="http://stackoverflow.com/questions/9339804/where-can-i-find-checkstyle-config-for-android-coding-style" target="_blank" rel="noopener">这篇帖子</a>，里面有诸如<a href="https://github.com/square/picasso/blob/master/checkstyle.xml" target="_blank" rel="noopener">Picasso</a>、<a href="http://checkstyle.sourceforge.net/google_style.html" target="_blank" rel="noopener">Google</a>等定义的CheckStyle可以参考。</p>
<p>Findbugs和PMD在gradle中的配置都非常方便，可以参考<a href="https://gist.github.com/rciovati/8461832" target="_blank" rel="noopener">GitHub上这个配置</a>。也可以直接使用<a href="https://github.com/noveogroup/android-check" target="_blank" rel="noopener">这个插件</a>，它集成了checkstyle、findbugs和pmd三个工具。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android6.0权限问题]]></title>
      <url>http://www.timebridge.space/2015/10/28/Android-6-quan-xian-wen-ti/</url>
      <content type="html"><![CDATA[<p>建议阅读<a href="http://inthecheesefactory.com/blog/things-you-need-to-know-about-android-m-permission-developer-edition/en" target="_blank" rel="noopener">这篇文章</a>和<a href="http://developer.android.com/intl/zh-cn/training/permissions/requesting.html#perm-check" target="_blank" rel="noopener">官方文档</a>。</p>
<p>简单来说，Android要向iOS靠拢，实行运行时权限控制啦！在很久以前，我们只需要在AndoridManifest.xml文件中声明程序运行所需要的权限，用户在安装的时候一次同意就可以了。</p>
<p>在Android M中，权限被分为两类：一类是普通权限，不会涉及到用户隐私，一类是高危权限，在使用权限的时候需要用户同意。当然用户也能在设置中取消应用的某个权限。<br><a id="more"></a><br>因此App需要考虑到用户拒绝权限的逻辑情况，需要对此做出适配。至于如何适配，如何申请权限，两篇文章都讲得很清楚。</p>
<p>这里主要讲一下其中一个重要的方法：shouldShowRequestPermissionRationale()。根据官网描述，这个方法其实是用于判断是否需要向用户提供一个explanation的。那么这个方法依据什么返回呢？</p>
<ol>
<li>如果app之前要求获取某个权限，但是被拒绝了，这个app会返回true（这种情况下，Android认为用户不理解应用获取该权限的目的，因此需要解释）；</li>
<li>如果用户在拒绝的时候选择了”Don’t ask again”（不再询问），这个方法就会返回false（用户理解目的，并且断然拒绝）；</li>
<li>如果设备本身就禁止这个应用获取该权限，返回false（无关用户理解与否，用户无法对权限的许可作出任何事情）；</li>
</ol>
<p>因此实际上Android的整个权限控制分两个逻辑：1）判断权限是都被授予；2）判断获取权限是否需要提供explanation。因此其官网的获取权限的示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Here, thisActivity is the current activity</span></span><br><span class="line"><span class="keyword">if</span> (ContextCompat.checkSelfPermission(thisActivity,</span><br><span class="line">                Manifest.permission.READ_CONTACTS)</span><br><span class="line">        != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Should we show an explanation?</span></span><br><span class="line">    <span class="keyword">if</span> (ActivityCompat.shouldShowRequestPermissionRationale(thisActivity,</span><br><span class="line">            Manifest.permission.READ_CONTACTS)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Show an expanation to the user *asynchronously* -- don't block</span></span><br><span class="line">        <span class="comment">// this thread waiting for the user's response! After the user</span></span><br><span class="line">        <span class="comment">// sees the explanation, try again to request the permission.</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// No explanation needed, we can request the permission.</span></span><br><span class="line"></span><br><span class="line">        ActivityCompat.requestPermissions(thisActivity,</span><br><span class="line">                <span class="keyword">new</span> String[]&#123;Manifest.permission.READ_CONTACTS&#125;,</span><br><span class="line">                MY_PERMISSIONS_REQUEST_READ_CONTACTS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// MY_PERMISSIONS_REQUEST_READ_CONTACTS is an</span></span><br><span class="line">        <span class="comment">// app-defined int constant. The callback method gets the</span></span><br><span class="line">        <span class="comment">// result of the request.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：内部的if…else…两个逻辑点都应该去请求权限！</p>
<p>那么如果用户在拒绝的时候选了”Don’t ask again”（不再询问），再调用ActivityCompat.requestPermissions获取权限会怎么样呢？会以PERMISSION_DENIED返回值直接进入回调。</p>
<p>以上。整个权限控制逻辑上可以走通。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ConcurrentModificationException]]></title>
      <url>http://www.timebridge.space/2015/10/26/Java-ConcurrentModificationException/</url>
      <content type="html"><![CDATA[<p>Java中的 ConcurrentModificationException 是 Fail-Fast 的一种表现，这里有<a href="http://javapapers.com/core-java/fail-fast-vs-fail-safe/" target="_blank" rel="noopener">一篇文章</a>探讨 Fail-Fast 和 Fail-Safe 谁更好。</p>
<p>这里我们以 Java 中 ArrayList 的 Iterator (它有好几个 Iterator，这个最简单，但能概括问题)实现为例，看看什么时候会发生 ConcurrentModificationException 。以下为 ArrayList 的 Iterator 实现源码：<a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">	<span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">	<span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> cursor != size;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		checkForComodification();<span class="comment">//第一种</span></span><br><span class="line">		<span class="keyword">int</span> i = cursor;</span><br><span class="line">		<span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">		Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">		<span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">		cursor = i + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">		checkForComodification();<span class="comment">//第一种</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">			cursor = lastRet;</span><br><span class="line">			lastRet = -<span class="number">1</span>;</span><br><span class="line">			expectedModCount = modCount;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; consumer)</span> </span>&#123;</span><br><span class="line">		Objects.requireNonNull(consumer);</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> size = ArrayList.<span class="keyword">this</span>.size;</span><br><span class="line">		<span class="keyword">int</span> i = cursor;</span><br><span class="line">		<span class="keyword">if</span> (i &gt;= size) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">final</span> Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">		<span class="keyword">if</span> (i &gt;= elementData.length) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();<span class="comment">//第二种</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) &#123;</span><br><span class="line">			consumer.accept((E) elementData[i++]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// update once at end of iteration to reduce heap write traffic</span></span><br><span class="line">		cursor = i;</span><br><span class="line">		lastRet = i - <span class="number">1</span>;</span><br><span class="line">		checkForComodification();<span class="comment">//第一种</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到有如下几种情况会抛出这个异常：</p>
<ol>
<li>next()和remove()方法一开始会调用checkForComodification()方法，这个方法主要是比较modCount和expectedModCount，这两个参数分别代表什么呢？前者代表集合本身的方法修改集合的次数：读者可以自行查看ArrayList的源码，在remove、add、trim等方法中都可以看到modCount被++。而expectedModCount则在一开始就赋值为modCount，而在Iterator中的remove方法中，又被赋值为modCount，由此可见，如果使用集合的remove、add等方法修改集合元素，则必然引起modCount增加，导致modCount != expectedModCount成立，在下次调用next()或者remove()方法的时候，就会抛出ConcurrentModificationException，这里要注意是下次：如果修改之后不调用这两个方法，就不会checkForComodification，也就不会引发异常。而Iterator本身的remove()方法在执行完毕后因为会重新赋值expectedModCount，因此后续是不会出问题的。</li>
<li>第二类是一种判断，从代码看，可以简单的认为是一种集合越界：cursor(指向下一个返回值)指向的元素不存在，需要remove的元素不存在等等，我们可以猜测一下为什么会发生这种情况？比较明显的一点是：所有的remove、add方法都没有同步措施，因此在多线程中很容易发生这种情况：一个线程在按序遍历，另外一个线程在随机删除数据，导致越界错误；</li>
</ol>
<p>以上，会导致我们在使用ArrayList的Iterator的时候抛出ConcurrentModificationException，可以认为Iterator在检测到任何可能发生的错误或者不一致的情况的时候，都应该抛出这个异常。</p>
<p>但是正如Java API中所提到的:</p>
<blockquote>
<p>“Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs.”</p>
</blockquote>
<p>这些方法并没有做好同步工作，只能说是一种辅助预防，即使是Iterator本身的方法也是没有做同步的，这就埋下一些隐患。举个简单的例子：<br>Iterator的remove方法中有一行代码<strong>expectedModCount = modCount;</strong>这行代码是重新赋值expectedModCount，假设这个Iterator被一个线程A获取，并执行到这一行，线程A被切换，则无论别的线程调用什么方法添加集合元素，当执行回到线程A的时候，都不会导致后续发生问题，因为expectedModCount会被重新赋值。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[EventBus杂谈]]></title>
      <url>http://www.timebridge.space/2015/10/20/EventBus/</url>
      <content type="html"><![CDATA[<p>关于EventBus源码的解析，已经有很多文章，比如<a href="http://a.codekk.com/detail/Android/Trinea/EventBus%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" target="_blank" rel="noopener">EventBus 源码解析</a>。此处就不赘述了，我的代码阅读标注在<a href="https://github.com/BigFootprint/AndroidSourceReader/tree/master/EventBus" target="_blank" rel="noopener">这里</a>。</p>
<p>下面随便聊一下。</p>
<p>Android开发一直在说MVC模式，C这块在客户端App上已经不是很明显，M和V两块单独分离是比较简单的。M层本身也可以比较容易的进行架构组织，但是整体在拆的时候会出现两个问题：<a id="more"></a></p>
<ol>
<li>V对M的变化监听实现比较复杂。在Android中，要么使用回调(需要声明接口，并添加监听)，要么使用广播(需要声明广播监听器，最重要的是传输的数据只能通过Intent，伴随的是声明一堆static final变量)，两种实现成本都比较高，重复工作很多；</li>
<li>V本身的拆分比较困难。许多复杂的页面，不可能将所有的View操作都写在同一个类中，因此会独立出一些Custom View(这个一般比较好处理)和Fragment，而Fragment之间的通讯是一件非常麻烦的事情：需要通过Activity中转(得判断Activity是否为空)或者广播进行。实际上，Activity之间的通讯也存在相似的问题。</li>
</ol>
<p>这些问题的出现在呼唤一个东西的出现——一种更高效的代码间通讯方式。这就是使用EventBus的最佳理由。</p>
<p>EventBus可以使得在代码上看上去毫无关系(只有需要传送的信息对象)的两个对象之间能够完成信息传递，并且代码简短高效。</p>
<p>EventBus提供的一些高级特性：比如Priority(可以用于事件拦截)、Sticky(想了一下，如果A页面跳转到B页面，A页面同时又在等待B页面的信息，此时应该使用sticky事件，因为A页面可能会因为内存不足而被杀掉，使用Sticky则可以在A页面恢复的时候再度获取到事件)，可以为一些特殊场景提供便利。</p>
<p>然而EventBus并不是毫无缺点的，<strong>最不好的一点</strong>是:<br>EventBus在事件类型以及监听者的实现上考虑到了继承，但即便不考虑，也会有一个比较麻烦的地方——太多的EventBus会导致程序逻辑不清晰。举个栗子，原先Activity和Fragment之间通讯，可能是Fragment直接调用getActivity()后强转类型，然后调用某个方法，现在可能直接post一个事件，两端代码相比较，明显前者更轻易能看出Fragment在和谁、什么方法通信，再者，如果某个onEvent方法是出现在Activity的父类中，整体代码看上去就更加隐晦，可读性变差。</p>
<p>因此使用时注意适量，并适当添加注释。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[观影《蚁人》]]></title>
      <url>http://www.timebridge.space/2015/10/18/yi-ren/</url>
      <content type="html"><![CDATA[<p>评分：8.0。点评上19.9元，3D长，效果不错。</p>
<h1 id="赞"><a href="#赞" class="headerlink" title="赞"></a>赞</h1><p>整体故事情节没有什么特别精彩的地方，但整个影片想象力很丰富，有几个场景很有震撼力:</p>
<ol>
<li>朗第一次在浴缸里面变成蚁人，被放水冲刷；</li>
<li>朗变成蚁人从水管里面潜入皮姆公司;</li>
<li>朗在最后为了打败达伦进入次原子级，不断缩小;</li>
<li>当然还有朗和各种蚂蚁们一起亲密接触的场景;</li>
</ol>
<p>影片的最后让人不禁想起星际穿越，我还以为朗会把皮姆教授的夫人从次原子级带回到现实生活中。<a id="more"></a></p>
<p>另外影片中笑点也蛮多。看完电影觉得有必要理一下漫威电影宇宙了。</p>
<h1 id="批"><a href="#批" class="headerlink" title="批"></a>批</h1><p>影片中有几个地方应该有漏洞:</p>
<ol>
<li>皮姆教授的女儿霍普在和朗练习拳击的时候说道:蚁人一拳出击的力气相当于一个90kg(数字记不清了)的男人出拳的力量，因此重了会打死人。那么就可以认为：a)皮姆教授的发现只是把人缩小，质量应该没变；另外从朗和蚂蚁练习交流以及后期并肩作战的场景看：b)缩小的朗应该和一个蚊子的大小差不多。而影片中多次出现缩小的朗把人掀翻在地的情景，按照前面的a和b假设，这个情景就有问题了：以蚊子的体积在人体皮肤上施加一个能够掀翻人的力量，难道不是应该和子弹一样穿透?</li>
<li>同样是基于前面的a假设，水管中朗乘坐蚂蚁们组成的蚁舟前进以及通过蚂蚁们搭建的链条进入管道就不能解释了;</li>
<li>影片前面出现了皮姆粒子一说，这种粒子是可以缩小原子之间的距离的(皮姆教授原话)，那么仅仅靠缩短原子间的距离，如何进入次原子级呢？除非皮姆粒子能够改变原子的体积，缩小至夸克甚至更小的粒子之下?这样，很多事情就不好解释了;</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[GitBook 环境搭建]]></title>
      <url>http://www.timebridge.space/2015/10/17/GitBook-huan-jing-da-jian/</url>
      <content type="html"><![CDATA[<p>关于如何搭建GitBook的本地环境以及一些简单的配置，可以参考<a href="http://www.chengweiyang.cn/gitbook/gitbook.com/config/domain.html" target="_blank" rel="noopener">这篇文章</a>。已经讲的很全面了。</p>
<p>GitBook的官网在<a href="https://github.com/GitbookIO/gitbook" target="_blank" rel="noopener">这里</a>。<a id="more"></a></p>
<p>不过可能是因为文章太老的缘故，有些截图和实际的操作界面已经不一样了。比如<a href="http://www.chengweiyang.cn/gitbook/gitbook.com/config/domain.html" target="_blank" rel="noopener">绑定域名</a>这一章，入口和配置页面已经变成这样:</p>
<p><img src="http://7xktd8.com1.z0.glb.clouddn.com/GitBook域名配置入口.png" alt="GitBook域名配置入口"></p>
<p><img src="http://7xktd8.com1.z0.glb.clouddn.com/GitBook域名配置界面.png" alt="GitBook域名配置界面"></p>
<p>添加完成域名，配置好DNS之后，就可以访问了。</p>
<p><a href="http://colobu.com/2014/10/09/gitbook-quickstart/" target="_blank" rel="noopener">这里</a>还有一篇文章可以参考。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[那些年计划看的电影]]></title>
      <url>http://www.timebridge.space/2015/10/17/Movie/</url>
      <content type="html"><![CDATA[<h3 id="待看区"><a href="#待看区" class="headerlink" title="待看区"></a>待看区</h3><p>《伊丽莎白镇》《迷失东京》《日出之前》《日落之前》《恋爱假期》《练习曲》《天使爱美丽》《巴黎，我爱你》《摩托日记》《托斯卡纳艳阳下》 《云中漫步》《菊次郎的夏天》《某个旅人的日记》《午夜巴塞罗那》</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android的数据恢复(二)]]></title>
      <url>http://www.timebridge.space/2015/10/17/Android-de-shu-ju-hui-fu-yi/</url>
      <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在Android上，会有以下原因导致需要保存和恢复当前页面的数据：  </p>
<ol>
<li>一个Activity退到后台：比如跳转到另外一个Activity，或者按Home键退到后端;</li>
<li>系统配置变化，如：屏幕旋转(在用户意识里只是屏幕旋转，实际上Activity是被杀掉后重建);</li>
</ol>
<p>第一种情况只有在内存不足，后台Activity确实被系统回收掉的时候才会进行数据恢复，如果Activity正常存在于内存中，则不需要数据恢复，但一定会做数据保存。第二种情况是因为在用户眼里只是界面旋转了一下，而实际上Activity是被销毁重建的，这个时候做数据恢复是合理而且应当的。<a id="more"></a></p>
<h2 id="数据如何保存"><a href="#数据如何保存" class="headerlink" title="数据如何保存"></a>数据如何保存</h2><p>一般来说，我们通过三个方法进行Activity的数据恢复与保存，分别如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span>  </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span>  </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRestoreInstanceState</span><span class="params">(Bundle savedInstanceState)</span></span></span><br></pre></td></tr></table></figure></p>
<p>我们通过第一个方法的outState参数保存数据，后面两个方法的savedInstanceState参数获取保存的数据。onRestoreInstanceState方法在onStart后面onResume前面执行。</p>
<p>关于以上两点，开发者官网上都有比较完善的描述，读者可以仔细阅读：<a href="http://developer.android.com/training/basics/activity-lifecycle/recreating.html" target="_blank" rel="noopener">【原文链接】</a></p>
<p>这一部分稍有经验的开发者都比较熟悉，本文重点讲述的是<strong>View如何去保存恢复数据</strong>。</p>
<h2 id="View状态如何保存"><a href="#View状态如何保存" class="headerlink" title="View状态如何保存"></a>View状态如何保存</h2><p>一个Activity展示给用户的除了数据，就是View，所以当我们做恢复的时候，不仅需要恢复重要数据，也需要尽可能的恢复View的状态。</p>
<p>日常开发中我们一般是通过onSaveInstanceState去保存View的状态(比如EditTex的输入内容)，恢复的时候将数据读出设置到View中去，但这种方式粗暴有用但不优雅，举个🌰：我封装了一个CustomView，其中包含着一个EditText，如果按照前面的方式去做恢复则EditText一定要暴露给外部，否则Activity就不能获取并设置值，这破坏了组件的封装性。</p>
<p>其实Android内部是有一套View状态保存和恢复机制的，不需要通过Activity的生命周期方法去实现。阅读官方文档的读者可以注意一点，文中提到了EditText状态的保存条件：需要有一个唯一的id。这是为什么呢？</p>
<p>下面我们来详细看一下View的数据保存机制，从中找出回答前面问题的答案。</p>
<blockquote>
<p>【Note】建议打开Android Studio，下面的代码片段比较多，直接阅读源码对照阅读比较容易理解。</p>
</blockquote>
<h3 id="Activity的onSaveInstanceState-方法"><a href="#Activity的onSaveInstanceState-方法" class="headerlink" title="Activity的onSaveInstanceState()方法"></a>Activity的onSaveInstanceState()方法</h3><p>View说到底是属于Activity的，onSaveInstanceState是整个Activity保存数据的出发点，我们从这里入手:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</span><br><span class="line">	outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState());</span><br><span class="line">	Parcelable p = mFragments.saveAllState();</span><br><span class="line">	<span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">		outState.putParcelable(FRAGMENTS_TAG, p);</span><br><span class="line">	&#125;</span><br><span class="line">	getApplication().dispatchActivitySaveInstanceState(<span class="keyword">this</span>, outState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如代码所示，第二行将整个Window的状态保存在一个Bundle中，将值保存到ontState中去，看上去很有可能与View相关，我们继续往下走。</p>
<p>3-6行则是触发Fragment数据保存的（下一篇博文主题）。关于Windnow的解释，可以查看这篇博客：<a href="http://www.cnblogs.com/lqminn/archive/2013/05/01/3050776.html" target="_blank" rel="noopener">【Android】Android界面从里至外浅析（一）</a></p>
<h3 id="Window的saveHierarchyState-方法"><a href="#Window的saveHierarchyState-方法" class="headerlink" title="Window的saveHierarchyState()方法"></a>Window的saveHierarchyState()方法</h3><p>了解之后，我们定位到PhoneWindow中的saveHierarchyState方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Bundle <span class="title">saveHierarchyState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Bundle outState = <span class="keyword">new</span> Bundle();</span><br><span class="line">	<span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line"> 		<span class="keyword">return</span> outState;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	SparseArray&lt;Parcelable&gt; states = <span class="keyword">new</span> SparseArray&lt;Parcelable&gt;();</span><br><span class="line"> 	mContentParent.saveHierarchyState(states);</span><br><span class="line"> 	outState.putSparseParcelableArray(VIEWS_TAG, states);</span><br><span class="line"> 	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此处省略了部分代码。我们看到，这个方法触发了mContentParent的saveHierarchyState的方法。mContentParent又是何方神圣？查看其声明发现：它是一个ViewGroup。比对<a href="http://www.cnblogs.com/lqminn/archive/2013/05/01/3050776.html" target="_blank" rel="noopener">【Android】Android界面从里至外浅析（一）</a>中的图，这个mContentParent又在什么位置呢？读者可以阅读一下PhoneWindow里面的setContentView方法，其实这个mContentParent就是图中DecorView下的LinearLayout，即我们setContentView的父容器。</p>
<p>然后我们看到方法声明了一个SparseArray对象，存储的是Parcelable，这个SparseArray对象被传递给了ViewGroup的saveHierarchyState方法，之后这个SparseArray对象又被存储到了outBundle中去了，那么问题就在于saveHierarchyState这个方法到底做了什么？</p>
<h3 id="ViewGroup的saveHierarchyState-方法"><a href="#ViewGroup的saveHierarchyState-方法" class="headerlink" title="ViewGroup的saveHierarchyState()方法"></a>ViewGroup的saveHierarchyState()方法</h3><p>标题虽然是ViewGroup的saveHierarchyState()方法，但ViewGroup本身其实并没有saveHierarchyState方法，这个方法继承于它的父类——View。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveHierarchyState</span><span class="params">(SparseArray&lt;Parcelable&gt; container)</span> </span>&#123;</span><br><span class="line">	dispatchSaveInstanceState(container);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchSaveInstanceState</span><span class="params">(SparseArray&lt;Parcelable&gt; container)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mID != NO_ID &amp;&amp; (mViewFlags &amp; SAVE_DISABLED_MASK) == <span class="number">0</span>) &#123;</span><br><span class="line">		mPrivateFlags &amp;= ~PFLAG_SAVE_STATE_CALLED;</span><br><span class="line">		Parcelable state = onSaveInstanceState();</span><br><span class="line">		<span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_SAVE_STATE_CALLED) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Derived class did not call super.onSaveInstanceState()"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (state != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// Log.i("View", "Freezing #" + Integer.toHexString(mID)</span></span><br><span class="line">			<span class="comment">// + ": " + state);</span></span><br><span class="line">			container.put(mID, state);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，在这个方法中，它调用了dispatchSaveInstanceState方法，而这个方法则调用本身的onSaveInstanceState方法获取一个Parcelable对象，通过View的id将这个对象存储到SparseArray里面去了。而ViewGroup里面重写了dispatchSaveInstanceState方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchSaveInstanceState</span><span class="params">(SparseArray&lt;Parcelable&gt; container)</span></span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.dispatchSaveInstanceState(container);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> count = mChildrenCount;</span><br><span class="line">	<span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">		View c = children[i];</span><br><span class="line">		<span class="keyword">if</span> ((c.mViewFlags &amp; PARENT_SAVE_DISABLED_MASK) != PARENT_SAVE_DISABLED) &#123;</span><br><span class="line">			c.dispatchSaveInstanceState(container);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码很好理解：它不但保存自己的状态，还遍历所有的子View，调用他们的dispatchSaveInstanceState方法去保存数据。</p>
<h3 id="View数据保存总结"><a href="#View数据保存总结" class="headerlink" title="View数据保存总结"></a>View数据保存总结</h3><p>综上，View本身的数据保存机制是这样的: <strong>Activity会触发根ViewGroup将该命令传达给所有的子View，同时传递一个SparseArray给它们。View调用自己的onSaveInstanceState()将自己的状态以<id, state="">方式存储到SparseArray中去，最终SparseArray会被保存到outState中。</id,></strong></p>
<p>现在解答前面说到的一个问题：id唯一的必要性。平时编码中id仅用于定位View，所以如果能实现这个功能，即使Id重复也没有关系。但是在保存状态的时候，因为Key就是id，如果id重复，那会怎么样呢？保存的时候数据会被覆盖，恢复的时候相同id的View会被以同样的数据恢复，很多人都遇到这样的问题，原因就在于此。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>这里通过以TextView为🌰看一下实际的情况:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Parcelable <span class="title">onSaveInstanceState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Parcelable superState = <span class="keyword">super</span>.onSaveInstanceState();</span><br><span class="line">	<span class="comment">// Save state if we are forced to</span></span><br><span class="line">	<span class="keyword">boolean</span> save = mFreezesText;</span><br><span class="line">	<span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (mText != <span class="keyword">null</span>) &#123;</span><br><span class="line">		start = getSelectionStart();</span><br><span class="line">		end = getSelectionEnd();</span><br><span class="line">		<span class="keyword">if</span> (start &gt;= <span class="number">0</span> || end &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">// Or save state if there is a selection</span></span><br><span class="line">			save = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (save) &#123;</span><br><span class="line">		SavedState ss = <span class="keyword">new</span> SavedState(superState);</span><br><span class="line">		<span class="comment">// XXX Should also save the current scroll position!</span></span><br><span class="line">		ss.selStart = start;</span><br><span class="line">		ss.selEnd = end;</span><br><span class="line">		<span class="keyword">if</span> (mText <span class="keyword">instanceof</span> Spanned) &#123;</span><br><span class="line">			Spannable sp = <span class="keyword">new</span> SpannableStringBuilder(mText);</span><br><span class="line">			<span class="keyword">if</span> (mEditor != <span class="keyword">null</span>) &#123;</span><br><span class="line">				removeMisspelledSpans(sp);</span><br><span class="line">				sp.removeSpan(mEditor.mSuggestionRangeSpan);</span><br><span class="line">			&#125;</span><br><span class="line">			ss.text = sp;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			ss.text = mText.toString();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (isFocused() &amp;&amp; start &gt;= <span class="number">0</span> &amp;&amp; end &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			ss.frozenWithFocus = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ss.error = getError();</span><br><span class="line">		<span class="keyword">return</span> ss;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> superState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如代码所示，TextView就通过这个方法保存了它显示的text，不过开发者可以通过设置mFreezesText控制否要保存。读者有兴趣还可以去看看ScrollView这个方法的实现。</p>
<p>##总结<br><strong>数据恢复的过程和数据保存的流程类似，此处略去不表。</strong></p>
<p>从开发经验来看，Android上回收资源发生的比较频繁，做好状态保存恢复工作对于提升用户体验有很大帮助。文章主要阐述了View状态保存恢复的过程，有助于开发者更好的利用该机制: </p>
<ol>
<li>注意id问题——粗暴的方式问题也不大，但是如果粗暴已经引起了设计或者实现问题，可以考虑View的内建机制，出现问题的时候，id的重复也可以作为一个考虑方向;</li>
<li>如果想写一个CustomView并且想保存状态，可以通过重载onSaveInstanceState()方法实现，恢复也有响应的方式，简单优雅且不依赖于使用者;</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Volley杂谈]]></title>
      <url>http://www.timebridge.space/2015/10/17/Volley-za-tan/</url>
      <content type="html"><![CDATA[<p>关于Volley框架的基本介绍，可以看下面几篇文章：</p>
<ol>
<li><a href="http://blog.csdn.net/t12x3456/article/details/9221611" target="_blank" rel="noopener">Android 网络通信框架Volley简介(Google IO 2013)</a></li>
<li><a href="http://www.codekk.com/open-source-project-analysis/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" target="_blank" rel="noopener">Volley 源码解析</a></li>
<li><a href="https://developer.android.com/training/volley/index.html" target="_blank" rel="noopener">Transmitting Network Data Using Volley</a></li>
</ol>
<p>看完这几篇博客，对Volley应该有相当的了解，因此关于其基本介绍以及优缺点的论述，省略。下面讨论几个Volley做的不错的方面。<a id="more"></a></p>
<h2 id="一、职责切分"><a href="#一、职责切分" class="headerlink" title="一、职责切分"></a>一、职责切分</h2><h3 id="1-1-纵向切分"><a href="#1-1-纵向切分" class="headerlink" title="1.1 纵向切分"></a>1.1 纵向切分</h3><p>即对整个请求流程的切分，包括以下几个部分:</p>
<ol>
<li>RequestQueue负责请求的执行和取消等操作；</li>
<li>Dispatcher负责分发相应的请求；</li>
<li>ResponseDelivery负责Response的分发：在很多网络框架实现中，这部分并不是独立出来的。这个接口定义了三个API，但是只有一个用到了，这里独立出来会使得整个Response的处理更加清晰；</li>
</ol>
<p>这三个部分涉及到一个请求的生命周期。流程如下：</p>
<p><img src="http://7xktd8.com1.z0.glb.clouddn.com/volley-request.png" alt="Volley请求流程图"></p>
<p>下面是我自己绘制的一个更加详细的流程图：</p>
<p><img src="http://7xktd8.com1.z0.glb.clouddn.com/Volley流程图.png" alt="Volley请求详细流程图"></p>
<h3 id="1-2-横向切分"><a href="#1-2-横向切分" class="headerlink" title="1.2 横向切分"></a>1.2 横向切分</h3><p>针对上面三个部分的细致切分，主要体现在第二步，包括：</p>
<ol>
<li>Request的重试部分独立出来成为了类RetryPolicy，整个配置一下子灵活起来，具体可以参见:DefaultRetryPolicy（注意这里的接口设计）；</li>
<li>请求发送方式做了拆分（主要是因为HttpURLConnection的Bug）:定义HttpStack接口。最终这部分策略被封装在Network里面，由Network统一完成Request的发送执行；</li>
<li>缓存和网络请求的拆分:CacheDispatcher和NetworkDispatcher。不过这里有个蛮有意思的点:一般OO设计来说，这两个Dispatcher所操纵的队列肯定是属于Dispatcher的一个属性，然后由Dispatcher向外暴露操纵队列的接口，这样有利于封装。但是在Volley里面，这两个队列直接暴露在RequestQueue中，两个Dispatcher之间的交互也并不是直接引用对方，而是通过直接操作RequestQueue来实现。虽然破坏了封装，但是从实现讲却更加简单（过度封装？）；</li>
</ol>
<h2 id="二、Log调试"><a href="#二、Log调试" class="headerlink" title="二、Log调试"></a>二、Log调试</h2><p>Volley的Log机制做的是比较Nice的：Volley自己实现了Log，并且在Request类中新建了Log类的实例，Request的Log与Request实例绑定，在任何时候，只要Request存在，都可以观察一个Request完整的Log，并且通过Log确认他的状态与生命周期。与一般简单的Log相比，尤其是在多线程情况下，显得更加清楚。</p>
<h2 id="三、细节"><a href="#三、细节" class="headerlink" title="三、细节"></a>三、细节</h2><p>1) ByteArrayPool：用于处理请求返回数据时分配Byte[]，节省资源，相信对整体的性能和稳定性都有较大的提升；<br>2) Request的设计：暴露了两个接口：deliverResponse和parseNetworkResponse，这两个接口暴露出来能够让开发者可以定制自己的请求类型（代表有StringRequest和JSONRequest），同时最后的分发（回调）也可以定制，但是奇怪的是这里有点错乱破碎：正常的请求回调是可以进行分发的，但是请求错误回调则是写死的。如果需要像正常回调一样可以通知到多个监听者，就需要再做一层开发，不爽；<br>3）RetryPolicy作为独立的类设计，使得重试机制变得异常灵活（开发者可以自己实现RetryPolicy，但是需要注意实现一定要参照DefaultRetryPolicy，尤其是retry方法）。这里的重试实现的比较精巧（但是也难以看懂）：具体的实现可以查看BasicNetwork的performRequest方法，这里的while循环只有在获得正确返回值或者抛出异常的时候才会被打断，否则会不停尝试；<br>4）RequestFuture的实现也很有意思：这个类是实现同步请求的，里面有少许关于多线程的知识；<br>5）NoCache：这个类是实现无缓存机制的，为不支持某一种功能提供了一个实现方式（很清晰，很赞）；  </p>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>正如其在Developer中描述的一样，Volley框架有很多优秀的特性。除了上面所描述的一些细节，对Http标准协议的实现都做得不错，整个框架非常专注且灵活，看其源码，受益匪浅。后面会继续补充一些细节点。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Fragment的事务实现细节分析]]></title>
      <url>http://www.timebridge.space/2015/10/17/Fragment-de-shi-wu-shi-xian-xi-jie-fen-xi/</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>Note:</strong> 本文适合对 Fragment 的用法比较熟悉的读者。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getSupportFragmentManager().beginTransaction()</span><br><span class="line">	                .add(R.id.container, LCFragment.newInstance(<span class="string">"I am new!"</span>)).addToBackStack(<span class="keyword">null</span>).commit();</span><br></pre></td></tr></table></figure>
<p>对于稍有经验的Android开发者而言，上面的代码都应该很熟悉，通过这段代码我们可以向某个ViewGroup中添加一个Fragment。对于这段代码，我有以下个好奇点: </p>
<ol>
<li>beginTransaction()应该是开启一个事务，这个事务是什么含义?</li>
<li>addToBackStack是将这个变化添加到堆栈中去，我们知道Fragment还可以Pop堆栈，从而恢复回到commit之前的状态，这是如何实现的？</li>
</ol>
<p>本文通过源码分析，解析Fragment的工作原理，顺便解释清楚以上三个问题。<a id="more"></a></p>
<blockquote>
<p><strong>PS:</strong> Fragment是3.0之后才添加的，为了支持3.0之前的应用开发，google提供了support包，本文的源码分析是基于support-v4版本进行的。</p>
</blockquote>
<h2 id="入口函数getSupportFragmentManager"><a href="#入口函数getSupportFragmentManager" class="headerlink" title="入口函数getSupportFragmentManager()"></a>入口函数getSupportFragmentManager()</h2><p>我们操作Fragment都是通过FragmentManager来执行的，在FragmentActivity中找到这个方法的实现，发现它返回的是FragmentManagerImpl的一个实例，我们直接定位到FragmentManager类，FragmentManagerImpl作为它的一个内部类存在。这里就是我们的切入点。</p>
<h3 id="那些带有疑问的函数以及不常见的API"><a href="#那些带有疑问的函数以及不常见的API" class="headerlink" title="那些带有疑问的函数以及不常见的API"></a>那些带有疑问的函数以及不常见的API</h3><ol>
<li><strong>public abstract Fragment findFragmentById(@IdRes int id);</strong><br>读者应该知道两点:1)如果一个Fragment在添加的适合没有指定id，则他的id就等于它的containerId；2）一个ViewGroup可以添加多个Fragment。那么问题来了，这个方法只返回了一个Fragment，在多个Fragment拥有同样的Id的时候，返回的是哪一个？</li>
<li><strong>POP_BACK_STACK_INCLUSIVE</strong><br>这个参数读者可以阅读注释，或者自行查阅相关资料先进行了解，文章后面会讲述。</li>
<li><strong>public abstract void putFragment(Bundle bundle, String key, Fragment fragment);</strong><br>这个函数很少用，其注释中说”Put a reference to a fragment in a Bundle.”，查看Fragment的实现，很容易发现Fragment本身并没有实现Parcelable接口，name它是如何实现将Fragment保存到Bundle的呢?</li>
</ol>
<p>这些问题将在后面的分析中一一解答。</p>
<h2 id="事务函数beginTransaction"><a href="#事务函数beginTransaction" class="headerlink" title="事务函数beginTransaction()"></a>事务函数beginTransaction()</h2><p>从FragmentManagerImpl找到这个函数的实现，返回的是一个BackStackRecord实例。这个类实现了接口FragmentTransaction，查看接口声明，很容易就发现这个接口中的方法就是我们常见的操作Fragment的方法，比如add, remove, 还有很重要的commit()和commitAllowingStateLoss()方法。这个类还实现了Runnable接口，具体作用后面讲述。</p>
<h3 id="BackStackRecord类"><a href="#BackStackRecord类" class="headerlink" title="BackStackRecord类"></a>BackStackRecord类</h3><p>粗略的看一下BackStackRecord类代码的实现，可以很容易发现，它定义了8种操作以及一个Op内部类。</p>
<h4 id="Op类实现"><a href="#Op类实现" class="headerlink" title="Op类实现"></a>Op类实现</h4><p>这个类用于将Add，Remove等这样的方法转换成一个个操作命令：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Op</span> </span>&#123;</span><br><span class="line">	Op next;</span><br><span class="line">	Op prev;</span><br><span class="line">	<span class="keyword">int</span> cmd;</span><br><span class="line">	Fragment fragment;</span><br><span class="line">	<span class="keyword">int</span> enterAnim;</span><br><span class="line">	<span class="keyword">int</span> exitAnim;</span><br><span class="line">	<span class="keyword">int</span> popEnterAnim;</span><br><span class="line">	<span class="keyword">int</span> popExitAnim;</span><br><span class="line">	ArrayList&lt;Fragment&gt; removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从类属性看，可以知道这个类记录了命令类型，以及执行命令时的动画(分为push和pop动画)，以及涉及到的相关的Fragment(比如replace方法，就涉及两个Fragment)，另外从最前面两个属性看，Op将成为一个双向链表的节点：实际上就在这个类声明的下面几行，BackStackRecord就声明了mHead和mTail两个变量，佐证了链表的猜测。</p>
<h4 id="操作方法示例解释"><a href="#操作方法示例解释" class="headerlink" title="操作方法示例解释"></a>操作方法示例解释</h4><p>从定义的命令来看，FragmentManager支持8种操作，我们选择一种简单的看(主要是代码简短，比较好贴)——remove。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FragmentTransaction <span class="title">remove</span><span class="params">(Fragment fragment)</span> </span>&#123;</span><br><span class="line">	Op op = <span class="keyword">new</span> Op();</span><br><span class="line">	op.cmd = OP_REMOVE;</span><br><span class="line">	op.fragment = fragment;</span><br><span class="line">	addOp(op);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码很简单，无需过多解释，我们看一下addOp方法的实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addOp</span><span class="params">(Op op)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">		mHead = mTail = op;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		op.prev = mTail;</span><br><span class="line">		mTail.next = op;</span><br><span class="line">		mTail = op;</span><br><span class="line">	&#125;</span><br><span class="line">	op.enterAnim = mEnterAnim;</span><br><span class="line">	op.exitAnim = mExitAnim;</span><br><span class="line">	op.popEnterAnim = mPopEnterAnim;</span><br><span class="line">	op.popExitAnim = mPopExitAnim;</span><br><span class="line">	mNumOp++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码彻底证明了链表的猜想——新添加的Op被加入了一个链表中。其余的操作也类似，会被转换成一个Op命令，添加到这个列表中。</p>
<h4 id="Commit-方法"><a href="#Commit-方法" class="headerlink" title="Commit()方法"></a><code>Commit()</code>方法</h4><p>commit和commitAllowingStateLoss()两个方法最终都会调用commitInternal方法，只是传入参数不一样，其实现如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">commitInternal</span><span class="params">(<span class="keyword">boolean</span> allowStateLoss)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mCommitted) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"commit already called"</span>);</span><br><span class="line">	mCommitted = <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (mAddToBackStack) &#123;</span><br><span class="line">		mIndex = mManager.allocBackStackIndex(<span class="keyword">this</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		mIndex = -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	mManager.enqueueAction(<span class="keyword">this</span>, allowStateLoss);</span><br><span class="line">	<span class="keyword">return</span> mIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码也很简单，commit之后返回的参数是调用FragmentManager的allocBackStackIndex后返回的值(先不探索，稍等转到FragmentManager后再解释)，之后调用FragmentManager的enqueueAction方法，将自己作为参数传入。从enqueueAction这个方法名字看，很容易就能猜到意思:将自己压入一个队列，做什么呢？等待执行。</p>
<h4 id="run-方法"><a href="#run-方法" class="headerlink" title="run()方法"></a><code>run()</code>方法</h4><p>前面说到BackStackRecord实现了Runnable()接口，作用什么呢？其实这里和线程没有关系，只是为了实现调用类的统一方法来执行一个动作，这个用法和Handler的post(Runnable)方法一样，读者可以先查阅一下FragmentManager的enqueueAction方法签名，它接受的第一个参数就是Runnable，而非BackStackRecord类型。</p>
<p>看一下run方法实现的核心:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Op op = mHead;</span><br><span class="line"><span class="keyword">while</span> (op != <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="keyword">int</span> enterAnim = state != <span class="keyword">null</span> ? <span class="number">0</span> : op.enterAnim;</span><br><span class="line">	<span class="keyword">int</span> exitAnim = state != <span class="keyword">null</span> ? <span class="number">0</span> : op.exitAnim;</span><br><span class="line">	<span class="keyword">switch</span> (op.cmd) &#123;</span><br><span class="line">		<span class="keyword">case</span> OP_ADD: &#123;</span><br><span class="line">			Fragment f = op.fragment;</span><br><span class="line">			f.mNextAnim = enterAnim;</span><br><span class="line">			mManager.addFragment(f, <span class="keyword">false</span>);</span><br><span class="line">			&#125; <span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">//....其余命令</span></span><br><span class="line">		<span class="keyword">default</span>: &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unknown cmd: "</span> + op.cmd);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	op = op.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mAddToBackStack) &#123;<span class="comment">//加入堆栈</span></span><br><span class="line">	mManager.addBackStackState(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是一个典型的链表扫描，这里以OP_ADD命令为例，我们可以看到它最终实现的时候，是调用了FragmentManager的addFragment方法，读者可以查看别的方法，很容易就发现其余的命令实现也是类似。再看方法整体，就是一个遍历扫描链表，执行节点Op的过程。</p>
<p>因此总结如下： <strong>一次beginTransaction()方法会开启一个BackStackRecord实例，后续对Fragment的操作(链式编程)会转化成Op节点以链表形式存储在BackStackRecord中，commit()之后就交给FragmentManager调度执行，而执行的时候，就是遍历链表的Op命令，将命令映射到FragmentManager的函数上，操作Fragment。</strong></p>
<p>读者注意到这个函数的最后三行代码，这里根据mAddToBackStack判断是否将自己添加到BackStack中去，mAddToBackStack什么时候会为true呢？搜索一下代码就会发现:调用addToBackStack之后就会为true。而且很容易得出结论：只要在commit()之前调用就可以，不一定在操作最后调用。但是为了易读，在所有操作之后、commit之前调用比较好。(还有个类似的方法disallowAddToBackStack，一旦调用了这个方法，再掉用addToBackStack就会抛异常)</p>
<p>FragmentManagerImpl中的addBackStackState方法实现如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addBackStackState</span><span class="params">(BackStackRecord state)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mBackStack == <span class="keyword">null</span>) &#123;</span><br><span class="line">		mBackStack = <span class="keyword">new</span> ArrayList&lt;BackStackRecord&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">	mBackStack.add(state);</span><br><span class="line">	reportBackStackChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，所有的事务都被封装为一个BackStackRecord对象存储到”栈”中(此处栈是用List模拟的)。</p>
<h3 id="BackStackRecord的执行"><a href="#BackStackRecord的执行" class="headerlink" title="BackStackRecord的执行"></a>BackStackRecord的执行</h3><p>前面讲到，commit之后，会把BackStackRecord压入到一个队列中去，现在我们来看一下具体的实现方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueueAction</span><span class="params">(Runnable action, <span class="keyword">boolean</span> allowStateLoss)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!allowStateLoss) &#123;</span><br><span class="line">		checkStateLoss();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (mDestroyed || mActivity == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Activity has been destroyed"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (mPendingActions == <span class="keyword">null</span>) &#123;</span><br><span class="line">			mPendingActions = <span class="keyword">new</span> ArrayList&lt;Runnable&gt;();</span><br><span class="line">		&#125;</span><br><span class="line">		mPendingActions.add(action);</span><br><span class="line">		<span class="keyword">if</span> (mPendingActions.size() == <span class="number">1</span>) &#123;</span><br><span class="line">			mActivity.mHandler.removeCallbacks(mExecCommit);</span><br><span class="line">			mActivity.mHandler.post(mExecCommit);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在FragmentManager中有一个List维护着所有待执行的Runnable对象，当然也包含BackStackRecord对象，每次执行enqueueAction，都会往List中加入一个enqueueAction，如果添加之后List的大小为1(表明之前List中是空的)，那么会在主Activity的Handler中发一条全新的mExecCommit命令，这个命令是一个Runnable对象，只执行一个函数：execPendingActions。</p>
<p>这个函数会做什么呢？读者看一下代码(比较长，不贴了)，可以看到以下几个步骤：</p>
<ol>
<li>将List中的Runnable对象都移入mTmpActions数组中，清空List，清空Handler中的mExecCommit命令——表示主线程上完整的对待执行的Runnable对象进行了一次执行操作；</li>
<li>调用每个Runnable对象的run()方法执行(还记得BackStackRecord的run()方法吗？)。</li>
</ol>
<p>逻辑非常简单。这样一次执行完成，就可以完成一次事务提交了。一些方法比如popBackStack都被打上了asynchronous的标记，就是这个原因：它们不是立刻执行的，都是向队列中添加一个Action，等待主线程去调度执行(试想主线程在执行其余的一些操作，则这些事务必须等待它们执行完成之后才有机会执行)。</p>
<p>在FragmentManager中也有一组方法，它们后面跟着Immediate，表明是立即执行的。那是如何做的呢？这涉及到另外一个函数:executePendingTransactions。这个函数其实是直接调用了execPendingActions，而没有经过Handler，因此可以立即执行，开发人员在外部也可以直接调用该函数。正如方法注释中所写的：这个方法只能从主线程调用。</p>
<h2 id="回退——事务出栈"><a href="#回退——事务出栈" class="headerlink" title="回退——事务出栈"></a>回退——事务出栈</h2><p>前面讲述了FragmentManager如何执行事务以及存储事务的。那具体的回退呢？</p>
<h3 id="事务出栈"><a href="#事务出栈" class="headerlink" title="事务出栈"></a>事务出栈</h3><p>FragmentActiivty中写了一个方法，细节如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBackPressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!<span class="keyword">this</span>.mFragments.popBackStackImmediate()) &#123;</span><br><span class="line">		<span class="keyword">this</span>.finish();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>原来回退键默认的行为就是关闭当前界面，这里做了一层拦截：查看popBackStackImmediate方法的返回值。</p>
<h3 id="popBackStackState方法"><a href="#popBackStackState方法" class="headerlink" title="popBackStackState方法"></a>popBackStackState方法</h3><p>popBackStackState方法最终调用了popBackStackState方法，这个方法极为重要，可以从中得出对之前一些参数详细的解释，下面分片段解释：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (name == <span class="keyword">null</span> &amp;&amp; id &lt; <span class="number">0</span> &amp;&amp; (flags &amp; POP_BACK_STACK_INCLUSIVE) == <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="keyword">int</span> last = mBackStack.size() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (last &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">final</span> BackStackRecord bss = mBackStack.remove(last);</span><br><span class="line">	SparseArray&lt;Fragment&gt; firstOutFragments = <span class="keyword">new</span> SparseArray&lt;Fragment&gt;();</span><br><span class="line">	SparseArray&lt;Fragment&gt; lastInFragments = <span class="keyword">new</span> SparseArray&lt;Fragment&gt;();</span><br><span class="line">	bss.calculateBackFragments(firstOutFragments, lastInFragments);</span><br><span class="line">	bss.popFromBackStack(<span class="keyword">true</span>, <span class="keyword">null</span>, firstOutFragments, lastInFragments);</span><br><span class="line">	reportBackStackChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先，执行这个If的条件是name和id值都非法并且Flag POP_BACK_STACK_INCLUSIVE没有被设置才会去执行，即默认行为，是弹出最上层一个。从方法片段可以看出，取出mBackStack中的最后一个事务操作记录，调用calculateBackFragments方法。</p>
<p>calculateBackFragments方法的目的是查看哪些Fragment需要被移除、哪些需要被添加(与之前的Op命令相反，比如之前是Add，现在就应该被计入移除队列)，传入参数是两个SparseArray，执行中涉及到两个函数setLastIn和setFirstOut，这两个方法没有特别的逻辑，就是以containerId为键值将需要添加和移除的fragment保存到SparseArray中。</p>
<blockquote>
<p><strong>Note:</strong> 以containerId为键值会有问题，原因同样是来自于一个container中会存在多个Fragment。比如setFirstOut实现的时时候，会判断f移除队列中是否存在以container为键值的fragment，没有的话才会去移除。这意味着：一次事务回退是不能从一个container中移除两个Fragment的。但是在添加的时候却可以，两相矛盾。<br>不过不用担心回退栈会出现问题，因为实际上并不是通过这两个SparseArray来进行回退的，这个计算结果最终是为了得到transitionStyle和transition，这边是另外一条线，不做细讲。</p>
</blockquote>
<h4 id="popFromBackStack方法实现"><a href="#popFromBackStack方法实现" class="headerlink" title="popFromBackStack方法实现"></a>popFromBackStack方法实现</h4><p>计算好之后，就会调用BackStackRecord的popFromBackStack方法。这个方法前面小半段是计算transitionStyle和transition，后面半段就比较有意思了:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TransitionState <span class="title">popFromBackStack</span><span class="params">(<span class="keyword">boolean</span> doStateMove, TransitionState state,</span></span></span><br><span class="line"><span class="function"><span class="params">	SparseArray&lt;Fragment&gt; firstOutFragments, SparseArray&lt;Fragment&gt; lastInFragments)</span> </span>&#123;</span><br><span class="line">    Op op = mTail;</span><br><span class="line">	<span class="keyword">while</span> (op != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> popEnterAnim = state != <span class="keyword">null</span> ? <span class="number">0</span> : op.popEnterAnim;</span><br><span class="line">		<span class="keyword">int</span> popExitAnim= state != <span class="keyword">null</span> ? <span class="number">0</span> : op.popExitAnim;</span><br><span class="line">		<span class="keyword">switch</span> (op.cmd) &#123;</span><br><span class="line">		<span class="keyword">case</span> OP_ADD: &#123;</span><br><span class="line">			Fragment f = op.fragment;</span><br><span class="line">			f.mNextAnim = popExitAnim;</span><br><span class="line">			mManager.removeFragment(f,</span><br><span class="line">			FragmentManagerImpl.reverseTransit(transition), transitionStyle);</span><br><span class="line">			&#125; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> OP_REMOVE: &#123;</span><br><span class="line">			Fragment f = op.fragment;</span><br><span class="line">			f.mNextAnim = popEnterAnim;</span><br><span class="line">			mManager.addFragment(f, <span class="keyword">false</span>);</span><br><span class="line">			&#125; <span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">//....</span></span><br><span class="line">		<span class="keyword">default</span>: &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unknown cmd: "</span> + op.cmd);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		op = op.prev;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (mIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		mManager.freeBackStackIndex(mIndex);</span><br><span class="line">		mIndex = -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码倒叙遍历之前的Op链表，以相反的方式执行Op链表。之前说到BackStackRecord中定义了8中Fragment操作，这8种操作都有互逆性，比如OP_ADD和OP_REMOVE就是相反的，OP_HIDE和OP_SHOW也是相反的，而OP_REPLACE则是一个OP_ADD和一组OP_REMOVE的组合。因此从这个方法的实现看，其实就是一个逆过程，比如之前的Op命令执行的是OP_ADD，这里只需要将这个Op中记录的Fragment移除就好了。通过这种方式，总能顺利的回退栈。</p>
<h4 id="popBackStackState方法后半段"><a href="#popBackStackState方法后半段" class="headerlink" title="popBackStackState方法后半段"></a>popBackStackState方法后半段</h4><p>继续回到popBackStackState方法，前面只讲了一半，还有一个If分支没有讲述，执行条件是：name或者id不为null其中一个有效或者设置了Flag POP_BACK_STACK_INCLUSIVE。这里可以看到程序是如何解释POP_BACK_STACK_INCLUSIVE这个Flag的，具体细节不解释，总结一下就是：对于popBackStack方法，如果int(flag)为POP_BACK_STACK_INCLUSIVE，则在这个name或者id标识的BackStackRecord以上的BackStackRecord包括自身都会被弹出，否则，自身不会被弹出，只有该Fragment以上的Fragemnt会被弹出。</p>
<p>name的含义很清楚，因为addToBackStack就要求传入一个String，但是id呢？这里可以看到一行代码:<br><strong>if (id &gt;= 0 &amp;&amp; id == bss.mIndex)</strong><br>是的，mIndex其实是BackStackRecord在栈中的位置！那么这个mIndex是在什么时候生成的呢？我们回退到commitInternal中，可以在这个方法实现中找到，在提交一个事务的时候，如果需要添加到事务回退栈，则会调用FragmentManager的allocBackStackIndex方法去分配一个Index。这个方法的实现也比较有意思。为了防止读者分心，此处不拓展讲述，读者只需要知道mIndex是BackStackRecord在栈中的位置就好。</p>
<p>因此，我们向事务栈中添加事务的时候，可以指定一个String作为此次添加的标记，当我们回退的时候，我们可以通过这个标记指定回退到某个历史状态，或者，直接通过位置去指定。</p>
<p>id是唯一的，一个位置上只能存储一个BackStackRecord，但是name却不唯一，多个BackStackRecord可以指定同一个BackStackRecord，如果我指定一个name去弹出，会发生什么呢？弹出栈的时候，首先找到name或者id匹配的那个BackStackRecord，如果没有找到，就直接返回，不进行退出操作。如果找到了，并且设置了POP_BACK_STACK_INCLUSIVE，会继续向下搜索，直到最后一个name或者id匹配的BackStackRecord才会结束。接下去后面的处理就和之前的类似了。</p>
<p>以上，是事务回退时的逻辑。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述，现在可以解答一开始提出的问题。第3个问题则在前面已经详细描述。</p>
<p>第1个问题：Fragment的事务和数据库中的事务是两个概念。虽然实际上它也是多个原子操作(Op)的组合，但是并不存在其中一个Op失败之后，回退其余Op的控制保证，这个事务目的是为了组合一堆零散的操作，以便于在一次提交中完成复杂的Fragment切换。而对于数据库而言，事务失败之后是需要回退到执行之前的样子的，Fragment的事务失败可以认为界面退出，它没有持久化保存任何数据，也没有后续的操作会受此次事务失败的影响，因此不需要做出保证。</p>
<p>关于Fragment的事务，还有一些细节没有去解读，但是大致的逻辑在此。读者如有补充，欢迎回复，如发现疑问，欢迎斧正。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android的数据恢复(二)]]></title>
      <url>http://www.timebridge.space/2015/10/17/Android-de-shu-ju-hui-fu-er/</url>
      <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近同事在开发中使用到FragmentStatePagerAdapter，在数据恢复的时候出现了非常奇怪的现象，因此研究了一下Fragment的数据恢复机制。</p>
<p><em>本文主要解决以下问题</em></p>
<ol>
<li>Fragment如何进行数据恢复和保存？</li>
<li>Fragment到底是啥？</li>
<li>Fragment的使用注意事项</li>
</ol>
<h2 id="Fragment如何进行数据恢复和保存"><a href="#Fragment如何进行数据恢复和保存" class="headerlink" title="Fragment如何进行数据恢复和保存"></a>Fragment如何进行数据恢复和保存</h2><p>和Actiivty一样，Fragment也有自己的生命周期，并且与Activity的生命周期紧密绑定在一起，一般一个页面要做数据保存和恢复都会涉及到Fragment，我们在<a href="http://muzileecoding.com/blog/2015/08/01/androidde-shu-ju-hui-fu/" target="_blank" rel="noopener">Android的数据恢复（一）</a>中解释了Activity是如何保存状态的，那么Fragment是否一样呢？<a id="more"></a></p>
<p><a href="http://muzileecoding.com/blog/2015/08/01/androidde-shu-ju-hui-fu/" target="_blank" rel="noopener">Android的数据恢复（一）</a>中说到: onSaveInstanceState方法是整个Activity保存数据的出发点，它的实现如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</span><br><span class="line">	outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState());</span><br><span class="line">	Parcelable p = mFragments.saveAllState();</span><br><span class="line">	<span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">		outState.putParcelable(FRAGMENTS_TAG, p);</span><br><span class="line">	&#125;</span><br><span class="line">	getApplication().dispatchActivitySaveInstanceState(<span class="keyword">this</span>, outState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的3-6行就涉及到Fragment的数据保存。我们看到mFragment通过saveAllState方法返回一个Parcelable对象，并最终存入outState中去了，mFragments是什么呢？其声明类型为：FragmentManagerImpl。顾名思义，是FragmentManager的实现类型。</p>
<blockquote>
<p>【Note】读者请打开Android Studio，查看FragmentManager的源码，版本是support-v4。</p>
</blockquote>
<p>由于FragmentManager的代码非常长，而且相互之间联系比较紧密，因此将标注过的代码传到了服务器：<a href="http://7xktd8.com1.z0.glb.clouddn.com/FragmentManager.java" target="_blank" rel="noopener">FragmentManager.java</a>、 <a href="http://7xktd8.com1.z0.glb.clouddn.com/Fragment.java" target="_blank" rel="noopener">Fragment.java</a>。<br>读者可以结合源码以及标注进行理解。建议就从FragmentManager.saveAllState()函数入手。</p>
<blockquote>
<p>【Note】代码很多非常长，有部分类也没有贴出来，但这两个类已经可以让读者知道Fragment的保存过程了。</p>
</blockquote>
<p>这里重点阐述几件事情:</p>
<ol>
<li>一个Activity对应着一个FragmentManager，每一个被添加的Fragment都会被记录在mActive中，显示移除的时候会将该位置记录为null，mAdded则记录着当前添加到容器里面的Fragment(mActive记录这所有被add的Fragment，mAdded则记录着所有被add和attach的Fragment，attach后的Fragment会被FragmentManager管理，但不会在ViewTree中);</li>
<li>保存状态的时候，状态保存是会遍历mActive里面的Fragment，同时也会以下标形式保存mAdded里面的元素，所有操作记录的BackStackRecord也会被保存下来：目的是可以恢复所有Active的Fragment的状态以及之前所做的Transaction动作。数据都被保存在FragmentManagerState中(此处分析的时候发现一个问题，从代码看，mActive的元素是mAdded元素的子集，当一个fragment detach、attach、detach一遍之后，保存mAdded下标就会crash);</li>
<li>恢复的时候则按照保存的数据逐步恢复，很重要的一个动作是在Activity的onCreate方法中，这个方法有如下调用：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (savedInstanceState != <span class="keyword">null</span>) &#123;</span><br><span class="line">		Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG);</span><br><span class="line">		mFragments.restoreAllState(p, mLastNonConfigurationInstances != <span class="keyword">null</span></span><br><span class="line">		                    ? mLastNonConfigurationInstances.fragments : <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">mFragments.dispatchCreate();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>第3行会restore保存的Fragment的状态，使变量赋值。第6行则会通知所有的Fragment进行onCreate()。注意restoreAllState这个函数第二个参数的判断，恢复Fragment发生在两种情况下：1)Config变化，最经典是屏幕旋转；2)saveInstanceState发生的时候。如果是前者就可以从mLastNonConfigurationInstances中拿出保存的fragments对象，否则就是null；</p>
<ol>
<li>Fragment恢复之后并不会替代你新建的Fragment，即：如果你在container里面加入了FragmentA，之后这个FragmentA实例被恢复重建，而你在Activity的onCreate方法中没有做任何检测再次新建FragmentA的实例并添加进入container，则会导致container有两个FragmentA的实例;</li>
</ol>
<h2 id="Fragment到底是啥"><a href="#Fragment到底是啥" class="headerlink" title="Fragment到底是啥"></a>Fragment到底是啥</h2><p>要解答这个问题，只需要看FragmentManager中moveToState方法的下列代码片段：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">f.mView = f.performCreateView(f.getLayoutInflater(f.mSavedFragmentState), container, f.mSavedFragmentState);</span><br><span class="line"><span class="keyword">if</span> (f.mView != <span class="keyword">null</span>) &#123;</span><br><span class="line">	f.mInnerView = f.mView;</span><br><span class="line">	f.mView = NoSaveStateFrameLayout.wrap(f.mView);</span><br><span class="line">	<span class="keyword">if</span> (container != <span class="keyword">null</span>) &#123;</span><br><span class="line">		Animation anim = loadAnimation(f, transit, <span class="keyword">true</span>, transitionStyle);</span><br><span class="line">		<span class="keyword">if</span> (anim != <span class="keyword">null</span>) &#123;</span><br><span class="line">			f.mView.startAnimation(anim);</span><br><span class="line">		&#125;</span><br><span class="line">		container.addView(f.mView);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (f.mHidden) </span><br><span class="line">		f.mView.setVisibility(View.GONE);</span><br><span class="line">	f.onViewCreated(f.mView, f.mSavedFragmentState);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	f.mInnerView = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第1行就是回调Fragment的onCreateView方法，所以f.mView就是我们在onCreateView中返回的View，而第10行则将f.mView添加到container中去。第14行回调Fragment的onViewCreated方法。到这里就很清楚：Fragment就是一个包装了生命周期的View，真正显示的机制过程和View一致。读者还可以通过FragmentManager.hideFragment方法验证一下这个结论。</p>
<h2 id="Fragment的使用注意事项"><a href="#Fragment的使用注意事项" class="headerlink" title="Fragment的使用注意事项"></a>Fragment的使用注意事项</h2><p>Fragment只是一个带有生命周期的View。写代码的时候首先需要注意的一点是：<br>往Container中添加Fragment的时候，需要去检测该Fragment是否存在，方法是getFragmentById和getFragmentByTag，否则在数据恢复的时候，就会造成多个相同的Fragment被创建。</p>
<p>其次，读者可以注意一下FragmentState这个类（用于保存Fragment的上下文环境以及重要参数，比如mIndex，mFragmentId，mContainerId，mClassName等），这个类里面还有一个非常重要的参数：mArguments。这个就是设置Fragment参数标准做法时所用到的，请见<a href="http://developer.android.com/reference/android/app/Fragment.html" target="_blank" rel="noopener">Developers</a>上的标准写法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DetailsFragment <span class="title">newInstance</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	DetailsFragment f = <span class="keyword">new</span> DetailsFragment();</span><br><span class="line">	<span class="comment">// Supply index input as an argument.</span></span><br><span class="line">	Bundle args = <span class="keyword">new</span> Bundle();</span><br><span class="line">	args.putInt(<span class="string">"index"</span>, index);</span><br><span class="line">	f.setArguments(args);</span><br><span class="line">	<span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为什么要这么写？或者说为什么这么写是标准的？因为通过Fragment.setArguments方法设置的bundle参数在数据保存的时候是会被保存下来的，恢复之后还能获取。而普通的带参构造函数并不能做到这一点。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最近开发的时候和同事遇到不少Fragment的相关问题，因此稍微做了一下研究。Fragment里面还有很多东西没有仔细参研，后面有时间会进一步挖掘。下一篇博客会以FragmentStatePagerAdapter为主题，因为在这个上面也遇到很坑的问题。<br>以上。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[观影《烈日灼心》]]></title>
      <url>http://www.timebridge.space/2015/10/17/lie-ri-zhuo-xin/</url>
      <content type="html"><![CDATA[<p>公司一文艺青年微信上力荐<a href="http://movie.douban.com/subject/24719063/?source=new_aladdin" target="_blank" rel="noopener">《烈日灼心》</a>，猫眼评分8.0，豆瓣评分8.0，周末无聊，闲来去看。</p>
<p>故事讲述的是三个年轻人，“杀害”了一家五口，在外躲避七年。七年间一个成了渔场的工人（陈比觉），一个成了出租车司机（杨自道），一个则成了协警（小丰）。后来警局来了新的警长（伊），在执勤中逐渐和小丰走近，伊刚出道由师傅带领办理的第一宗案件就是这起灭门案，七年未破，在接触中，伊逐渐发现线索，怀疑起小丰，小丰亦有所警觉，三兄弟商量之后打算先跑路，但他们“领养”的弃婴尾巴（尾巴其实是被杀女孩的女儿）此时却需要做手术，逼不得已三人留下来凑钱。<a id="more"></a>小丰在伊刚来的时候就敏锐的察觉到不安，因此搬出了警局的宿舍，然租房的房东是个BT，在房内装了窃听器，小丰每次和杨自道的谈话都被窃听并被记录。里面还有一个插曲，就是伊的妹妹在一起抢劫中意外结识了杨自道，杨自道为抓捕抢劫犯被砍了一刀，自此伊的妹妹就喜欢上了杨自道。小丰为洗脱自己的嫌疑，伪装成Gay，并把三兄弟也描述成Gay，伊妹妹得知此事后急于求证，并意外得知灭门案的真相，后打算去找杨自道（私奔？），伊跟随妹妹来到他们的出租屋，意外发现窃听器和笔记本，并得知整个事情的真相。在随后一次抓捕通缉犯的过程中，伊在生死关头劝小丰去自首，之后小丰和杨自道被抓，并将尾巴托付给伊和其妹妹。小丰和杨自道被安乐死，陈比觉逃脱。但事情真相却不是如此，随后抓捕的一个杀人犯承认当时灭门案件中，他杀害了死人，他们三人只杀害了那个女的。最后的结尾以陈比觉跳海自尽结束。<br><!-- more --><br>文字描述总是苍白的，这部电影表面平淡，既没有惊心动魄的线索分析，也没见血腥的枪战画面，但内在波涛汹涌，看的过程中总是不由自主的想起《肖申克的救赎》。</p>
<p>电影的主题是小丰说过的一句话：世界上没有什么坏人，也没有什么好人。这三个人犯了十恶不赦的罪行，也是别人眼中的好人，他们究竟是好是坏，一时之间难以决断。</p>
<p>故事一开始这三个年轻人就背负着“谋杀”的罪恶，陈比觉在逃跑中还不幸刺瞎了自己的右眼，七年后的形象更是一个傻子，有一种恶有恶报的暗示在其中，但是故事的主体部分却在不紧不慢的叙述这三个人的善良：小丰做了协警，在执勤的过程中非常的敏锐，也非常勇敢，尽职尽责，伊一直很看中他，不顾路途遥远，定期去看尾巴；杨自道在开车的时候遇到了劫匪，面对警察的盘问，他放走了三个劫匪，4000元现金也被带走了，而在买烟路上遇到劫匪则奋不顾身，开车直追，最后被砍一刀；陈比觉一直在渔场细心照看尾巴，在医院照顾她。一面是伊不断的发现线索，谋杀的罪名始终缭绕在剧情中，一面是三个人简简单单，善良的日常生活，最后升华是在小丰被抓前：</p>
<blockquote>
<p>伊问小丰:为什么，为什么会做那种事？小丰回答:我也想过。</p>
</blockquote>
<p>一种淡然，一种无奈。其实他们也不知道自己的人生怎么就变成了这样，三个人确实经历了那场谋杀案，并害死了一个女孩，但自此后的七年他们守着尾巴，悉心照料，如果不是伊出现，他们三人还是会继续这样生活下去，然伊的出现和BT房东却昭示着天网恢恢疏而不漏，最终这纸还是包不住火，三人在最后都选择了以死亡的代价为尾巴创造一个轻松的未来。</p>
<p>电影还有一个不明显的主题，但这个主题却更加有力：人生的选择。小丰在逃跑后选择回去抱回女婴，三人在七年中选择默默坚守尾巴，并在得知尾巴需要手术时放弃逃跑的最佳时机，伊选择在知晓下属知法犯法的时候“包庇”，杨自道和小丰在最后选择自首并认罪以给尾巴一个轻松的未来，陈比觉最后还是选择跳崖自尽。如果说三个人在一开始选择杀害女孩是错的，那他们之后的选择都是对的，也正因为这些选择，他们展现出善良的一面。在小丰被抓之后，伊去监狱看望他，小丰说：我现在可以说自己是一个好爸爸了。尾巴是他们的罪恶，也是他们的善良，好爸爸不仅是好爸爸，也是他们烈火灼心、自我救赎后的重新做人。</p>
<p>电影结尾比较有意思，在他们安乐死之后，剧情陡然一转，出现了真正的凶手，不知道是不是编剧想告诉观众：善良且悔过的人不该死。</p>
<p>虽然在观影中一直想起《肖申克的救赎》，但就像国人和外国人编写的技术书对比起来一样，一个清晰内敛，读起来轻松，一个相对而言杂乱贪多，读起来似有所悟却摸不清抓不着。尽管如此，确实不失为一部好电影。</p>
<blockquote>
<p>PS1:王珞丹的形象怎么总是略疯癫的….<br>PS2:租房子房东还是很重要的<br>PS3:以前听侯捷老师讲课，觉得台湾腔很好听，这部剧里面怎么就觉得台湾腔这么恶心？难道是因为Gay导致台湾腔听上去娘娘腔？<br>PS4:邓超确实是实力派，演技杠杠的，赞一个</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Markdown常用语法]]></title>
      <url>http://www.timebridge.space/2015/10/17/Markdown-chang-yong-yu-fa/</url>
      <content type="html"><![CDATA[<p>Markdown是一种标记语言，可以方便的转化为HTML，比如本文就是以Markdown编写，最终转化为网页展现在读者面前。这种标记语言相对于HTML来说功能有限，但是对于专心写文章的人来说，却非常足够(Markdown兼容HTML)。目前Github，StackOverFlow以及很多的博客网站、静态博客系统（Octopress, Hexo…）都支持Markdown语言，因此对于有兴趣的读者来说，学习markdown不仅成本小，而且实用性很大。<a id="more"></a></p>
<p>本文主要是是整理一些我常用到的且不容易记住的Markdown语法。这里先推荐一个Mac下的Markdown写作工具：Mou。而本文则是在另外一个编辑器”MacDown”下编写完成，MacDown基于Mou，两个我都用过，都挺不错。Windows下也有相应的编辑器，读者可以安装一枚。</p>
<p>下面内容随时更新。</p>
<p>###列表<br>无须列表前面加上*，+，-都可以表示，比如：</p>
<pre><code>*  AAAA
*  BBBB
*  CCCC
</code></pre><p>展示出来如下：</p>
<ul>
<li>AAAA</li>
<li>BBBB</li>
<li>CCCC</li>
</ul>
<p>有序列表则直接以数字表示：  </p>
<pre><code>*  AAAA
*  BBBB
*  CCCC
</code></pre><p>展示出来如下：</p>
<ol>
<li>AAAA</li>
<li>BBBB</li>
<li>CCCC</li>
</ol>
<p>但是注意：列表和前面文段之间需要加上一个空行，否则Mackdown语法不能识别。</p>
<p>###分割线<br>可以这样写（还有别的语法，但是学会一种就够啦）：  </p>
<pre><code>***
</code></pre><p> 展示出来如下:</p>
<hr>
<p>###代码<br>代码块有两种写法:<br>1）选中代码块，按Tab键，如下:</p>
<pre><code>AAA
BBB
</code></pre><p>展示出来如下:</p>
<pre><code>AAA
BBB
</code></pre><p>还有一种就是如下写:  </p>
<pre><code>​<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">​</span><br></pre></td></tr></table></figure>
</code></pre><p>效果则是这样的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>###图片<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![封面](http://7xktd8.com1.z0.glb.clouddn.com/cover.png)</span><br></pre></td></tr></table></figure></p>
<p>实际效果就是:<br><img src="http://7xktd8.com1.z0.glb.clouddn.com/cover.png" alt="封面"></p>
<p>###链接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[木子李的博客](http://www.muzileecoding.com/)</span><br></pre></td></tr></table></figure></p>
<p>实际效果是:<br><a href="http://www.muzileecoding.com/" target="_blank" rel="noopener">木子李的博客</a></p>
<p>###表格<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|文章 | 作者 |</span><br><span class="line">|:---|:--- |</span><br><span class="line">|Markdown常用语法|木子李|</span><br></pre></td></tr></table></figure></p>
<p>实际效果是:</p>
<table>
<thead>
<tr>
<th style="text-align:left">文章</th>
<th style="text-align:left">作者</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Markdown常用语法</td>
<td style="text-align:left">木子李</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    
  
  
</search>
