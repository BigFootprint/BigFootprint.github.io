<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="李全民的个人博客"><title>Android官方MVX项目解析 | 蜗牛壳</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-65882749-1','auto');ga('send','pageview');</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android官方MVX项目解析</h1><a id="logo" href="/.">蜗牛壳</a><p class="description">计算机只有 0 和 1 ，但世界是连续的</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android官方MVX项目解析</h1><div class="post-meta">Apr 22, 2016<span> | </span><span class="category"><a href="/categories/Android/">Android</a></span></div><div class="post-content"><blockquote>
<p><strong>设计</strong>, 即根据问题当前的情况以及未来可预见的变化，提供优雅的解决方案。何谓优雅，不是投机取巧，而是简单易懂，成本低。</p>
</blockquote>
<p>前段时间Google官方推出了<strong><a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="noopener">“Android Architecture Blueprints”</a></strong>项目。正如项目介绍中所说，虽然Android平台对于如何组织项目结构提供了很大的自由度，但这种自由度也造成了混乱，使得项目的测试、维护以及扩展遇到困难。</p>
<p>在这个项目里面，Google针对同一个应用使用不同的架构和技术进行实现，以帮助开发者解决问题。它的重点在于<strong>代码结构，项目架构，测试以及可维护性</strong>。研究这个项目要注意以下几件事情：</p>
<ol>
<li>架构以及架构的实现由很多种选择，取决于你的现实情况，因此这些例子只是一个指引，并不能作为规范；</li>
<li>这个项目还处于beta状态，后期可能会出现影响所有例子的改动；<a id="more"></a></li>
</ol>
<h2 id="项目目前状态"><a href="#项目目前状态" class="headerlink" title="项目目前状态"></a>项目目前状态</h2><p>第一期已经完成近二分之一了：</p>
<ol>
<li><strong>todo-mvp/</strong> 基础项目，使用MVP架构；</li>
<li><strong>todo-mvp-loaders/</strong> 基于mvp项目，但是是使用Loaders加载数据；</li>
<li><strong>todo-mvp-databinding/</strong> 基于mvp项目，使用Data Binding库实现；</li>
</ol>
<p>剩余的还有几种技术的组合，目前还在开发中。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>直接clone项目即可，分支如下：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/android-architecture.png" height="250" alt="One Piece"></div><br>从分支命名可以看出目前该项目所做的一些工作以及所使用的技术。<br><br>## MVP<br>todo-mvp是所有例子的基础，它没有依赖任何的其余框架实现了MVP架构。这里重点分析<code>origin/todo-mvp</code>分支代码。<br><br>### 项目结构<br><div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/mvp项目结构.png" width="500" alt="One Piece"></div>

<p>如图所示，除了源码文件夹，还有四个文件夹是专门为测试建立的，关于测试这里不分析，但会阐述一下MVP结构对于测试的支持。</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/MVP项目结构-Detail.png" width="500" alt="One Piece"></div>

<p>在这里可以看到项目的分包特点：<strong>整体分包是按照页面功能分的，从外部并不能显示的看出是MVP模式</strong>。</p>
<p>我们展开详细看一下：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/mvp项目结构-Expand.png" width="500" alt="One Piece"></div>

<p><code>A</code>处是添加Task的页面，这里面有四个类，可以清晰的看到P的存在，每个类具体的含义下一节细说，<code>B</code>从包名以及类名可以推测出是数据源，也就是Model。<code>C</code>处定义了基本的V和P的接口。</p>
<blockquote>
<p>这个项目的UI都是由Activity + Fragment组成的，Activity和Fragment扮演的角色并不一样。</p>
</blockquote>
<h3 id="项目细说——职责和组装"><a href="#项目细说——职责和组装" class="headerlink" title="项目细说——职责和组装"></a>项目细说——职责和组装</h3><p>首先我们先看一下V和P的基本接口定义，如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BasePresenter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseView</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPresenter</span><span class="params">(T presenter)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简单，P里面只有一个<code>start()</code>方法，表示初始加载数据。V中也只有一个方法<code>setPresenter()</code>，用于给V设置对应的P。</p>
<p>接着我们看A中圈出的四个类（这四个类对应实现了一个界面，这里拉出来作为例子，其余的界面实现也是一致的），这几个类的关系如下：</p>
<ol>
<li><strong><code>AddEditTaskContract</code></strong> 扩展BaseView和BasePresenter接口，定义该页面V和P需要实现的接口；</li>
<li><strong><code>AddEditTaskFragment</code></strong> V接口的实现；</li>
<li><strong><code>AddEditTaskPresenter</code></strong> P接口的实现；</li>
<li><strong><code>AddEditTaskActivity</code></strong> M、V、P三者的组装；</li>
</ol>
<p><code>AddEditTaskActivity</code>的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">	setContentView(R.layout.addtask_act);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set up the toolbar.</span></span><br><span class="line">	Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);</span><br><span class="line">	setSupportActionBar(toolbar);</span><br><span class="line">	ActionBar actionBar = getSupportActionBar();</span><br><span class="line">	actionBar.setDisplayHomeAsUpEnabled(<span class="keyword">true</span>);</span><br><span class="line">	actionBar.setDisplayShowHomeEnabled(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建View</span></span><br><span class="line">	AddEditTaskFragment addEditTaskFragment = (AddEditTaskFragment) getSupportFragmentManager().findFragmentById(R.id.contentFrame);</span><br><span class="line"></span><br><span class="line">	String taskId = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (addEditTaskFragment == <span class="keyword">null</span>) &#123;</span><br><span class="line">		addEditTaskFragment = AddEditTaskFragment.newInstance();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (getIntent().hasExtra(AddEditTaskFragment.ARGUMENT_EDIT_TASK_ID)) &#123;</span><br><span class="line">		taskId = getIntent().getStringExtra(AddEditTaskFragment.ARGUMENT_EDIT_TASK_ID);</span><br><span class="line">		actionBar.setTitle(R.string.edit_task);</span><br><span class="line">		Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">		bundle.putString(AddEditTaskFragment.ARGUMENT_EDIT_TASK_ID, taskId);</span><br><span class="line">			addEditTaskFragment.setArguments(bundle);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			actionBar.setTitle(R.string.add_task);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ActivityUtils.addFragmentToActivity(getSupportFragmentManager(), addEditTaskFragment, R.id.contentFrame);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建Presenter并将View传递给Presenter</span></span><br><span class="line">	<span class="keyword">new</span> AddEditTaskPresenter(taskId, </span><br><span class="line">	<span class="comment">// 创建M</span></span><br><span class="line">	Injection.provideTasksRepository(getApplicationContext()), addEditTaskFragment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如注释所描述，Activity创建了V、P、M，并将M、V传递给了P，<code>AddEditTaskPresenter</code>的构造函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AddEditTaskPresenter</span><span class="params">(@Nullable String taskId, @NonNull TasksDataSource tasksRepository, @NonNull AddEditTaskContract.View addTaskView)</span> </span>&#123;</span><br><span class="line">	mTaskId = taskId;</span><br><span class="line">	<span class="comment">//获取到M</span></span><br><span class="line">	mTasksRepository = checkNotNull(tasksRepository);</span><br><span class="line">	mAddTaskView = checkNotNull(addTaskView);</span><br><span class="line">	<span class="comment">//组装M和P</span></span><br><span class="line">	mAddTaskView.setPresenter(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一行，P将自己设置为V的Presenter。即Activity的<code>onCreate()</code>方法执行完毕后，M、V、P三个部分组装完毕。<strong>除了组装，Activity还负责一件很重要的事情:初始化数据环境</strong>。从<code>onCreate()</code>方法可以看到，Activity获取了对应的taskId，并传递给了<code>AddEditTaskFragment</code>和<code>AddEditTaskPresenter</code>两者，这样在编辑一个Task的时候，Presenter才知道具体的编辑对象。</p>
<blockquote>
<p>这里taskId应该传入到<code>AddEditTaskFragment</code>中么？从实现上看，这个taskId在<code>AddEditTaskFragment</code>用于判断是在编辑一个Task还是在创建一个Task，这个逻辑应该放在P层更加合适。</p>
</blockquote>
<p><strong>组装完毕之后，整个页面是在哪里启动的呢？在V中，由V的生命周期触发。</strong><code>AddEditTaskFragment</code>的<code>onResume()</code>方法实现如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.onResume();</span><br><span class="line">	mPresenter.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法里面触发了mPresenter的<code>start()</code>方法加载数据(正因为Activity初始化了数据环境，因此<code>start()</code>函数不需要任何的参数）。</p>
<p><code>start()</code>方法会加载数据，我们来看逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	openTask();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">null</span> == mTaskId || mTaskId.isEmpty()) &#123;</span><br><span class="line">		mTaskDetailView.showMissingTask();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mTaskDetailView.setLoadingIndicator(<span class="keyword">true</span>);</span><br><span class="line">	mTasksRepository.getTask(mTaskId, <span class="keyword">new</span> TasksDataSource.GetTaskCallback() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTaskLoaded</span><span class="params">(Task task)</span> </span>&#123;</span><br><span class="line">			<span class="comment">// The view may not be able to handle UI updates anymore</span></span><br><span class="line">			<span class="keyword">if</span> (!mTaskDetailView.isActive()) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			mTaskDetailView.setLoadingIndicator(<span class="keyword">false</span>);</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">null</span> == task) &#123;</span><br><span class="line">				mTaskDetailView.showMissingTask();</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				showTask(task);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataNotAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="comment">// The view may not be able to handle UI updates anymore</span></span><br><span class="line">			<span class="keyword">if</span> (!mTaskDetailView.isActive()) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			mTaskDetailView.showMissingTask();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法是用于打开一个Task，它是通过<code>mTasksRepository</code>来加载数据的。<code>TasksRepository</code>是一个很重要的类，它实现了<code>TasksDataSource</code>接口：这个接口中定义了很多的有关Task操作的方法，有增删改查等。<code>TasksRepository</code>是<code>TasksDataSource</code>的一个实现，其余实现类如下：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/TasksDataSource实现类.png" height="100" alt="TasksDataSource实现类"></div>

<p>这四个实现的关系如下：</p>
<ol>
<li><code>TasksLocalDataSource</code>和<code>TasksRemoteDataSource</code>分别通过<code>TasksDataSource</code>定义的API实现了Task的本地（数据库）保存和远端保存（代码里面是一段假实现，Mock了一下从服务器上操作Task资源的过程）；</li>
<li><code>TasksRepository</code>通过以上两个类实现了<code>TasksDataSource</code>:把相关的请求直接代理给以上两个类；</li>
<li><code>FakeTasksRemoteDataSource</code>则是一个完全的Mock类，用于给自动化测试提供数据源；</li>
</ol>
<p>关于第2点，可以看<code>TasksRepository</code>中的一个方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveTask</span><span class="params">(@NonNull Task task)</span> </span>&#123;</span><br><span class="line">	checkNotNull(task);</span><br><span class="line">	mTasksRemoteDataSource.saveTask(task);</span><br><span class="line">	mTasksLocalDataSource.saveTask(task);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Do in memory cache update to keep the app UI up to date</span></span><br><span class="line">	<span class="keyword">if</span> (mCachedTasks == <span class="keyword">null</span>) &#123;</span><br><span class="line">		mCachedTasks = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">	mCachedTasks.put(task.getId(), task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在这个MVP的实现中，M对上是暴露出接口的（即<code>TasksDataSource</code>），并且整个App的数据接口都定义在一个接口中，这样在进行测试的时候便于提供Fake数据源。M层加载完数据之后是通过回调来告诉P层的，在<code>TasksDataSource</code>中我们可以看到两个回调接口的定义:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">LoadTasksCallback</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onTasksLoaded</span><span class="params">(List&lt;Task&gt; tasks)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onDataNotAvailable</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GetTaskCallback</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onTaskLoaded</span><span class="params">(Task task)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onDataNotAvailable</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PS: <code>TasksRepository</code>是单例设计。</p>
</blockquote>
<p>以上，我们知道了最基本的MVP的实现中各个类的大体作用、位置以及它们的关系。</p>
<h2 id="MVP-Loader"><a href="#MVP-Loader" class="headerlink" title="MVP-Loader"></a>MVP-Loader</h2><p>这个分支演示的是如何通过Loader实现MVP架构。前面介绍的基本结构以及各个类的职责都没有变化。Loader主要是用于数据异步加载的，因此在Model这块变化比较大。</p>
<blockquote>
<p>关于Loader如果有疑问，可以阅读文章：<a href="http://www.muzileecoding.com/androidsource/Android-loader-and-loadermanager.html" target="_blank" rel="noopener">Loader &amp; LoaderManager</a>。</p>
</blockquote>
<p>下面我们来看变化。首先在组装上不太一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create the loader and presenter</span></span><br><span class="line">TaskLoader taskLoader = <span class="keyword">new</span> TaskLoader(taskId, getApplicationContext());</span><br><span class="line"><span class="keyword">new</span> AddEditTaskPresenter(taskId, Injection.provideTasksRepository(getApplicationContext()), addEditTaskFragment, taskLoader, getSupportLoaderManager());</span><br></pre></td></tr></table></figure>
<p>这里在创建P的时候，还创建了Loader并将它传入给了P，P怎么使用这个Loader呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddEditTaskPresenter</span> <span class="keyword">implements</span> <span class="title">AddEditTaskContract</span>.<span class="title">Presenter</span>,</span></span><br><span class="line"><span class="class">        <span class="title">LoaderManager</span>.<span class="title">LoaderCallbacks</span>&lt;<span class="title">Task</span>&gt; </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		mLoaderManager.initLoader(TASK_QUERY, <span class="keyword">null</span>, <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>P的<code>start()</code>方法直接代理给了Loader，并且P自身实现了LoaderCallbacks回调。</p>
<p>在整个App里面总共实现了两个Loader，一个用于加载单个Task，一个用于加载所有的Task。前面提到过原始的MVP实现中<code>TasksDataSource</code>有两个回调接口来告诉P层数据加载完毕，这两个接口在这种实现中已经被Loader代替掉。</p>
<p>这种实现的另外一个有意思的地方是：<code>TasksRepository</code>里面可以设置观察者，而每一个Loader都实现了接口，成为相应的观察者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TasksRepositoryObserver</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onTasksChanged</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TasksLoader</span> <span class="keyword">extends</span> <span class="title">AsyncTaskLoader</span>&lt;<span class="title">List</span>&lt;<span class="title">Task</span>&gt;&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">TasksRepository</span>.<span class="title">TasksRepositoryObserver</span></span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是利用了Loader的特性：Loader在监听到数据变化之后，可以通过<code>forceLoad()</code>方法重新加载数据并回调通知上层，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTasksChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (isStarted()) &#123;</span><br><span class="line">		forceLoad();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种组合看上去也非常棒，整个结构流转如下：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/mvp-loader.png" height="400" alt="mvp-loader"></div>

<p>因为<code>TasksRepository</code>是单例的，页面只要通过Loader从数据源中加载数据，就等于是在数据源中设置了一个监听：因此这种设计可以监听所有数据的变化。</p>
<h3 id="TODO：继续分析其余实现方式"><a href="#TODO：继续分析其余实现方式" class="headerlink" title="TODO：继续分析其余实现方式"></a>TODO：继续分析其余实现方式</h3></div><div class="tags"><a href="/tags/代码设计/">代码设计</a></div><div class="post-nav"><a href="/2016/05/03/Android-instantrun/" class="pre">Instant Run 简介</a><a href="/2016/04/21/Apk-reverse-engineering/" class="next">反编译APK</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">59</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactiveX/">ReactiveX</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/后端/">后端</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/影视/">影视</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/电影/">电影</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Gitbook/" style="font-size: 15px;">Gitbook</a> <a href="/tags/Runtime/" style="font-size: 15px;">Runtime</a> <a href="/tags/视图/" style="font-size: 15px;">视图</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/权限/" style="font-size: 15px;">权限</a> <a href="/tags/代码优化/" style="font-size: 15px;">代码优化</a> <a href="/tags/Framework/" style="font-size: 15px;">Framework</a> <a href="/tags/性能优化/" style="font-size: 15px;">性能优化</a> <a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/合集/" style="font-size: 15px;">合集</a> <a href="/tags/ADB/" style="font-size: 15px;">ADB</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/反编译/" style="font-size: 15px;">反编译</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/Gradle/" style="font-size: 15px;">Gradle</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/基础/" style="font-size: 15px;">基础</a> <a href="/tags/效率/" style="font-size: 15px;">效率</a> <a href="/tags/MarkDown/" style="font-size: 15px;">MarkDown</a> <a href="/tags/电影/" style="font-size: 15px;">电影</a> <a href="/tags/Reactive/" style="font-size: 15px;">Reactive</a> <a href="/tags/AIDL/" style="font-size: 15px;">AIDL</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/驱动/" style="font-size: 15px;">驱动</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/日志/" style="font-size: 15px;">日志</a> <a href="/tags/事件/" style="font-size: 15px;">事件</a> <a href="/tags/代码设计/" style="font-size: 15px;">代码设计</a> <a href="/tags/网络/" style="font-size: 15px;">网络</a> <a href="/tags/测试/" style="font-size: 15px;">测试</a> <a href="/tags/Binder/" style="font-size: 15px;">Binder</a> <a href="/tags/Groovy/" style="font-size: 15px;">Groovy</a> <a href="/tags/Loader/" style="font-size: 15px;">Loader</a> <a href="/tags/RAC/" style="font-size: 15px;">RAC</a> <a href="/tags/事件处理/" style="font-size: 15px;">事件处理</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/10/30/AIDL-原理分析/">AIDL 原理分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/30/App-启动过程/">App 启动过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/PMS-解析/">PMS 解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/WMS-解析/">WindowManagerService 解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/AMS-解析/">AMS 解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/10/The-Good-Wife/">The-Good-Wife</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/10/Black-Sails/">黑帆</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/29/hello-world/">Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/23/XCode-8-2-1-ClangFormat-插件安装/">XCode 8.2.1 ClangFormat 插件安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/07/SourceTree-分支图谱/">SourceTree 分支图谱</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">蜗牛壳.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>