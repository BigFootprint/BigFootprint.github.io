<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="李全民的个人博客"><title>Binder之Service查询 | 蜗牛壳</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-65882749-1','auto');ga('send','pageview');</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Binder之Service查询</h1><a id="logo" href="/.">蜗牛壳</a><p class="description">计算机只有 0 和 1 ，但世界是连续的</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Binder之Service查询</h1><div class="post-meta">Jun 21, 2016<span> | </span><span class="category"><a href="/categories/Android/">Android</a></span></div><div class="post-content"><p>前一篇文章<a href="http://www.muzileecoding.com/framework/binder-service-register.html" target="_blank" rel="noopener">Binder之Service注册</a>描述了一个 Service 如何在 SM 中完成服务注册，接下来就是要探索如何向 SM 查询这个服务。有前一篇的基础，希望这一篇可以快一些~</p>
<blockquote>
<p>【注意】服务查询和服务注册过程其实非常接近，因此本文会大量引用前一篇文章的分析过程，读者可以仔细阅读上一篇文章之后再来阅读这篇文章。</p>
</blockquote>
<p>本文将以 <strong>前文</strong> 指代文章<a href="http://www.muzileecoding.com/framework/binder-service-register.html" target="_blank" rel="noopener">Binder之Service注册</a>。<a id="more"></a></p>
<h2 id="研究入口"><a href="#研究入口" class="headerlink" title="研究入口"></a>研究入口</h2><p>上一篇研究的对象是 MediaServer 和 MediaPlayerService，可以猜测一下在整个系统中必然有<code>getMediaPlayerService()</code>方法的调用，在 AndroidXRef 中搜索 “getMediaPlayerService” 字符串，很快就可以发现有很多类中调用了这个方法，我们选择 “IMediaDeathNotifier.cpp” 中的一段代码作为入口进行研究：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// establish binder interface to MediaPlayerService</span></span><br><span class="line"><span class="comment">/*static*/</span><span class="keyword">const</span> sp&lt;IMediaPlayerService&gt;&amp;</span><br><span class="line">IMediaDeathNotifier::getMediaPlayerService()</span><br><span class="line">&#123;</span><br><span class="line">    LOGV(<span class="string">"getMediaPlayerService"</span>);</span><br><span class="line">    Mutex::Autolock _l(sServiceLock);</span><br><span class="line">    <span class="keyword">if</span> (sMediaPlayerService.get() == <span class="number">0</span>) &#123;</span><br><span class="line">        sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line">        sp&lt;IBinder&gt; binder;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            binder = sm-&gt;getService(String16(<span class="string">"media.player"</span>));</span><br><span class="line">            <span class="keyword">if</span> (binder != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             usleep(<span class="number">500000</span>); <span class="comment">// 0.5 s</span></span><br><span class="line">        &#125; <span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sDeathNotifier == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        sDeathNotifier = <span class="keyword">new</span> DeathNotifier();</span><br><span class="line">    &#125;</span><br><span class="line">    binder-&gt;linkToDeath(sDeathNotifier);</span><br><span class="line">    sMediaPlayerService = interface_cast&lt;IMediaPlayerService&gt;(binder);</span><br><span class="line">    &#125;</span><br><span class="line">    LOGE_IF(sMediaPlayerService == <span class="number">0</span>, <span class="string">"no media player service!?"</span>);</span><br><span class="line">    <span class="keyword">return</span> sMediaPlayerService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码其实就是<code>getMediaPlayerService</code>方法的实现代码。可以看到核心代码其实只有三行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line">binder = sm-&gt;getService(String16(<span class="string">"media.player"</span>));</span><br><span class="line">sMediaPlayerService = interface_cast&lt;IMediaPlayerService&gt;(binder);</span><br></pre></td></tr></table></figure>
<p>第一行代码是获取 SM 实例的，这一点在前文中已经有非常详细的解析过程，这里就不再重复解析了。重点是后面两句。</p>
<p><strong>【涉及文件】</strong></p>
<table>
<thead>
<tr>
<th>文件</th>
<th>位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>IMediaDeathNotifier.cpp</td>
<td>/frameworks/base/media/libmedia/IMediaDeathNotifier.cpp</td>
</tr>
</tbody>
</table>
<p>包括前文所提到的文件。</p>
<h2 id="发送服务获取命令"><a href="#发送服务获取命令" class="headerlink" title="发送服务获取命令"></a>发送服务获取命令</h2><p>服务获取调用的代码是:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binder = sm-&gt;getService(String16(<span class="string">"media.player"</span>));</span><br></pre></td></tr></table></figure>
<p><code>getService()</code>方法的实现如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> sp&lt;IBinder&gt; getService(<span class="keyword">const</span> String16&amp; name) <span class="keyword">const</span> &#123;</span><br><span class="line">	<span class="keyword">unsigned</span> n;</span><br><span class="line">	<span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; <span class="number">5</span>; n++)&#123;</span><br><span class="line">		<span class="comment">// 调用checkService方法获取</span></span><br><span class="line">		sp&lt;IBinder&gt; svc = checkService(name);</span><br><span class="line">		<span class="keyword">if</span> (svc != <span class="literal">NULL</span>) <span class="keyword">return</span> svc;</span><br><span class="line">		LOGI(<span class="string">"Waiting for service %s...\n"</span>, String8(name).<span class="built_in">string</span>());</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> sp&lt;IBinder&gt; checkService( <span class="keyword">const</span> String16&amp; name) <span class="keyword">const</span> &#123;</span><br><span class="line">	Parcel data, reply;</span><br><span class="line">	data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());</span><br><span class="line">	data.writeString16(name);</span><br><span class="line">	remote()-&gt;transact(CHECK_SERVICE_TRANSACTION, data, &amp;reply);</span><br><span class="line">	<span class="keyword">return</span> reply.readStrongBinder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些方法名字虽然第一次见，可是内容应该非常熟悉了 —— 和注册服务非常非常接近，只不过这一次命令有所变化。关于<code>transact()</code>方法的追踪，上一篇文章中也有非常详细的分析，详见前文 5.2 节。根据前文，我们最终会来到：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用代码: writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL);</span></span><br><span class="line"><span class="comment">// 参数解释: handle 为 0，code 为 CHECK_SERVICE_TRANSACTION， binderFlags 是 TF_ACCEPT_FDS;</span></span><br><span class="line"><span class="keyword">status_t</span> IPCThreadState::writeTransactionData(<span class="keyword">int32_t</span> cmd, <span class="keyword">uint32_t</span> binderFlags,</span><br><span class="line">    <span class="keyword">int32_t</span> handle, <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, <span class="keyword">status_t</span>* statusBuffer)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 该结构体在字典中可查</span></span><br><span class="line">    binder_transaction_data tr;</span><br><span class="line"></span><br><span class="line">    tr.target.handle = handle;</span><br><span class="line">    tr.code = code;</span><br><span class="line">    tr.flags = binderFlags;</span><br><span class="line">    tr.cookie = <span class="number">0</span>;</span><br><span class="line">    tr.sender_pid = <span class="number">0</span>;</span><br><span class="line">    tr.sender_euid = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">status_t</span> err = data.errorCheck();</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">    	<span class="comment">// 将之前写在 data 中的数据再换一种形式写到 binder_transaction_data 中</span></span><br><span class="line">        tr.data_size = data.ipcDataSize(); </span><br><span class="line">        tr.data.ptr.buffer = data.ipcData(); </span><br><span class="line">        tr.offsets_size = data.ipcObjectsCount()*<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>);</span><br><span class="line">        tr.data.ptr.offsets = data.ipcObjects(); </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusBuffer) &#123;</span><br><span class="line">        tr.flags |= TF_STATUS_CODE;</span><br><span class="line">        *statusBuffer = err;</span><br><span class="line">        tr.data_size = <span class="keyword">sizeof</span>(<span class="keyword">status_t</span>);</span><br><span class="line">        tr.data.ptr.buffer = statusBuffer;</span><br><span class="line">        tr.offsets_size = <span class="number">0</span>;</span><br><span class="line">        tr.data.ptr.offsets = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mOut.writeInt32(cmd);<span class="comment">//BC_TRANSACTION</span></span><br><span class="line">    mOut.write(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里要注意的是，除了命令不一样，数据上也有差别了。前文中是进行服务注册，所以数据中是携带了一个序列化的服务节点的，但这里很简单，只有想要获取的服务名字而已。</p>
<h2 id="SM-处理命令"><a href="#SM-处理命令" class="headerlink" title="SM 处理命令"></a>SM 处理命令</h2><p>中间的驱动处理和前文基本一致，这里略去分析，主要是看 SM 如何处理这个命令，处理函数是<code>svcmgr_handler</code>: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint16_t</span> svcmgr_id[] = &#123; </span><br><span class="line">    <span class="string">'a'</span>,<span class="string">'n'</span>,<span class="string">'d'</span>,<span class="string">'r'</span>,<span class="string">'o'</span>,<span class="string">'i'</span>,<span class="string">'d'</span>,<span class="string">'.'</span>,<span class="string">'o'</span>,<span class="string">'s'</span>,<span class="string">'.'</span>,</span><br><span class="line">    <span class="string">'I'</span>,<span class="string">'S'</span>,<span class="string">'e'</span>,<span class="string">'r'</span>,<span class="string">'v'</span>,<span class="string">'i'</span>,<span class="string">'c'</span>,<span class="string">'e'</span>,<span class="string">'M'</span>,<span class="string">'a'</span>,<span class="string">'n'</span>,<span class="string">'a'</span>,<span class="string">'g'</span>,<span class="string">'e'</span>,<span class="string">'r'</span> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">svcmgr_handler</span><span class="params">(struct binder_state *bs,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_txn *txn,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_io *msg,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_io *reply)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span> *<span class="title">si</span>;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> *s;</span><br><span class="line">    <span class="keyword">unsigned</span> len;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="keyword">uint32_t</span> strict_policy;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// svcmgr_handle 被赋值为 svcmgr，即BINDER_SERVICE_MANAGER，即0</span></span><br><span class="line">    <span class="keyword">if</span> (txn-&gt;target != svcmgr_handle)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Equivalent to Parcel::enforceInterface(), reading the RPC</span></span><br><span class="line">    <span class="comment">// header with the strict mode policy mask and the interface name.</span></span><br><span class="line">    <span class="comment">// Note that we ignore the strict_policy and don't propagate it</span></span><br><span class="line">    <span class="comment">// further (since we do no outbound RPCs anyway).</span></span><br><span class="line">    strict_policy = bio_get_uint32(msg);</span><br><span class="line">    s = bio_get_string16(msg, &amp;len);</span><br><span class="line">    <span class="comment">// svcmgr_id是一个字符数组，见最上面，这里判断是通过的，因为s读取出来就是"android.os.IServiceManager"</span></span><br><span class="line">    <span class="keyword">if</span> ((len != (<span class="keyword">sizeof</span>(svcmgr_id) / <span class="number">2</span>)) ||</span><br><span class="line">        <span class="built_in">memcmp</span>(svcmgr_id, s, <span class="keyword">sizeof</span>(svcmgr_id))) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"invalid id %s\n"</span>, str8(s));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(txn-&gt;code) &#123;</span><br><span class="line">    <span class="keyword">case</span> SVC_MGR_GET_SERVICE:</span><br><span class="line">    <span class="keyword">case</span> SVC_MGR_CHECK_SERVICE:</span><br><span class="line">        s = bio_get_string16(msg, &amp;len); <span class="comment">// "media.player"</span></span><br><span class="line">        ptr = do_find_service(bs, s, len);</span><br><span class="line">        <span class="keyword">if</span> (!ptr)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        bio_put_ref(reply, ptr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bio_put_uint32(reply, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里其实可以看到，获取服务和查询服务的处理流程是一样的。</p>
<blockquote>
<p>至于为什么会落到<code>SVC_MGR_CHECK_SERVICE</code>这个命令，前文也有解释。</p>
</blockquote>
<p>在获取服务名称之后，调用<code>do_find_service</code>方法来查询服务: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">do_find_service</span><span class="params">(struct binder_state *bs, <span class="keyword">uint16_t</span> *s, <span class="keyword">unsigned</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span> *<span class="title">si</span>;</span></span><br><span class="line">    si = find_svc(s, len);</span><br><span class="line"></span><br><span class="line"><span class="comment">//    LOGI("check_service('%s') ptr = %p\n", str8(s), si ? si-&gt;ptr : 0);</span></span><br><span class="line">    <span class="keyword">if</span> (si &amp;&amp; si-&gt;ptr) &#123;</span><br><span class="line">        <span class="keyword">return</span> si-&gt;ptr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct svcinfo *<span class="title">find_svc</span><span class="params">(<span class="keyword">uint16_t</span> *s16, <span class="keyword">unsigned</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span> *<span class="title">si</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (si = svclist; si; si = si-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((len == si-&gt;len) &amp;&amp;</span><br><span class="line">            !<span class="built_in">memcmp</span>(s16, si-&gt;name, len * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>))) &#123;</span><br><span class="line">            <span class="keyword">return</span> si;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数<code>find_svc</code>前文已经解析过了，这里其实就是找到在 svclist 中是否有对应的 svcinfo 节点，名称与需要查找的服务名称一致，如果有，则返回 svcinfo 的 ptr 字段，ptr 字段的来源前文也有解释: 服务在 SM 中分配得到的 handle 值。也就是说，返回这个 handle 值就好了。</p>
<p>找到 ptr 之后，我们回到<code>do_find_service</code>，在这里会调用<code>bio_put_ref</code>方法:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bio_put_ref</span><span class="params">(struct binder_io *bio, <span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 该结构体在字典中可查</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_object</span> *<span class="title">obj</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr)</span><br><span class="line">        obj = bio_alloc_obj(bio);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        obj = bio_alloc(bio, <span class="keyword">sizeof</span>(*obj));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!obj)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    obj-&gt;flags = <span class="number">0x7f</span> | FLAT_BINDER_FLAG_ACCEPTS_FDS;</span><br><span class="line">    obj-&gt;type = BINDER_TYPE_HANDLE;</span><br><span class="line">    obj-&gt;pointer = ptr;</span><br><span class="line">    obj-&gt;cookie = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有必要好好分析一下 binder_io 这个结构体相关的方法了，它们集中在 “binder.c” 文件中。首先来看<code>bio_alloc_obj</code>方法: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct binder_object *<span class="title">bio_alloc_obj</span><span class="params">(struct binder_io *bio)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_object</span> *<span class="title">obj</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 下面解释 bio_alloc 方法</span></span><br><span class="line">    obj = bio_alloc(bio, <span class="keyword">sizeof</span>(*obj));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (obj &amp;&amp; bio-&gt;offs_avail) &#123;</span><br><span class="line">    	<span class="comment">// 表示偏移数据可记录数目又少了1，因为下面即将记录新的偏移信息</span></span><br><span class="line">        bio-&gt;offs_avail--;</span><br><span class="line">        <span class="comment">// 记录新的 binder_object 在结构体中的偏移量</span></span><br><span class="line">        *bio-&gt;offs++ = ((<span class="keyword">char</span>*) obj) - ((<span class="keyword">char</span>*) bio-&gt;data0);</span><br><span class="line">        <span class="comment">// 返回 binder_object 结构体的起始位置</span></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bio-&gt;flags |= BIO_F_OVERFLOW;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法声明了一个 <code>binder_object</code> 的结构体，实例化方法调用的是<code>bio_alloc</code>: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">bio_alloc</span><span class="params">(struct binder_io *bio, <span class="keyword">uint32_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    size = (size + <span class="number">3</span>) &amp; (~<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (size &gt; bio-&gt;data_avail) &#123;</span><br><span class="line">        bio-&gt;flags |= BIO_F_OVERFLOW;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *ptr = bio-&gt;data;</span><br><span class="line">        bio-&gt;data += size;</span><br><span class="line">        bio-&gt;data_avail -= size;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法非常简单，首先检测传入的参数 binder_io 是否还有足够的容量分配 size 的空间，如果足够，就操作 data 和 data_avail 变量，仅这样来表示空间分配。方法会返回分配空间的起始地址。综上，这组方法以及 binder_io 结构体其实是对内存分配的一个封装。</p>
<p>回到<code>bio_alloc_obj</code>方法后的代码都有注释，不难理解。再回到<code>bio_put_ref</code>方法后，会在该结构体中填充以下数据: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">obj-&gt;flags = <span class="number">0x7f</span> | FLAT_BINDER_FLAG_ACCEPTS_FDS;</span><br><span class="line">obj-&gt;type = BINDER_TYPE_HANDLE;</span><br><span class="line">obj-&gt;pointer = ptr;</span><br><span class="line">obj-&gt;cookie = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>这部分数据很重要，后面还会用到。回到<code>svcmgr_handler</code>函数，还会执行下面语句才会返回:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bio_put_uint32(reply, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bio_put_uint32</span><span class="params">(struct binder_io *bio, <span class="keyword">uint32_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> *ptr = bio_alloc(bio, <span class="keyword">sizeof</span>(n));</span><br><span class="line">    <span class="keyword">if</span> (ptr)</span><br><span class="line">        *ptr = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是在 binder_io 结构体中分配空间写入数据。执行完毕之后，回到函数<code>binder_parse</code>中:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_parse</span><span class="params">(struct binder_state *bs, struct binder_io *bio,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">uint32_t</span> *ptr, <span class="keyword">uint32_t</span> size, binder_handler func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> *end = ptr + (size / <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (ptr &lt; end) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> cmd = *ptr++;</span><br><span class="line">        <span class="keyword">switch</span>(cmd) &#123;</span><br><span class="line">            ......</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION: &#123;</span><br><span class="line">        	<span class="comment">//该结构体字典中可查</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_txn</span> *<span class="title">txn</span> = (<span class="title">void</span> *) <span class="title">ptr</span>;</span></span><br><span class="line">            <span class="keyword">if</span> ((end - ptr) * <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>) &lt; <span class="keyword">sizeof</span>(struct binder_txn)) &#123;</span><br><span class="line">                LOGE(<span class="string">"parse: txn too small!\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            binder_dump_txn(txn);</span><br><span class="line">            <span class="keyword">if</span> (func) &#123;</span><br><span class="line">                <span class="keyword">unsigned</span> rdata[<span class="number">256</span>/<span class="number">4</span>];</span><br><span class="line">                <span class="comment">// 该结构体字典中可查</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">binder_io</span> <span class="title">msg</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">binder_io</span> <span class="title">reply</span>;</span></span><br><span class="line">                <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">                bio_init(&amp;reply, rdata, <span class="keyword">sizeof</span>(rdata), <span class="number">4</span>);</span><br><span class="line">                bio_init_from_txn(&amp;msg, txn);</span><br><span class="line">                <span class="comment">// 刚刚在这里，不清楚的可以看前文</span></span><br><span class="line">                res = func(bs, txn, &amp;msg, &amp;reply);</span><br><span class="line">                binder_send_reply(bs, &amp;reply, txn-&gt;data, res);</span><br><span class="line">            &#125;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(*txn) / <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下去就是要执行<code>binder_send_reply</code>方法发送 reply 数据:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数解释：status 为0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binder_send_reply</span><span class="params">(struct binder_state *bs,</span></span></span><br><span class="line"><span class="function"><span class="params">                       struct binder_io *reply,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">void</span> *buffer_to_free,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> status)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> cmd_free;</span><br><span class="line">        <span class="keyword">void</span> *buffer;</span><br><span class="line">        <span class="keyword">uint32_t</span> cmd_reply;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_txn</span> <span class="title">txn</span>;</span></span><br><span class="line">    &#125; __attribute__((packed)) data;</span><br><span class="line"></span><br><span class="line">    data.cmd_free = BC_FREE_BUFFER; <span class="comment">// 注意命令</span></span><br><span class="line">    data.buffer = buffer_to_free;</span><br><span class="line">    data.cmd_reply = BC_REPLY; <span class="comment">// 注意命令</span></span><br><span class="line">    data.txn.target = <span class="number">0</span>;</span><br><span class="line">    data.txn.cookie = <span class="number">0</span>;</span><br><span class="line">    data.txn.code = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (status) &#123;</span><br><span class="line">        data.txn.flags = TF_STATUS_CODE;</span><br><span class="line">        data.txn.data_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">        data.txn.offs_size = <span class="number">0</span>;</span><br><span class="line">        data.txn.data = &amp;status;</span><br><span class="line">        data.txn.offs = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 走这里，和前面的分析一对比就非常清晰</span></span><br><span class="line">        data.txn.flags = <span class="number">0</span>;</span><br><span class="line">        data.txn.data_size = reply-&gt;data - reply-&gt;data0;</span><br><span class="line">        data.txn.offs_size = ((<span class="keyword">char</span>*) reply-&gt;offs) - ((<span class="keyword">char</span>*) reply-&gt;offs0);</span><br><span class="line">        data.txn.data = reply-&gt;data0;</span><br><span class="line">        data.txn.offs = reply-&gt;offs0;</span><br><span class="line">    &#125;</span><br><span class="line">    binder_write(bs, &amp;data, <span class="keyword">sizeof</span>(data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>reply 中的数据部分包含两组数据，一个是一个 binder_io 结构体，一个则是整数 0。接下去就不分析了，和前文一样，我们直接进入驱动。</p>
<h2 id="驱动节点生成"><a href="#驱动节点生成" class="headerlink" title="驱动节点生成"></a>驱动节点生成</h2><p>根据前文的分析，答复的处理肯定经过方法<code>binder_transaction</code>，这也是本文分析的重点，我们看看和服务注册具体有什么区别。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_transaction</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_transaction_data *tr, <span class="keyword">int</span> reply)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	......</span><br><span class="line">    <span class="comment">// 核心不同！确实有数据，是通过 binder_object 结构体写入的</span></span><br><span class="line">    off_end = (<span class="keyword">void</span> *)offp + tr-&gt;offsets_size;</span><br><span class="line">    <span class="keyword">for</span> (; offp &lt; off_end; offp++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> *<span class="title">fp</span>;</span></span><br><span class="line">        fp = (struct flat_binder_object *)(t-&gt;buffer-&gt;data + *offp);</span><br><span class="line">        <span class="keyword">switch</span> (fp-&gt;type) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_HANDLE:</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_WEAK_HANDLE: &#123;</span><br><span class="line">            <span class="comment">// 获取服务注册的时候在 SM 中生成的 binder_ref</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span> *<span class="title">ref</span> = <span class="title">binder_get_ref</span>(<span class="title">proc</span>, <span class="title">fp</span>-&gt;<span class="title">handle</span>);</span></span><br><span class="line">            <span class="comment">// 权限检测</span></span><br><span class="line">            <span class="keyword">if</span> (security_binder_transfer_binder(proc-&gt;tsk, target_proc-&gt;tsk)) &#123;</span><br><span class="line">                return_error = BR_FAILED_REPLY;</span><br><span class="line">                <span class="keyword">goto</span> err_binder_get_ref_failed;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ref-&gt;node-&gt;proc == target_proc) &#123;<span class="comment">// 如果请求的服务节点的进程就是请求发起的进程</span></span><br><span class="line">                <span class="keyword">if</span> (fp-&gt;type == BINDER_TYPE_HANDLE)</span><br><span class="line">                    fp-&gt;type = BINDER_TYPE_BINDER; <span class="comment">// 直接更改为 binder 实体节点，不需要引用</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    fp-&gt;type = BINDER_TYPE_WEAK_BINDER;</span><br><span class="line">                fp-&gt;binder = ref-&gt;node-&gt;ptr;</span><br><span class="line">                fp-&gt;cookie = ref-&gt;node-&gt;cookie;</span><br><span class="line">                binder_inc_node(ref-&gt;node, fp-&gt;type == BINDER_TYPE_BINDER, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">                trace_binder_transaction_ref_to_node(t, ref);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                struct binder_ref *new_ref;</span><br><span class="line">                <span class="comment">// ⭐️在目标进程，也就是请求进程中查看该节点的引用，没有则新建</span></span><br><span class="line">                new_ref = binder_get_ref_for_node(target_proc, ref-&gt;node);</span><br><span class="line">                <span class="comment">// 拿到该服务节点在本进程中的 handle 值</span></span><br><span class="line">                fp-&gt;handle = new_ref-&gt;desc;</span><br><span class="line">                binder_inc_ref(new_ref, fp-&gt;type == BINDER_TYPE_HANDLE, <span class="literal">NULL</span>);</span><br><span class="line">                trace_binder_transaction_ref_to_ref(t, ref,</span><br><span class="line">                                    new_ref);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">        BUG_ON(t-&gt;buffer-&gt;async_transaction != <span class="number">0</span>);</span><br><span class="line">        binder_pop_transaction(target_thread, in_reply_to);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 挂载节点</span></span><br><span class="line">    t-&gt;work.type = BINDER_WORK_TRANSACTION;</span><br><span class="line">    list_add_tail(&amp;t-&gt;work.entry, target_list);</span><br><span class="line">    tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;</span><br><span class="line">    list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);</span><br><span class="line">    <span class="keyword">if</span> (target_wait)</span><br><span class="line">        wake_up_interruptible(target_wait);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法前半部分的处理和服务注册都类似，核心不同在于驱动对数据的处理上：</p>
<p><strong>服务注册，binder_transaction中的 binder 节点是一个 binder_node 实体节点，在驱动中它会将它换成 BINDER_TYPE_HANDLE 类型，并在请求注册的进程上生成新的实体节点；但是服务查询中，却只会判断该服务是否属于当前进程，如果服务属于当前进程，则会换成 BINDER_TYPE_BINDER 类型；否则会以 BINDER_TYPE_HANDLE 类型继续传递处理。尤其要注意⭐️的地方！</strong></p>
<p>经过数据处理，binder_transaction 的数据内容已经变化。到这里，SM 的处理全部完成。</p>
<h2 id="查询方的等待"><a href="#查询方的等待" class="headerlink" title="查询方的等待"></a>查询方的等待</h2><p>查询方此时必然在<code>binder_thread_read</code>方法中等待: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_read</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                  struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">void</span>  __user *buffer, <span class="keyword">int</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">signed</span> <span class="keyword">long</span> *consumed, <span class="keyword">int</span> non_block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">w</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span> = <span class="title">NULL</span>;</span></span><br><span class="line">        <span class="keyword">if</span> (!list_empty(&amp;thread-&gt;todo))</span><br><span class="line">            w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work)</span><br><span class="line">            w = list_first_entry(&amp;proc-&gt;todo, struct binder_work, entry);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ptr - buffer == <span class="number">4</span> &amp;&amp; !(thread-&gt;looper &amp; BINDER_LOOPER_STATE_NEED_RETURN)) <span class="comment">/* no data added */</span></span><br><span class="line">                <span class="keyword">goto</span> retry;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end - ptr &lt; <span class="keyword">sizeof</span>(tr) + <span class="number">4</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">switch</span> (w-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> BINDER_WORK_TRANSACTION: &#123;</span><br><span class="line">            t = container_of(w, struct binder_transaction, work);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        ......</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!t)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// reply 的时候，该字段赋值为 NULL</span></span><br><span class="line">        <span class="keyword">if</span> (t-&gt;buffer-&gt;target_node) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 走这里</span></span><br><span class="line">            tr.target.ptr = <span class="literal">NULL</span>;</span><br><span class="line">            tr.cookie = <span class="literal">NULL</span>;</span><br><span class="line">            cmd = BR_REPLY;</span><br><span class="line">        &#125;</span><br><span class="line">        tr.code = t-&gt;code;</span><br><span class="line">        tr.flags = t-&gt;flags;</span><br><span class="line">        tr.sender_euid = t-&gt;sender_euid;</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;from) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">sender</span> = <span class="title">t</span>-&gt;<span class="title">from</span>-&gt;<span class="title">proc</span>-&gt;<span class="title">tsk</span>;</span></span><br><span class="line">            tr.sender_pid = task_tgid_nr_ns(sender,</span><br><span class="line">                            current-&gt;nsproxy-&gt;pid_ns);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tr.sender_pid = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tr.data_size = t-&gt;buffer-&gt;data_size;</span><br><span class="line">        tr.offsets_size = t-&gt;buffer-&gt;offsets_size;</span><br><span class="line">        tr.data.ptr.buffer = (<span class="keyword">void</span> *)t-&gt;buffer-&gt;data +</span><br><span class="line">                    proc-&gt;user_buffer_offset;</span><br><span class="line">        tr.data.ptr.offsets = tr.data.ptr.buffer +</span><br><span class="line">                    ALIGN(t-&gt;buffer-&gt;data_size,</span><br><span class="line">                        <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line">        <span class="keyword">if</span> (put_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(ptr, &amp;tr, <span class="keyword">sizeof</span>(tr)))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(tr);</span><br><span class="line">        trace_binder_transaction_received(t);</span><br><span class="line">        binder_stat_br(proc, thread, cmd);</span><br><span class="line">        list_del(&amp;t-&gt;work.entry);</span><br><span class="line">        t-&gt;buffer-&gt;allow_user_free = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (cmd == BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">            t-&gt;to_parent = thread-&gt;transaction_stack;</span><br><span class="line">            t-&gt;to_thread = thread;</span><br><span class="line">            thread-&gt;transaction_stack = t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            t-&gt;buffer-&gt;transaction = <span class="literal">NULL</span>;</span><br><span class="line">            kfree(t);</span><br><span class="line">            binder_stats_deleted(BINDER_STAT_TRANSACTION);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有必要详细分析一下数据内容了。这里面有一段很重要的数据拷贝: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tr.data_size = t-&gt;buffer-&gt;data_size;</span><br><span class="line">tr.offsets_size = t-&gt;buffer-&gt;offsets_size;</span><br><span class="line">tr.data.ptr.buffer = (<span class="keyword">void</span> *)t-&gt;buffer-&gt;data + proc-&gt;user_buffer_offset;</span><br><span class="line">tr.data.ptr.offsets = tr.data.ptr.buffer + ALIGN(t-&gt;buffer-&gt;data_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line"><span class="keyword">if</span> (put_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">	<span class="keyword">return</span> -EFAULT;</span><br><span class="line">ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line"><span class="keyword">if</span> (copy_to_user(ptr, &amp;tr, <span class="keyword">sizeof</span>(tr)))</span><br><span class="line">	<span class="keyword">return</span> -EFAULT;</span><br></pre></td></tr></table></figure>
<p>首先将数据内容和偏移数据大小记录下来，接着将数据地址映射到用户空间，以便于用户空间可以直接访问这块内存。之后拷贝<code>BR_TRANSACTION</code>命令，拷贝 binder_transaction_data 结构体后返回。中间过程比较冗长，在前文中也做了分析，我们直接到处理返回结果的地方。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::waitForResponse(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> cmd;</span><br><span class="line">    <span class="keyword">int32_t</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        err = mIn.errorCheck();</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (mIn.dataAvail() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        cmd = mIn.readInt32();</span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">            ......</span><br><span class="line">        <span class="keyword">case</span> BR_REPLY:</span><br><span class="line">            &#123;</span><br><span class="line">                binder_transaction_data tr;</span><br><span class="line">                err = mIn.read(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line">                LOG_ASSERT(err == NO_ERROR, <span class="string">"Not enough command data for brREPLY"</span>);</span><br><span class="line">                <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((tr.flags &amp; TF_STATUS_CODE) == <span class="number">0</span>) &#123;</span><br><span class="line">                        reply-&gt;ipcSetDataReference(</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                            tr.data_size,</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                            tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>),</span><br><span class="line">                            freeBuffer, <span class="keyword">this</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        err = *<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">status_t</span>*&gt;(tr.data.ptr.buffer);</span><br><span class="line">                        freeBuffer(<span class="literal">NULL</span>,</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                            tr.data_size,</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                            tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>), <span class="keyword">this</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ......</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里首先从 mIn 中把 binder_transaction_data 结构体读出来，然后调用<code>Parcel.ipcSetDataReference()</code>方法把数据写入到 reply 中去：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 调用代码:reply-&gt;ipcSetDataReference(</span></span><br><span class="line"><span class="comment"> *                          reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),</span></span><br><span class="line"><span class="comment"> *                          tr.data_size,</span></span><br><span class="line"><span class="comment"> *                          reinterpret_cast&lt;const size_t*&gt;(tr.data.ptr.offsets),</span></span><br><span class="line"><span class="comment"> *                          tr.offsets_size/sizeof(size_t),</span></span><br><span class="line"><span class="comment"> *                          freeBuffer, this);</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">void</span> Parcel::ipcSetDataReference(<span class="keyword">const</span> <span class="keyword">uint8_t</span>* data, <span class="keyword">size_t</span> dataSize,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span>* objects, <span class="keyword">size_t</span> objectsCount, release_func relFunc, <span class="keyword">void</span>* relCookie)</span><br><span class="line">&#123;</span><br><span class="line">    freeDataNoInit();</span><br><span class="line">    mError = NO_ERROR;</span><br><span class="line">    mData = <span class="keyword">const_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(data);</span><br><span class="line">    mDataSize = mDataCapacity = dataSize;</span><br><span class="line">    mDataPos = <span class="number">0</span>;</span><br><span class="line">    LOGV(<span class="string">"setDataReference Setting data pos of %p to %d\n"</span>, <span class="keyword">this</span>, mDataPos);</span><br><span class="line">    mObjects = <span class="keyword">const_cast</span>&lt;<span class="keyword">size_t</span>*&gt;(objects);</span><br><span class="line">    mObjectsSize = mObjectsCapacity = objectsCount;</span><br><span class="line">    mNextObjectHint = <span class="number">0</span>;</span><br><span class="line">    mOwner = relFunc;</span><br><span class="line">    mOwnerCookie = relCookie;</span><br><span class="line">    scanForFds();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这几个参数前面基本都见过，不多做解释，但是 objectsCount 的计算式是<code>tr.offsets_size/sizeof(size_t)</code>，即偏移数据量尺寸除以偏移记录大小，因此就是偏移记录的条数，也就是记录的对象数，因为是查询服务，从前面的分析来看，这里只返回了一个对象。然后根据 objects 参数，就可以从 data 中获取到所有的 binder 节点数据。</p>
<p>而 reply 参数是怎么来的呢？来自这里:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remote()-&gt;transact(CHECK_SERVICE_TRANSACTION, data, &amp;reply);</span><br></pre></td></tr></table></figure>
<p>接下去一句便是: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> reply.readStrongBinder();</span><br></pre></td></tr></table></figure>
<p>如上分析，此时 reply 中已经有有关 binder 的数据了，那么是怎么读取的呢？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IBinder&gt; Parcel::readStrongBinder() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;IBinder&gt; val;</span><br><span class="line">    unflatten_binder(ProcessState::self(), *<span class="keyword">this</span>, &amp;val);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> unflatten_binder(<span class="keyword">const</span> sp&lt;ProcessState&gt;&amp; proc,</span><br><span class="line">    <span class="keyword">const</span> Parcel&amp; in, sp&lt;IBinder&gt;* out)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> flat_binder_object* flat = in.readObject(<span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (flat) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (flat-&gt;type) &#123;</span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_BINDER:</span><br><span class="line">                *out = <span class="keyword">static_cast</span>&lt;IBinder*&gt;(flat-&gt;cookie);</span><br><span class="line">                <span class="keyword">return</span> finish_unflatten_binder(<span class="literal">NULL</span>, *flat, in);</span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_HANDLE:</span><br><span class="line">                *out = proc-&gt;getStrongProxyForHandle(flat-&gt;handle);</span><br><span class="line">                <span class="keyword">return</span> finish_unflatten_binder(</span><br><span class="line">                    <span class="keyword">static_cast</span>&lt;BpBinder*&gt;(out-&gt;get()), *flat, in);</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BAD_TYPE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际的读取是在<code>readObject</code>中进行的:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> flat_binder_object* Parcel::readObject(<span class="keyword">bool</span> nullMetaData) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> DPOS = mDataPos;</span><br><span class="line">    <span class="comment">// 首先判断剩余数据量是否足以读取出一个 flat_binder_object</span></span><br><span class="line">    <span class="keyword">if</span> ((DPOS+<span class="keyword">sizeof</span>(flat_binder_object)) &lt;= mDataSize) &#123;</span><br><span class="line">        <span class="comment">// 强转读取</span></span><br><span class="line">        <span class="keyword">const</span> flat_binder_object* obj</span><br><span class="line">                = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> flat_binder_object*&gt;(mData+DPOS);</span><br><span class="line">        mDataPos = DPOS + <span class="keyword">sizeof</span>(flat_binder_object);</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// Ensure that this object is valid...</span></span><br><span class="line">        <span class="keyword">size_t</span>* <span class="keyword">const</span> OBJS = mObjects;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">size_t</span> N = mObjectsSize;</span><br><span class="line">        <span class="keyword">size_t</span> opos = mNextObjectHint;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            LOGV(<span class="string">"Parcel %p looking for obj at %d, hint=%d\n"</span>,</span><br><span class="line">                 <span class="keyword">this</span>, DPOS, opos);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Start at the current hint position, looking for an object at</span></span><br><span class="line">            <span class="comment">// the current data position.</span></span><br><span class="line">            <span class="keyword">if</span> (opos &lt; N) &#123;</span><br><span class="line">                <span class="keyword">while</span> (opos &lt; (N<span class="number">-1</span>) &amp;&amp; OBJS[opos] &lt; DPOS) &#123;</span><br><span class="line">                    opos++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                opos = N<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (OBJS[opos] == DPOS) &#123;</span><br><span class="line">                mNextObjectHint = opos+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> obj;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// Look backwards for it...</span></span><br><span class="line">            <span class="keyword">while</span> (opos &gt; <span class="number">0</span> &amp;&amp; OBJS[opos] &gt; DPOS) &#123;</span><br><span class="line">                opos--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (OBJS[opos] == DPOS) &#123;</span><br><span class="line">                <span class="comment">// Found it!</span></span><br><span class="line">                LOGV(<span class="string">"Parcel found obj %d at index %d with backward search"</span>,</span><br><span class="line">                     <span class="keyword">this</span>, DPOS, opos);</span><br><span class="line">                mNextObjectHint = opos+<span class="number">1</span>;</span><br><span class="line">                LOGV(<span class="string">"readObject Setting data pos of %p to %d\n"</span>, <span class="keyword">this</span>, mDataPos);</span><br><span class="line">                <span class="keyword">return</span> obj;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是一个简单的读取，但是会做一些校验。在当前情况下，当然可以找到我们想要的 flat_binder_object 结构体对象，接着回到<code>unflatten_binder</code>，执行如下代码: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flat) &#123;</span><br><span class="line">	<span class="keyword">switch</span> (flat-&gt;type) &#123;</span><br><span class="line">		<span class="keyword">case</span> BINDER_TYPE_BINDER:</span><br><span class="line">				*out = <span class="keyword">static_cast</span>&lt;IBinder*&gt;(flat-&gt;cookie);</span><br><span class="line"> 				<span class="keyword">return</span> finish_unflatten_binder(<span class="literal">NULL</span>, *flat, in);</span><br><span class="line">		<span class="keyword">case</span> BINDER_TYPE_HANDLE:</span><br><span class="line">				*out = proc-&gt;getStrongProxyForHandle(flat-&gt;handle);</span><br><span class="line">				<span class="keyword">return</span> finish_unflatten_binder(</span><br><span class="line">                    	<span class="keyword">static_cast</span>&lt;BpBinder*&gt;(out-&gt;get()), *flat, in);</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>很明显，我们返回的 Binder 类型是 BINDER_TYPE_HANDLE 的。out 最后被赋值为 <code>proc-&gt;getStrongProxyForHandle(flat-&gt;handle);</code>，<code>getStrongProxyForHandle</code>这个函数我们也是见过的，这里再分析一次，因为情景有些不同。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(<span class="keyword">int32_t</span> handle)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;IBinder&gt; result;</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// handle 为0</span></span><br><span class="line">    handle_entry* e = lookupHandleLocked(handle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// We need to create a new BpBinder if there isn't currently one, OR we</span></span><br><span class="line">        <span class="comment">// are unable to acquire a weak reference on this current one.  See comment</span></span><br><span class="line">        <span class="comment">// in getWeakProxyForHandle() for more info about this.</span></span><br><span class="line">        IBinder* b = e-&gt;binder;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">NULL</span> || !e-&gt;refs-&gt;attemptIncWeak(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            b = <span class="keyword">new</span> BpBinder(handle); </span><br><span class="line">            e-&gt;binder = b;</span><br><span class="line">            <span class="keyword">if</span> (b) e-&gt;refs = b-&gt;getWeakRefs();</span><br><span class="line">            result = b;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// This little bit of nastyness is to allow us to add a primary</span></span><br><span class="line">            <span class="comment">// reference to the remote proxy when this team doesn't have one</span></span><br><span class="line">            <span class="comment">// but another team is sending the handle to us.</span></span><br><span class="line">            result.force_set(b);</span><br><span class="line">            e-&gt;refs-&gt;decWeak(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ProcessState::handle_entry* ProcessState::lookupHandleLocked(<span class="keyword">int32_t</span> handle)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> N = mHandleToObject.size();</span><br><span class="line">    <span class="keyword">if</span> (N &lt;= (<span class="keyword">size_t</span>)handle) &#123;</span><br><span class="line">        handle_entry e;</span><br><span class="line">        e.binder = <span class="literal">NULL</span>;</span><br><span class="line">        e.refs = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">status_t</span> err = mHandleToObject.insertAt(e, N, handle+<span class="number">1</span>-N);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;mHandleToObject.editItemAt(handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为是初次获取这个服务，因此实际上<code>lookupHandleLocked</code>返回的还是一个新建的 handle_entry 结构体，因此实际上<code>getStrongProxyForHandle</code>返回的对象就是<code>new BpBinder(handle)</code>，这整个过程返回的则是<code>new BpBinder(flat-&gt;handle)</code>对象。</p>
<h2 id="最后的交互"><a href="#最后的交互" class="headerlink" title="最后的交互"></a>最后的交互</h2><p>现在Client已经拿到这个<code>new BpBinder(flat-&gt;handle)</code>了，那么怎么和远程服务通信呢？这个其实在注册服务中也分析过了，只不过那时候<code>flat-&gt;handle</code>为 0 而已，而在<code>binder_transaction</code>方法中，是否为 0 是有区别的:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tr-&gt;target.handle) &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span> *<span class="title">ref</span>;</span></span><br><span class="line">	ref = binder_get_ref(proc, tr-&gt;target.handle);</span><br><span class="line">	target_node = ref-&gt;node;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	target_node = binder_context_mgr_node;</span><br><span class="line">	<span class="keyword">if</span> (target_node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		return_error = BR_DEAD_REPLY;</span><br><span class="line">		<span class="keyword">goto</span> err_no_context_mgr_node;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 handle 为 0，默认目标服务节点就是<code>binder_context_mgr_node</code>，但如果不为 0，则会在进程(<code>binder_proc</code>对象)的红黑树中寻找，这个寻找一定是OK的，因为在查询服务的时候就把<code>binder_ref</code>节点插入到红黑树中去了。自然而然也就能定位到目标进程，从而发送请求。</p>
<h2 id="interface-cast"><a href="#interface-cast" class="headerlink" title="interface_cast"></a>interface_cast</h2><p>在发送服务请求之前，还需要做一次转换，因为我们还不知道远程服务的API是什么样子的，这就是<code>IMediaDeathNotifier::getMediaPlayerService()</code>方法中最后一句的作用:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sMediaPlayerService = interface_cast&lt;IMediaPlayerService&gt;(binder);</span><br></pre></td></tr></table></figure>
<p><code>interface_cast</code>在前文已经分析过一次了，很容易推断出最终<code>interface_cast&lt;IMediaPlayerService&gt;(binder);</code>返回的值是：<strong><code>new BpMediaPlayerService(new BpBinder(flat-&gt;handle))</code></strong>。</p>
<p>这在下图中也能看到该对象:</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/Binder-Lib层架构.png" alt="Binder Lib层架构"></div>

<p>这里就不多做分析了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，搜寻服务也分析完毕。如果读者对这几篇文章都已经比较熟悉，墙裂建议阅读推荐文章①和文章③两系列博客！整个分析下来，Binder 机制所做的重要事情如下：</p>
<ol>
<li>启动 SM，并且固定 SM 的 handle 值为0，这样任何其余的服务都可以随时获取到 SM 服务；</li>
<li>服务启动后都会去 SM 注册，这个注册的过程是：在驱动层本进程的映射数据结构<code>binder_proc</code>中生成对应的<code>binder_node</code>节点，这个节点在穿越驱动边界的时候，会在目标进程中生成<code>binder_ref</code>结构体，注册的时候，这个目标进程就是 SM，也就是说 SM 会持有所有服务的引用；</li>
<li>服务查询的时候，也是问询 SM ，SM 就通过名字查询对应的服务引用，在返回的时候同样需要穿越驱动边界，驱动又会查询目标进程是否有该服务节点的引用，没有的话又会去目标进程生成一个，并且生成对应的 handle 值，这个值会最总返回到 Libraries 层；</li>
<li>在 Librries 层会通过 <code>new BpXXXService(new BpBinder(handle))</code>的形式生成服务对象这其实是一个代理，最外层的<code>new BpXXXService()</code>最主要的目的是找到<code>XXXService</code>的接口，而内部<code>new BpBinder(handle)</code>则是为了将请求转发给真正的服务进程，因为这个时候持有 handle，就可以在驱动层查询到对应的<code>binder_node</code>节点，从而可以向对方 proc/thread 挂载任务并唤醒对方；</li>
</ol>
<p>以上。</p>
</div><div class="tags"><a href="/tags/源码/">源码</a><a href="/tags/Binder/">Binder</a></div><div class="post-nav"><a href="/2016/07/30/ReactiveX/" class="pre">ReactiveX 初探</a><a href="/2016/06/21/binder-service-register/" class="next">Binder之Service注册</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">59</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactiveX/">ReactiveX</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/后端/">后端</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/影视/">影视</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/电影/">电影</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Gitbook/" style="font-size: 15px;">Gitbook</a> <a href="/tags/Runtime/" style="font-size: 15px;">Runtime</a> <a href="/tags/视图/" style="font-size: 15px;">视图</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/权限/" style="font-size: 15px;">权限</a> <a href="/tags/代码优化/" style="font-size: 15px;">代码优化</a> <a href="/tags/Framework/" style="font-size: 15px;">Framework</a> <a href="/tags/性能优化/" style="font-size: 15px;">性能优化</a> <a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/合集/" style="font-size: 15px;">合集</a> <a href="/tags/ADB/" style="font-size: 15px;">ADB</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/反编译/" style="font-size: 15px;">反编译</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/Gradle/" style="font-size: 15px;">Gradle</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/基础/" style="font-size: 15px;">基础</a> <a href="/tags/效率/" style="font-size: 15px;">效率</a> <a href="/tags/MarkDown/" style="font-size: 15px;">MarkDown</a> <a href="/tags/电影/" style="font-size: 15px;">电影</a> <a href="/tags/Reactive/" style="font-size: 15px;">Reactive</a> <a href="/tags/AIDL/" style="font-size: 15px;">AIDL</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/驱动/" style="font-size: 15px;">驱动</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/日志/" style="font-size: 15px;">日志</a> <a href="/tags/事件/" style="font-size: 15px;">事件</a> <a href="/tags/代码设计/" style="font-size: 15px;">代码设计</a> <a href="/tags/网络/" style="font-size: 15px;">网络</a> <a href="/tags/测试/" style="font-size: 15px;">测试</a> <a href="/tags/Binder/" style="font-size: 15px;">Binder</a> <a href="/tags/Groovy/" style="font-size: 15px;">Groovy</a> <a href="/tags/Loader/" style="font-size: 15px;">Loader</a> <a href="/tags/RAC/" style="font-size: 15px;">RAC</a> <a href="/tags/事件处理/" style="font-size: 15px;">事件处理</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/10/30/AIDL-原理分析/">AIDL 原理分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/30/App-启动过程/">App 启动过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/PMS-解析/">PMS 解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/WMS-解析/">WindowManagerService 解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/AMS-解析/">AMS 解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/10/The-Good-Wife/">The-Good-Wife</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/10/Black-Sails/">黑帆</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/29/hello-world/">Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/23/XCode-8-2-1-ClangFormat-插件安装/">XCode 8.2.1 ClangFormat 插件安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/07/SourceTree-分支图谱/">SourceTree 分支图谱</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">蜗牛壳.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>