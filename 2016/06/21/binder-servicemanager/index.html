<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="李全民的个人博客"><title>Binder之Service Manager | 蜗牛壳</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-65882749-1','auto');ga('send','pageview');</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Binder之Service Manager</h1><a id="logo" href="/.">蜗牛壳</a><p class="description">计算机只有 0 和 1 ，但世界是连续的</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Binder之Service Manager</h1><div class="post-meta">Jun 21, 2016<span> | </span><span class="category"><a href="/categories/Android/">Android</a></span></div><div class="post-content"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>Service Manager (以下简称 SM )在 Binder 框架中负责的是维护 Service 的查询工作：给我一个名字，给你想要的服务。</strong>要注意的是：这里所说的 SM 并不是我们日常开发中用到的 SM，那个是 Java 层的封装，这里所讲的 SM 位于 Libraries 层。</p>
<p><strong>【涉及文件】</strong></p>
<table>
<thead>
<tr>
<th>文件</th>
<th>位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>service_manager.c</td>
<td>/frameworks/base/cmds/servicemanager/service_manager.c</td>
</tr>
<tr>
<td>Libraries 层 binder.c</td>
<td>/frameworks/base/cmds/servicemanager/binder.c</td>
</tr>
<tr>
<td>驱动层 binder.c</td>
<td>kernel/common/drivers/staging/android/binder.c</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<p>##主要函数调用<br>SM 的启动 main 函数位于”service_manager.c”文件中:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_state</span> *<span class="title">bs</span>;</span></span><br><span class="line">    <span class="comment">// #define BINDER_SERVICE_MANAGER ((void*) 0) </span></span><br><span class="line">    <span class="keyword">void</span> *svcmgr = BINDER_SERVICE_MANAGER;</span><br><span class="line">    <span class="comment">// 1. 打开 Binder 驱动</span></span><br><span class="line">    bs = binder_open(<span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 注册成为 SM</span></span><br><span class="line">    <span class="keyword">if</span> (binder_become_context_manager(bs)) &#123;</span><br><span class="line">        LOGE(<span class="string">"cannot become context manager (%s)\n"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    svcmgr_handle = svcmgr;</span><br><span class="line">    <span class="comment">// 3. 启动循环监听</span></span><br><span class="line">    binder_loop(bs, svcmgr_handler);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要步骤就如代码中注释的那样，分为三步:</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/service_manager_main.png" width="320" alt="SM main函数调用"></div>

<p>我们就从这三步入手，逐步解析 SM 的启动过程。</p>
<h2 id="打开-Binder-驱动"><a href="#打开-Binder-驱动" class="headerlink" title="打开 Binder 驱动"></a>打开 Binder 驱动</h2><p><code>binder_open</code>，顾名思义就是打开 binder 驱动，来看看它在打开时做了什么:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用代码: bs = binder_open(128*1024);</span></span><br><span class="line"><span class="function">struct binder_state *<span class="title">binder_open</span><span class="params">(<span class="keyword">unsigned</span> mapsize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	 <span class="comment">// 该结构可在字典中查询</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_state</span> *<span class="title">bs</span>;</span></span><br><span class="line"></span><br><span class="line">    bs = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*bs));</span><br><span class="line">    <span class="keyword">if</span> (!bs) &#123;</span><br><span class="line">        errno = ENOMEM;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">// 1. 打开驱动</span></span><br><span class="line">    bs-&gt;fd = open(<span class="string">"/dev/binder"</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (bs-&gt;fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"binder: cannot open device (%s)\n"</span>,</span><br><span class="line">                strerror(errno));</span><br><span class="line">        <span class="keyword">goto</span> fail_open;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bs-&gt;mapsize = mapsize;</span><br><span class="line">    <span class="comment">// 2. 内存映射</span></span><br><span class="line">    bs-&gt;mapped = mmap(<span class="literal">NULL</span>, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (bs-&gt;mapped == MAP_FAILED) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"binder: cannot map device (%s)\n"</span>,</span><br><span class="line">                strerror(errno));</span><br><span class="line">        <span class="keyword">goto</span> fail_map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* <span class="doctag">TODO:</span> check version */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bs;</span><br><span class="line"></span><br><span class="line">fail_map:</span><br><span class="line">    close(bs-&gt;fd);</span><br><span class="line">fail_open:</span><br><span class="line">    <span class="built_in">free</span>(bs);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如注释所示，主要步骤分为两步，我们一步一步来看。</p>
<h3 id="驱动层binder-open"><a href="#驱动层binder-open" class="headerlink" title="驱动层binder_open"></a>驱动层<code>binder_open</code></h3><p>程序 binder 驱动设备调用的是<code>open</code>方法，这个方法实际会调用到驱动层的<code>binder_open</code>方法，将打开的文件描述符记录到 binder_state 的 fd 字段: </p>
<blockquote>
<p>至于为什么会有 Libraries 的<code>open</code>方法映射到驱动层的<code>binder_open</code>方法，这属于驱动知识，不详细解释，后面也会有很多这样的映射例子，一般是前面加上<code>binder_</code>做映射，这个关系是 binder 驱动自己定义的。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static int binder_open(struct inode *nodp, struct file *filp)</span><br><span class="line">&#123;</span><br><span class="line">    //声明proc的数据结构，可在字典中查询</span><br><span class="line">    struct binder_proc *proc;</span><br><span class="line">    proc = kzalloc(sizeof(*proc), GFP_KERNEL);</span><br><span class="line">    if (proc == NULL)</span><br><span class="line">        return -ENOMEM;</span><br><span class="line"></span><br><span class="line">    //增加引用计数</span><br><span class="line">    get_task_struct(current);</span><br><span class="line">    </span><br><span class="line">    //记录当前进程到proc中</span><br><span class="line">    proc-&gt;tsk = current;</span><br><span class="line"></span><br><span class="line">    //初始化链表</span><br><span class="line">    INIT_LIST_HEAD(&amp;proc-&gt;todo);</span><br><span class="line">    //初始化等待队列</span><br><span class="line">    init_waitqueue_head(&amp;proc-&gt;wait);</span><br><span class="line">    //设置优先级</span><br><span class="line">    proc-&gt;default_priority = task_nice(current);</span><br><span class="line">    binder_lock(__func__);</span><br><span class="line">    binder_stats_created(BINDER_STAT_PROC);</span><br><span class="line">    //把binder_proc添加到binder_procs链表中去</span><br><span class="line">    hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs);</span><br><span class="line">    //记录进程ID</span><br><span class="line">    proc-&gt;pid = current-&gt;group_leader-&gt;pid;</span><br><span class="line">    INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);</span><br><span class="line"></span><br><span class="line">    //保存进程信息</span><br><span class="line">    filp-&gt;private_data = proc;</span><br><span class="line">    binder_unlock(__func__);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分配<code>binder_proc</code>对象之后，后面的代码都有注释，这里 current 其实是一个宏，指向的是一个内联函数，返回的结果指向当前的进程，具体在 SOF 的问题 <a href="http://stackoverflow.com/questions/12434651/what-is-the-current-in-linux-kernel-source" target="_blank" rel="noopener">what is the “current” in linux kernel source</a> 下面有详细的解释。接着就是初始化一些队列，记录环境值。最后会将 proc 保存到<code>filp-&gt;private_data</code>中去，后面就可以从这个字段中再把 proc 读取出来。</p>
<blockquote>
<p>这里涉及到很多的C++、Linux、驱动知识，比如将 proc 保存到 <code>filp-&gt;private_data</code> 中去。</p>
</blockquote>
<p>这个就是打开 binder 驱动做的主要工作，以下是调用路径图:</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/binder_open.png" alt="打开binder驱动"></div>

<h3 id="驱动层binder-mmap"><a href="#驱动层binder-mmap" class="headerlink" title="驱动层binder_mmap"></a>驱动层<code>binder_mmap</code></h3><p>接着程序将传入的 mapsize 记录到 binder_state 的 mapsize 字段( main 函数传入的值是 128*1024)；最后调用<code>mmap</code>函数进行内存映射。<code>mmap</code>是系统调用，可以理解为从驱动中划分一块内存出来映射到本进程中，从而 binder 驱动和本进程都可以操作这块内存。</p>
<p>这块较复杂，功力不足暂时分析不了，如果读者有兴趣可以去看老罗的文章<a href="http://blog.csdn.net/luoshengyang/article/details/6621566" target="_blank" rel="noopener">浅谈Service Manager成为Android进程间通信（IPC）机制Binder守护进程之路</a>，直接搜 “binder_mmap” 就好。</p>
<p>至此，binder 驱动打开，并且做好了映射，终于可以直接和驱动通信了。</p>
<blockquote>
<p>这个过程类似于打开了一个文件，定位好了写入位置和可以写入的数据量，接下去就可以写入数据了。</p>
</blockquote>
<h2 id="成为服务管理者"><a href="#成为服务管理者" class="headerlink" title="成为服务管理者"></a>成为服务管理者</h2><p>现在我们已经打开了 binder 驱动，并且记录下它的文件描述符，接着 service_manager 开始申请成为服务管理者了，它调用的方法是<code>binder_become_context_manager</code>。这个方法同样存在于 Libraries 层 “binder.c” 文件中:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_become_context_manager</span><span class="params">(struct binder_state *bs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//#define BINDER_SET_CONTEXT_MGR  _IOW('b', 7, int) </span></span><br><span class="line">    <span class="keyword">return</span> ioctl(bs-&gt;fd, BINDER_SET_CONTEXT_MGR, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只有一行很简单的调用。<code>ioctl</code>也是一个系统调用，最终这个调用会映射到 binder 驱动的 <code>binder_ioctl</code>。</p>
<p>这么一来就进入了驱动层，<code>binder_ioctl</code>是一个较大的方法，它可以处理很多的命令。调用这个方法的第二个参数就代表命令，而上面的调用传进来的是<code>BINDER_SET_CONTEXT_MGR</code>，我们就先看这个命令的处理过程:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">binder_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	 <span class="comment">// 通过 filp-&gt;private_data 获取进程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">    <span class="comment">// 该结构体在字典中可查</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取到线程</span></span><br><span class="line">    thread = binder_get_thread(proc);</span><br><span class="line">    <span class="keyword">if</span> (thread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ret = -ENOMEM;</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> BINDER_SET_CONTEXT_MGR:</span><br><span class="line">        <span class="comment">// binder_context_mgr_node是一个全局静态变量</span></span><br><span class="line">        <span class="keyword">if</span> (binder_context_mgr_node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            printk(KERN_ERR <span class="string">"binder: BINDER_SET_CONTEXT_MGR already set\n"</span>);</span><br><span class="line">            ret = -EBUSY;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = security_binder_set_context_mgr(proc-&gt;tsk);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        <span class="keyword">if</span> (binder_context_mgr_uid != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (binder_context_mgr_uid != current-&gt;cred-&gt;euid) &#123;</span><br><span class="line">                printk(KERN_ERR <span class="string">"binder: BINDER_SET_"</span></span><br><span class="line">                       <span class="string">"CONTEXT_MGR bad uid %d != %d\n"</span>,</span><br><span class="line">                       current-&gt;cred-&gt;euid,</span><br><span class="line">                       binder_context_mgr_uid);</span><br><span class="line">                ret = -EPERM;</span><br><span class="line">                <span class="keyword">goto</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            binder_context_mgr_uid = current-&gt;cred-&gt;euid;</span><br><span class="line">        <span class="comment">// 新建binder_node</span></span><br><span class="line">        binder_context_mgr_node = binder_new_node(proc, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (binder_context_mgr_node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ret = -ENOMEM;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        binder_context_mgr_node-&gt;local_weak_refs++;</span><br><span class="line">        binder_context_mgr_node-&gt;local_strong_refs++;</span><br><span class="line">        binder_context_mgr_node-&gt;has_strong_ref = <span class="number">1</span>;</span><br><span class="line">        binder_context_mgr_node-&gt;has_weak_ref = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ret = -EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line">    <span class="keyword">if</span> (thread)</span><br><span class="line">        thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_NEED_RETURN;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong> 这里是删除了很多代码的，只把核心相关的部分展示出来了。</p>
<p>我们来分析一下代码，首先是调用<code>binder_get_thread</code>方法查找 binder_thread:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct binder_thread *<span class="title">binder_get_thread</span><span class="params">(struct binder_proc *proc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">thread</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// threads: binder_proc进程内用于处理用户请求的线程组成的红黑树(关联binder_thread-&gt;rb_node)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">p</span> = &amp;<span class="title">proc</span>-&gt;<span class="title">threads</span>.<span class="title">rb_node</span>;</span></span><br><span class="line">    <span class="comment">// 遍历红黑树寻找线程节点</span></span><br><span class="line">    <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">        parent = *p;</span><br><span class="line">        thread = rb_entry(parent, struct binder_thread, rb_node);</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;pid &lt; thread-&gt;pid)</span><br><span class="line">            p = &amp;(*p)-&gt;rb_left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current-&gt;pid &gt; thread-&gt;pid)</span><br><span class="line">            p = &amp;(*p)-&gt;rb_right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没找到就新建，初始化线程</span></span><br><span class="line">    <span class="keyword">if</span> (*p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        thread = kzalloc(<span class="keyword">sizeof</span>(*thread), GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (thread == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        binder_stats_created(BINDER_STAT_THREAD);</span><br><span class="line">        thread-&gt;proc = proc;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录进程的pid</span></span><br><span class="line">        thread-&gt;pid = current-&gt;pid;</span><br><span class="line">        <span class="comment">// 初始化thread的两个队列</span></span><br><span class="line">        init_waitqueue_head(&amp;thread-&gt;wait);</span><br><span class="line">        INIT_LIST_HEAD(&amp;thread-&gt;todo);</span><br><span class="line">        <span class="comment">// 挂载节点到 &amp;proc-&gt;threads 红黑树上</span></span><br><span class="line">        rb_link_node(&amp;thread-&gt;rb_node, parent, p);</span><br><span class="line">        rb_insert_color(&amp;thread-&gt;rb_node, &amp;proc-&gt;threads);</span><br><span class="line">        <span class="comment">// 设置状态</span></span><br><span class="line">        thread-&gt;looper |= BINDER_LOOPER_STATE_NEED_RETURN;</span><br><span class="line">        thread-&gt;return_error = BR_OK;</span><br><span class="line">        thread-&gt;return_error2 = BR_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传递进来的是当前进程的记录对象<code>binder_proc</code>，具体的解释已经标注在代码中了。这里标注一个<strong>【疑点】</strong>：按照这里的算法，这棵红黑树是否只可能有一个thread？</p>
<blockquote>
<p>这里给出挂载红黑树的两个操作的解释:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// 它把 parent 设为 node 的父结点，并且让 rb_link 指向 node。</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rb_link_node</span><span class="params">(struct rb_node * node, struct rb_node * parent, struct rb_node ** rb_link)</span></span>;</span><br><span class="line">&gt;</span><br><span class="line">&gt;<span class="comment">// 它把已确定父结点的 node 结点融入到以 root 为根的红黑树中</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">void</span> <span class="title">rb_insert_color</span><span class="params">(struct rb_node *node, struct rb_root *root)</span></span>;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>OK，回到前面，获取到 binder_thread 之后，就进入命令<code>BINDER_SET_CONTEXT_MGR</code>的处理阶段，首先是如下一个判断:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (binder_context_mgr_node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	printk(KERN_ERR <span class="string">"binder: BINDER_SET_CONTEXT_MGR already set\n"</span>);</span><br><span class="line">	ret = -EBUSY;</span><br><span class="line">	<span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>binder_context_mgr_node</code>是一个全局变量，它的声明如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该结构体在字典中可查</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">binder_context_mgr_node</span>;</span></span><br></pre></td></tr></table></figure>
<p>它是一个全局静态的 binder_node 结构体，这里的判断是保证全局只有一个 binder_context_mgr_node，也就是说只有一个 SM。第一次进来该变量没有新建过，即该变量为 NULL，所以会去调用方法<code>binder_new_node</code>新建：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用代码：binder_context_mgr_node = binder_new_node(proc, NULL, NULL);</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct binder_node *<span class="title">binder_new_node</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">void</span> __user *ptr,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">void</span> __user *cookie)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">p</span> = &amp;<span class="title">proc</span>-&gt;<span class="title">nodes</span>.<span class="title">rb_node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">        parent = *p;</span><br><span class="line">        node = rb_entry(parent, struct binder_node, rb_node)</span><br><span class="line">        <span class="keyword">if</span> (ptr &lt; node-&gt;ptr)</span><br><span class="line">            p = &amp;(*p)-&gt;rb_left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ptr &gt; node-&gt;ptr)</span><br><span class="line">            p = &amp;(*p)-&gt;rb_right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node = kzalloc(<span class="keyword">sizeof</span>(*node), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    binder_stats_created(BINDER_STAT_NODE);</span><br><span class="line">    rb_link_node(&amp;node-&gt;rb_node, parent, p);</span><br><span class="line">    rb_insert_color(&amp;node-&gt;rb_node, &amp;proc-&gt;nodes);</span><br><span class="line">    node-&gt;debug_id = ++binder_last_id;</span><br><span class="line">    node-&gt;proc = proc;</span><br><span class="line">    node-&gt;ptr = ptr;</span><br><span class="line">    node-&gt;cookie = cookie;</span><br><span class="line">    node-&gt;work.type = BINDER_WORK_NODE;</span><br><span class="line">    INIT_LIST_HEAD(&amp;node-&gt;work.entry);</span><br><span class="line">    INIT_LIST_HEAD(&amp;node-&gt;async_todo);</span><br><span class="line">    binder_debug(BINDER_DEBUG_INTERNAL_REFS,</span><br><span class="line">             <span class="string">"binder: %d:%d node %d u%p c%p created\n"</span>,</span><br><span class="line">             proc-&gt;pid, current-&gt;pid, node-&gt;debug_id,</span><br><span class="line">             node-&gt;ptr, node-&gt;cookie);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里第一行代码就遇到了 binder_proc 中的第二棵红黑树 nodes。nodes 节点记录的是属于该进程的所有 binder_node 节点，前面说了，binder_node 节点可以看做是一个服务实体，因此这棵树上记录的就是该进程提供的所有服务。新建完成之后就是一些赋值操作以及挂载 binder_node 的动作，注意，这里传进来的 ptr 和 cookie 都是 NULL。</p>
<blockquote>
<p>后面就会知道 cookie 为 NULL 其实表明 Libraries 层没有对应的服务。这是 SM 这个服务的特殊性。</p>
</blockquote>
<p>扯到哪了？哦，对了，我们已经在驱动层为 SM 创建了一个全局的服务实体，以下是调用关系图：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/binder_become_context_manager2.png" alt="打开binder驱动"></div>

<p>接下去是对强引用、弱引用的维护，这个涉及到服务实体的释放，我们不需要太关心。上面两个步骤是差不多的路子，都是从 Libraries 层走到驱动层，接下去还有一个步骤，还得把这个过程再走一遍。</p>
<h2 id="启动循环监听"><a href="#启动循环监听" class="headerlink" title="启动循环监听"></a>启动循环监听</h2><p>再回到 service_manager 的<code>main</code>函数，SM 程序调用<code>binder_loop</code>进入循环监听:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binder_loop</span><span class="params">(struct binder_state *bs, binder_handler func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="comment">// 该结构体在字典中可查</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> readbuf[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">    bwr.write_size = <span class="number">0</span>;</span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.write_buffer = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    readbuf[<span class="number">0</span>] = BC_ENTER_LOOPER;</span><br><span class="line">    <span class="comment">//告诉Binder驱动程序， Service Manager要进入循环了</span></span><br><span class="line">    binder_write(bs, readbuf, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        bwr.read_size = <span class="keyword">sizeof</span>(readbuf);</span><br><span class="line">        bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = (<span class="keyword">unsigned</span>) readbuf;</span><br><span class="line"></span><br><span class="line">        res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            LOGE(<span class="string">"binder_loop: ioctl failed (%s)\n"</span>, strerror(errno));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res = binder_parse(bs, <span class="number">0</span>, readbuf, bwr.read_consumed, func);</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">0</span>) &#123;</span><br><span class="line">            LOGE(<span class="string">"binder_loop: unexpected reply?!\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            LOGE(<span class="string">"binder_loop: io error %d %s\n"</span>, res, strerror(errno));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数虽然看上去比较简单，但是要分析的东西非常多。</p>
<h3 id="线程状态更改"><a href="#线程状态更改" class="headerlink" title="线程状态更改"></a>线程状态更改</h3><p><code>for</code>循环前一段代码稍微有点凌乱，整理之后可以看出首先执行的是:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> readbuf[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">readbuf[<span class="number">0</span>] = BC_ENTER_LOOPER;</span><br><span class="line">binder_write(bs, readbuf, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>));</span><br></pre></td></tr></table></figure>
<p>bs 是之前声明的<code>binder_state</code>结构体，这里把<code>BC_ENTER_LOOPER</code>传递进去了，我们直接去看<code>binder_write</code>函数是怎么使用这些参数的:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用代码：binder_write(bs, readbuf, sizeof(unsigned))</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_write</span><span class="params">(struct binder_state *bs, <span class="keyword">void</span> *data, <span class="keyword">unsigned</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    bwr.write_size = len;</span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.write_buffer = (<span class="keyword">unsigned</span>) data;</span><br><span class="line">    bwr.read_size = <span class="number">0</span>;</span><br><span class="line">    bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"binder_write: ioctl failed (%s)\n"</span>,</span><br><span class="line">                strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里用到了 binder_write_read 结构体，在字典中有提到：这个结构体只是负责传输数据，具体语义由上下文环境自行定义。这里就可以很明显的看出来这种玩法：刚刚传进来的 data 字段被赋值到了 bwr 的 write 部分了，即 write_buffer 字段被赋予了<code>BC_ENTER_LOOPER</code>命令，并且 write_consumed 也被赋予了0，表示 binder 驱动没有读取任何数据，通过 wite_consumed 和 write_size 两个字段，就可以指定 write_buffer 中的数据哪一段是有效的，binder 驱动会根据这两个值读取有效数据。数据以及位置设定好之后，再调用<code>ioctl</code>方法，这个方法我们前面有过一次分析，它也会携带一个命令，这次携带的是<code>BINDER_WRITE_READ</code>，到对应驱动函数中看一下这个命令的处理方式:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用代码：res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">binder_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size = _IOC_SIZE(cmd);</span><br><span class="line">    <span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> BINDER_WRITE_READ: &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">        <span class="comment">// 验证数据格式是否正确</span></span><br><span class="line">        <span class="keyword">if</span> (size != <span class="keyword">sizeof</span>(struct binder_write_read)) &#123;</span><br><span class="line">            ret = -EINVAL;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(&amp;bwr, ubuf, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">            ret = -EFAULT;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ret = binder_thread_write(proc, thread, (<span class="keyword">void</span> __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);</span><br><span class="line">            trace_binder_write_done(ret);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">                    ret = -EFAULT;</span><br><span class="line">                <span class="keyword">goto</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ret = binder_thread_read(proc, thread, (<span class="keyword">void</span> __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK);</span><br><span class="line">            trace_binder_read_done(ret);</span><br><span class="line">            <span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo))</span><br><span class="line">                wake_up_interruptible(&amp;proc-&gt;wait);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">                    ret = -EFAULT;</span><br><span class="line">                <span class="keyword">goto</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        binder_debug(BINDER_DEBUG_READ_WRITE,</span><br><span class="line">                 <span class="string">"binder: %d:%d wrote %ld of %ld, read return %ld of %ld\n"</span>,</span><br><span class="line">                 proc-&gt;pid, thread-&gt;pid, bwr.write_consumed, bwr.write_size,</span><br><span class="line">                 bwr.read_consumed, bwr.read_size);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">            ret = -EFAULT;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line">    <span class="keyword">if</span> (thread)</span><br><span class="line">        thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_NEED_RETURN;</span><br><span class="line">    binder_unlock(__func__);</span><br><span class="line">    wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &amp;&amp; ret != -ERESTARTSYS)</span><br><span class="line">        printk(KERN_INFO <span class="string">"binder: %d:%d ioctl %x %lx returned %d\n"</span>, proc-&gt;pid, current-&gt;pid, cmd, arg, ret);</span><br><span class="line">err_unlocked:</span><br><span class="line">    trace_binder_ioctl_done(ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来开动小火车分析 case 的代码。首先是一个判断，这是判断数据格式是否正确。接着调用函数<code>copy_from_user</code>，这个函数的 user 是用户空间的意思，它的目的是从用户空间拷贝数据到内核空间。</p>
<p>我们调用<code>binder_ioctl</code>的时候传入的第三个参数是<code>&amp;bwr</code>，也就是一个 binder_write_read 结构体，这里就是将这个结构体拷贝到驱动层的 bwr 结构体中。</p>
<blockquote>
<p>读者应当熟悉这种模式，这很类似于网络请求。Http请求定义了八种方法，最常见的是Post，Get两种，这就类似于该函数的 cmd 参数，而具体的语义其实是由请求内容确定的，这包括API结构，比如我的接口叫做<code>getorder.api</code>，伴随着这个接口发出去的还有一些数据，这些就类似于 binder_write_read 结构体了。处理完成之后，也在该请求上返回数据。</p>
<p>后面还会见到这种模式的反复使用，它是 binder 机制 Libraries 层和驱动层通信的一种典型模式。 </p>
</blockquote>
<p>理所应当的，接下来就是解析数据的过程。因为传递参数中只有 write 部分有数据，那么接下去的两个判断只有下面这个会执行:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	ret = binder_thread_write(proc, thread, (<span class="keyword">void</span> __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);</span><br><span class="line">	trace_binder_write_done(ret);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">			ret = -EFAULT;</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里调用了<code>binder_thread_write</code>来处理 binder_write_read 结构体的内容，这个函数也是一个非常复杂的函数，因为它需要解析该结构体中可能传输过来的所有的命令，这里我们只看其中一部分，也就是处理命令<code>BC_ENTER_LOOPER</code>的地方:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_thread_write</span><span class="params">(struct binder_proc *proc, struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">void</span> __user *buffer, <span class="keyword">int</span> size, <span class="keyword">signed</span> <span class="keyword">long</span> *consumed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">    <span class="keyword">void</span> __user *ptr = buffer + *consumed;</span><br><span class="line">    <span class="keyword">void</span> __user *end = buffer + size;</span><br><span class="line">    <span class="keyword">while</span> (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (get_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))<span class="comment">//读取cmd</span></span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">        trace_binder_command(cmd);</span><br><span class="line">        <span class="keyword">if</span> (_IOC_NR(cmd) &lt; ARRAY_SIZE(binder_stats.bc)) &#123;</span><br><span class="line">            binder_stats.bc[_IOC_NR(cmd)]++;</span><br><span class="line">            proc-&gt;stats.bc[_IOC_NR(cmd)]++;</span><br><span class="line">            thread-&gt;stats.bc[_IOC_NR(cmd)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BC_ENTER_LOOPER:<span class="comment">//Service将要进入Loop状态时，发送此消息</span></span><br><span class="line">            <span class="keyword">if</span> (thread-&gt;looper &amp; BINDER_LOOPER_STATE_REGISTERED) &#123;</span><br><span class="line">                thread-&gt;looper |= BINDER_LOOPER_STATE_INVALID;</span><br><span class="line">                binder_user_error(<span class="string">"binder: %d:%d ERROR:"</span></span><br><span class="line">                    <span class="string">" BC_ENTER_LOOPER called after "</span></span><br><span class="line">                    <span class="string">"BC_REGISTER_LOOPER\n"</span>,</span><br><span class="line">                    proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//表示进入enter状态，looper用于记录状态</span></span><br><span class="line">            thread-&gt;looper |= BINDER_LOOPER_STATE_ENTERED;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意!!!</span></span><br><span class="line">        *consumed = ptr - buffer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的入参 buffer 指向的是我们在结构体 binder_write_read 中写入的数据，也就是:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bwr.write_buffer = (<span class="keyword">unsigned</span>) data;</span><br></pre></td></tr></table></figure>
<p>而 data 就是<code>BC_ENTER_LOOPER</code>，所以 ptr 实际是指向这段数据的开始，end 指向的是这段数据的末尾。<code>get_user</code>也是一个内核函数，这里可以认为就是从 ptr 开始读取一个 uint32_t 值存储到 cmd 中，那么这个 cmd 就是<code>BC_ENTER_LOOPER</code>，接着指针后移。</p>
<blockquote>
<p>从这里的读取方式来看，可以猜到这是一种非常固定的”命令+数据”的模式，是两层之间约定俗称的协议。</p>
</blockquote>
<p>之后就进入处理阶段，字典里面说到 binder_thread 的 looper 字段记录是线程当前的状态，这里主要进行的就是状态设置，在检测完状态是否正确之后，调用以下语句:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread-&gt;looper |= BINDER_LOOPER_STATE_ENTERED;</span><br></pre></td></tr></table></figure>
<p>设置状态<code>ENTERED</code>，就表示要进入循环状态了。讲完这个再回到<code>binder_ioctl</code>方法去，还没完呢，正常执行完上面的方法之后，会走到这段代码中去:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) &#123;</span><br><span class="line">	ret = -EFAULT;</span><br><span class="line">	goto err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>copy_to_user</code>看名字就知道和<code>copy_from_user</code>函数什么关系了：这个函数是从内核空间拷贝数据到用户空间。这里拷贝的还是 binder_write_read 结构体，要把内核空间的修改反映到 Libraries 层：这里唯一的改动就是 write_consumed 的指针的移动，这个指针在读完数据之后，被执行了如下操作:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">*consumed = ptr - buffer;</span><br></pre></td></tr></table></figure>
<p>ptr 原本指向 buffer 数据的开始，根据上面的写法，实际上<code>*consumed</code>就等于<code>sizeof(uint32_t)</code>，也就是<code>BC_ENTER_LOOPER</code>的长度，这就表示驱动已经读取了 write 部分的数据。</p>
<p>好了到这里总算分析完成<code>binder_write(bs, readbuf, sizeof(unsigned));</code>这一句了。它只做一件事情：告诉驱动层我要进入循环监听状态了。读者务必应熟悉这种交互方式，这里是最简单清楚的一个例子。这里是调用关系图：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/binder_write.png" alt="告诉binder驱动即将进入循环监听"></div>

<h3 id="循环-amp-监听"><a href="#循环-amp-监听" class="headerlink" title="循环 &amp; 监听"></a>循环 &amp; 监听</h3><p>终于进入正题了，前面都是状态准备而已。在分析代码之前，可以先从猜测一下它会怎么做？到目前为止，状态都已经设置完毕，驱动层和当前进程也有共享内存来传输数据，那比较合理的做法就是去读取这块共享内存，看是否有数据可以处理，如果有则读出来进行处理，如果没有，则阻塞，直到有数据写入，被驱动层唤醒再返回。那么实际上是不是这样的呢？Read the fucking code !</p>
<p><code>binder_loop</code>函数接下去的是一个无限循环，再贴一下代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用代码：readbuf[0] = BC_ENTER_LOOPER;</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">	bwr.read_size = <span class="keyword">sizeof</span>(readbuf);</span><br><span class="line">	bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">	bwr.read_buffer = (<span class="keyword">unsigned</span>) readbuf;</span><br><span class="line"></span><br><span class="line">	res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		LOGE(<span class="string">"binder_loop: ioctl failed (%s)\n"</span>, strerror(errno));</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	res = binder_parse(bs, <span class="number">0</span>, readbuf, bwr.read_consumed, func);</span><br><span class="line">	<span class="keyword">if</span> (res == <span class="number">0</span>) &#123;</span><br><span class="line">		LOGE(<span class="string">"binder_loop: unexpected reply?!\n"</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		LOGE(<span class="string">"binder_loop: io error %d %s\n"</span>, res, strerror(errno));</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看循环的第一次执行过程。首先还是在操作 binder_write_read 结构体，只不过这里操作的是 read 部分：它告诉驱动，我要读取数据，读取的数据大小是<code>sizeof(readbuf)</code>。执行的命令也是同样的<code>BINDER_WRITE_READ</code>，因此实际上还是走的这段代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">binder_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size = _IOC_SIZE(cmd);</span><br><span class="line">    <span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> BINDER_WRITE_READ: &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">        <span class="keyword">if</span> (size != <span class="keyword">sizeof</span>(struct binder_write_read)) &#123;</span><br><span class="line">            ret = -EINVAL;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(&amp;bwr, ubuf, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">            ret = -EFAULT;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ret = binder_thread_write(proc, thread, (<span class="keyword">void</span> __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);</span><br><span class="line">            trace_binder_write_done(ret);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">                    ret = -EFAULT;</span><br><span class="line">                <span class="keyword">goto</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ret = binder_thread_read(proc, thread, (<span class="keyword">void</span> __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK);</span><br><span class="line">            trace_binder_read_done(ret);</span><br><span class="line">            <span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo))</span><br><span class="line">                wake_up_interruptible(&amp;proc-&gt;wait);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">                    ret = -EFAULT;</span><br><span class="line">                <span class="keyword">goto</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">            ret = -EFAULT;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line">    <span class="keyword">if</span> (thread)</span><br><span class="line">        thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_NEED_RETURN;</span><br><span class="line">    binder_unlock(__func__);</span><br><span class="line">    wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &amp;&amp; ret != -ERESTARTSYS)</span><br><span class="line">        printk(KERN_INFO <span class="string">"binder: %d:%d ioctl %x %lx returned %d\n"</span>, proc-&gt;pid, current-&gt;pid, cmd, arg, ret);</span><br><span class="line">err_unlocked:</span><br><span class="line">    trace_binder_ioctl_done(ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，在这里分析的时候不要被之前<code>BC_ENTER_LOOPER</code>的 bwr 结构体影响，那个写入的 bwr 是在<code>binder_write</code>方法中新创建的，这里的 bwr 是另外一个变量，就是在<code>binder_loop</code>中创建的。因此在<code>for</code>循环执行前，bwr 的状态是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">bwr.write_size = <span class="number">0</span>;</span><br><span class="line">bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">bwr.write_buffer = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>根据前面的代码，此时<code>bwr.read_size</code>的值是<code>sizeof(readbuf)</code>，因此实际执行的是:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用代码：bwr.read_size = sizeof(readbuf);</span></span><br><span class="line"><span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	ret = binder_thread_read(proc, thread, (<span class="keyword">void</span> __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK);</span><br><span class="line">	trace_binder_read_done(ret);</span><br><span class="line">	<span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo))</span><br><span class="line">		wake_up_interruptible(&amp;proc-&gt;wait);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">			ret = -EFAULT;</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>刚进来就直接调用<code>binder_thread_read</code>函数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 调用代码：ret = binder_thread_read(proc, thread, (void __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK);</span></span><br><span class="line"><span class="comment"> * 参数解释：</span></span><br><span class="line"><span class="comment"> * bwr.read_size = sizeof(readbuf);</span></span><br><span class="line"><span class="comment"> * bwr.read_consumed = 0;</span></span><br><span class="line"><span class="comment"> * bwr.read_buffer = (unsigned) readbuf;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * non_block 是 false 的，因为打开驱动的时候使用的代码是 open("/dev/binder", O_RDWR);</span></span><br><span class="line"><span class="comment"> * 并没有设置 O_NONBLOCK 标识，因此这个操作就是阻塞的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_read</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                  struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">void</span>  __user *buffer, <span class="keyword">int</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">signed</span> <span class="keyword">long</span> *consumed, <span class="keyword">int</span> non_block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> __user *ptr = buffer + *consumed;</span><br><span class="line">    <span class="keyword">void</span> __user *end = buffer + size;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> wait_for_proc_work;</span><br><span class="line">    <span class="keyword">if</span> (*consumed == <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="comment">// 拷贝"BR_NOOP"命令到prt地址，也就是read部分的数据区</span></span><br><span class="line">    	<span class="keyword">if</span> (put_user(BR_NOOP, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        <span class="comment">// 移动指针</span></span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line">retry:</span><br><span class="line">	 <span class="comment">// 成立，因此 wait_for_proc_work 为 true</span></span><br><span class="line">    wait_for_proc_work = thread-&gt;transaction_stack == <span class="literal">NULL</span> &amp;&amp; list_empty(&amp;thread-&gt;todo);</span><br><span class="line">    <span class="comment">// 不成立，thread-&gt;return_error 在 binder_thread 的 return_error 字段在创建的时候就被初始化为 BR_OK，</span></span><br><span class="line">    <span class="comment">// 具体可见方法`binder_get_thread`方法中新建 binder_thread 结构体的部分</span></span><br><span class="line">    <span class="comment">// 另外 ptr = end</span></span><br><span class="line">    <span class="keyword">if</span> (thread-&gt;return_error != BR_OK &amp;&amp; ptr &lt; end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (thread-&gt;return_error2 != BR_OK) &#123;</span><br><span class="line">            <span class="keyword">if</span> (put_user(thread-&gt;return_error2, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">            binder_stat_br(proc, thread, thread-&gt;return_error2);</span><br><span class="line">            <span class="keyword">if</span> (ptr == end)</span><br><span class="line">                <span class="keyword">goto</span> done;</span><br><span class="line">            thread-&gt;return_error2 = BR_OK;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (put_user(thread-&gt;return_error, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">        binder_stat_br(proc, thread, thread-&gt;return_error);</span><br><span class="line">        thread-&gt;return_error = BR_OK;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置状态为等待</span></span><br><span class="line">    thread-&gt;looper |= BINDER_LOOPER_STATE_WAITING;</span><br><span class="line">    <span class="comment">// 表示有一个线程进入就绪状态</span></span><br><span class="line">    <span class="keyword">if</span> (wait_for_proc_work)</span><br><span class="line">        proc-&gt;ready_threads++;</span><br><span class="line">    binder_unlock(__func__);</span><br><span class="line">    <span class="keyword">if</span> (wait_for_proc_work) &#123;</span><br><span class="line">    	<span class="comment">// 之前已经设置 BINDER_LOOPER_STATE_ENTERED 状态，因此判断不成立</span></span><br><span class="line">        <span class="keyword">if</span> (!(thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED |</span><br><span class="line">                    BINDER_LOOPER_STATE_ENTERED))) &#123;</span><br><span class="line">            binder_user_error(<span class="string">"binder: %d:%d ERROR: Thread waiting "</span></span><br><span class="line">                <span class="string">"for process work before calling BC_REGISTER_"</span></span><br><span class="line">                <span class="string">"LOOPER or BC_ENTER_LOOPER (state %x)\n"</span>,</span><br><span class="line">                proc-&gt;pid, thread-&gt;pid, thread-&gt;looper);</span><br><span class="line">            wait_event_interruptible(binder_user_error_wait,</span><br><span class="line">                         binder_stop_on_user_error &lt; <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        binder_set_nice(proc-&gt;default_priority);</span><br><span class="line">        <span class="comment">//打开binder设备的时候使用的是open("/dev/binder", O_RDWR)，而不是open("/dev/ttys", O_RDWR|O_NONBLOCK)，因此是阻塞的，所以non_block为false</span></span><br><span class="line">        <span class="keyword">if</span> (non_block) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!binder_has_proc_work(proc, thread))</span><br><span class="line">                ret = -EAGAIN;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">        	<span class="comment">// 最终会执行到这里</span></span><br><span class="line">            ret = wait_event_freezable_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (non_block) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!binder_has_thread_work(thread))</span><br><span class="line">                ret = -EAGAIN;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            ret = wait_event_freezable(thread-&gt;wait, binder_has_thread_work(thread));</span><br><span class="line">    &#125;</span><br><span class="line">    binder_lock(__func__);</span><br><span class="line">    <span class="comment">// 阻塞释放之后，减少一个就绪的线程</span></span><br><span class="line">    <span class="keyword">if</span> (wait_for_proc_work)</span><br><span class="line">        proc-&gt;ready_threads--;</span><br><span class="line">    <span class="comment">// 表示线程不在等待状态</span></span><br><span class="line">    thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_WAITING;</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中相关注释都已经标明具体在做什么，最终会执行到<code>wait_event_freezable_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread));</code>这一句。从网上找的资料看<code>wait_event_freezable_exclusive</code>基本等同于<code>wait_event_interruptible_exclusive</code>，老罗的分析中代码就是写的这个函数（它的源码版本比较老），调用这个方法之后进程就被阻塞，直到<code>binder_has_thread_work(thread)</code>为 true:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_has_thread_work</span><span class="params">(struct binder_thread *thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !list_empty(&amp;thread-&gt;todo) || thread-&gt;return_error != BR_OK ||</span><br><span class="line">        (thread-&gt;looper &amp; BINDER_LOOPER_STATE_NEED_RETURN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>thread-&gt;todo</code>列表不为空的时候，该函数返回true，至于这个列表中存放的什么，下两篇文章中会解释。</p>
<p>这里详细解释一下<code>wait_event_interruptible_exclusive</code>这个函数，Linux中还有一个类似的函数叫做<code>wait_event_interruptible</code>，exclusive表示排他进程，这个我们不去考虑，官方文档上对于这个方法的解释是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wait_event_interruptible — sleep until a condition gets true</span><br><span class="line"></span><br><span class="line">【Description】</span><br><span class="line">The process is put to sleep (TASK_INTERRUPTIBLE) until the condition evaluates to true or a signal is received. The condition is checked each time the waitqueue wq is woken up.</span><br><span class="line"></span><br><span class="line">wake_up has to be called after changing any variable that could change the result of the wait condition.</span><br><span class="line"></span><br><span class="line">The function will return -ERESTARTSYS if it was interrupted by a signal and 0 if condition evaluated to true.</span><br></pre></td></tr></table></figure>
<p>我们要看的其实是这句：<strong>The function will return -ERESTARTSYS if it was interrupted by a signal and 0 if condition evaluated to true.</strong> 换句话说，如果是被中断的，返回的是<code>-ERESTARTSYS</code>，如果是条件满足后返回的，则返回0。</p>
<p>为什么要解释这个呢？因为在阻塞恢复以后，有这样一段代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br></pre></td></tr></table></figure>
<p>ret 正是该函数的返回值，因此如果是条件满足后阻塞恢复，会继续往下执行。</p>
<p>OK，到这里，我们也把循环监听分析完了，以下是调用关系图:</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/binder_read.png" alt="告诉binder驱动进入循环监听"></div>

<h3 id="处理命令"><a href="#处理命令" class="headerlink" title="处理命令"></a>处理命令</h3><p>当循环监听到消息，即有消息返回的时候，首先会通过一个while循环初步处理数据，之后返回无限循环中，调用方法<code>binder_parse</code>解析请求:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = binder_parse(bs, <span class="number">0</span>, readbuf, bwr.read_consumed, func);</span><br></pre></td></tr></table></figure>
<p>因为这里没有实际的场景，就暂不分析请求处理这块的代码，下面两篇文章中都会涉及到该函数的分析。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上，SM 启动的过程分析完毕。它现在在等待着<code>binder_has_thread_work</code>为真。</p>
</div><div class="tags"><a href="/tags/源码/">源码</a><a href="/tags/Binder/">Binder</a></div><div class="post-nav"><a href="/2016/06/21/binder-service-register/" class="pre">Binder之Service注册</a><a href="/2016/06/19/paraclete/" class="next">观影《辩护人》</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">59</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactiveX/">ReactiveX</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/后端/">后端</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/影视/">影视</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/电影/">电影</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Gitbook/" style="font-size: 15px;">Gitbook</a> <a href="/tags/Runtime/" style="font-size: 15px;">Runtime</a> <a href="/tags/视图/" style="font-size: 15px;">视图</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/权限/" style="font-size: 15px;">权限</a> <a href="/tags/代码优化/" style="font-size: 15px;">代码优化</a> <a href="/tags/Framework/" style="font-size: 15px;">Framework</a> <a href="/tags/性能优化/" style="font-size: 15px;">性能优化</a> <a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/合集/" style="font-size: 15px;">合集</a> <a href="/tags/ADB/" style="font-size: 15px;">ADB</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/反编译/" style="font-size: 15px;">反编译</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/Gradle/" style="font-size: 15px;">Gradle</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/基础/" style="font-size: 15px;">基础</a> <a href="/tags/效率/" style="font-size: 15px;">效率</a> <a href="/tags/MarkDown/" style="font-size: 15px;">MarkDown</a> <a href="/tags/电影/" style="font-size: 15px;">电影</a> <a href="/tags/Reactive/" style="font-size: 15px;">Reactive</a> <a href="/tags/AIDL/" style="font-size: 15px;">AIDL</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/驱动/" style="font-size: 15px;">驱动</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/日志/" style="font-size: 15px;">日志</a> <a href="/tags/事件/" style="font-size: 15px;">事件</a> <a href="/tags/代码设计/" style="font-size: 15px;">代码设计</a> <a href="/tags/网络/" style="font-size: 15px;">网络</a> <a href="/tags/测试/" style="font-size: 15px;">测试</a> <a href="/tags/Binder/" style="font-size: 15px;">Binder</a> <a href="/tags/Groovy/" style="font-size: 15px;">Groovy</a> <a href="/tags/Loader/" style="font-size: 15px;">Loader</a> <a href="/tags/RAC/" style="font-size: 15px;">RAC</a> <a href="/tags/事件处理/" style="font-size: 15px;">事件处理</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/10/30/AIDL-原理分析/">AIDL 原理分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/30/App-启动过程/">App 启动过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/PMS-解析/">PMS 解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/WMS-解析/">WindowManagerService 解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/AMS-解析/">AMS 解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/10/The-Good-Wife/">The-Good-Wife</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/10/Black-Sails/">黑帆</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/29/hello-world/">Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/23/XCode-8-2-1-ClangFormat-插件安装/">XCode 8.2.1 ClangFormat 插件安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/07/SourceTree-分支图谱/">SourceTree 分支图谱</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">蜗牛壳.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>