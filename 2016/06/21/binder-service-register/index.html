<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="李全民的个人博客"><title>Binder之Service注册 | 蜗牛壳</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-65882749-1','auto');ga('send','pageview');</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Binder之Service注册</h1><a id="logo" href="/.">蜗牛壳</a><p class="description">计算机只有 0 和 1 ，但世界是连续的</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Binder之Service注册</h1><div class="post-meta">Jun 21, 2016<span> | </span><span class="category"><a href="/categories/Android/">Android</a></span></div><div class="post-content"><p>前文<a href="http://www.muzileecoding.com/framework/binder-servicemanager.html" target="_blank" rel="noopener">Binder之Service Manager</a>已经讲述了 SM 如何启动并循环监听消息的，接下去按照逻辑应该是先说如何注册一个服务再说如何获取一个服务，但是从代码层面来说，先说获取服务似乎更好，好纠结。还是按照逻辑来讲吧~</p>
<h2 id="研究对象"><a href="#研究对象" class="headerlink" title="研究对象"></a>研究对象</h2><p>既然是讲述服务注册，最好的当然是从现有的系统中找出一枚服务，研究它的注册过程。<a href="http://www.muzileecoding.com/framework/binder.html" target="_blank" rel="noopener">总纲</a>中推荐的5篇文章正好有一篇是从这个角度切入分析Binder的：文章⑤<a href="http://www.cnblogs.com/innost/archive/2011/01/09/1931456.html" target="_blank" rel="noopener">Android深入浅出之Binder机制</a>。它是从 MediaServer 来切入分析的。</p>
<p>因为我们主要是看注册的过程，选择什么服务是次要的，因此这里也以该服务为分析对象。<strong>以下 MediaServer 简称 MS</strong>。MS 是为系统提供多媒体功能的服务，比如音频、视频等。</p>
<blockquote>
<p>和前一篇文章一样，这里仍然沿用 SM 指代 Service Manager。</p>
</blockquote>
<a id="more"></a><strong>【涉及文件】</strong><br><br>| 文件                      | 位置                                       |<br>| ———————– | —————————————- |<br>| main_mediaserver.cpp    | /frameworks/base/media/mediaserver/main_mediaserver.cpp |<br>| IServiceManager.h       | /frameworks/base/include/binder/IServiceManager.h |<br>| IServiceManager.cpp     | /frameworks/base/libs/binder/IServiceManager.cpp |<br>| IMediaPlayerService.cpp | /frameworks/base/media/libmedia/IMediaPlayerService.cpp |<br>| IPCThreadState.cpp      | /frameworks/base/libs/binder/IPCThreadState.cpp |<br>| ProcessState.cpp        | /frameworks/base/libs/binder/ProcessState.cpp |<br>| Binder.cpp              | /frameworks/base/libs/binder/Binder.cpp  |<br>| BpBinder.cpp            | /frameworks/base/libs/binder/BpBinder.cpp |<br>| Parcel.cpp              | /frameworks/base/libs/binder/Parcel.cpp  |<br>| IInterface.h            | /frameworks/base/include/binder/IInterface.h |<br>其余一些零碎文件、头文件，这里不一一列举了。<br><br>## 初见 MS<br>MS 的<code>main</code>函数位于 “main_mediaserver.cpp” 中，这个文件的代码内容非常简单:<br><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> android;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;ProcessState&gt; proc(ProcessState::self());</span><br><span class="line">    sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line">    LOGI(<span class="string">"ServiceManager: %p"</span>, sm.get());</span><br><span class="line">    AudioFlinger::instantiate();</span><br><span class="line">    MediaPlayerService::instantiate();</span><br><span class="line">    CameraService::instantiate();</span><br><span class="line">    AudioPolicyService::instantiate();</span><br><span class="line">    ProcessState::self()-&gt;startThreadPool();</span><br><span class="line">    IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就只有一个<code>main</code>函数。该方法会初始化很多的多媒体服务，我们选择一个 —— <strong>MediaPlayerService</strong> 分析就好了。因此以下是我们本次的代码分析路径:</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/main_mediaserver_main.png" width="320" alt="MS main函数调用"></div>

<h2 id="打开驱动-amp-内存映射"><a href="#打开驱动-amp-内存映射" class="headerlink" title="打开驱动 &amp; 内存映射"></a>打开驱动 &amp; 内存映射</h2><p><code>main</code>函数的第一行代码核心在于<code>ProcessState::self()</code>这一句:</p>
<blockquote>
<p><code>sp&lt;XXX&gt;</code> 可以看成 <code>XXX *</code>，即指针。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;ProcessState&gt; ProcessState::self()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (gProcess != <span class="literal">NULL</span>) <span class="keyword">return</span> gProcess;</span><br><span class="line">    </span><br><span class="line">    AutoMutex _l(gProcessMutex);</span><br><span class="line">    <span class="keyword">if</span> (gProcess == <span class="literal">NULL</span>) gProcess = <span class="keyword">new</span> ProcessState;</span><br><span class="line">    <span class="keyword">return</span> gProcess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个单例方法，确保只创建一个 ProcessState ，我们看看 ProcessState 的构造函数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ProcessState::ProcessState()</span><br><span class="line">    : mDriverFD(open_driver())</span><br><span class="line">    , mVMStart(MAP_FAILED)</span><br><span class="line">    , mManagesContexts(<span class="literal">false</span>)</span><br><span class="line">    , mBinderContextCheckFunc(<span class="literal">NULL</span>)</span><br><span class="line">    , mBinderContextUserData(<span class="literal">NULL</span>)</span><br><span class="line">    , mThreadPoolStarted(<span class="literal">false</span>)</span><br><span class="line">    , mThreadPoolSeq(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDriverFD &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// XXX Ideally, there should be a specific define for whether we</span></span><br><span class="line">        <span class="comment">// have mmap (or whether we could possibly have the kernel module</span></span><br><span class="line">        <span class="comment">// availabla).</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(HAVE_WIN32_IPC)</span></span><br><span class="line">        <span class="comment">// mmap the binder, providing a chunk of virtual address space to receive transactions.</span></span><br><span class="line">        mVMStart = mmap(<span class="number">0</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (mVMStart == MAP_FAILED) &#123;</span><br><span class="line">            <span class="comment">// *sigh*</span></span><br><span class="line">            LOGE(<span class="string">"Using /dev/binder failed: unable to mmap transaction memory.\n"</span>);</span><br><span class="line">            close(mDriverFD);</span><br><span class="line">            mDriverFD = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        mDriverFD = <span class="number">-1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG_ALWAYS_FATAL_IF(mDriverFD &lt; <span class="number">0</span>, <span class="string">"Binder driver could not be opened.  Terminating."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数并不复杂，但是关键点很隐蔽： <strong><code>mDriverFD(open_driver())</code></strong> ，这里将调用函数<code>open_driver()</code>，并将返回值赋值给<code>mDriverFD</code>。自然而然我们又要去看看<code>open_driver()</code>函数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">open_driver</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/dev/binder"</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        fcntl(fd, F_SETFD, FD_CLOEXEC);</span><br><span class="line">        <span class="keyword">int</span> vers;</span><br><span class="line">        <span class="keyword">status_t</span> result = ioctl(fd, BINDER_VERSION, &amp;vers);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">            LOGE(<span class="string">"Binder ioctl to obtain version failed: %s"</span>, strerror(errno));</span><br><span class="line">            close(fd);</span><br><span class="line">            fd = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="number">0</span> || vers != BINDER_CURRENT_PROTOCOL_VERSION) &#123;</span><br><span class="line">            LOGE(<span class="string">"Binder driver protocol does not match user space protocol!"</span>);</span><br><span class="line">            close(fd);</span><br><span class="line">            fd = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">size_t</span> maxThreads = <span class="number">15</span>;</span><br><span class="line">        result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123;</span><br><span class="line">            LOGE(<span class="string">"Binder ioctl to set max threads failed: %s"</span>, strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOGW(<span class="string">"Opening '/dev/binder' failed: %s\n"</span>, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里看到了熟悉的代码：它打开了 Binder 驱动。如果打开成功，它会向驱动发送两个命令，一个是<code>BINDER_VERSION</code>，这个无关紧要，略过；一个是<code>BINDER_SET_MAX_THREADS</code>，这个最终还是会走到<code>binder_ioctrl</code>中去，多余代码就不贴了，直接看这条命令的处理case:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ubuf 指代传递进入驱动的数据</span></span><br><span class="line"><span class="keyword">case</span> BINDER_SET_MAX_THREADS:</span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(&amp;proc-&gt;max_threads, ubuf, <span class="keyword">sizeof</span>(proc-&gt;max_threads))) &#123;</span><br><span class="line">			ret = -EINVAL;</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>这个处理很简单，proc指向的是<code>binder_proc</code>实体，这个结构体中有一个 max_threads 字段，这里就是将传递进来的值赋值到这个字段上，至于字段具体什么作用，后面会讲到。</p>
<p>回到前面，ProcessState 实例在新建的时候就打开了 Binder 驱动，接下去有一句很重要的代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mmap the binder, providing a chunk of virtual address space to receive transactions.</span></span><br><span class="line">mVMStart = mmap(<span class="number">0</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p><code>mmap</code>这个函数不是第一次见，看注释就明白这里是在做什么：这里和 SM 一样，也去 binder 驱动中挖一块内存，便于 Service 和驱动进行通信。按注释的说法，就是 “receive transactions”。</p>
<p>再回到 MS 的<code>main</code>函数，执行完第一句之后，我们创建了一个 ProcessState 实例，在这个实例里面打开了 Binder 驱动并做了内存映射，映射起始地址记录在 mVMStart 变量中。</p>
<p>以下是上面分析的函数调用的关系图：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/ProcessState实例化.png" alt="ProcessState实例化"></div>

<h2 id="获取-SM-实例"><a href="#获取-SM-实例" class="headerlink" title="获取 SM 实例"></a>获取 SM 实例</h2><p>第二行代码是:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br></pre></td></tr></table></figure>
<p>看函数名字以及返回的变量指针，就知道这和 SM 相关 —— 这里实际上就是在获取 SM 实例。这个方法来自哪里呢？”IServiceManager.cpp”:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IServiceManager&gt; defaultServiceManager()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (gDefaultServiceManager != <span class="literal">NULL</span>) <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        AutoMutex _l(gDefaultServiceManagerLock);</span><br><span class="line">        <span class="keyword">if</span> (gDefaultServiceManager == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(</span><br><span class="line">                ProcessState::self()-&gt;getContextObject(<span class="literal">NULL</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又是一个单例方法，调用的是<code>interface_cast&lt;IServiceManager&gt;(ProcessState::self()-&gt;getContextObject(NULL));</code>来实例化返回对象的，这个方法包含很多内容，我们一步一步看。</p>
<h3 id="ProcessState-self-gt-getContextObject-NULL"><a href="#ProcessState-self-gt-getContextObject-NULL" class="headerlink" title="ProcessState::self()-&gt;getContextObject(NULL)"></a><code>ProcessState::self()-&gt;getContextObject(NULL)</code></h3><p>首先是<code>ProcessState::self()-&gt;getContextObject(NULL)</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IBinder&gt; ProcessState::getContextObject(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; caller)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> getStrongProxyForHandle(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(<span class="keyword">int32_t</span> handle)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;IBinder&gt; result;</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// handle 为0</span></span><br><span class="line">    handle_entry* e = lookupHandleLocked(handle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// We need to create a new BpBinder if there isn't currently one, OR we</span></span><br><span class="line">        <span class="comment">// are unable to acquire a weak reference on this current one.  See comment</span></span><br><span class="line">        <span class="comment">// in getWeakProxyForHandle() for more info about this.</span></span><br><span class="line">        IBinder* b = e-&gt;binder;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">NULL</span> || !e-&gt;refs-&gt;attemptIncWeak(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            b = <span class="keyword">new</span> BpBinder(handle); </span><br><span class="line">            e-&gt;binder = b;</span><br><span class="line">            <span class="keyword">if</span> (b) e-&gt;refs = b-&gt;getWeakRefs();</span><br><span class="line">            result = b;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// This little bit of nastyness is to allow us to add a primary</span></span><br><span class="line">            <span class="comment">// reference to the remote proxy when this team doesn't have one</span></span><br><span class="line">            <span class="comment">// but another team is sending the handle to us.</span></span><br><span class="line">            result.force_set(b);</span><br><span class="line">            e-&gt;refs-&gt;decWeak(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上调用的是<code>getStrongProxyForHandle</code>获取的返回值，传入参数0，那么这个方法又在干啥呢？我把代码贴在一块了，很明显它又调用了另外一个方法<code>lookupHandleLocked</code>，继续传递参数0:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用代码：lookupHandleLocked(0);</span></span><br><span class="line">ProcessState::handle_entry* ProcessState::lookupHandleLocked(<span class="keyword">int32_t</span> handle)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> N = mHandleToObject.size();</span><br><span class="line">    <span class="keyword">if</span> (N &lt;= (<span class="keyword">size_t</span>)handle) &#123;</span><br><span class="line">        handle_entry e;</span><br><span class="line">        e.binder = <span class="literal">NULL</span>;</span><br><span class="line">        e.refs = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">status_t</span> err = mHandleToObject.insertAt(e, N, handle+<span class="number">1</span>-N);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;mHandleToObject.editItemAt(handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>mHandleToObject</code>是一个 Vector，它的元素是结构体 handle_entry，声明如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">handle_entry</span> &#123;</span></span><br><span class="line">	IBinder* binder;</span><br><span class="line">	RefBase::weakref_type* refs;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Vector&lt;handle_entry&gt; mHandleToObject;</span><br></pre></td></tr></table></figure>
<p>因为进程刚启动，因此<code>mHandleToObject</code>是空的，因此<code>N &lt;= (size_t)handle</code>判断成立，这样就会新建一个 handle_entry 结构体实例，它的 binder 字段是 NULL 。</p>
<p>新建完成后继续回到<code>getStrongProxyForHandle</code>方法，它会取出 binder 字段，并作如下判断:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (b == <span class="literal">NULL</span> || !e-&gt;refs-&gt;attemptIncWeak(<span class="keyword">this</span>))</span><br></pre></td></tr></table></figure>
<p>binder 字段为 NULL，因此最终会走到:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="keyword">new</span> BpBinder(handle); </span><br><span class="line">e-&gt;binder = b;</span><br><span class="line"><span class="keyword">if</span> (b) e-&gt;refs = b-&gt;getWeakRefs();</span><br><span class="line">result = b;</span><br></pre></td></tr></table></figure>
<p>这里会以 handle 为参数新建一个 BpBinder 对象，并赋值给 e 的 binder 字段，最后这个 b 就被赋值给 result 并作为方法返回值，最终返回到了<code>defaultServiceManager</code>方法中。</p>
<blockquote>
<p>BpBinder 后面再做介绍，我们先把 SM 的实例获取讲完。</p>
</blockquote>
<p>因此下面这句代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface_cast&lt;IServiceManager&gt;(ProcessState::self()-&gt;getContextObject(<span class="literal">NULL</span>))</span><br></pre></td></tr></table></figure>
<p>实际上等于:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface_cast&lt;IServiceManager&gt;(<span class="keyword">new</span> BpBinder(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<h3 id="interface-cast"><a href="#interface-cast" class="headerlink" title="interface_cast"></a><code>interface_cast</code></h3><p>接下来我们来啃<code>interface_cast</code>，它是一个内联的模板函数，定义在 “IInterface.h”中: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</span><br><span class="line"><span class="keyword">inline</span> sp&lt;INTERFACE&gt; interface_cast(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> INTERFACE::asInterface(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以前面那行代码又等价于:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IServiceManager::asInterface(<span class="keyword">new</span> BpBinder(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p><code>asInterface</code>这个方法实际又不是来自<code>IServiceManager</code>，而是来自<code>IInterface</code>（<code>IServiceManager</code>继承于<code>IInterface</code>），所以我们又回到了 “IInterface.h” 这个文件，在这个文件里面又发现这个方法实际上是定义在两个宏里面的:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_META_INTERFACE(INTERFACE)                               \</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> android::String16 descriptor;                          \</span><br><span class="line">    <span class="keyword">static</span> android::sp&lt;I##INTERFACE&gt; asInterface(                       \</span><br><span class="line">            <span class="keyword">const</span> android::sp&lt;android::IBinder&gt;&amp; obj);                  \</span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">const</span> android::<span class="function">String16&amp; <span class="title">getInterfaceDescriptor</span><span class="params">()</span> <span class="keyword">const</span></span>;    \</span><br><span class="line">    I##INTERFACE();                                                     \</span><br><span class="line">    <span class="keyword">virtual</span> ~I##INTERFACE();                                            \</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPLEMENT_META_INTERFACE(INTERFACE, NAME)                       \</span></span><br><span class="line">    <span class="keyword">const</span> android::String16 I##INTERFACE::descriptor(NAME);             \</span><br><span class="line">    <span class="keyword">const</span> android::String16&amp;                                            \</span><br><span class="line">            I##INTERFACE::getInterfaceDescriptor() <span class="keyword">const</span> &#123;              \</span><br><span class="line">        <span class="keyword">return</span> I##INTERFACE::descriptor;                                \</span><br><span class="line">    &#125;                                                                   \</span><br><span class="line">    android::sp&lt;I##INTERFACE&gt; I##INTERFACE::asInterface(                \</span><br><span class="line">            <span class="keyword">const</span> android::sp&lt;android::IBinder&gt;&amp; obj)                   \</span><br><span class="line">    &#123;                                                                   \</span><br><span class="line">        android::sp&lt;I##INTERFACE&gt; intr;                                 \</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="literal">NULL</span>) &#123;                                              \</span><br><span class="line">            intr = <span class="keyword">static_cast</span>&lt;I##INTERFACE*&gt;(                          \</span><br><span class="line">                obj-&gt;queryLocalInterface(                               \</span><br><span class="line">                        I##INTERFACE::descriptor).get());               \</span><br><span class="line">            <span class="keyword">if</span> (intr == <span class="literal">NULL</span>) &#123;                                         \</span><br><span class="line">                intr = <span class="keyword">new</span> Bp##INTERFACE(obj);                          \</span><br><span class="line">            &#125;                                                           \</span><br><span class="line">        &#125;                                                               \</span><br><span class="line">        <span class="keyword">return</span> intr;                                                    \</span><br><span class="line">    &#125;                                                                   \</span><br><span class="line">    I##INTERFACE::I##INTERFACE() &#123; &#125;                                    \</span><br><span class="line">    I##INTERFACE::~I##INTERFACE() &#123; &#125;                                   \</span><br></pre></td></tr></table></figure>
<p>恩…不出意外，子类中应该有相关使用声明。我们回到 “IServiceManager.h” 文件中，果然发现有这么一行代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_META_INTERFACE(ServiceManager);</span><br></pre></td></tr></table></figure>
<p>而在 “IServiceManager.cpp” 中，又有这么一条:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMPLEMENT_META_INTERFACE(ServiceManager, <span class="string">"android.os.IServiceManager"</span>);</span><br></pre></td></tr></table></figure>
<p>看样子搞懂这个宏，就知道<code>interface_cast</code>到底在干什么了。先来看看添加这条语句后倒地增加了什么样的方法:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> android::String16 IServiceManager::descriptor(NAME);</span><br><span class="line"><span class="keyword">const</span> android::String16&amp; IServiceManager::getInterfaceDescriptor() <span class="keyword">const</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> IServiceManager::descriptor;</span><br><span class="line">&#125; </span><br><span class="line">android::sp&lt;IServiceManager&gt; IServiceManager::asInterface(<span class="keyword">const</span> android::sp&lt;android::IBinder&gt;&amp; obj) &#123;</span><br><span class="line">	android::sp&lt;IServiceManager&gt; intr;</span><br><span class="line">	<span class="comment">//还记得obj是啥么？new BpBinder(0)，所以肯定不为null</span></span><br><span class="line">	<span class="keyword">if</span> (obj != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		intr = <span class="keyword">static_cast</span>&lt;IServiceManager*&gt;(obj-&gt;queryLocalInterface(IServiceManager::descriptor).get());</span><br><span class="line">		<span class="keyword">if</span> (intr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			intr = <span class="keyword">new</span> BpServiceManager(obj);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> intr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IServiceManager:: IServiceManager() &#123; &#125;</span><br><span class="line">IServiceManager::~ IServiceManager() &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>哈，看到了我们最想看到的函数，也就是<code>asInterface</code>，这又是在干啥呢？这里调用了一个 <code>queryLocalInterface</code> 方法，我们看看 BpBinder 中的实现，在文件 “Binder.cpp” 中可以找到:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IInterface&gt;  IBinder::queryLocalInterface(<span class="keyword">const</span> String16&amp; descriptor)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此这里就会执行<code>new BpServiceManager(obj)</code>并返回对象，因此下面这句代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface_cast&lt;IServiceManager&gt;(<span class="keyword">new</span> BpBinder(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p>实际上就等于:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> BpServiceManager(<span class="keyword">new</span> BpBinder(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p>通过这样一个语句，我们就可以获得一个 SM 实例。实际上到这里我们只知道 <code>defaultServiceManager()</code> 方法返回了一个<code>IServiceManager</code>的对象，实际指向的是 BpServiceManager 实例，具体这个对象和 SM 什么关系、如何帮助我们完成服务注册我们并不清楚。不要捉急，下面一节讲完就清楚了。</p>
<p>好了，喘口气，下面是调用关系图：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/defaultServiceManager.png" alt="defaultServiceManager调用"></div>

<p>看上去有点复杂，但是更复杂的还在后面。</p>
<h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><p>这里再贴一下<code>main</code>函数的代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> android;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	 <span class="comment">// 实例化 Process</span></span><br><span class="line">    sp&lt;ProcessState&gt; proc(ProcessState::self());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取 SM</span></span><br><span class="line">    sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line">    LOGI(<span class="string">"ServiceManager: %p"</span>, sm.get());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化服务</span></span><br><span class="line">    AudioFlinger::instantiate();</span><br><span class="line">    MediaPlayerService::instantiate();</span><br><span class="line">    CameraService::instantiate();</span><br><span class="line">    AudioPolicyService::instantiate();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 很重要的两个方法，后面分析</span></span><br><span class="line">    ProcessState::self()-&gt;startThreadPool();</span><br><span class="line">    IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从<code>main</code>函数看，到这里主要做了两件事情：</p>
<ol>
<li>初始化 ProcessState 变量，初始化过程主要是打开 binder 驱动，进行内存映射；</li>
<li>获取 defaultServiceManager，它实际上是一个 BpServiceManager 对象；</li>
</ol>
<p>如注释所写，接下去就是要初始化服务了。这下面有很多的服务进行初始化，包括音频，视频，照相机等，我们找<code>MediaPlayerService</code>为例进行研究。因为这部分分析涉及到的函数很多，调用链较长，因此这里先贴一下主要函数调用关系图（看不清可以右击查看大图）：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/服务注册函数调用链.png" alt="服务注册函数调用链"></div>

<p>首先来看 MediaPlayerService 的<code>instantiate()</code>方法了:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MediaPlayerService::instantiate() &#123;</span><br><span class="line">    defaultServiceManager()-&gt;addService(</span><br><span class="line">            String16(<span class="string">"media.player"</span>), <span class="keyword">new</span> MediaPlayerService());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为方法<code>defaultServiceManager()</code>是一个单例方法，因此这里获取到的其实还是前面新建的那个实例。接着调用的就是它的<code>addService</code>方法，我们终于走到了 <strong>服务注册</strong> 的地方！</p>
<p>我们来看这个方法的实现（位于 “IServiceManager.cpp” 中）:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> status_t <span class="title">addService</span><span class="params">(<span class="keyword">const</span> String16&amp; name, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; service)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Parcel data, reply;</span><br><span class="line">	data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());</span><br><span class="line">	data.writeString16(name);</span><br><span class="line">	data.writeStrongBinder(service);</span><br><span class="line">	<span class="keyword">status_t</span> err = remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply);</span><br><span class="line">	<span class="keyword">return</span> err == NO_ERROR ? reply.readExceptionCode() : err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里出了一个和 Android Java 层很相似的概念: Parcel，用于序列化对象。从代码看，它先序列化两个字符串，再序列化 service ，最后通过<code>remote()-&gt;transact()</code>发送到某个地方去了。让我们吸口气，一步步潜下去瞧瞧。</p>
<h3 id="Parcel-序列化"><a href="#Parcel-序列化" class="headerlink" title="Parcel 序列化"></a>Parcel 序列化</h3><p>这里使用 Parcel 对象将数据全部打包，相关方法都集中在<code>Parcel.cpp</code>。前面写入了两个字符串，第一个是 RPC 头部，不需要多关注，实际写入值是 “android.os.IServiceManager” （这个方法建议读者自行查看，其实前面还写入了一些信息，会在下面指出），相关代码直接看 <code>IServiceManager::getInterfaceDescriptor()</code>即可；接着写入参数 name 的值，也就是传入的 “media.player”；最后写入了 Service，这里有必要好好看看方法<code>writeStrongBinder</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> Parcel::writeStrongBinder(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> flatten_binder(ProcessState::self(), val, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> flatten_binder(<span class="keyword">const</span> sp&lt;ProcessState&gt;&amp; proc,</span><br><span class="line">    <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; binder, Parcel* out)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 该结构体在字典中可查</span></span><br><span class="line">    flat_binder_object obj;</span><br><span class="line">    </span><br><span class="line">    obj.flags = <span class="number">0x7f</span> | FLAT_BINDER_FLAG_ACCEPTS_FDS;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//传入的是new MediaPlayerService()，因此不为NULL</span></span><br><span class="line">    <span class="keyword">if</span> (binder != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    	  <span class="comment">// 什么鬼？</span></span><br><span class="line">        IBinder *local = binder-&gt;localBinder();</span><br><span class="line">        <span class="keyword">if</span> (!local) &#123;</span><br><span class="line">            BpBinder *proxy = binder-&gt;remoteBinder();</span><br><span class="line">            <span class="keyword">if</span> (proxy == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                LOGE(<span class="string">"null proxy"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int32_t</span> handle = proxy ? proxy-&gt;handle() : <span class="number">0</span>;</span><br><span class="line">            obj.type = BINDER_TYPE_HANDLE;</span><br><span class="line">            obj.handle = handle;</span><br><span class="line">            obj.cookie = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            obj.type = BINDER_TYPE_BINDER;</span><br><span class="line">            obj.binder = local-&gt;getWeakRefs();</span><br><span class="line">            obj.cookie = local;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        obj.type = BINDER_TYPE_BINDER;</span><br><span class="line">        obj.binder = <span class="literal">NULL</span>;</span><br><span class="line">        obj.cookie = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> finish_flatten_binder(binder, obj, out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它实际调用的是<code>flatten_binder</code>方法，看名字意思是把一个 binder 对象扁平化，看上去很有序列化的味道（想象把一个对象转成 JSON），在这个方法里这个 binder 对象就是我们的<code>new MediaPlayerService()</code>。</p>
<p>后面还调用了很多 binder 的方法，比如<code>localBinder()</code>，<code>remoteBinder()</code>，开始大面积出现 IBinder，BpBinder 等概念，这里必须要分析一下一些类之间的关系，这也是为了方便后面分析。</p>
<p>Binder 机制在 Libraries 层面建立了一组对象，它们协同起来与驱动交互，完成 IPC 功能。这里就不一步步看代码了，直接上关系图:</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/Binder-Lib层架构.png" alt="Binder Lib层架构"></div>

<p>这里直接画上了<code>MediaPlayerService</code>服务并标注了一些重要的属性和方法，好了，看着图我们继续往下走。</p>
<blockquote>
<p>PS: 凡是出现了 MediaPlayerService 的地方，实际都可以由别的 Service 替换。</p>
</blockquote>
<p>首先我们要看的是<code>binder-&gt;localBinder();</code>，这个方法最先声明是在 IBinder 中，我搜索代码只能看到关于该方法如下的实现:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BBinder* IBinder::localBinder()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BpBinder* IBinder::remoteBinder()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说返回为 NULL ，从 MediaPlayerService 到 IBinder 的继承树中再也没有别的实现，但是这个不符合常理：因为这里研究的是如何注册一个 Service，且 MediaPlayerService 确实又是本地的，按照道理<code>localBinder()</code>应该有返回，翻看几篇文章，也没有关于<code>localBinder()</code>方法的其余实现代码的展示，这里留作一个<strong>【疑点】</strong>。</p>
<blockquote>
<p>找的眼睛都快瞎了！</p>
</blockquote>
<p>那么按照常理实际会执行下面的代码才对:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj.type = BINDER_TYPE_BINDER;</span><br><span class="line">obj.binder = local-&gt;getWeakRefs();</span><br><span class="line">obj.cookie = local;</span><br></pre></td></tr></table></figure>
<p>这里会产生一个type为<code>BINDER_TYPE_BINDER</code>的<code>flat_binder_object</code>结构体对象，binder 字段记录的是本地 binder 的弱引用对象，<strong>cookie 中记录的则是本地服务实体的地址</strong>。接着就调用<code>finish_flatten_binder()</code>方法:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> status_t <span class="title">finish_flatten_binder</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; binder, <span class="keyword">const</span> flat_binder_object&amp; flat, Parcel* out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> out-&gt;writeObject(flat, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就只是写入对象了：到这里为止，我们把 Service 的名字和 Service 本身写入到一个Parcel对象中去。现在 out 里面的数据应该是这样的：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/service注册transact数据.png" width="600" alt="service注册transact数据"></div>

<blockquote>
<p>data 中还有一些元数据，比如写入字符串之前会写入字符串长度，图中没有标注出来。</p>
</blockquote>
<p>这张图非常重要，后面直到服务注册成功，这部分数据格式、内容都不会变化，因此在 SM 中注册时候，最后解析的格式还是按照这个顺序进行。<strong>以下称这幅图为 “服务注册初始数据图”</strong> 。</p>
<h3 id="传输数据"><a href="#传输数据" class="headerlink" title="传输数据"></a>传输数据</h3><p>在准备好数据之后，接下来就是调用:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// data 大致就是上图的样子，reply 不为空</span></span><br><span class="line"><span class="keyword">status_t</span> err = remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply);</span><br></pre></td></tr></table></figure>
<p>这里顾名思义是在传输数据。<code>remote()</code>是什么呢？要知道<code>addService()</code>这个方法其实是来自类<code>BpServiceManager</code>的，它和上面类图中的<code>BpMediaPlayerService</code>位置类似，因此这个方法实际来自于<code>BpRefBase</code>。我们看一下这几个类的代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#############  BpServiceManager  ###############</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BpServiceManager</span> :</span> <span class="keyword">public</span> BpInterface&lt;IServiceManager&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BpServiceManager(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; impl)</span><br><span class="line">        : BpInterface&lt;IServiceManager&gt;(impl)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#############  BpInterface  ###############</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BpInterface</span> :</span> <span class="keyword">public</span> INTERFACE, <span class="keyword">public</span> BpRefBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">                                BpInterface(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; remote);</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IBinder*            <span class="title">onAsBinder</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#############  BpRefBase  ###############</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BpRefBase</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">                            BpRefBase(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; o);</span><br><span class="line">    <span class="keyword">virtual</span>                 ~BpRefBase();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>            <span class="title">onFirstRef</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>            <span class="title">onLastStrongRef</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span>            <span class="title">onIncStrongAttempted</span><span class="params">(<span class="keyword">uint32_t</span> flags, <span class="keyword">const</span> <span class="keyword">void</span>* id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span>  IBinder*        <span class="title">remote</span><span class="params">()</span>                </span>&#123; <span class="keyword">return</span> mRemote; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span>  IBinder*        <span class="title">remote</span><span class="params">()</span> <span class="keyword">const</span>          </span>&#123; <span class="keyword">return</span> mRemote; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">                            BpRefBase(<span class="keyword">const</span> BpRefBase&amp; o);</span><br><span class="line">    BpRefBase&amp;              <span class="keyword">operator</span>=(<span class="keyword">const</span> BpRefBase&amp; o);</span><br><span class="line"></span><br><span class="line">    IBinder* <span class="keyword">const</span>          mRemote;</span><br><span class="line">    RefBase::weakref_type*  mRefs;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span>        mState;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>BpRefBase 的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get() 方法应该是 sp 持有的，可以类比 Java 的弱引用</span></span><br><span class="line">BpRefBase::BpRefBase(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; o)</span><br><span class="line">    : mRemote(o.get()), mRefs(<span class="literal">NULL</span>), mState(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    extendObjectLifetime(OBJECT_LIFETIME_WEAK);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mRemote) &#123;</span><br><span class="line">        mRemote-&gt;incStrong(<span class="keyword">this</span>);           <span class="comment">// Removed on first IncStrong().</span></span><br><span class="line">        mRefs = mRemote-&gt;createWeak(<span class="keyword">this</span>);  <span class="comment">// Held for our entire lifetime.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样很隐蔽，mRemote的赋值来自<code>o.get()</code>，因此<code>remote()</code>返回的实际就是新建 BpServiceManager 时传入的参数，也就是<code>new BpBinder(0)</code>，换句话说，我们应该去 BpBinder 中寻找<code>transact()</code>函数的实现:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用代码：status_t err = remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply);</span></span><br><span class="line"><span class="comment">// 参数解释：data 就是服务注册初始数据图所示内容，reply 是一个 Parcel 对象，flags 默认是 0</span></span><br><span class="line"><span class="keyword">status_t</span> BpBinder::transact(</span><br><span class="line">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Once a binder has died, it will never come back to life.</span></span><br><span class="line">    <span class="keyword">if</span> (mAlive) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里又转到<code>IPCThreadState::self()</code>里面去了，看上去似乎又是一个获取单例的方法，它的方法如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">IPCThreadState* IPCThreadState::self()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (gHaveTLS) &#123;</span><br><span class="line">restart:</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">pthread_key_t</span> k = gTLS;</span><br><span class="line">        IPCThreadState* st = (IPCThreadState*)pthread_getspecific(k);</span><br><span class="line">        <span class="keyword">if</span> (st) <span class="keyword">return</span> st;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IPCThreadState;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (gShutdown) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    pthread_mutex_lock(&amp;gTLSMutex);</span><br><span class="line">    <span class="keyword">if</span> (!gHaveTLS) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pthread_key_create(&amp;gTLS, threadDestructor) != <span class="number">0</span>) &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;gTLSMutex);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        gHaveTLS = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;gTLSMutex);</span><br><span class="line">    <span class="keyword">goto</span> restart;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的实现涉及到一些 Linux 函数以及线程知识：它并不是前面所说的获取单例，而是获取线程变量副本。相似的机制 Java 中也有，可以查看文章 <a href="http://www.muzileecoding.com/java/Java-threadlocal.html" target="_blank" rel="noopener">ThreadLocal 源码剖析</a>，简单来说，就是为每个线程创建一个变量的副本，保证线程之间不共享原有的变量，保证线程内部只有一个该变量的副本。关于这个知识点，在网上找到一篇文章:<a href="http://blog.csdn.net/lmh12506/article/details/8452700" target="_blank" rel="noopener">pthread_key_t和pthread_key_create()详解</a>，读者读完这两篇文章之后，再看这个函数就会比较清晰，这里就不做详细分析了。总结一下该函数: 为该进程中的每一个线程创建唯一一个 IPCThreadState 对象。</p>
<blockquote>
<p>这个创建并不是线程一启动就进行的，而是在这个变量中获取该变量的时候进行创建的。</p>
</blockquote>
<p>好，咱继续走！创建之后调用的是 IPCThreadState 的<code>transact()</code>函数: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用代码: status_t status = IPCThreadState::self()-&gt;transact(mHandle, code, data, reply, flags);</span></span><br><span class="line"><span class="comment">// 参数解释: handle 是 BpBinder 的实例化参数，也就是0，code 是 ADD_SERVICE_TRANSACTION，flags是0</span></span><br><span class="line"><span class="keyword">status_t</span> IPCThreadState::transact(<span class="keyword">int32_t</span> handle,</span><br><span class="line">                                  <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data,</span><br><span class="line">                                  Parcel* reply, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">status_t</span> err = data.errorCheck();</span><br><span class="line"></span><br><span class="line">    flags |= TF_ACCEPT_FDS;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">// 数据没有问题，判断通过</span></span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err);</span><br><span class="line">        <span class="keyword">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">            err = waitForResponse(reply);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err = waitForResponse(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = waitForResponse(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法删除一些Log和无用代码之后，大致就是上面这个样子。首先进来调用的就是<code>writeTransactionData()</code>方法:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用代码: writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL);</span></span><br><span class="line"><span class="comment">// 参数解释: handle 为0，code 为 ADD_SERVICE_TRANSACTION， binderFlags 是 TF_ACCEPT_FDS;</span></span><br><span class="line"><span class="keyword">status_t</span> IPCThreadState::writeTransactionData(<span class="keyword">int32_t</span> cmd, <span class="keyword">uint32_t</span> binderFlags,</span><br><span class="line">    <span class="keyword">int32_t</span> handle, <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, <span class="keyword">status_t</span>* statusBuffer)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 该结构体在字典中可查</span></span><br><span class="line">    binder_transaction_data tr;</span><br><span class="line"></span><br><span class="line">    tr.target.handle = handle;</span><br><span class="line">    tr.code = code;</span><br><span class="line">    tr.flags = binderFlags;</span><br><span class="line">    tr.cookie = <span class="number">0</span>;</span><br><span class="line">    tr.sender_pid = <span class="number">0</span>;</span><br><span class="line">    tr.sender_euid = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">status_t</span> err = data.errorCheck();</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">    	<span class="comment">// 将之前写在 data 中的数据再换一种形式写到 binder_transaction_data 中</span></span><br><span class="line">        tr.data_size = data.ipcDataSize(); </span><br><span class="line">        tr.data.ptr.buffer = data.ipcData(); </span><br><span class="line">        tr.offsets_size = data.ipcObjectsCount()*<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>);</span><br><span class="line">        tr.data.ptr.offsets = data.ipcObjects(); </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusBuffer) &#123;</span><br><span class="line">        tr.flags |= TF_STATUS_CODE;</span><br><span class="line">        *statusBuffer = err;</span><br><span class="line">        tr.data_size = <span class="keyword">sizeof</span>(<span class="keyword">status_t</span>);</span><br><span class="line">        tr.data.ptr.buffer = statusBuffer;</span><br><span class="line">        tr.offsets_size = <span class="number">0</span>;</span><br><span class="line">        tr.data.ptr.offsets = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mOut.writeInt32(cmd);<span class="comment">//BC_TRANSACTION</span></span><br><span class="line">    mOut.write(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们终于遇到一直在等待的重要结构体了: binder_transaction_data。</p>
<blockquote>
<p>如果读者看过推荐文章①，一定知道 binder_transaction 表示IPC之间的一个请求，而  binder_transaction_data 就是为了这样一个事务包装的结构体对象。</p>
</blockquote>
<p>这里主要将之前写入 Parcel 的数据再设置到 binder_transaction_data 结构体中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tr.data_size = data.ipcDataSize();  <span class="comment">//记录数据大小</span></span><br><span class="line">tr.data.ptr.buffer = data.ipcData();  <span class="comment">// 记录数据内容</span></span><br><span class="line">tr.offsets_size = data.ipcObjectsCount()*<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>);</span><br><span class="line">tr.data.ptr.offsets = data.ipcObjects();</span><br></pre></td></tr></table></figure>
<p>这四个数据是有必要说道说道的，前两个很简单，就是我们之前写入的数据尺寸以及内容（注意，内容没有变），内容就是”服务注册初始数据图”所绘制的。后两个要注意了：这两个数据就是为了 flat_binder_object 准备的，在最终传输的数据中，我们是需要记录哪些位置存放着 flat_binder_object 对象的，其中<code>tr.data.ptr.offsets</code>中存放的就是每个对象实际的偏移量，<code>tr.offsets_size</code>中存放的就是这些偏移数据的大小 —— 记录这些元数据是为后面可以再反序列化出 flat_binder_object 对象。</p>
<p>那么问题来了，mOut 是什么东西呢？它也是个 Parcel 对象，它在<code>IPCThreadState</code>初始化的时候被设置相应的初始值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">IPCThreadState::IPCThreadState()</span><br><span class="line">    : mProcess(ProcessState::self()),</span><br><span class="line">      mMyThreadId(androidGetTid()),</span><br><span class="line">      mStrictModePolicy(<span class="number">0</span>),</span><br><span class="line">      mLastTransactionBinderFlags(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_setspecific(gTLS, <span class="keyword">this</span>);</span><br><span class="line">    clearCaller();</span><br><span class="line">    <span class="comment">// 注意，这两个变量的容量都不为0</span></span><br><span class="line">    mIn.setDataCapacity(<span class="number">256</span>);</span><br><span class="line">    mOut.setDataCapacity(<span class="number">256</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行完成<code>writeTransactionData</code>之后数据都被写入了 mOut 内，那是在哪里发送数据到驱动层的呢？回到<code>IPCThreadState::transact()</code>方法，在调用<code>writeTransactionData()</code>方法之后，做了一些错误检测，之后就是调用函数<code>waitForResponse()</code>，代码删减一下如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::waitForResponse(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> cmd;</span><br><span class="line">    <span class="keyword">int32_t</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((err = talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        err = mIn.errorCheck();</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (mIn.dataAvail() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 注意：下面有一段很长的命令解析，这段数据来自驱动。等分析完数据的发送之后，我们还会回到这里</span></span><br><span class="line">        cmd = mIn.readInt32();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            err = executeCommand(cmd);</span><br><span class="line">            <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里又调用了一个<code>talkWithDriver()</code>函数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法声明的时候默认 doReceive 是 true</span></span><br><span class="line"><span class="keyword">status_t</span> IPCThreadState::talkWithDriver(<span class="keyword">bool</span> doReceive)</span><br><span class="line">&#123;</span><br><span class="line">    LOG_ASSERT(mProcess-&gt;mDriverFD &gt;= <span class="number">0</span>, <span class="string">"Binder driver is not opened"</span>);</span><br><span class="line">    </span><br><span class="line">    binder_write_read bwr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Is the read buffer empty?</span></span><br><span class="line">    <span class="comment">// 为 true</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> needRead = mIn.dataPosition() &gt;= mIn.dataSize();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// We don't want to write anything if we are still reading</span></span><br><span class="line">    <span class="comment">// from data left in the input buffer and the caller</span></span><br><span class="line">    <span class="comment">// has requested to read the next data.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> outAvail = (!doReceive || needRead) ? mOut.dataSize() : <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将 mOut中 的数据写入到bwr中</span></span><br><span class="line">    bwr.write_size = outAvail;</span><br><span class="line">    bwr.write_buffer = (<span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)mOut.data();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is what we'll read. 这两个变量名取得很好</span></span><br><span class="line">    <span class="keyword">if</span> (doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">    	<span class="comment">//注意：前面说了，这个 mIn 在 IPCThreadState 中初始化的时候就被设置为 256 的容量</span></span><br><span class="line">        bwr.read_size = mIn.dataCapacity();</span><br><span class="line">        bwr.read_buffer = (<span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)mIn.data();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bwr.read_size = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Return immediately if there is nothing to do.</span></span><br><span class="line">    <span class="keyword">if</span> ((bwr.write_size == <span class="number">0</span>) &amp;&amp; (bwr.read_size == <span class="number">0</span>)) <span class="keyword">return</span> NO_ERROR;</span><br><span class="line"></span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> defined(HAVE_ANDROID_OS)</span></span><br><span class="line">        <span class="keyword">if</span> (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</span><br><span class="line">            err = NO_ERROR;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err = -errno;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        err = INVALID_OPERATION;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (err == -EINTR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err &gt;= NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bwr.write_consumed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bwr.write_consumed &lt; (<span class="keyword">ssize_t</span>)mOut.dataSize())</span><br><span class="line">                mOut.remove(<span class="number">0</span>, bwr.write_consumed);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mOut.setDataSize(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bwr.read_consumed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mIn.setDataSize(bwr.read_consumed);</span><br><span class="line">            mIn.setDataPosition(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在和驱动交互之前，还是需要把数据写入 binder_write_read 结构体中，然后使用<code>ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr)</code>命令将数据写入驱动。</p>
<blockquote>
<p>这里是第二次遇到这种模式了。这里做了一点小修改：通过两个 Parcel 对象进行数据读写，bwr 是这两个对象和驱动层交互的介质。</p>
</blockquote>
<p>回想一下这个时候 <code>mOut.data()</code>，也就是bwr.write_buffer中是什么内容？ <strong>是一个命令 <code>BC_TRANSACTION</code> + <code>binder_transaction_data</code>结构体，<code>binder_transaction_data</code>结构体中记录着服务注册初始数据图中所描述的 data 数据结构以及一些元数据(具体转换都在<code>IPCThreadState::writeTransactionData()</code>方法中)。</strong></p>
<p>接着来！看来要知道如何注册的，问题就在于解析<code>ioctl</code>期间到底发生了什么事情，我们来看一下驱动层对于<code>BINDER_WRITE_READ</code>的命令的解析，之前已经有过类似的例子，执行如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">binder_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> BINDER_WRITE_READ: &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">        <span class="keyword">if</span> (size != <span class="keyword">sizeof</span>(struct binder_write_read)) &#123;</span><br><span class="line">            ret = -EINVAL;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(&amp;bwr, ubuf, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">            ret = -EFAULT;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;<span class="comment">//写入内容</span></span><br><span class="line">            <span class="comment">//参数：前两个表示发起传输动作的进程和线程</span></span><br><span class="line">            ret = binder_thread_write(proc, thread, (<span class="keyword">void</span> __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);</span><br><span class="line">            trace_binder_write_done(ret);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">                    ret = -EFAULT;</span><br><span class="line">                <span class="keyword">goto</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// write之后紧接着调用read</span></span><br><span class="line">        <span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;<span class="comment">//读取内容</span></span><br><span class="line">            ret = binder_thread_read(proc, thread, (<span class="keyword">void</span> __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK);</span><br><span class="line">            trace_binder_read_done(ret);</span><br><span class="line">            <span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo))</span><br><span class="line">                wake_up_interruptible(&amp;proc-&gt;wait);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">                    ret = -EFAULT;</span><br><span class="line">                <span class="keyword">goto</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//再写回去</span></span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">            ret = -EFAULT;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里<code>bwr.write_size</code>和<code>bwr.read_size</code>都大于 0，我们先来看<code>binder_thread_write</code>。这个函数解析的时候会首先读取一个 cmd 参数，从前面的代码中不难发现，这个 cmd 是<code>BC_TRANSACTION</code>，它的处理如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> BC_TRANSACTION:</span><br><span class="line"><span class="keyword">case</span> BC_REPLY: &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line">		<span class="comment">// 从用户空间拷贝到内核空间</span></span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(&amp;tr, ptr, <span class="keyword">sizeof</span>(tr)))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		<span class="comment">// 已经读取了tr，向后移动指针</span></span><br><span class="line">		ptr += <span class="keyword">sizeof</span>(tr);</span><br><span class="line">		</span><br><span class="line">		binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面几步都已经比较熟悉，数据读取和写入一一对应，binder_transaction_data 对应数据被复制到驱动层。最后调用的是<code>binder_transaction</code>函数进行解析，前面两个参数很熟悉，最后一个参数为 false 。</p>
<blockquote>
<p>让我哭一会儿，这个方法在源码里面是一个 400 多行的函数….我要罢工了！</p>
</blockquote>
<p>删删删，删完之后还剩下这么多: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tr 的 write 数据中有 binder 节点信息，就是之前写入mOut中的数据</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_transaction</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_transaction_data *tr, <span class="keyword">int</span> reply)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">tcomplete</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> *offp, *off_end;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">target_proc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">target_thread</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">target_list</span>;</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> *target_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">in_reply_to</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_log_entry</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> return_error;</span><br><span class="line">    e = binder_transaction_log_add(&amp;binder_transaction_log);</span><br><span class="line">    e-&gt;call_type = reply ? <span class="number">2</span> : !!(tr-&gt;flags &amp; TF_ONE_WAY);</span><br><span class="line">    e-&gt;from_proc = proc-&gt;pid;</span><br><span class="line">    e-&gt;from_thread = thread-&gt;pid;</span><br><span class="line">    e-&gt;target_handle = tr-&gt;target.handle;</span><br><span class="line">    e-&gt;data_size = tr-&gt;data_size;</span><br><span class="line">    e-&gt;offsets_size = tr-&gt;offsets_size;</span><br><span class="line">    <span class="comment">// transaction 和 reply 是同一个处理流程，但这里是transaction，因此 reply 为false</span></span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 在 IPCThreadState::writeTransactionData 可以看到 handle 被赋值了，</span></span><br><span class="line">        <span class="comment">// 而且解析中特意指出这个 handle 为 0，因此这个判断不成立</span></span><br><span class="line">        <span class="keyword">if</span> (tr-&gt;target.handle) &#123;</span><br><span class="line">            struct binder_ref *ref;</span><br><span class="line">            ref = binder_get_ref(proc, tr-&gt;target.handle);</span><br><span class="line">            <span class="keyword">if</span> (ref == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                binder_user_error(<span class="string">"binder: %d:%d got "</span></span><br><span class="line">                    <span class="string">"transaction to invalid handle\n"</span>,</span><br><span class="line">                    proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">                return_error = BR_FAILED_REPLY;</span><br><span class="line">                <span class="keyword">goto</span> err_invalid_target_handle;</span><br><span class="line">            &#125;</span><br><span class="line">            target_node = ref-&gt;node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="comment">// target_node: 目标节点，前面分析说了，binder_node 表示一个服务节点，</span></span><br><span class="line">            <span class="comment">// 这里的目标节点的含义就是发送请求的目标节点，这里是在注册服务，所以目标</span></span><br><span class="line">            <span class="comment">// 节点就是 binder_context_mgr_node，也就是 SM 注册成为守护进程的时</span></span><br><span class="line">            <span class="comment">// 候生成的节点：这也就是说 handle = 0就代表着指向 SM 服务节点。</span></span><br><span class="line">            target_node = binder_context_mgr_node;</span><br><span class="line">            <span class="keyword">if</span> (target_node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                return_error = BR_DEAD_REPLY;</span><br><span class="line">                <span class="keyword">goto</span> err_no_context_mgr_node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        e-&gt;to_node = target_node-&gt;debug_id;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取目标节点所在的进程，也就是 SM 服务进程(在binder_new_node()方法中新建node的时候进行了赋值)</span></span><br><span class="line">        target_proc = target_node-&gt;proc;</span><br><span class="line">        <span class="keyword">if</span> (target_proc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            return_error = BR_DEAD_REPLY;</span><br><span class="line">            <span class="keyword">goto</span> err_dead_binder;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 权限检测</span></span><br><span class="line">        <span class="keyword">if</span> (security_binder_transaction(proc-&gt;tsk, target_proc-&gt;tsk) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            return_error = BR_FAILED_REPLY;</span><br><span class="line">            <span class="keyword">goto</span> err_invalid_target_handle;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// thread-&gt;transaction_stack 为 null，不成立</span></span><br><span class="line">        <span class="keyword">if</span> (!(tr-&gt;flags &amp; TF_ONE_WAY) &amp;&amp; thread-&gt;transaction_stack) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">tmp</span>;</span></span><br><span class="line">            tmp = thread-&gt;transaction_stack;</span><br><span class="line">            <span class="keyword">if</span> (tmp-&gt;to_thread != thread) &#123;</span><br><span class="line">                binder_user_error(<span class="string">"binder: %d:%d got new "</span></span><br><span class="line">                    <span class="string">"transaction with bad transaction stack"</span></span><br><span class="line">                    <span class="string">", transaction %d has target %d:%d\n"</span>,</span><br><span class="line">                    proc-&gt;pid, thread-&gt;pid, tmp-&gt;debug_id,</span><br><span class="line">                    tmp-&gt;to_proc ? tmp-&gt;to_proc-&gt;pid : <span class="number">0</span>,</span><br><span class="line">                    tmp-&gt;to_thread ?</span><br><span class="line">                    tmp-&gt;to_thread-&gt;pid : <span class="number">0</span>);</span><br><span class="line">                return_error = BR_FAILED_REPLY;</span><br><span class="line">                <span class="keyword">goto</span> err_bad_call_stack;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tmp-&gt;from &amp;&amp; tmp-&gt;from-&gt;proc == target_proc)</span><br><span class="line">                    target_thread = tmp-&gt;from;</span><br><span class="line">                tmp = tmp-&gt;from_parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果找到了合适的线程，获取目标线程的两组List，实际这里 target_thread 为 NULL</span></span><br><span class="line">    <span class="keyword">if</span> (target_thread) &#123;</span><br><span class="line">        e-&gt;to_thread = target_thread-&gt;pid;</span><br><span class="line">        target_list = &amp;target_thread-&gt;todo;</span><br><span class="line">        target_wait = &amp;target_thread-&gt;wait;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则获取目标进程的两组List</span></span><br><span class="line">        target_list = &amp;target_proc-&gt;todo;</span><br><span class="line">        target_wait = &amp;target_proc-&gt;wait;</span><br><span class="line">    &#125;</span><br><span class="line">    e-&gt;to_proc = target_proc-&gt;pid;</span><br><span class="line">    <span class="comment">/* <span class="doctag">TODO:</span> reuse incoming transaction for reply */</span></span><br><span class="line">    <span class="comment">// t 是 binder_transaction 结构体，该结构体可以在字典中查询</span></span><br><span class="line">    t = kzalloc(<span class="keyword">sizeof</span>(*t), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        return_error = BR_FAILED_REPLY;</span><br><span class="line">        <span class="keyword">goto</span> err_alloc_t_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    binder_stats_created(BINDER_STAT_TRANSACTION);</span><br><span class="line">    <span class="comment">// tcomplete 是 binder_work 结构体，该结构体可以在字典中查询</span></span><br><span class="line">    tcomplete = kzalloc(<span class="keyword">sizeof</span>(*tcomplete), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (tcomplete == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        return_error = BR_FAILED_REPLY;</span><br><span class="line">        <span class="keyword">goto</span> err_alloc_tcomplete_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    binder_stats_created(BINDER_STAT_TRANSACTION_COMPLETE);</span><br><span class="line">    t-&gt;debug_id = ++binder_last_id;</span><br><span class="line">    e-&gt;debug_id = t-&gt;debug_id;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// reply 为 false， tr-flags 为 TF_ACCEPT_FDS，因此成立</span></span><br><span class="line">    <span class="keyword">if</span> (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY))</span><br><span class="line">        t-&gt;from = thread; <span class="comment">// 指向当前线程</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        t-&gt;from = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为 binder_transaction 结构体设置属性，包括把该 transaction 交给哪个 proc，哪个 thread</span></span><br><span class="line">    t-&gt;sender_euid = proc-&gt;tsk-&gt;cred-&gt;euid;</span><br><span class="line">    t-&gt;to_proc = target_proc;</span><br><span class="line">    t-&gt;to_thread = target_thread;</span><br><span class="line">    <span class="comment">// code 为 ADD_SERVICE_TRANSACTION</span></span><br><span class="line">    t-&gt;code = tr-&gt;code;</span><br><span class="line">    t-&gt;flags = tr-&gt;flags;</span><br><span class="line">    t-&gt;priority = task_nice(current);</span><br><span class="line">    trace_binder_transaction(reply, t, target_node);</span><br><span class="line">    <span class="comment">// 注意，这是在target_proc中进行内存分配，包括数据填入</span></span><br><span class="line">    t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size,</span><br><span class="line">        tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;buffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        return_error = BR_FAILED_REPLY;</span><br><span class="line">        <span class="keyword">goto</span> err_binder_alloc_buf_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;buffer-&gt;allow_user_free = <span class="number">0</span>;</span><br><span class="line">    t-&gt;buffer-&gt;debug_id = t-&gt;debug_id;</span><br><span class="line">    t-&gt;buffer-&gt;transaction = t;</span><br><span class="line">    t-&gt;buffer-&gt;target_node = target_node;</span><br><span class="line">    trace_binder_transaction_alloc_buf(t-&gt;buffer);</span><br><span class="line">    <span class="comment">// 增加引用计数</span></span><br><span class="line">    <span class="keyword">if</span> (target_node)</span><br><span class="line">        binder_inc_node(target_node, <span class="number">1</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    offp = (<span class="keyword">size_t</span> *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拷贝 transaction 数据</span></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) &#123;</span><br><span class="line">        binder_user_error(<span class="string">"binder: %d:%d got transaction with invalid "</span></span><br><span class="line">            <span class="string">"data ptr\n"</span>, proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">        return_error = BR_FAILED_REPLY;</span><br><span class="line">        <span class="keyword">goto</span> err_copy_data_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拷贝 transaction offset指针</span></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) &#123;</span><br><span class="line">        binder_user_error(<span class="string">"binder: %d:%d got transaction with invalid "</span></span><br><span class="line">            <span class="string">"offsets ptr\n"</span>, proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">        return_error = BR_FAILED_REPLY;</span><br><span class="line">        <span class="keyword">goto</span> err_copy_data_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// offsets 数据记录末尾</span></span><br><span class="line">    off_end = (<span class="keyword">void</span> *)offp + tr-&gt;offsets_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 flat_binder_object </span></span><br><span class="line">    <span class="keyword">for</span> (; offp &lt; off_end; offp++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> *<span class="title">fp</span>;</span></span><br><span class="line">        <span class="keyword">if</span> (*offp &gt; t-&gt;buffer-&gt;data_size - <span class="keyword">sizeof</span>(*fp) ||</span><br><span class="line">            t-&gt;buffer-&gt;data_size &lt; <span class="keyword">sizeof</span>(*fp) ||</span><br><span class="line">            !IS_ALIGNED(*offp, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *))) &#123;</span><br><span class="line">            binder_user_error(<span class="string">"binder: %d:%d got transaction with "</span></span><br><span class="line">                <span class="string">"invalid offset, %zd\n"</span>,</span><br><span class="line">                proc-&gt;pid, thread-&gt;pid, *offp);</span><br><span class="line">            return_error = BR_FAILED_REPLY;</span><br><span class="line">            <span class="keyword">goto</span> err_bad_offset;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 我们之前存进去的扁平化的flat_binder_object对象</span></span><br><span class="line">        fp = (struct flat_binder_object *)(t-&gt;buffer-&gt;data + *offp);</span><br><span class="line">        <span class="keyword">switch</span> (fp-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_BINDER:</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_WEAK_BINDER: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span> *<span class="title">ref</span>;</span></span><br><span class="line">            <span class="comment">// 获取Binder实体节点，这个proc表示当前进程，也就是发起命令的进程，</span></span><br><span class="line">            <span class="comment">// 初次注册，通过binder_get_node拿不到Binder节点</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">node</span> = <span class="title">binder_get_node</span>(<span class="title">proc</span>, <span class="title">fp</span>-&gt;<span class="title">binder</span>);</span></span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">// 新建binder节点，这个方法之前分析过了：会在proc的nodes红黑树上</span></span><br><span class="line">                <span class="comment">// 创建对应的binder节点，表示该proc提供该服务，这里要注意的是，和</span></span><br><span class="line">                <span class="comment">// SM 不同，这里后面两个参数都实际传递了值进去，因此，binder_node</span></span><br><span class="line">                <span class="comment">// 可以根据cookie来寻找 Libraries 层的服务位置，也就是</span></span><br><span class="line">                <span class="comment">// BBinder —— 我们要注册的服务。</span></span><br><span class="line">                node = binder_new_node(proc, fp-&gt;binder, fp-&gt;cookie);</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    return_error = BR_FAILED_REPLY;</span><br><span class="line">                    <span class="keyword">goto</span> err_binder_new_node_failed;</span><br><span class="line">                &#125;</span><br><span class="line">                node-&gt;min_priority = fp-&gt;flags &amp; FLAT_BINDER_FLAG_PRIORITY_MASK;</span><br><span class="line">                node-&gt;accept_fds = !!(fp-&gt;flags &amp; FLAT_BINDER_FLAG_ACCEPTS_FDS);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 保证指针值一致</span></span><br><span class="line">            <span class="keyword">if</span> (fp-&gt;cookie != node-&gt;cookie) &#123;</span><br><span class="line">                binder_user_error(<span class="string">"binder: %d:%d sending u%p "</span></span><br><span class="line">                    <span class="string">"node %d, cookie mismatch %p != %p\n"</span>,</span><br><span class="line">                    proc-&gt;pid, thread-&gt;pid,</span><br><span class="line">                    fp-&gt;binder, node-&gt;debug_id,</span><br><span class="line">                    fp-&gt;cookie, node-&gt;cookie);</span><br><span class="line">                <span class="keyword">goto</span> err_binder_get_ref_for_node_failed;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (security_binder_transfer_binder(proc-&gt;tsk, target_proc-&gt;tsk)) &#123;</span><br><span class="line">                return_error = BR_FAILED_REPLY;</span><br><span class="line">                <span class="keyword">goto</span> err_binder_get_ref_for_node_failed;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建好对应的 binder_node 之后，去对应的 target_proc中寻找是否有该node的引用</span></span><br><span class="line">            <span class="comment">// 没有的话，binder_get_ref_for_node 会新建一个 binder_ref 对象，插入到我们之</span></span><br><span class="line">            <span class="comment">// 前提到过的 binder_proc 的四棵红黑树中的两棵里面去，分别是 refs_by_node 和</span></span><br><span class="line">            <span class="comment">// refs_by_desc。注意，binder_ref 中也包含了该node的引用。</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// binder_get_ref_for_node 寻找 binder_ref 的过程是直接通过比较node来进行的。</span></span><br><span class="line">            ref = binder_get_ref_for_node(target_proc, node);</span><br><span class="line">            <span class="keyword">if</span> (ref == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                return_error = BR_FAILED_REPLY;</span><br><span class="line">                <span class="keyword">goto</span> err_binder_get_ref_for_node_failed;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 前面提到过，binder 驱动会更改类型</span></span><br><span class="line">            <span class="keyword">if</span> (fp-&gt;type == BINDER_TYPE_BINDER)</span><br><span class="line">                fp-&gt;type = BINDER_TYPE_HANDLE;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                fp-&gt;type = BINDER_TYPE_WEAK_HANDLE;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 同前面提到过，这里也会更改数据。</span></span><br><span class="line">            <span class="comment">// desc 值，其实就是该 binder_node 节点在 target_proc 中的 handle，通过这个handle</span></span><br><span class="line">            <span class="comment">// 可以直接找到对应的 binder_node 节点，也就是找到对应的服务，这里解释的可能不清楚，等</span></span><br><span class="line">            <span class="comment">// 下一篇文章讲述获取服务的时候，这里就很清楚了。</span></span><br><span class="line">            fp-&gt;handle = ref-&gt;desc;</span><br><span class="line">            binder_inc_ref(ref, fp-&gt;type == BINDER_TYPE_HANDLE,</span><br><span class="line">                       &amp;thread-&gt;todo);</span><br><span class="line">            trace_binder_transaction_node_to_ref(t, node, ref);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123; <span class="comment">// 成立</span></span><br><span class="line">        BUG_ON(t-&gt;buffer-&gt;async_transaction != <span class="number">0</span>);</span><br><span class="line">        t-&gt;need_reply = <span class="number">1</span>;</span><br><span class="line">        t-&gt;from_parent = thread-&gt;transaction_stack;</span><br><span class="line">        <span class="comment">// 记录这个transaction，等下 SM 回复的时候需要使用这个 transaction</span></span><br><span class="line">        thread-&gt;transaction_stack = t; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// t-&gt;work 是 binder_work 结构体，该结构体在字典中可查询</span></span><br><span class="line">    t-&gt;work.type = BINDER_WORK_TRANSACTION;</span><br><span class="line">    <span class="comment">// 添加 t 到目标进程的todo list中去</span></span><br><span class="line">    list_add_tail(&amp;t-&gt;work.entry, target_list);</span><br><span class="line">    tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;</span><br><span class="line">    <span class="comment">// 添加到当前线程的 todo list中去</span></span><br><span class="line">    list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);</span><br><span class="line">    <span class="comment">// 唤醒队列</span></span><br><span class="line">    <span class="keyword">if</span> (target_wait)</span><br><span class="line">        wake_up_interruptible(target_wait);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是有200多行…这里我直接在代码里面添加注释来解析代码。到这里我们在目标线程中插入了一个<code>binder_transaction</code>，这里的目标进程就是 SM 进程；并在自己线程的 todo 列表中插入了一个<code>binder_work</code>结构体实例（这个结构体，等会儿 SM 回复的时候需要使用）。</p>
<p>里面有一个重要函数，这里也使用这种方式进行分析:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数解释：proc 是目标进程，这里就是指 SM，node 是指服务节点，这里代指 MS 服务 binder 节点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct binder_ref *<span class="title">binder_get_ref_for_node</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                          struct binder_node *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">n</span>;</span></span><br><span class="line">    <span class="comment">// 红黑树</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">p</span> = &amp;<span class="title">proc</span>-&gt;<span class="title">refs_by_node</span>.<span class="title">rb_node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="comment">// 该结构体字典中可查</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span> *<span class="title">ref</span>, *<span class="title">new_ref</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过比较 node 来寻找对应的 binder_ref 对象</span></span><br><span class="line">    <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">        parent = *p;</span><br><span class="line">        ref = rb_entry(parent, struct binder_ref, rb_node_node);</span><br><span class="line">        <span class="keyword">if</span> (node &lt; ref-&gt;node)</span><br><span class="line">            p = &amp;(*p)-&gt;rb_left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node &gt; ref-&gt;node)</span><br><span class="line">            p = &amp;(*p)-&gt;rb_right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> ref;</span><br><span class="line">    &#125;</span><br><span class="line">    new_ref = kzalloc(<span class="keyword">sizeof</span>(*ref), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (new_ref == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    binder_stats_created(BINDER_STAT_REF);</span><br><span class="line">    new_ref-&gt;debug_id = ++binder_last_id;</span><br><span class="line">    new_ref-&gt;proc = proc;</span><br><span class="line">    <span class="comment">// 注意：binder_ref 中是直接携带 node 引用的，因为在驱动中node以及引用都在</span></span><br><span class="line">    <span class="comment">// 同一个内存空间，因此这样的赋值是可以的。</span></span><br><span class="line">    new_ref-&gt;node = node;</span><br><span class="line">    rb_link_node(&amp;new_ref-&gt;rb_node_node, parent, p);</span><br><span class="line">    <span class="comment">// 将红黑树节点插入到 refs_by_node 中</span></span><br><span class="line">    rb_insert_color(&amp;new_ref-&gt;rb_node_node, &amp;proc-&gt;refs_by_node);</span><br><span class="line">    new_ref-&gt;desc = (node == binder_context_mgr_node) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成desc值，实际就是一个 binder_node 节点在 target_proc 中的 handle 值</span></span><br><span class="line">    <span class="keyword">for</span> (n = rb_first(&amp;proc-&gt;refs_by_desc); n != <span class="literal">NULL</span>; n = rb_next(n)) &#123;</span><br><span class="line">        ref = rb_entry(n, struct binder_ref, rb_node_desc);</span><br><span class="line">        <span class="keyword">if</span> (ref-&gt;desc &gt; new_ref-&gt;desc)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        new_ref-&gt;desc = ref-&gt;desc + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//红黑树操作</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> new_ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结一下这一段代码中有关 binder_node 和 binder_ref 的操作：</p>
<p><strong>当一个<code>BC_TRANSACTION</code>命令被处理的时候，binder 驱动会根据携带的元数据解析数据内容，查看是否有 binder 节点信息，如果存在 binder 节点，那么会检测当前进程的<code>binder_proc</code>结构体的红黑树中是否存在代表该节点的<code>binder_node</code>结构体，如果没有则需要新建并放到红黑树中去，其次会检测目标进程是否有对该节点的引用，如果没有，则需要新建<code>binder_ref</code>结构体并挂载到目标进程的红黑树中</strong>。</p>
<h3 id="与-SM-接头"><a href="#与-SM-接头" class="headerlink" title="与 SM 接头"></a>与 SM 接头</h3><p>列出的<code>binder_transaction</code>方法代码的最后几句如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//唤醒队列</span></span><br><span class="line"><span class="keyword">if</span> (target_wait)</span><br><span class="line">	wake_up_interruptible(target_wait);</span><br></pre></td></tr></table></figure>
<p>还记得我们分析 SM 的时候，在循环监听部分，它在最后做的是什么吗？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret = wait_event_freezable_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread));</span><br></pre></td></tr></table></figure>
<p>一看就是对应的好么！碰巧上面的 target_wait 就是 SM 的 wait 队列，因此<code>wake_up_interruptible</code>就唤醒了正在等待的 SM 服务。所以我们又转回 SM。但在转到 SM 之前，我们得知道 MS 后面会做什么？</p>
<h3 id="等待-SM-的答复"><a href="#等待-SM-的答复" class="headerlink" title="等待 SM 的答复"></a>等待 SM 的答复</h3><p><code>binder_transaction</code>方法执行完毕之后，<code>binder_thread_write</code>函数也执行完毕，返回到<code>binder_ioctl</code>函数。接下去要执行如下代码: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// write之后紧接着调用read</span></span><br><span class="line"><span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;<span class="comment">//读取内容</span></span><br><span class="line">	ret = binder_thread_read(proc, thread, (<span class="keyword">void</span> __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK);</span><br><span class="line">	trace_binder_read_done(ret);</span><br><span class="line">	<span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo))</span><br><span class="line">		wake_up_interruptible(&amp;proc-&gt;wait);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">			ret = -EFAULT;</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//再写回去</span></span><br><span class="line"><span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">	ret = -EFAULT;</span><br><span class="line">	<span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>bwr</code> 变量在传入之前赋值如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bwr.read_size = mIn.dataCapacity(); <span class="comment">// 256</span></span><br><span class="line">bwr.read_buffer = (<span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)mIn.data();</span><br><span class="line">bwr.read_consumed = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><code>bwr.read_size &gt; 0</code>这个判断是成立的，因此我们进入<code>binder_thread_read</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_read</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                  struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">void</span>  __user *buffer, <span class="keyword">int</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">signed</span> <span class="keyword">long</span> *consumed, <span class="keyword">int</span> non_block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// ptr 指向 read_buffer的起始位置</span></span><br><span class="line">    <span class="keyword">void</span> __user *ptr = buffer + *consumed;</span><br><span class="line">    <span class="keyword">void</span> __user *end = buffer + size;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> wait_for_proc_work;</span><br><span class="line">    <span class="comment">// 入参为0，写入命令 BR_NOOP</span></span><br><span class="line">    <span class="keyword">if</span> (*consumed == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (put_user(BR_NOOP, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line">retry:</span><br><span class="line">    <span class="comment">// 根据前面 binder_transaction 的代码，两者都不为空</span></span><br><span class="line">    wait_for_proc_work = thread-&gt;transaction_stack == <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">                list_empty(&amp;thread-&gt;todo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置状态为等待</span></span><br><span class="line">    thread-&gt;looper |= BINDER_LOOPER_STATE_WAITING;</span><br><span class="line">    <span class="keyword">if</span> (wait_for_proc_work)</span><br><span class="line">        proc-&gt;ready_threads++;</span><br><span class="line">    binder_unlock(__func__);</span><br><span class="line">    <span class="keyword">if</span> (wait_for_proc_work) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (non_block) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!binder_has_thread_work(thread))</span><br><span class="line">                ret = -EAGAIN;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="comment">// 执行这里，但是 binder_has_thread_work 返回 true，可以见下面函数的解析</span></span><br><span class="line">            ret = wait_event_freezable(thread-&gt;wait, binder_has_thread_work(thread));</span><br><span class="line">    &#125;</span><br><span class="line">    binder_lock(__func__);</span><br><span class="line">    <span class="keyword">if</span> (wait_for_proc_work)</span><br><span class="line">        proc-&gt;ready_threads--;</span><br><span class="line">    thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_WAITING;</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">w</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span> = <span class="title">NULL</span>;</span></span><br><span class="line">        <span class="keyword">if</span> (!list_empty(&amp;thread-&gt;todo)) <span class="comment">// 此时不为空，这里会取一个 binder_work 出来，之后变为空</span></span><br><span class="line">            w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work)</span><br><span class="line">            w = list_first_entry(&amp;proc-&gt;todo, struct binder_work, entry);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ptr - buffer == <span class="number">4</span> &amp;&amp; !(thread-&gt;looper &amp; BINDER_LOOPER_STATE_NEED_RETURN)) <span class="comment">/* no data added */</span></span><br><span class="line">                <span class="keyword">goto</span> retry;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end - ptr &lt; <span class="keyword">sizeof</span>(tr) + <span class="number">4</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">switch</span> (w-&gt;type) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">case</span> BINDER_WORK_TRANSACTION_COMPLETE: &#123; <span class="comment">// 可以看 binder_transaction 函数</span></span><br><span class="line">            cmd = BR_TRANSACTION_COMPLETE;</span><br><span class="line">            <span class="comment">// 又写入一个新的命令：BR_TRANSACTION_COMPLETE</span></span><br><span class="line">            <span class="keyword">if</span> (put_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">            binder_stat_br(proc, thread, cmd);</span><br><span class="line">            <span class="comment">// 资源释放</span></span><br><span class="line">            list_del(&amp;w-&gt;entry);</span><br><span class="line">            kfree(w);</span><br><span class="line">            binder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        ......</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!t)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相关代码解析已经写作代码注释，可以看到它往<code>bwr</code>中参数写入了两个命令：<code>BR_NOOP</code>和<code>BR_TRANSACTION_COMPLETE</code>，接着返回到<code>binder_ioctl</code>函数，执行:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">	ret = -EFAULT;</span><br><span class="line">	<span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将数据又写回到用户空间，在用户空间等待的，自然是<code>IPCThreadState::talkWithDriver()</code>方法中的如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (err &gt;= NO_ERROR) &#123;</span><br><span class="line">	<span class="keyword">if</span> (bwr.write_consumed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (bwr.write_consumed &lt; (<span class="keyword">ssize_t</span>)mOut.dataSize())</span><br><span class="line">			mOut.remove(<span class="number">0</span>, bwr.write_consumed);</span><br><span class="line">		<span class="keyword">else</span> <span class="comment">// 写入数据全部读取完毕，清零</span></span><br><span class="line">			mOut.setDataSize(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (bwr.read_consumed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// 设置数据所在范围</span></span><br><span class="line">		mIn.setDataSize(bwr.read_consumed);</span><br><span class="line">		mIn.setDataPosition(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要是数据清理以及标记有效数据存储在 mIn 中的什么位置，这里的有效数据就是两个命令，我们继续往下看，就又回到了<code>IPCThreadState::waitForResponse</code>方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::waitForResponse(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> cmd;</span><br><span class="line">    <span class="keyword">int32_t</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        err = mIn.errorCheck();</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (mIn.dataAvail() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        cmd = mIn.readInt32();</span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</span><br><span class="line">            <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            ......</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            err = executeCommand(cmd); <span class="comment">// 执行 executeCommand 方法</span></span><br><span class="line">            <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">finish:</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (acquireResult) *acquireResult = err;</span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err);</span><br><span class="line">        mLastError = err;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> IPCThreadState::executeCommand(<span class="keyword">int32_t</span> cmd)</span><br><span class="line">&#123;</span><br><span class="line">    BBinder* obj;</span><br><span class="line">    RefBase::weakref_type* refs;</span><br><span class="line">    <span class="keyword">status_t</span> result = NO_ERROR;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">case</span> BR_NOOP: <span class="comment">// 不做任何处理</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候 mIn 第一个读出的命令是 <code>BR_NOOP</code>，什么也不做。<code>while</code>循环继续执行，执行的时候出现了什么情况呢？又进入了<code>IPCThreadState::talkWithDriver()</code>：（PS：又得走一遍？）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// doReceive 默认为 true</span></span><br><span class="line"><span class="keyword">status_t</span> IPCThreadState::talkWithDriver(<span class="keyword">bool</span> doReceive)</span><br><span class="line">&#123;</span><br><span class="line">	binder_write_read bwr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Is the read buffer empty?</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> needRead = mIn.dataPosition() &gt;= mIn.dataSize();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// We don't want to write anything if we are still reading</span></span><br><span class="line">    <span class="comment">// from data left in the input buffer and the caller</span></span><br><span class="line">    <span class="comment">// has requested to read the next data.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> outAvail = (!doReceive || needRead) ? mOut.dataSize() : <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    bwr.write_size = outAvail;</span><br><span class="line">    bwr.write_buffer = (<span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)mOut.data();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is what we'll read.</span></span><br><span class="line">    <span class="keyword">if</span> (doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">        bwr.read_size = mIn.dataCapacity();</span><br><span class="line">        bwr.read_buffer = (<span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)mIn.data();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 走这里</span></span><br><span class="line">        bwr.read_size = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Return immediately if there is nothing to do.</span></span><br><span class="line">    <span class="keyword">if</span> ((bwr.write_size == <span class="number">0</span>) &amp;&amp; (bwr.read_size == <span class="number">0</span>)) <span class="keyword">return</span> NO_ERROR;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mIn 的数据在驱动层返回的时候设置过一次：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mIn.setDataSize(bwr.read_consumed);</span><br><span class="line">mIn.setDataPosition(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>dataPosition 代表有效数据的起始点，dataSize 代表数据的大小，前面说过这个时候数据包含两个命令，现在只读取了一个，还剩一个，因此<code>mIn.dataPosition() &lt; mIn.dataSize()</code>，因此<code>needRead</code>为false，<code>doReceive</code>为false，因此 outAvail 是 0，那么 <code>(bwr.write_size == 0) &amp;&amp; (bwr.read_size == 0)</code>成立，直接返回 <code>NO_ERROR</code>。</p>
<p>好了，这里并没有走的很深入，我们又回到<code>IPCThreadState::waitForResponse</code>方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::waitForResponse(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> cmd;</span><br><span class="line">    <span class="keyword">int32_t</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        err = mIn.errorCheck();</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (mIn.dataAvail() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        cmd = mIn.readInt32();</span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</span><br><span class="line">        	<span class="comment">// reply 是传进来的，这里只是break，循环继续</span></span><br><span class="line">            <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">finish:</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>命令读完啦，第三次进入<code>talkWithDriver()</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::talkWithDriver(<span class="keyword">bool</span> doReceive)</span><br><span class="line">&#123;</span><br><span class="line">    LOG_ASSERT(mProcess-&gt;mDriverFD &gt;= <span class="number">0</span>, <span class="string">"Binder driver is not opened"</span>);</span><br><span class="line">    </span><br><span class="line">    binder_write_read bwr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Is the read buffer empty?</span></span><br><span class="line">    <span class="comment">// 为 true，经过两轮循环之后，mIn 中的数据已经读取完毕</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> needRead = mIn.dataPosition() &gt;= mIn.dataSize();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// We don't want to write anything if we are still reading</span></span><br><span class="line">    <span class="comment">// from data left in the input buffer and the caller</span></span><br><span class="line">    <span class="comment">// has requested to read the next data.</span></span><br><span class="line">    <span class="comment">// mOut 前面已经被清零，因此 outAvail 为 0</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> outAvail = (!doReceive || needRead) ? mOut.dataSize() : <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    bwr.write_size = outAvail;</span><br><span class="line">    bwr.write_buffer = (<span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)mOut.data();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is what we'll read.</span></span><br><span class="line">    <span class="keyword">if</span> (doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">        bwr.read_size = mIn.dataCapacity(); <span class="comment">// 不为 0</span></span><br><span class="line">        bwr.read_buffer = (<span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>)mIn.data();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bwr.read_size = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return immediately if there is nothing to do.</span></span><br><span class="line">    <span class="keyword">if</span> ((bwr.write_size == <span class="number">0</span>) &amp;&amp; (bwr.read_size == <span class="number">0</span>)) <span class="keyword">return</span> NO_ERROR;</span><br><span class="line"></span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 进入binder驱动</span></span><br><span class="line">        <span class="keyword">if</span> (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>)</span><br><span class="line">            err = NO_ERROR;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err = -errno;</span><br><span class="line">    &#125; <span class="keyword">while</span> (err == -EINTR);</span><br><span class="line"></span><br><span class="line">    .....</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码注释如上，不多解释，咱又进入驱动层了，因为只有<code>bwr.read_size</code>大于0，因此直接进入函数<code>binder_thread_read</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_read</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                  struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">void</span>  __user *buffer, <span class="keyword">int</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">signed</span> <span class="keyword">long</span> *consumed, <span class="keyword">int</span> non_block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> __user *ptr = buffer + *consumed;</span><br><span class="line">    <span class="keyword">void</span> __user *end = buffer + size;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> wait_for_proc_work;</span><br><span class="line">    <span class="keyword">if</span> (*consumed == <span class="number">0</span>) &#123; <span class="comment">// 同样滴，这里还是 0</span></span><br><span class="line">        <span class="keyword">if</span> (put_user(BR_NOOP, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line">retry:</span><br><span class="line">    <span class="comment">// thread-&gt;transaction_stack 不为空，&amp;thread-&gt;todo 为空，因此 wait_for_proc_work 为 false</span></span><br><span class="line">    wait_for_proc_work = thread-&gt;transaction_stack == <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">                list_empty(&amp;thread-&gt;todo);</span><br><span class="line">    <span class="comment">//设置状态为等待</span></span><br><span class="line">    thread-&gt;looper |= BINDER_LOOPER_STATE_WAITING;</span><br><span class="line">    <span class="keyword">if</span> (wait_for_proc_work)</span><br><span class="line">        proc-&gt;ready_threads++;</span><br><span class="line">    binder_unlock(__func__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wait_for_proc_work) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (non_block) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!binder_has_thread_work(thread))</span><br><span class="line">                ret = -EAGAIN;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="comment">// 走到这里，这时候 thread 的 todo 列表为空，阻塞</span></span><br><span class="line">            ret = wait_event_freezable(thread-&gt;wait, binder_has_thread_work(thread));</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，最终阻塞在了<code>thread</code>的<code>todo</code>队列上。</p>
<p>也就是说，MediaPlayerService 在发起一个注册请求的同时，通过向自己当前线程的<code>todo</code>队列上挂载 binder_work 对象，可以很顺利的向 Libraries 层发送消息。而 Libraries 此时处于一个循环读取数据的状态，在没有数据可以读取的情况下，就会被阻塞住，直到<code>todo</code>再次不为空。</p>
<h2 id="SM-的处理"><a href="#SM-的处理" class="headerlink" title="SM 的处理"></a>SM 的处理</h2><p>开始这一节之前，读者可以回顾一下文章 <a href="http://www.muzileecoding.com/framework/binder-servicemanager.html" target="_blank" rel="noopener">Binder之Service Manager</a> 的 5.3 和 5.4 小节。</p>
<p><strong>【注意】</strong> 下面的函数和前面的分析很类似，但是都是运行在 SM 进程中的，千万不要混淆了！</p>
<p>首先这里是因为条件符合才返回的，因此会走到<code>binder_thread_read</code>函数的<code>while</code>循环中去:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">w</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span> = <span class="title">NULL</span>;</span></span><br><span class="line">        <span class="keyword">if</span> (!list_empty(&amp;thread-&gt;todo))</span><br><span class="line">            w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work)</span><br><span class="line">            w = list_first_entry(&amp;proc-&gt;todo, struct binder_work, entry);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ptr - buffer == <span class="number">4</span> &amp;&amp; !(thread-&gt;looper &amp; BINDER_LOOPER_STATE_NEED_RETURN)) <span class="comment">/* no data added */</span></span><br><span class="line">                <span class="keyword">goto</span> retry;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end - ptr &lt; <span class="keyword">sizeof</span>(tr) + <span class="number">4</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 根据不同的 work 类型进行处理</span></span><br><span class="line">        <span class="keyword">switch</span> (w-&gt;type) &#123;</span><br><span class="line">	        <span class="keyword">case</span> BINDER_WORK_TRANSACTION: &#123;</span><br><span class="line">	        t = container_of(w, struct binder_transaction, work);</span><br><span class="line">	        &#125;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里从 thread/proc 的<code>todo</code>队列中获取 binder_work 来进行处理，以下是根据不同的 work 类型进行处理，前面插入 binder_work 的代码是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t-&gt;work 是 binder_work 结构体，该结构体在字典中可查询</span></span><br><span class="line">t-&gt;work.type = BINDER_WORK_TRANSACTION;</span><br><span class="line"><span class="comment">// 添加 t 到目标进程的todo list中去</span></span><br><span class="line">list_add_tail(&amp;t-&gt;work.entry, target_list);</span><br></pre></td></tr></table></figure>
<p>因此类型是”BINDER_WORK_TRANSACTION”，所以接着调用<code>container_of</code>方法获取 t，即 binder_transaction 对象。</p>
<blockquote>
<p><code>container_of</code>的作用：根据结构体的成员变量获取所在结构体的首地址。</p>
<p>代码里面藏着很多这样的函数/宏 —— 强大但是很不好阅读。</p>
</blockquote>
<p>获取到 binder_transaction 对象之后，剩下的就是解析了:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tr 是 binder_transaction_data 结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">w</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!t)<span class="comment">// 通过</span></span><br><span class="line">	<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 赋值：t-&gt;buffer-&gt;target_node = target_node; </span></span><br><span class="line"> <span class="comment">// 因此条件成立，且target_node指向的是 binder_context_mgr_node</span></span><br><span class="line"><span class="keyword">if</span> (t-&gt;buffer-&gt;target_node) &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span> = <span class="title">t</span>-&gt;<span class="title">buffer</span>-&gt;<span class="title">target_node</span>;</span></span><br><span class="line">	<span class="comment">// tr 是 binder_transaction_data 类型，还记得target这两个变量的值么？</span></span><br><span class="line">	tr.target.ptr = target_node-&gt;ptr;</span><br><span class="line">	tr.cookie =  target_node-&gt;cookie;</span><br><span class="line">	t-&gt;saved_priority = task_nice(current);</span><br><span class="line">	<span class="keyword">if</span> (t-&gt;priority &lt; target_node-&gt;min_priority &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY))</span><br><span class="line">		binder_set_nice(t-&gt;priority);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY) || t-&gt;saved_priority &gt; target_node-&gt;min_priority)</span><br><span class="line">		binder_set_nice(target_node-&gt;min_priority);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//注意这个命令的赋值</span></span><br><span class="line">	cmd = BR_TRANSACTION;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	tr.target.ptr = <span class="literal">NULL</span>;</span><br><span class="line">	tr.cookie = <span class="literal">NULL</span>;</span><br><span class="line">	cmd = BR_REPLY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tr.code = t-&gt;code;</span><br><span class="line">tr.flags = t-&gt;flags;</span><br><span class="line">tr.sender_euid = t-&gt;sender_euid;</span><br><span class="line"><span class="keyword">if</span> (t-&gt;from) &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">sender</span> = <span class="title">t</span>-&gt;<span class="title">from</span>-&gt;<span class="title">proc</span>-&gt;<span class="title">tsk</span>;</span></span><br><span class="line">	tr.sender_pid = task_tgid_nr_ns(sender, current-&gt;nsproxy-&gt;pid_ns);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	tr.sender_pid = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">tr.data_size = t-&gt;buffer-&gt;data_size;</span><br><span class="line">tr.offsets_size = t-&gt;buffer-&gt;offsets_size;</span><br><span class="line"><span class="comment">// 根据老罗的文章：这里正是 binder 机制的精髓，即如何做到复制一次的。</span></span><br><span class="line">tr.data.ptr.buffer = (<span class="keyword">void</span> *)t-&gt;buffer-&gt;data +  proc-&gt;user_buffer_offset;</span><br><span class="line">tr.data.ptr.offsets = tr.data.ptr.buffer + ALIGN(t-&gt;buffer-&gt;data_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line"></span><br><span class="line"><span class="comment">// @read数据@ 下面就是把cmd 和 tr 结构体 copy 到用户空间，cmd = BR_TRANSACTION;</span></span><br><span class="line"><span class="keyword">if</span> (put_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">	<span class="keyword">return</span> -EFAULT;</span><br><span class="line">ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (copy_to_user(ptr, &amp;tr, <span class="keyword">sizeof</span>(tr)))</span><br><span class="line">	<span class="keyword">return</span> -EFAULT;</span><br><span class="line">ptr += <span class="keyword">sizeof</span>(tr);</span><br><span class="line"></span><br><span class="line">trace_binder_transaction_received(t);</span><br><span class="line">binder_stat_br(proc, thread, cmd);</span><br><span class="line"><span class="comment">// 处理完毕，删除节点</span></span><br><span class="line">list_del(&amp;t-&gt;work.entry);</span><br><span class="line">t-&gt;buffer-&gt;allow_user_free = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 添加服务的时候是需要回复的，这里判断成立</span></span><br><span class="line"><span class="keyword">if</span> (cmd == BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">	t-&gt;to_parent = thread-&gt;transaction_stack;</span><br><span class="line">	t-&gt;to_thread = thread;</span><br><span class="line">	thread-&gt;transaction_stack = t; <span class="comment">// 放到栈顶 </span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	t-&gt;buffer-&gt;transaction = <span class="literal">NULL</span>;</span><br><span class="line">	kfree(t);</span><br><span class="line">	binder_stats_deleted(BINDER_STAT_TRANSACTION);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 跳出循环</span></span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>相关解析都在注释中，之前传过来的数据都被拷贝到用户空间中去了，之后就跳出循环，回到<code>binder_ioctl()</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">binder_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size = _IOC_SIZE(cmd);</span><br><span class="line">    <span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> BINDER_WRITE_READ: &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">        <span class="keyword">if</span> (size != <span class="keyword">sizeof</span>(struct binder_write_read)) &#123;</span><br><span class="line">            ret = -EINVAL;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(&amp;bwr, ubuf, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">            ret = -EFAULT;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ret = binder_thread_write(proc, thread, (<span class="keyword">void</span> __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);</span><br><span class="line">            trace_binder_write_done(ret);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">                    ret = -EFAULT;</span><br><span class="line">                <span class="keyword">goto</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="comment">// 数据都被拷贝到用户空间了</span></span><br><span class="line">            ret = binder_thread_read(proc, thread, (<span class="keyword">void</span> __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK);</span><br><span class="line">            trace_binder_read_done(ret);</span><br><span class="line">            <span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo))</span><br><span class="line">                wake_up_interruptible(&amp;proc-&gt;wait);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr)))</span><br><span class="line">                    ret = -EFAULT;</span><br><span class="line">                <span class="keyword">goto</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//再次拷贝数据到用户空间</span></span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">            ret = -EFAULT;</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，所有的数据顺利传输到了用户空间，在用户空间等待它的是<code>binder_loop()</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binder_loop</span><span class="params">(struct binder_state *bs, binder_handler func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="comment">// 该结构体在字典中可查</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> readbuf[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">    bwr.write_size = <span class="number">0</span>;</span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.write_buffer = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    readbuf[<span class="number">0</span>] = BC_ENTER_LOOPER;</span><br><span class="line">    <span class="comment">//告诉Binder驱动程序， Service Manager要进入循环了</span></span><br><span class="line">    binder_write(bs, readbuf, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        bwr.read_size = <span class="keyword">sizeof</span>(readbuf);</span><br><span class="line">        bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = (<span class="keyword">unsigned</span>) readbuf;</span><br><span class="line"></span><br><span class="line">        res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            LOGE(<span class="string">"binder_loop: ioctl failed (%s)\n"</span>, strerror(errno));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res = binder_parse(bs, <span class="number">0</span>, readbuf, bwr.read_consumed, func);</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">0</span>) &#123;</span><br><span class="line">            LOGE(<span class="string">"binder_loop: unexpected reply?!\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            LOGE(<span class="string">"binder_loop: io error %d %s\n"</span>, res, strerror(errno));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>ioctl()</code>返回之后，调用的就是<code>binder_parse()</code>函数，这个函数可以处理很多的命令，我们就看相关部分:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_parse</span><span class="params">(struct binder_state *bs, struct binder_io *bio,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">uint32_t</span> *ptr, <span class="keyword">uint32_t</span> size, binder_handler func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> *end = ptr + (size / <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (ptr &lt; end) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> cmd = *ptr++;</span><br><span class="line">        <span class="keyword">switch</span>(cmd) &#123;</span><br><span class="line">            ......</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION: &#123;</span><br><span class="line">        	<span class="comment">//该结构体字典中可查</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_txn</span> *<span class="title">txn</span> = (<span class="title">void</span> *) <span class="title">ptr</span>;</span></span><br><span class="line">            <span class="keyword">if</span> ((end - ptr) * <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>) &lt; <span class="keyword">sizeof</span>(struct binder_txn)) &#123;</span><br><span class="line">                LOGE(<span class="string">"parse: txn too small!\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            binder_dump_txn(txn);</span><br><span class="line">            <span class="keyword">if</span> (func) &#123;</span><br><span class="line">                <span class="keyword">unsigned</span> rdata[<span class="number">256</span>/<span class="number">4</span>];</span><br><span class="line">                <span class="comment">// 该结构体字典中可查</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">binder_io</span> <span class="title">msg</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">binder_io</span> <span class="title">reply</span>;</span></span><br><span class="line">                <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">                bio_init(&amp;reply, rdata, <span class="keyword">sizeof</span>(rdata), <span class="number">4</span>);</span><br><span class="line">                bio_init_from_txn(&amp;msg, txn);</span><br><span class="line">                res = func(bs, txn, &amp;msg, &amp;reply);</span><br><span class="line">                binder_send_reply(bs, &amp;reply, txn-&gt;data, res);</span><br><span class="line">            &#125;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(*txn) / <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里读出来的命令就是<code>BR_TRANSACTION</code>，然后将数据部分（一个 binder_transaction_data 结构体，读者可以搜”@read数据@”定位）解析成<code>binder_txn</code>结构体(对比结构体字段就可以知道转换确实可行)。接着是声明了两个 binder_io 结构体，在字典中可查。在这里还有两个方法，也一并列举一下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bio_init_from_txn</span><span class="params">(struct binder_io *bio, struct binder_txn *txn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bio-&gt;data = bio-&gt;data0 = txn-&gt;data;</span><br><span class="line">    bio-&gt;offs = bio-&gt;offs0 = txn-&gt;offs;</span><br><span class="line">    bio-&gt;data_avail = txn-&gt;data_size;</span><br><span class="line">    bio-&gt;offs_avail = txn-&gt;offs_size / <span class="number">4</span>;</span><br><span class="line">    bio-&gt;flags = BIO_F_SHARED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bio_init</span><span class="params">(struct binder_io *bio, <span class="keyword">void</span> *data,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">uint32_t</span> maxdata, <span class="keyword">uint32_t</span> maxoffs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> n = maxoffs * <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &gt; maxdata) &#123;</span><br><span class="line">        bio-&gt;flags = BIO_F_OVERFLOW;</span><br><span class="line">        bio-&gt;data_avail = <span class="number">0</span>;</span><br><span class="line">        bio-&gt;offs_avail = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bio-&gt;data = bio-&gt;data0 = data + n;</span><br><span class="line">    bio-&gt;offs = bio-&gt;offs0 = data;</span><br><span class="line">    bio-&gt;data_avail = maxdata - n;</span><br><span class="line">    bio-&gt;offs_avail = maxoffs;</span><br><span class="line">    bio-&gt;flags = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个结构体在这里解释的意义不大，下一篇文章<a href="http://www.muzileecoding.com/framework/binder-service-lookup.html" target="_blank" rel="noopener">Binder之Service查询</a>中有较详细的解释。</p>
<p>最后调用func来处理命令，func是从 SM 的<code>main</code>函数中传递过来的，它真实的指向是<code>svcmgr_handler</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint16_t</span> svcmgr_id[] = &#123; </span><br><span class="line">    <span class="string">'a'</span>,<span class="string">'n'</span>,<span class="string">'d'</span>,<span class="string">'r'</span>,<span class="string">'o'</span>,<span class="string">'i'</span>,<span class="string">'d'</span>,<span class="string">'.'</span>,<span class="string">'o'</span>,<span class="string">'s'</span>,<span class="string">'.'</span>,</span><br><span class="line">    <span class="string">'I'</span>,<span class="string">'S'</span>,<span class="string">'e'</span>,<span class="string">'r'</span>,<span class="string">'v'</span>,<span class="string">'i'</span>,<span class="string">'c'</span>,<span class="string">'e'</span>,<span class="string">'M'</span>,<span class="string">'a'</span>,<span class="string">'n'</span>,<span class="string">'a'</span>,<span class="string">'g'</span>,<span class="string">'e'</span>,<span class="string">'r'</span> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">svcmgr_handler</span><span class="params">(struct binder_state *bs,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_txn *txn,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_io *msg,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_io *reply)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span> *<span class="title">si</span>;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> *s;</span><br><span class="line">    <span class="keyword">unsigned</span> len;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="keyword">uint32_t</span> strict_policy;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// svcmgr_handle 被赋值为 svcmgr，即BINDER_SERVICE_MANAGER，即0</span></span><br><span class="line">    <span class="keyword">if</span> (txn-&gt;target != svcmgr_handle)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Equivalent to Parcel::enforceInterface(), reading the RPC</span></span><br><span class="line">    <span class="comment">// header with the strict mode policy mask and the interface name.</span></span><br><span class="line">    <span class="comment">// Note that we ignore the strict_policy and don't propagate it</span></span><br><span class="line">    <span class="comment">// further (since we do no outbound RPCs anyway).</span></span><br><span class="line">    strict_policy = bio_get_uint32(msg);</span><br><span class="line">    s = bio_get_string16(msg, &amp;len);</span><br><span class="line">    <span class="comment">// svcmgr_id是一个字符数组，见最上面，这里判断是通过的，因为s读取出来就是"android.os.IServiceManager"</span></span><br><span class="line">    <span class="keyword">if</span> ((len != (<span class="keyword">sizeof</span>(svcmgr_id) / <span class="number">2</span>)) ||</span><br><span class="line">        <span class="built_in">memcmp</span>(svcmgr_id, s, <span class="keyword">sizeof</span>(svcmgr_id))) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"invalid id %s\n"</span>, str8(s));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(txn-&gt;code) &#123;</span><br><span class="line">		......</span><br><span class="line">    <span class="keyword">case</span> SVC_MGR_ADD_SERVICE:</span><br><span class="line">        s = bio_get_string16(msg, &amp;len); <span class="comment">// "media.player"</span></span><br><span class="line">        ptr = bio_get_ref(msg);</span><br><span class="line">        <span class="keyword">if</span> (do_add_service(bs, s, len, ptr, txn-&gt;sender_euid))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">	</span><br><span class="line">		......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bio_put_uint32(reply, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 code 最初是什么呢？读者往上翻翻就知道是<code>ADD_SERVICE_TRANSACTION</code>，它是定义在 “IServiceManager.h” 中的一个枚举值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">	GET_SERVICE_TRANSACTION = IBinder::FIRST_CALL_TRANSACTION,</span><br><span class="line">	CHECK_SERVICE_TRANSACTION,</span><br><span class="line">	ADD_SERVICE_TRANSACTION,</span><br><span class="line">	LIST_SERVICES_TRANSACTION,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>IBinder::FIRST_CALL_TRANSACTION</code>的定义如下：<code>FIRST_CALL_TRANSACTION  = 0x00000001</code>，即1，那么ADD_SERVICE_TRANSACTION就是 3。而这里 code 的几个可能值类型也是枚举值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    SVC_MGR_GET_SERVICE = <span class="number">1</span>,</span><br><span class="line">    SVC_MGR_CHECK_SERVICE,</span><br><span class="line">    SVC_MGR_ADD_SERVICE,</span><br><span class="line">    SVC_MGR_LIST_SERVICES,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所以，<code>SVC_MGR_ADD_SERVICE</code>的值也是 3，即执行该 case。从代码看应该正好有四句数据读取代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">strict_policy = bio_get_uint32(msg); <span class="comment">// 读取 StrictModePolicy，一个int值</span></span><br><span class="line">s = bio_get_string16(msg, &amp;len); <span class="comment">// “android.os.IServiceManager”</span></span><br><span class="line">s = bio_get_string16(msg, &amp;len);</span><br><span class="line">ptr = bio_get_ref(msg);</span><br></pre></td></tr></table></figure>
<p>还记得服务注册初始数据图么？它正好也是四个部分，与这里是一一对应，这部分数据从一开始的分析就出现了，一直到现在才开始解析，调用链极长。第四个变量还需要看一下方法<code>bio_get_ref</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">bio_get_ref</span><span class="params">(struct binder_io *bio)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_object</span> *<span class="title">obj</span>;</span></span><br><span class="line"></span><br><span class="line">    obj = _bio_get_obj(bio);</span><br><span class="line">    <span class="keyword">if</span> (!obj)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;type == BINDER_TYPE_HANDLE)</span><br><span class="line">        <span class="keyword">return</span> obj-&gt;pointer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">binder_object</span> *_<span class="title">bio_get_obj</span>(<span class="title">struct</span> <span class="title">binder_io</span> *<span class="title">bio</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> n;</span><br><span class="line">    <span class="keyword">unsigned</span> off = bio-&gt;data - bio-&gt;data0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; bio-&gt;offs_avail; n++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bio-&gt;offs[n] == off)</span><br><span class="line">        	<span class="comment">//获取 binder_object 对象</span></span><br><span class="line">            <span class="keyword">return</span> bio_get(bio, <span class="keyword">sizeof</span>(struct binder_object));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bio-&gt;data_avail = <span class="number">0</span>;</span><br><span class="line">    bio-&gt;flags |= BIO_F_OVERFLOW;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里还是得看服务注册初始数据图：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/service注册transact数据.png" width="600" alt="service注册transact数据"></div>

<p>实际上我们在这个位置存储的对象并不是 binder_object 结构体，而是 flat_binder_object 结构体，但是字段上看，的确是可以强转的。另外不知道读者还是否记得，binder 驱动在传递 binder 节点的时候，已经把 Type 改成了 BINDER_TYPE_HANDLE 了，因此这里的 ptr 实际就是 SM 为 MediaPlayerService 分配的 handle 值。</p>
<p>接下去就到了正主出现的时刻：<code>do_add_service</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数解释：s 就是 "media.player"</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_add_service</span><span class="params">(struct binder_state *bs,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">uint16_t</span> *s, <span class="keyword">unsigned</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">void</span> *ptr, <span class="keyword">unsigned</span> uid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 该结构体在字典中可查</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span> *<span class="title">si</span>;</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (!ptr || (len == <span class="number">0</span>) || (len &gt; <span class="number">127</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (!svc_can_register(uid, s)) &#123;</span><br><span class="line">        LOGE(<span class="string">"add_service('%s',%p) uid=%d - PERMISSION DENIED\n"</span>,</span><br><span class="line">             str8(s), ptr, uid);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    si = find_svc(s, len);</span><br><span class="line">    <span class="keyword">if</span> (si) &#123;</span><br><span class="line">        <span class="keyword">if</span> (si-&gt;ptr) &#123;</span><br><span class="line">            LOGE(<span class="string">"add_service('%s',%p) uid=%d - ALREADY REGISTERED, OVERRIDE\n"</span>,</span><br><span class="line">                 str8(s), ptr, uid);</span><br><span class="line">            svcinfo_death(bs, si);</span><br><span class="line">        &#125;</span><br><span class="line">        si-&gt;ptr = ptr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        si = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*si) + (len + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">        <span class="keyword">if</span> (!si) &#123;</span><br><span class="line">            LOGE(<span class="string">"add_service('%s',%p) uid=%d - OUT OF MEMORY\n"</span>,</span><br><span class="line">                 str8(s), ptr, uid);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        si-&gt;ptr = ptr;</span><br><span class="line">        si-&gt;len = len;</span><br><span class="line">        <span class="built_in">memcpy</span>(si-&gt;name, s, (len + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">        si-&gt;name[len] = <span class="string">'\0'</span>;</span><br><span class="line">        si-&gt;death.func = svcinfo_death;</span><br><span class="line">        si-&gt;death.ptr = si;</span><br><span class="line">        si-&gt;next = svclist;</span><br><span class="line">        svclist = si;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    binder_acquire(bs, ptr);</span><br><span class="line">    binder_link_to_death(bs, ptr, &amp;si-&gt;death);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数一进来首先是参数判断，从这里可以看出，实际上 Service 名字的长度是有限制的，转成字符数组必须在长度 127 以内；第二步是权限检测：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> uid;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">&#125; allowed[] = &#123;</span><br><span class="line">#ifdef LVMX</span><br><span class="line">    &#123; AID_MEDIA, <span class="string">"com.lifevibes.mx.ipc"</span> &#125;,</span><br><span class="line">#endif</span><br><span class="line">    &#123; AID_MEDIA, <span class="string">"media.audio_flinger"</span> &#125;,</span><br><span class="line">    &#123; AID_MEDIA, <span class="string">"media.player"</span> &#125;,</span><br><span class="line">    &#123; AID_MEDIA, <span class="string">"media.camera"</span> &#125;,</span><br><span class="line">    &#123; AID_MEDIA, <span class="string">"media.audio_policy"</span> &#125;,</span><br><span class="line">    &#123; AID_DRM,   <span class="string">"drm.drmManager"</span> &#125;,</span><br><span class="line">    &#123; AID_NFC,   <span class="string">"nfc"</span> &#125;,</span><br><span class="line">    &#123; AID_RADIO, <span class="string">"radio.phone"</span> &#125;,</span><br><span class="line">    &#123; AID_RADIO, <span class="string">"radio.sms"</span> &#125;,</span><br><span class="line">    &#123; AID_RADIO, <span class="string">"radio.phonesubinfo"</span> &#125;,</span><br><span class="line">    &#123; AID_RADIO, <span class="string">"radio.simphonebook"</span> &#125;,</span><br><span class="line"><span class="comment">/* <span class="doctag">TODO:</span> remove after phone services are updated: */</span></span><br><span class="line">    &#123; AID_RADIO, <span class="string">"phone"</span> &#125;,</span><br><span class="line">    &#123; AID_RADIO, <span class="string">"sip"</span> &#125;,</span><br><span class="line">    &#123; AID_RADIO, <span class="string">"isms"</span> &#125;,</span><br><span class="line">    &#123; AID_RADIO, <span class="string">"iphonesubinfo"</span> &#125;,</span><br><span class="line">    &#123; AID_RADIO, <span class="string">"simphonebook"</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">svc_can_register</span><span class="params">(<span class="keyword">unsigned</span> uid, <span class="keyword">uint16_t</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((uid == <span class="number">0</span>) || (uid == AID_SYSTEM))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; <span class="keyword">sizeof</span>(allowed) / <span class="keyword">sizeof</span>(allowed[<span class="number">0</span>]); n++)</span><br><span class="line">        <span class="keyword">if</span> ((uid == allowed[n].uid) &amp;&amp; str16eq(name, allowed[n].name))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有 root 进程或者 system server 进程或者具有特殊名字的服务才能注册的。再接着就是查看是否有同名服务注册：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct svcinfo *<span class="title">find_svc</span><span class="params">(<span class="keyword">uint16_t</span> *s16, <span class="keyword">unsigned</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span> *<span class="title">si</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (si = svclist; si; si = si-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((len == si-&gt;len) &amp;&amp;</span><br><span class="line">            !<span class="built_in">memcmp</span>(s16, si-&gt;name, len * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>))) &#123;</span><br><span class="line">            <span class="keyword">return</span> si;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有必要解释一下 svclist 这个变量了，它是一个链表，元素就是 svcinfo，所有注册过来的服务都以 svcinfo 记录下来添加在 svclist 中，因此函数<code>find_svc()</code>实际在做事情是遍历该链表，找出是否有同名的服务已经注册过了。如果有，则更新服务，用新的 ptr 替换旧有的 ptr，否则分配新的 svcinfo 结构体，记录服务信息，并挂载到 svclist 链表上，执行完毕后返回 0。</p>
<p>好了，到这里，<strong>服务终于注册到 SM 了</strong>。实际上还没有完结，因为 MediaPlayerService 还在等待回复啊！</p>
<h2 id="注册答复"><a href="#注册答复" class="headerlink" title="注册答复"></a>注册答复</h2><p>注册答复的起始点我们还得回到<code>binder_parse</code>方法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_parse</span><span class="params">(struct binder_state *bs, struct binder_io *bio,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">uint32_t</span> *ptr, <span class="keyword">uint32_t</span> size, binder_handler func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> *end = ptr + (size / <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (ptr &lt; end) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> cmd = *ptr++;</span><br><span class="line">        <span class="keyword">switch</span>(cmd) &#123;</span><br><span class="line">            ......</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION: &#123;</span><br><span class="line">        	<span class="comment">//该结构体字典中可查</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_txn</span> *<span class="title">txn</span> = (<span class="title">void</span> *) <span class="title">ptr</span>;</span></span><br><span class="line">            <span class="keyword">if</span> ((end - ptr) * <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>) &lt; <span class="keyword">sizeof</span>(struct binder_txn)) &#123;</span><br><span class="line">                LOGE(<span class="string">"parse: txn too small!\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            binder_dump_txn(txn);</span><br><span class="line">            <span class="keyword">if</span> (func) &#123;</span><br><span class="line">                <span class="keyword">unsigned</span> rdata[<span class="number">256</span>/<span class="number">4</span>];</span><br><span class="line">                <span class="comment">// 该结构体字典中可查</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">binder_io</span> <span class="title">msg</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">binder_io</span> <span class="title">reply</span>;</span></span><br><span class="line">                <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">                bio_init(&amp;reply, rdata, <span class="keyword">sizeof</span>(rdata), <span class="number">4</span>);</span><br><span class="line">                bio_init_from_txn(&amp;msg, txn);</span><br><span class="line">                res = func(bs, txn, &amp;msg, &amp;reply);</span><br><span class="line">                binder_send_reply(bs, &amp;reply, txn-&gt;data, res);</span><br><span class="line">            &#125;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(*txn) / <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在调用<code>svcmgr_handler</code>函数处理请求之后，会接着调用<code>binder_send_reply</code>发送答复：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数解释：status 为0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binder_send_reply</span><span class="params">(struct binder_state *bs,</span></span></span><br><span class="line"><span class="function"><span class="params">                       struct binder_io *reply,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">void</span> *buffer_to_free,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> status)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> cmd_free;</span><br><span class="line">        <span class="keyword">void</span> *buffer;</span><br><span class="line">        <span class="keyword">uint32_t</span> cmd_reply;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_txn</span> <span class="title">txn</span>;</span></span><br><span class="line">    &#125; __attribute__((packed)) data;</span><br><span class="line"></span><br><span class="line">    data.cmd_free = BC_FREE_BUFFER; <span class="comment">// 注意命令</span></span><br><span class="line">    data.buffer = buffer_to_free;</span><br><span class="line">    data.cmd_reply = BC_REPLY; <span class="comment">// 注意命令</span></span><br><span class="line">    data.txn.target = <span class="number">0</span>;</span><br><span class="line">    data.txn.cookie = <span class="number">0</span>;</span><br><span class="line">    data.txn.code = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (status) &#123;</span><br><span class="line">        data.txn.flags = TF_STATUS_CODE;</span><br><span class="line">        data.txn.data_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">        data.txn.offs_size = <span class="number">0</span>;</span><br><span class="line">        data.txn.data = &amp;status;</span><br><span class="line">        data.txn.offs = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 走这里</span></span><br><span class="line">        data.txn.flags = <span class="number">0</span>;</span><br><span class="line">        data.txn.data_size = reply-&gt;data - reply-&gt;data0;</span><br><span class="line">        data.txn.offs_size = ((<span class="keyword">char</span>*) reply-&gt;offs) - ((<span class="keyword">char</span>*) reply-&gt;offs0);</span><br><span class="line">        data.txn.data = reply-&gt;data0;</span><br><span class="line">        data.txn.offs = reply-&gt;offs0;</span><br><span class="line">    &#125;</span><br><span class="line">    binder_write(bs, &amp;data, <span class="keyword">sizeof</span>(data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里包装了很多数据，通过<code>binder_write</code>又写回到 驱动中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_write</span><span class="params">(struct binder_state *bs, <span class="keyword">void</span> *data, <span class="keyword">unsigned</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    bwr.write_size = len;</span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.write_buffer = (<span class="keyword">unsigned</span>) data;</span><br><span class="line">    bwr.read_size = <span class="number">0</span>;</span><br><span class="line">    bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"binder_write: ioctl failed (%s)\n"</span>,</span><br><span class="line">                strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，只有write部分是有数据的，接着又回到了<code>binder_thread_write</code>方法中，其中有两个命令，一个是<code>BC_FREE_BUFFER</code>，另外一个是<code>BC_REPLY</code>，前者顾名思义就是释放缓冲区，我们就不去看了，后者比较重要：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> BC_TRANSACTION:</span><br><span class="line"><span class="keyword">case</span> BC_REPLY: &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(&amp;tr, ptr, <span class="keyword">sizeof</span>(tr)))</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		ptr += <span class="keyword">sizeof</span>(tr);</span><br><span class="line">		binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法已经来过一次了，只不过上次是<code>BC_TRANSACTION</code>命令。自然而然又要进入<code>binder_transaction</code>了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数解释：reply 是 true</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_transaction</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_transaction_data *tr, <span class="keyword">int</span> reply)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">tcomplete</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> *offp, *off_end;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">target_proc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">target_thread</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">target_list</span>;</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> *target_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">in_reply_to</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_log_entry</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> return_error;</span><br><span class="line">    e = binder_transaction_log_add(&amp;binder_transaction_log);</span><br><span class="line">    e-&gt;call_type = reply ? <span class="number">2</span> : !!(tr-&gt;flags &amp; TF_ONE_WAY);</span><br><span class="line">    e-&gt;from_proc = proc-&gt;pid;</span><br><span class="line">    e-&gt;from_thread = thread-&gt;pid;</span><br><span class="line">    e-&gt;target_handle = tr-&gt;target.handle;</span><br><span class="line">    e-&gt;data_size = tr-&gt;data_size;</span><br><span class="line">    e-&gt;offsets_size = tr-&gt;offsets_size;</span><br><span class="line">    <span class="keyword">if</span> (reply) &#123; <span class="comment">// true</span></span><br><span class="line">        in_reply_to = thread-&gt;transaction_stack; <span class="comment">// 之前放了一个进去，不为null</span></span><br><span class="line">        binder_set_nice(in_reply_to-&gt;saved_priority);</span><br><span class="line">        <span class="keyword">if</span> (in_reply_to-&gt;to_thread != thread) &#123;</span><br><span class="line">            .....</span><br><span class="line">            <span class="keyword">goto</span> err_bad_call_stack;</span><br><span class="line">        &#125;</span><br><span class="line">        thread-&gt;transaction_stack = in_reply_to-&gt;to_parent;</span><br><span class="line">        target_thread = in_reply_to-&gt;from; <span class="comment">// 找到发送请求的线程</span></span><br><span class="line">        <span class="keyword">if</span> (target_thread == <span class="literal">NULL</span>) &#123; </span><br><span class="line">            return_error = BR_DEAD_REPLY;</span><br><span class="line">            <span class="keyword">goto</span> err_dead_binder;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 校验，保证是同一个 transaction</span></span><br><span class="line">        <span class="keyword">if</span> (target_thread-&gt;transaction_stack != in_reply_to) &#123;</span><br><span class="line">            <span class="keyword">goto</span> err_dead_binder;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 本次回复的目标进程</span></span><br><span class="line">        target_proc = target_thread-&gt;proc;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (target_thread) &#123;</span><br><span class="line">        e-&gt;to_thread = target_thread-&gt;pid;</span><br><span class="line">        target_list = &amp;target_thread-&gt;todo;</span><br><span class="line">        target_wait = &amp;target_thread-&gt;wait;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        target_list = &amp;target_proc-&gt;todo;</span><br><span class="line">        target_wait = &amp;target_proc-&gt;wait;</span><br><span class="line">    &#125;</span><br><span class="line">    e-&gt;to_proc = target_proc-&gt;pid;</span><br><span class="line">    t = kzalloc(<span class="keyword">sizeof</span>(*t), GFP_KERNEL);</span><br><span class="line">    binder_stats_created(BINDER_STAT_TRANSACTION);</span><br><span class="line">    tcomplete = kzalloc(<span class="keyword">sizeof</span>(*tcomplete), GFP_KERNEL);</span><br><span class="line">    binder_stats_created(BINDER_STAT_TRANSACTION_COMPLETE);</span><br><span class="line">    t-&gt;debug_id = ++binder_last_id;</span><br><span class="line">    e-&gt;debug_id = t-&gt;debug_id;</span><br><span class="line">    <span class="keyword">if</span> (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY))</span><br><span class="line">        t-&gt;from = thread;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 走这里</span></span><br><span class="line">        t-&gt;from = <span class="literal">NULL</span>; </span><br><span class="line">    t-&gt;sender_euid = proc-&gt;tsk-&gt;cred-&gt;euid;</span><br><span class="line">    t-&gt;to_proc = target_proc;</span><br><span class="line">    t-&gt;to_thread = target_thread;</span><br><span class="line">    t-&gt;code = tr-&gt;code;</span><br><span class="line">    t-&gt;flags = tr-&gt;flags;</span><br><span class="line">    t-&gt;priority = task_nice(current);</span><br><span class="line">    trace_binder_transaction(reply, t, target_node);</span><br><span class="line">    t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size,</span><br><span class="line">        tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));</span><br><span class="line">    t-&gt;buffer-&gt;allow_user_free = <span class="number">0</span>;</span><br><span class="line">    t-&gt;buffer-&gt;debug_id = t-&gt;debug_id;</span><br><span class="line">    t-&gt;buffer-&gt;transaction = t;</span><br><span class="line">    t-&gt;buffer-&gt;target_node = target_node;</span><br><span class="line">    trace_binder_transaction_alloc_buf(t-&gt;buffer);</span><br><span class="line">    <span class="keyword">if</span> (target_node)</span><br><span class="line">        binder_inc_node(target_node, <span class="number">1</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    offp = (<span class="keyword">size_t</span> *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)));</span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) &#123;</span><br><span class="line">        return_error = BR_FAILED_REPLY;</span><br><span class="line">        <span class="keyword">goto</span> err_copy_data_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) &#123;</span><br><span class="line">        return_error = BR_FAILED_REPLY;</span><br><span class="line">        <span class="keyword">goto</span> err_copy_data_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!IS_ALIGNED(tr-&gt;offsets_size, <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>))) &#123;</span><br><span class="line">        return_error = BR_FAILED_REPLY;</span><br><span class="line">        <span class="keyword">goto</span> err_bad_offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">        <span class="comment">// 执行pop，删除该 binder_transaction</span></span><br><span class="line">        binder_pop_transaction(target_thread, in_reply_to);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;work.type = BINDER_WORK_TRANSACTION;</span><br><span class="line">    <span class="comment">// 又是挂载任务</span></span><br><span class="line">    list_add_tail(&amp;t-&gt;work.entry, target_list);</span><br><span class="line">    tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;</span><br><span class="line">    list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);</span><br><span class="line">    <span class="comment">// 唤醒线程</span></span><br><span class="line">    <span class="keyword">if</span> (target_wait)</span><br><span class="line">        wake_up_interruptible(target_wait);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释已经添加，和之前进来差不多，只不过角色互换了：SM 往 MediaPlayerService 的 申请服务注册线程上面挂载了一个任务。最终 SM 的线程唤醒了在<code>target_wait</code>上等待的线程，即我们在 <strong>2.3.4 节</strong> 描述的 MediaPlayerService 的申请服务注册线程。然后 SM 欢快的回去进行收尾工作。</p>
<p>MediaPlayerService 的申请服务注册线程被唤醒后会做什么，这里不做分析了，读者可以自行分析，下篇文章会涉及。</p>
<h2 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h2><p>在服务初始化完成之后，”main_mediaserver” 会执行下面两行代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ProcessState::self()-&gt;startThreadPool();</span><br><span class="line">IPCThreadState::self()-&gt;joinThreadPool();</span><br></pre></td></tr></table></figure>
<p>下面就来解析一下这两行代码：</p>
<h3 id="ProcessState-self-gt-startThreadPool"><a href="#ProcessState-self-gt-startThreadPool" class="headerlink" title="ProcessState::self()-&gt;startThreadPool()"></a><code>ProcessState::self()-&gt;startThreadPool()</code></h3><p>该方法的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ProcessState::startThreadPool()</span><br><span class="line">&#123;</span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    <span class="keyword">if</span> (!mThreadPoolStarted) &#123;</span><br><span class="line">        mThreadPoolStarted = <span class="literal">true</span>;</span><br><span class="line">        spawnPooledThread(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">``</span><br><span class="line">设置`mThreadPoolStarted`属性之后，调用方法`spawnPooledThread`：</span><br><span class="line"></span><br><span class="line">​```C++</span><br><span class="line"><span class="comment">// 参数解释：isMain为true</span></span><br><span class="line"><span class="keyword">void</span> ProcessState::spawnPooledThread(<span class="keyword">bool</span> isMain)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mThreadPoolStarted) &#123;</span><br><span class="line">        <span class="keyword">int32_t</span> s = android_atomic_add(<span class="number">1</span>, &amp;mThreadPoolSeq);</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">"Binder Thread #%d"</span>, s);</span><br><span class="line">        LOGV(<span class="string">"Spawning new pooled thread, name=%s\n"</span>, buf);</span><br><span class="line">        sp&lt;Thread&gt; t = <span class="keyword">new</span> PoolThread(isMain);</span><br><span class="line">        t-&gt;run(buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要工作是新建了 PoolThread 实例，并调用<code>run()</code>方法，该类定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PoolThread</span> :</span> <span class="keyword">public</span> Thread</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    PoolThread(<span class="keyword">bool</span> isMain)</span><br><span class="line">        : mIsMain(isMain)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">threadLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        IPCThreadState::self()-&gt;joinThreadPool(mIsMain);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> mIsMain;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>run()</code>来源于父类，会调用虚方法<code>threadLoop()</code>，而在<code>threadLoop()</code>中调用的却是<code>IPCThreadState::self()-&gt;joinThreadPool(mIsMain)</code>，好了，万剑归宗，直接看这个方法吧。</p>
<h3 id="7-2-IPCThreadState-self-gt-joinThreadPool"><a href="#7-2-IPCThreadState-self-gt-joinThreadPool" class="headerlink" title="7.2 IPCThreadState::self()-&gt;joinThreadPool()"></a>7.2 <code>IPCThreadState::self()-&gt;joinThreadPool()</code></h3><p>该方法的在 header 文件中的定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">joinThreadPool</span><span class="params">(<span class="keyword">bool</span> isMain = <span class="literal">true</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>默认参数为 true。</p>
<blockquote>
<p>老罗的文章在这里有个小错误，默认值确实是 true，我看了1.6，2.2.3，4.0.4几个版本都是true。</p>
</blockquote>
<p>这个方法的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> IPCThreadState::joinThreadPool(<span class="keyword">bool</span> isMain)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进入 Looper 状态</span></span><br><span class="line">    mOut.writeInt32(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// This thread may have been spawned by a thread that was in the background</span></span><br><span class="line">    <span class="comment">// scheduling group, so first we will make sure it is in the default/foreground</span></span><br><span class="line">    <span class="comment">// one to avoid performing an initial transaction in the background.</span></span><br><span class="line">    <span class="comment">// 调度线程的优先级</span></span><br><span class="line">    androidSetThreadSchedulingGroup(mMyThreadId, ANDROID_TGROUP_DEFAULT);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">status_t</span> result;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">int32_t</span> cmd;</span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取命令</span></span><br><span class="line">        result = talkWithDriver();</span><br><span class="line">        <span class="keyword">if</span> (result &gt;= NO_ERROR) &#123;</span><br><span class="line">            <span class="keyword">size_t</span> IN = mIn.dataAvail();</span><br><span class="line">            <span class="keyword">if</span> (IN &lt; <span class="keyword">sizeof</span>(<span class="keyword">int32_t</span>)) <span class="keyword">continue</span>;</span><br><span class="line">            cmd = mIn.readInt32();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用该函数执行命令</span></span><br><span class="line">            result = executeCommand(cmd);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调度线程的优先级</span></span><br><span class="line">        androidSetThreadSchedulingGroup(mMyThreadId, ANDROID_TGROUP_DEFAULT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Let this thread exit the thread pool if it is no longer</span></span><br><span class="line">        <span class="comment">// needed and it is not the main process thread.</span></span><br><span class="line">        <span class="keyword">if</span>(result == TIMED_OUT &amp;&amp; !isMain) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (result != -ECONNREFUSED &amp;&amp; result != -EBADF);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出 Looper 状态</span></span><br><span class="line">    mOut.writeInt32(BC_EXIT_LOOPER);</span><br><span class="line">    <span class="comment">// 不再接受数据</span></span><br><span class="line">    talkWithDriver(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以这里是起了两个线程，不停的从驱动中读取数据，并交给<code>executeCommand()</code>执行命令。在处理各种命令的时候，有一段如下的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tr.target.ptr) &#123;</span><br><span class="line">	sp&lt;BBinder&gt; b((BBinder*)tr.cookie);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">status_t</span> error = b-&gt;transact(tr.code, buffer, &amp;reply, tr.flags);</span><br><span class="line">	<span class="keyword">if</span> (error &lt; NO_ERROR) reply.setError(error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码可谓精华了！还记得<code>cookie</code>记录的是什么么？服务实例在用户空间的引用地址！所以这里是根据这个地址又拿到了该服务的实例，然后还记得这张图么？</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/Binder-Lib层架构.png" alt="Binder Lib层架构"></div>

<p>BBinder的<code>transact()</code>方法实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> BBinder::transact(</span><br><span class="line">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    data.setDataPosition(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err = NO_ERROR;</span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">        <span class="keyword">case</span> PING_TRANSACTION:</span><br><span class="line">            reply-&gt;writeInt32(pingBinder());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            err = onTransact(code, data, reply, flags);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reply != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        reply-&gt;setDataPosition(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里调用的又是<code>onTransact()</code>，而这个方法又是在BBinder的子类，比如<code>BnMediaPlayerService</code>中实现的 —— 即可以根据具体的服务 API 进行不同的解析，并完成相关功能。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>代码分析完毕，读者可能觉得整个过程无比繁杂，有些方法又臭又长，还不止调用一次。但实际上这块机制并不复杂，理解起来困难可能是因为：</p>
<ol>
<li>C++ 语言编写，对于 Java 开发者来说语言不熟悉，C++ 本身的语言特性也导致阅读起来比较困难；</li>
<li>涉及驱动层，驱动知识造成障碍；</li>
<li>不能调试，如果是一个开源框架，我们是可以写一个 Demo 去调试某个点的，这样就不用费这么多精力把脑子当做计算机使用了；</li>
<li>对 Libraries 和 Binder 驱动层的交互协议不清楚，这样在数据上就比较难搞清楚结构，方法调用链又长，调用几层之后对于参数的内容就模糊了；</li>
<li>代码问题，这两层的代码写的并不好，注释也少，理解起来非常费力；</li>
</ol>
<blockquote>
<p>和 framework 层的代码比起来，这里的方法调用链其实并不算长。</p>
</blockquote>
<p>这里类比网络请求做一些文字描述，希望有助于读者搞清楚 Binder 的机理。大体过程上有以下几个关键部分：</p>
<ol>
<li>使用<code>binder_write_read</code>结构体在 Libraries 层和驱动层之间做数据传输介质，类比网络请求，该结构体就相当于 Request 和 Response 的合体；</li>
<li>有传输介质之后，传输使用的手段是<code>ioctl</code>、<code>open</code>等函数，类比网络请求，就像<code>openConnection()</code>等函数；</li>
<li>如果我们要发送数据，则在<code>binder_write_read</code>结构体的 write 部分写入数据，驱动层会 copy 数据到内核空间，并读取数据进行处理，当然，这个时候也会携带一些命令，比如<code>BINDER_WRITE_READ</code>，类比网络请求，这些命令类似于<code>GET</code>，<code>POST</code>等；</li>
<li>如果<code>binder_write_read</code>的 read 部分要求读取数据，那么驱动层会查看有没有事务要处理，有没有数据要传输给上层（具体传输什么数据，由场景确定），如果有就写入到 read 部分并 copy 到 Libraries 层，函数返回，Libraries 层读取数据进行处理，同样的这个时候数据中也会有命令，类比网络请求，这些命令就像”200”，”404”，”500”等 Http Status Code；如果没有数据，则会阻塞在自己的事务处理队列上，<ol>
<li>驱动层拿到数据之后，会做一些处理，比如生成<code>binder_node</code>节点，在目标进程中生成<code>binder_ref</code>节点，并操作红黑树、插入<code>binder_transaction</code>等等，这些过程看上去极为复杂，原因是我们一开始并不了解 binder 具体要做什么。实际上 binder 记录这些数据只为两件事：binder_transaction 能够正确发送到目标进程和目标进程处理完事务之后能够正确找到回复进程。这是 IPC 的主要任务，其余的数据都是为了这两个目标准备的。举个例子，比如在注册的时候在目标进程的 transaction_stack 中插入 binder_transaction 节点，就是为了处理完事务之后可以找到回复进程；</li>
</ol>
</li>
</ol>
<p>以上前四点和一个网络请求并无二致，只是数据规则变了一下，最后一点则是机制本身导致的特性。另外这里有一个核心点一定要整理一下：</p>
<p><strong>每一个服务都会对应在驱动层生成一个<code>binder_node</code>节点，这个节点是记录在本服务进程在驱动层的映射<code>binder_proc</code>结构体中的，binder驱动会维护很多的<code>binder_proc</code>结构体，在除本进程外的<code>binder_proc</code>结构体中，引用本进程的服务，一律使用的是<code>binder_ref</code>结构体！至于如何通过<code>binder_ref</code>结构体获取到对应的服务，正是下一篇文章所要探索的内容。</strong></p>
<p>以上，如果读者想要了解原理的话，直接读这部分即可。如果读者想了解一些较细致的原理的话，墙裂建议阅读推荐文章①和文章③两系列博客，还是那个评价：整理有序，图文并茂。实乃对付此等巨兽的神兵之作。</p>
<p>至此，服务注册分析完成。</p>
</div><div class="tags"><a href="/tags/源码/">源码</a><a href="/tags/Binder/">Binder</a></div><div class="post-nav"><a href="/2016/06/21/binder-service-lookup/" class="pre">Binder之Service查询</a><a href="/2016/06/21/binder-servicemanager/" class="next">Binder之Service Manager</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">59</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactiveX/">ReactiveX</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/后端/">后端</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/影视/">影视</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/电影/">电影</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Gitbook/" style="font-size: 15px;">Gitbook</a> <a href="/tags/Runtime/" style="font-size: 15px;">Runtime</a> <a href="/tags/视图/" style="font-size: 15px;">视图</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/权限/" style="font-size: 15px;">权限</a> <a href="/tags/代码优化/" style="font-size: 15px;">代码优化</a> <a href="/tags/Framework/" style="font-size: 15px;">Framework</a> <a href="/tags/性能优化/" style="font-size: 15px;">性能优化</a> <a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/合集/" style="font-size: 15px;">合集</a> <a href="/tags/ADB/" style="font-size: 15px;">ADB</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/反编译/" style="font-size: 15px;">反编译</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/Gradle/" style="font-size: 15px;">Gradle</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/基础/" style="font-size: 15px;">基础</a> <a href="/tags/效率/" style="font-size: 15px;">效率</a> <a href="/tags/MarkDown/" style="font-size: 15px;">MarkDown</a> <a href="/tags/电影/" style="font-size: 15px;">电影</a> <a href="/tags/Reactive/" style="font-size: 15px;">Reactive</a> <a href="/tags/AIDL/" style="font-size: 15px;">AIDL</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/驱动/" style="font-size: 15px;">驱动</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/日志/" style="font-size: 15px;">日志</a> <a href="/tags/事件/" style="font-size: 15px;">事件</a> <a href="/tags/代码设计/" style="font-size: 15px;">代码设计</a> <a href="/tags/网络/" style="font-size: 15px;">网络</a> <a href="/tags/测试/" style="font-size: 15px;">测试</a> <a href="/tags/Binder/" style="font-size: 15px;">Binder</a> <a href="/tags/Groovy/" style="font-size: 15px;">Groovy</a> <a href="/tags/Loader/" style="font-size: 15px;">Loader</a> <a href="/tags/RAC/" style="font-size: 15px;">RAC</a> <a href="/tags/事件处理/" style="font-size: 15px;">事件处理</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/10/30/AIDL-原理分析/">AIDL 原理分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/30/App-启动过程/">App 启动过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/PMS-解析/">PMS 解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/WMS-解析/">WindowManagerService 解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/AMS-解析/">AMS 解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/10/The-Good-Wife/">The-Good-Wife</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/10/Black-Sails/">黑帆</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/29/hello-world/">Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/23/XCode-8-2-1-ClangFormat-插件安装/">XCode 8.2.1 ClangFormat 插件安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/07/SourceTree-分支图谱/">SourceTree 分支图谱</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">蜗牛壳.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>