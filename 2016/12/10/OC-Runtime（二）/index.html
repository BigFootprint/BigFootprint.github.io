<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="李全民的个人博客"><title>OC Runtime（二） | 蜗牛壳</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-65882749-1','auto');ga('send','pageview');</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">OC Runtime（二）</h1><a id="logo" href="/.">蜗牛壳</a><p class="description">计算机只有 0 和 1 ，但世界是连续的</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">OC Runtime（二）</h1><div class="post-meta">Dec 10, 2016<span> | </span><span class="category"><a href="/categories/iOS/">iOS</a></span></div><div class="post-content"><p>在前一篇文章<a href="http://timebridge.space/2016/12/10/OC-Runtime/" target="_blank" rel="noopener">OC Runtime（一）</a>（以下简称”前文”）里面，通过对<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048-CH1-SW1" target="_blank" rel="noopener">《ObjC Runtime Guide》</a>文档的阅读，基本了解了 Runtime 的概念和能力。本文在此基础上进一步深入探索，为什么 Runtime 具备这样的能力，OC 又是基于怎样的结构实现当前的特性的。</p>
<blockquote>
<p>在 Apple 的<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">Source Browser</a>网站上可以下载到 Runtime 的源代码，代码下载下来解压后可以导入到 XCode 中查看。</p>
</blockquote>
<h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><p>前文提到，开发者在 OC 中的消息发送最终会被转化为 <code>objc_msgSend(receiver, selector, arg1, arg2, ...)</code>这样的调用格式，<code>objc_msgSend</code>方法定义在 message.h 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id objc_msgSend(id self, SEL op, ...)</span><br></pre></td></tr></table></figure>
<p>第一个和第二个参数在前文中有相应解释，这里它们的类型分别是 id 和 SEL，并且函数的返回值类型也是 id。那么这两个类型代表什么呢？我们就从这里入手。<a id="more"></a></p>
<h2 id="SEL-和-id"><a href="#SEL-和-id" class="headerlink" title="SEL 和 id"></a>SEL 和 id</h2><p>在项目中简单搜索，很快就能发现两者的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_selector *SEL;</span><br><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure>
<p>SEL 是一个指向 objc_selector 的指针，id 是一个指向 objc_object 的指针。</p>
<h3 id="objc-selector"><a href="#objc-selector" class="headerlink" title="objc_selector"></a>objc_selector</h3><p>关于 objc_selector 这个结构体的定义，runtime 库中并没有给出，但是可以参考以下两份资料：</p>
<ul>
<li><a href="https://sourceware.org/svn/gcc/tags/stack-last-merge/libobjc/objc/objc.h" target="_blank" rel="noopener">objc.h</a></li>
<li><a href="https://books.google.com.hk/books?id=onyzCAAAQBAJ&amp;pg=PA237&amp;lpg=PA237&amp;dq=the+definition+of+objc_selector&amp;source=bl&amp;ots=p2rIQX9Wjb&amp;sig=MxfZ9CPPzWSlAKqyz1xMZJt_10k&amp;hl=zh-CN&amp;sa=X&amp;ved=0ahUKEwj7vbD-4enQAhXFLhoKHa__Cz0Q6AEIVDAI#v=onepage&amp;q=the%20definition%20of%20objc_selector&amp;f=false" target="_blank" rel="noopener">Professional Swift</a></li>
</ul>
<p>其中第二份资料提到：</p>
<blockquote>
<p>However, on OS X and iOS, a struct objc_selector is simply a C string internally.</p>
</blockquote>
<p>结合我们对 SEL 的使用看，可以认为 SEL 等于一个字符串。比如下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method method = class_getInstanceMethod([MsgTest class], @selector(realMethod));</span><br><span class="line">NSLog(@&quot;%@&quot;, NSStringFromSelector(method_getName(method)));</span><br></pre></td></tr></table></figure>
<p>就会输出：realMethod。</p>
<p>读者可以去看看<code>method_getName</code>这个方法的返回值类型，就是 SEL，也就是说 SEL 是用来表示方法名的。</p>
<h3 id="objc-object"><a href="#objc-object" class="headerlink" title="objc_object"></a>objc_object</h3><p>这个结构体定义在 object-private.h 中，只有一个属性：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">isa_t</span> isa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//各种方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个属性是 isa_t 类型，它是一个联合体：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="keyword">isa_t</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="keyword">isa_t</span>(<span class="keyword">uintptr_t</span> value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;</span><br><span class="line">  	<span class="comment">//下面是三个结构体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中核心部分是一个 Class 属性，Class 是什么呢？定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_class *Class;</span><br></pre></td></tr></table></figure>
<p>是一个指向 objc_class 的指针，也就是说，<strong>每一个对象内部都存储着指向自己所属类型的指针</strong>。</p>
<p>objc_class 的定义则如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">    Class superclass;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">uint32_t</span> version;</span><br><span class="line">    <span class="keyword">uint32_t</span> info;</span><br><span class="line">    <span class="keyword">uint32_t</span> instance_size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">old_ivar_list</span> *<span class="title">ivars</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">old_method_list</span> **<span class="title">methodLists</span>;</span></span><br><span class="line">    Cache cache;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">old_protocol_list</span> *<span class="title">protocols</span>;</span></span><br><span class="line">  	<span class="comment">// CLS_EXT only</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> *ivar_layout;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">old_class_ext</span> *<span class="title">ext</span>;</span></span><br><span class="line">    <span class="comment">//各种方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里就很有意思了，虽然这些代码注释不多，但根据名字，依然能够看出一些端倪。</p>
<ul>
<li>首先这个结构体是继承 objc_object 的，这表明类也是一个对象，同时也会有一个 isa 属性；</li>
<li>其次这个结构体包含一个 superclass 的 Class 属性，这应该是指向它的父类；</li>
<li>接着，这个结构体包含三个结构体，从名字看，应该是依次包含所有变量、方法和实现的协议；</li>
<li>还有一个 Cache 变量，这个应该是前文提到的用于缓存被调用方法的；</li>
<li>最后，有一个 old_class_ext 扩展结构体属性；</li>
</ul>
<h4 id="变量、方法、协议和属性"><a href="#变量、方法、协议和属性" class="headerlink" title="变量、方法、协议和属性"></a>变量、方法、协议和属性</h4><p>变量列表的结构定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">old_ivar</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *ivar_name;</span><br><span class="line">    <span class="keyword">char</span> *ivar_type;</span><br><span class="line">    <span class="keyword">int</span> ivar_offset;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">old_ivar_list</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ivar_count;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* variable length structure */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">old_ivar</span> <span class="title">ivar_list</span>[1];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>看上去很简单，这个列表里面存储着的元素是 old_var，而这个结构体中有两个很重要的成员：变量名和变量类型。方法列表大致相同：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">old_method</span> &#123;</span></span><br><span class="line">    SEL method_name;</span><br><span class="line">    <span class="keyword">char</span> *method_types;</span><br><span class="line">    IMP method_imp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">old_method_list</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *obsolete;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> method_count;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">int</span> space;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* variable length structure */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">old_method</span> <span class="title">method_list</span>[1];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是方法列表的元素结构体有些特殊，首先方法名是 SEL 类型的，这个前面已经有分析。method_types 是什么？IMP 是又什么东西呢？</p>
<p>如果读者阅读了前文提到的<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1" target="_blank" rel="noopener">Type Encodings</a>小节，其实不是很难理解 method_types，我们可以使用如下的代码打印出它的案例，还是以前文的 MsgTest 类为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method method = class_getInstanceMethod([MsgTest class], @selector(realMethod));</span><br><span class="line">NSLog(@&quot;%s&quot;, method_getTypeEncoding(method));</span><br></pre></td></tr></table></figure>
<p>这段代码会输出：v16@0:8。</p>
<blockquote>
<p>v 表示 void，即返回值为 void，16 表示 整个方法参数占位的总长度，@0 表示在参数区域偏移为 0 的位置有一个 OC 对象，还记得前面说到的方法在被编译之后，第一个参数是 id 类型，即 self 么？:8 表示在参数列表偏移为 8 字节的地方有一个 SEL 对象，也就是前面分析的第二个参数 _cmd。</p>
<p>这里由于内存对齐的原因，会导致很多类型都站 4 个字节或者 8 个字节，读者可以自己实验。</p>
</blockquote>
<p>IMP 的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A pointer to the function of a method implementation. </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !OBJC_OLD_DISPATCH_PROTOTYPES</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*IMP)</span><span class="params">(<span class="keyword">void</span> <span class="comment">/* id, SEL, ... */</span> )</span></span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">id</span> <span class="params">(*IMP)</span><span class="params">(id, SEL, ...)</span></span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>注释说的很明白：指向方法实现的函数指针。其实在前文中提到 class_addMethod 的时候，已经遇到并使用过它了。</p>
<p>协议部分的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">old_protocol</span> &#123;</span></span><br><span class="line">    Class isa;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *protocol_name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">old_protocol_list</span> *<span class="title">protocol_list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_method_description_list</span> *<span class="title">instance_methods</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_method_description_list</span> *<span class="title">class_methods</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">old_protocol_list</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">old_protocol_list</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">long</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">old_protocol</span> *<span class="title">list</span>[1];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>协议元素 old_protocol 包含两个结构体，分别描述实例方法和类方法。最终都指向以下元素的一个集合：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Defines a method</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_method_description</span> &#123;</span></span><br><span class="line">	SEL name;               <span class="comment">/**&lt; The name of the method */</span></span><br><span class="line">	<span class="keyword">char</span> *types;            <span class="comment">/**&lt; The types of the method arguments */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里倒是很清楚的指出了<strong>SEL 代表的就是方法名</strong>，而 types 指向的是参数类型。只不过协议是没有方法实现的，因此这里没有 IMP 指针。其余的部分就不过多探究了。</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>乍一看，objc_class 结构体中并没有属性相关的内容，那是因为属性藏到了 old_class_ext 结构体中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">old_class_ext</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> size;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> *weak_ivar_layout;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">old_property_list</span> **<span class="title">propertyLists</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>old_property_list 结构体的内容如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">old_property</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *attributes;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">old_property_list</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> entsize;</span><br><span class="line">    <span class="keyword">uint32_t</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">old_property</span> <span class="title">first</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>到这边会看到一些熟悉的东西，这个列表里的元素是 old_property 结构体，还记得前文中打印属性的 name 和attributes 的例子么？这就是那两个值存储的地方。</p>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>Cache 的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_cache</span> *<span class="title">Cache</span></span></span><br></pre></td></tr></table></figure>
<p>它是一个指向 objc_cache 的指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_cache</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask <span class="comment">/* total = mask + 1 */</span>                 OBJC2_UNAVAILABLE;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> occupied                                    OBJC2_UNAVAILABLE;</span><br><span class="line">    Method buckets[<span class="number">1</span>]                                        OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Method 又是啥？其实前面的例子中已经用到，它的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">old_method</span> *<span class="title">Method</span>;</span></span><br></pre></td></tr></table></figure>
<p>就是一个指向 old_method 结构体的指针，这个结构体前面已经展示过了，因此 Cache 可以简单的认为就是一个存储着方法列表的结构体。这和我们之前了解到的和猜测的也相符合。</p>
<h4 id="类和元类"><a href="#类和元类" class="headerlink" title="类和元类"></a>类和元类</h4><p>虽然前面对 objc_class 结构体的展示省略了所有的方法，但是其中有一个方法还是比较重要的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NOT identical to this-&gt;ISA() when this is a metaclass</span></span><br><span class="line"><span class="function">Class <span class="title">getMeta</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (isMetaClass()) <span class="keyword">return</span> (Class)<span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">this</span>-&gt;ISA();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里涉及到一个元类的概念，当调用<code>getMeta()</code>方法的时候，如果当前类就是一个元类，返回自身就好，否则返回的是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> Class objc_object::ISA() </span><br><span class="line">&#123;</span><br><span class="line">    assert(!isTaggedPointer()); </span><br><span class="line">    <span class="keyword">return</span> isa.cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是个内联函数，最终值为 isa.cls —— 指向的是一个 Class 对象。那么究竟什么是 Meta Class 呢？读者可以参考这篇文章：<a href="https://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html" target="_blank" rel="noopener">What is a meta-class in Objective-C?</a> 它的主要结论如下：</p>
<ol>
<li>任何包含指向 Class 结构体指针的结构体都可以被认为是 objc_object，这也是为什么 OC 中可以向对象发送消息的原因：因为 Class 中包含了方法列表，这个在前文以及前面的分析中都已经提到；</li>
<li>Class 也是一个对象，根据前面的分析，objc_class 是继承 objc_object 的，也就是说，Class 也可以接收消息，比如<code>[NSObject alloc]</code>；</li>
<li>既然 Class 也是一个对象，那就必然有一个指针指针一个类型，以符合结论 1 中定义的 objc_object 的结构体特性，Class 指向的这个类型也必须包含一个 Method 列表以表明我们可以在 Class 上执行哪些方法；</li>
<li>Meta-Class，即元类，就是为这个需求存在的：当向一个 Class 对象发送消息的时候，就会在元类中寻找消息的处理者，也就是说，元类存储着类方法，每一个类都必须有自己独特的元类，因为每个类的类方法都可能不一样；</li>
<li>既然元类也有消息处理能力，即表明元类也和 Class 一样，也是一个对象，那它也必须有一个 Class。所有的元类都以继承树中的最基类的元类作为它们的 Class，也就是 NSObject 的所有子类的元类都以 NSObject 的元类作为自己的 Class。</li>
<li>Class 通过 superclass 指向指向自己的父类，meta-class 则通过自己的 superclass 指向父类的元类。</li>
</ol>
<p>总结下来就是下面这幅图（来源不明）：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/类与元类.jpg" height="360" alt="Android调优工具汇总"></div>

<p><strong>最基类（NSObject）是所有子类的基类，最基类的元类是最基类所有子类的元类的最基类，最基类的元类是所有子类以及自身元类的元类。</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，Runtime 中比较重要的数据结构分析完毕，结合前文，我们也基本知道了 OC 下面是怎样的一套数据结构在支撑它的特性。</p>
<p>Runtime 库中有部分实现代码在其中，在了解了基本的数据结构之后，接着就是探索 OC 特性与这些数据结构之间的关系，比如 Category 的实现原理、Method Swizzling等。</p>
</div><div class="tags"><a href="/tags/Runtime/">Runtime</a></div><div class="post-nav"><a href="/2016/12/22/Java-注释/" class="pre">Java 注释</a><a href="/2016/12/10/OC-Runtime/" class="next">OC Runtime（一）</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">59</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactiveX/">ReactiveX</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/后端/">后端</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/影视/">影视</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/电影/">电影</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Gitbook/" style="font-size: 15px;">Gitbook</a> <a href="/tags/Runtime/" style="font-size: 15px;">Runtime</a> <a href="/tags/视图/" style="font-size: 15px;">视图</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/权限/" style="font-size: 15px;">权限</a> <a href="/tags/代码优化/" style="font-size: 15px;">代码优化</a> <a href="/tags/Framework/" style="font-size: 15px;">Framework</a> <a href="/tags/性能优化/" style="font-size: 15px;">性能优化</a> <a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/合集/" style="font-size: 15px;">合集</a> <a href="/tags/ADB/" style="font-size: 15px;">ADB</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/反编译/" style="font-size: 15px;">反编译</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/Gradle/" style="font-size: 15px;">Gradle</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/基础/" style="font-size: 15px;">基础</a> <a href="/tags/效率/" style="font-size: 15px;">效率</a> <a href="/tags/MarkDown/" style="font-size: 15px;">MarkDown</a> <a href="/tags/电影/" style="font-size: 15px;">电影</a> <a href="/tags/Reactive/" style="font-size: 15px;">Reactive</a> <a href="/tags/AIDL/" style="font-size: 15px;">AIDL</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/驱动/" style="font-size: 15px;">驱动</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/日志/" style="font-size: 15px;">日志</a> <a href="/tags/事件/" style="font-size: 15px;">事件</a> <a href="/tags/代码设计/" style="font-size: 15px;">代码设计</a> <a href="/tags/网络/" style="font-size: 15px;">网络</a> <a href="/tags/测试/" style="font-size: 15px;">测试</a> <a href="/tags/Binder/" style="font-size: 15px;">Binder</a> <a href="/tags/Groovy/" style="font-size: 15px;">Groovy</a> <a href="/tags/Loader/" style="font-size: 15px;">Loader</a> <a href="/tags/RAC/" style="font-size: 15px;">RAC</a> <a href="/tags/事件处理/" style="font-size: 15px;">事件处理</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/10/30/AIDL-原理分析/">AIDL 原理分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/30/App-启动过程/">App 启动过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/PMS-解析/">PMS 解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/WMS-解析/">WindowManagerService 解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/AMS-解析/">AMS 解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/10/The-Good-Wife/">The-Good-Wife</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/10/Black-Sails/">黑帆</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/29/hello-world/">Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/23/XCode-8-2-1-ClangFormat-插件安装/">XCode 8.2.1 ClangFormat 插件安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/07/SourceTree-分支图谱/">SourceTree 分支图谱</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">蜗牛壳.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>