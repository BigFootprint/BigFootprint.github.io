<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="李全民的个人博客"><title>Android View事件处理 | 蜗牛壳</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-65882749-1','auto');ga('send','pageview');</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android View事件处理</h1><a id="logo" href="/.">蜗牛壳</a><p class="description">计算机只有 0 和 1 ，但世界是连续的</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android View事件处理</h1><div class="post-meta">Sep 4, 2016<span> | </span><span class="category"><a href="/categories/Android/">Android</a></span></div><div class="post-content"><h2 id="View-模型-amp-事件模型"><a href="#View-模型-amp-事件模型" class="headerlink" title="View 模型 &amp; 事件模型"></a>View 模型 &amp; 事件模型</h2><h3 id="View-模型"><a href="#View-模型" class="headerlink" title="View 模型"></a>View 模型</h3><p>如图所示，是我们日常开发布局所接触的 View 模型：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/Android-View模型.png" alt="Android-View模型"></div>

<p>简单来说，就是 View 和 ViewGroup 的嵌套组合。ViewGroup 是一种特殊的 View，特殊之处就在于它可以容纳并按照一定的规则排列View，此时的 View 被称为子 View，常见的 View 有 Button、ImageView 等，常见的 ViewGroup 有 LinearLayout、Relativelayout等，Android 开发者应该非常熟悉。<a id="more"></a></p>
<h3 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h3><p>本文要讨论的是这样一组 View 模型对事件的处理过程。什么是事件？我们触摸屏幕，从我们的手指开始接触屏幕到手指离开屏幕，手指与屏幕之间的交互都被抽象成连续的事件，用于描述一个触摸过程。事件主要分为三类：</p>
<ol>
<li>ACTION_DOWN：Down事件，也就是我们落下手指的事件，它是一个事件流的开始；</li>
<li>ACTION_MOVE：Move事件，我们手指按在屏幕上，不会一直不动，比如我们玩切水果游戏，手指会飞快的划过页面，这样就产生了一系列的Move事件，通过Move事件，可以构造出手指移动的路径；</li>
<li>ACTION_UP：Up事件，也就是手指拿起的事件；</li>
</ol>
<p>这三类事件串起来可以描述我们绝大部分的触屏操作：ACTION_DOWN, ACTION_MOVE,ACTION_MOVE…ACTION_MOVE, ACTION_UP。那么这样一组事件流是如何分发到 View 模型中去处理的呢？下面详细分析。</p>
<h2 id="View的事件处理"><a href="#View的事件处理" class="headerlink" title="View的事件处理"></a>View的事件处理</h2><h3 id="事件分发——dispatchTouchEvent"><a href="#事件分发——dispatchTouchEvent" class="headerlink" title="事件分发——dispatchTouchEvent"></a>事件分发——<code>dispatchTouchEvent</code></h3><p>View 的事件处理是从<code>dispatchTouchEvent()</code>方法开始的，View中这个方法比较长，我们抽重点看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = event.getActionMasked();</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 过滤</span></span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">        <span class="comment">//noinspection SimplifiableIfStatement</span></span><br><span class="line">        ListenerInfo li = mListenerInfo;</span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">                &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，核心代码就这一段。在事件处理前，首先要做一下安全过滤，<code>onFilterTouchEventForSecurity()</code>方法的定义如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Filter the touch event to apply security policies.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> event The motion event to be filtered.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> True if the event should be dispatched, false if the event should be dropped.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getFilterTouchesWhenObscured</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onFilterTouchEventForSecurity</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//noinspection RedundantIfStatement</span></span><br><span class="line">    <span class="keyword">if</span> ((mViewFlags &amp; FILTER_TOUCHES_WHEN_OBSCURED) != <span class="number">0</span></span><br><span class="line">            &amp;&amp; (event.getFlags() &amp; MotionEvent.FLAG_WINDOW_IS_OBSCURED) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Window is obscured, drop this touch.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如注释所说，这个过滤是为了一些安全策略，有兴趣的读者可以去查看一下<code>FILTER_TOUCHES_WHEN_OBSCURED</code>和<code>FLAG_WINDOW_IS_OBSCURED</code>两个变量的注释，尤其是后者的，可以大致了解一下这里的安全指的是什么。这里我们可以当它是返回的 true 来继续往下分析 2 处。分析 2 之前，我们先看几个方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnTouchListener</span><span class="params">(OnTouchListener l)</span> </span>&#123;</span><br><span class="line">	getListenerInfo().mOnTouchListener = l;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function">ListenerInfo <span class="title">getListenerInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mListenerInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> mListenerInfo;</span><br><span class="line">	&#125;</span><br><span class="line">	mListenerInfo = <span class="keyword">new</span> ListenerInfo();</span><br><span class="line">	<span class="keyword">return</span> mListenerInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个方法指明了<code>mListenerInfo</code>中<code>mOnTouchListener</code>的来源，也就是我们平时开发中通过调用<code>setOnTouchListener()</code>为View设置的<code>OnTouchListener</code>监听，因此 2 处的判断的含义是如果 View 满足以下三个条件：</p>
<ol>
<li>设置了<code>OnTouchListener</code>监听；</li>
<li>View 的状态是 enable 的；</li>
<li>调用<code>OnTouchListener</code>的<code>onTouch</code>方法返回的是true；</li>
</ol>
<p>那么<code>dispatchTouchEvent()</code>方法就会返回true，否则<code>result</code>为 false，会继续执行 3 处，也就是执行自己的<code>onTouchEvent()</code>方法。以下是处理流程图：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/View事件处理流程图.png" width="600" alt="View事件处理流程图"></div>

<h3 id="事件处理——onTouchEvent"><a href="#事件处理——onTouchEvent" class="headerlink" title="事件处理——onTouchEvent"></a>事件处理——<code>onTouchEvent</code></h3><p>下面我们来重点看一下<code>onTouchEvent</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 【注意】这里调用的是getX()和getY()，不加任何的参数！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> x = event.getX();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> y = event.getY();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> action = event.getAction();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 如果 View 是 DISABLED</span></span><br><span class="line">    <span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class="line">        <span class="comment">// 如果是 UP 事件，并且当前 View 处于 PRESSED 状态</span></span><br><span class="line">        <span class="keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 取消 PRESSED 状态</span></span><br><span class="line">            setPressed(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// A disabled view that is clickable still consumes the touch</span></span><br><span class="line">        <span class="comment">// events, it just doesn't respond to them.</span></span><br><span class="line">        <span class="keyword">return</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE</span><br><span class="line">                    || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</span><br><span class="line">                    || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 如果设置了 mTouchDelegate，先调用它的 onTouchEvent 方法</span></span><br><span class="line">    <span class="keyword">if</span> (mTouchDelegate != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mTouchDelegate.onTouchEvent(event)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3 如果 View 可点击</span></span><br><span class="line">    <span class="keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</span><br><span class="line">            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||</span><br><span class="line">            (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                mHasPerformedLongPress = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (performButtonActionOnTouchDown(event)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 4</span></span><br><span class="line">                <span class="comment">// Walk up the hierarchy to determine if we're inside a scrolling container.</span></span><br><span class="line">                <span class="keyword">boolean</span> isInScrollingContainer = isInScrollingContainer();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// For views inside a scrolling container, delay the pressed feedback for</span></span><br><span class="line">                <span class="comment">// a short period in case this is a scroll.</span></span><br><span class="line">                <span class="keyword">if</span> (isInScrollingContainer) &#123;</span><br><span class="line">                    mPrivateFlags |= PFLAG_PREPRESSED;</span><br><span class="line">                    <span class="keyword">if</span> (mPendingCheckForTap == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mPendingCheckForTap = <span class="keyword">new</span> CheckForTap();</span><br><span class="line">                    &#125;</span><br><span class="line">                    mPendingCheckForTap.x = event.getX();</span><br><span class="line">                    mPendingCheckForTap.y = event.getY();</span><br><span class="line">                    <span class="comment">// 5 延迟一段时间再去Check</span></span><br><span class="line">                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                    <span class="comment">// 6 直接设置 PRESSED 状态，并 Check LongClick</span></span><br><span class="line">                    <span class="comment">// Not inside a scrolling container, so show the feedback right away</span></span><br><span class="line">                    setPressed(<span class="keyword">true</span>, x, y);</span><br><span class="line">                    checkForLongClick(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                drawableHotspotChanged(x, y);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 7 判断是否移出了 View 的边界</span></span><br><span class="line">                <span class="keyword">if</span> (!pointInView(x, y, mTouchSlop)) &#123;</span><br><span class="line">                    <span class="comment">// 移出去了就移除 Tap 任务</span></span><br><span class="line">                    removeTapCallback();</span><br><span class="line">                    <span class="comment">// 如果 Tap 任务已经执行</span></span><br><span class="line">                    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 移除 LongPress任务</span></span><br><span class="line">                        removeLongPressCallback();</span><br><span class="line">                        <span class="comment">// 取消 PRESSED 状态</span></span><br><span class="line">                        setPressed(<span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                <span class="keyword">boolean</span> prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 8 如果抬起的时候，View处于 PRESSED 状态或者处于 PRESSED 确认期</span></span><br><span class="line">                <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span> || prepressed) &#123;</span><br><span class="line">                    <span class="comment">// take focus if we don't have it already and we should in</span></span><br><span class="line">                    <span class="comment">// touch mode.</span></span><br><span class="line">                    <span class="comment">// 获取焦点</span></span><br><span class="line">                    <span class="keyword">boolean</span> focusTaken = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;</span><br><span class="line">                        focusTaken = requestFocus();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果处于 PRESSED 确认期，此时确认 PRESSED</span></span><br><span class="line">                    <span class="keyword">if</span> (prepressed) &#123;</span><br><span class="line">                        <span class="comment">// The button is being released before we actually</span></span><br><span class="line">                        <span class="comment">// showed it as pressed.  Make it show the pressed</span></span><br><span class="line">                        <span class="comment">// state now (before scheduling the click) to ensure</span></span><br><span class="line">                        <span class="comment">// the user sees it.</span></span><br><span class="line">                        setPressed(<span class="keyword">true</span>, x, y);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 9 如果此时没有进入长按 (另外一个变量不需要care)</span></span><br><span class="line">                    <span class="keyword">if</span> (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</span><br><span class="line">                        <span class="comment">// This is a tap, so remove the longpress check</span></span><br><span class="line">                        <span class="comment">// 不要再去 Check 长按事件了</span></span><br><span class="line">                        removeLongPressCallback();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Only perform take click actions if we were in the pressed state</span></span><br><span class="line">                        <span class="comment">// 10 判断是否处于焦点状态, 不处于则执行 PerformClick 任务</span></span><br><span class="line">                        <span class="keyword">if</span> (!focusTaken) &#123;</span><br><span class="line">                            <span class="comment">// Use a Runnable and post this rather than calling</span></span><br><span class="line">                            <span class="comment">// performClick directly. This lets other visual state</span></span><br><span class="line">                            <span class="comment">// of the view update before click actions start.</span></span><br><span class="line">                            <span class="keyword">if</span> (mPerformClick == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                mPerformClick = <span class="keyword">new</span> PerformClick();</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (!post(mPerformClick)) &#123;</span><br><span class="line">                                performClick();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 取消 PRESSED 状态</span></span><br><span class="line">                    <span class="keyword">if</span> (mUnsetPressedState == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mUnsetPressedState = <span class="keyword">new</span> UnsetPressedState();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (prepressed) &#123;</span><br><span class="line">                        postDelayed(mUnsetPressedState,</span><br><span class="line">                                ViewConfiguration.getPressedStateDuration());</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!post(mUnsetPressedState)) &#123;</span><br><span class="line">                        <span class="comment">// If the post failed, unpress right now</span></span><br><span class="line">                        mUnsetPressedState.run();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    removeTapCallback();</span><br><span class="line">                &#125;</span><br><span class="line">                mIgnoreNextUpEvent = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class="line">                setPressed(<span class="keyword">false</span>);</span><br><span class="line">                removeTapCallback();</span><br><span class="line">                removeLongPressCallback();</span><br><span class="line">                mInContextButtonPress = <span class="keyword">false</span>;</span><br><span class="line">                mHasPerformedLongPress = <span class="keyword">false</span>;</span><br><span class="line">                mIgnoreNextUpEvent = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;            </span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中几个 case 的处理调换了以下顺序，以便于分析。代码总共做了 10 处注释，基本可以理清楚这段代码的脉络。下面对其中几处做一下补充。</p>
<h4 id="getX-getY-与getX-int-getY-int"><a href="#getX-getY-与getX-int-getY-int" class="headerlink" title="getX()/getY()与getX(int)/getY(int)"></a>getX()/getY()与getX(int)/getY(int)</h4><p>在方法执行的一开始我就标注了一个<strong>【注意】</strong>，这是一个很细节的地方，这两组方法的区别读者可以自己去查 API 文档，注意到它们的不同就可以解释下面的现象：</p>
<p><strong>有一个 View 是Clickable的，如果 View 上有两根手指，假设 A 是先按下的，B 是后按下的，那么如果 B 移出 View 边界，A 抬起依然可以触发 Click 事件，但是如果 A 先移出边界，B 后抬起，则不能触发 Click 事件。</strong>(从实践结果来看，虽然 A 和 B 触发的都是 Move 事件，但是实际上 B 的 Move 事件的坐标并不是绝对坐标，而就是 A 的坐标，只有当 A 抬起之后，B 触发的才会恢复自己的绝对坐标。)</p>
<h4 id="VIEW-的-CLICKABLE"><a href="#VIEW-的-CLICKABLE" class="headerlink" title="VIEW 的 CLICKABLE"></a>VIEW 的 CLICKABLE</h4><p>1 和 3 处合起来可以得出一个结论：一个 View 只要是 <code>CLICKABLE || LONG_CLICKABLE || CONTEXT_CLICKABLE</code> 的，它就能消费事件，与是否 DISABLE 无关，只不过 DISABLE 的时候不会做出响应。</p>
<p>View 在没有任何设置的情况下，默认 CLICKABLE 是 false 的，但是可以通过 xml 中设置 <code>android:clickable=&quot;true&quot;</code>或者调用<code>setClickable(boolean)</code>来更改，或者当我们调用<code>setOnClickListener()</code>的时候，这个标志位也会被默认设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnClickListener</span><span class="params">(@Nullable OnClickListener l)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!isClickable()) &#123;</span><br><span class="line">		setClickable(<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	getListenerInfo().mOnClickListener = l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="手势延迟判断"><a href="#手势延迟判断" class="headerlink" title="手势延迟判断"></a>手势延迟判断</h4><p>4 处在处理事件的时候，首先要判断自身是不是处于一个可以滚动的容器中，这个方法其实是调用的 ViewGroup 的<code>shouldDelayChildPressedState()</code>来判断的，查看了几个常见的 ViewGroup，其中比如 LinearLayout、FrameLayout 等，这个方法返回的就是 false，而像 ScrollView、ListView 返回的就是 true，ViewGroup 中默认返回的就是true。</p>
<p>那么为什么需要做这个判断呢？因为在可滚动的容器中，DOWN 事件发生的时候是无法判断用户的用意到底是点击还是滚动的，因此这里只回去设置一个 <code>PFLAG_PREPRESSED</code> 状态，并且启动了一个 <code>CheckForTap</code> 任务，延迟 <code>ViewConfiguration.getTapTimeout()</code> 再执行；否则就直接设置 Pressed 状态，并且添加一个 <code>CheckForLongPress</code> 任务。 </p>
<h4 id="手势识别任务"><a href="#手势识别任务" class="headerlink" title="手势识别任务"></a>手势识别任务</h4><p>上一小节提到了两个任务：<code>CheckForTap</code> 和 <code>CheckForLongPress</code>。下面细看看这两个任务具体做什么。</p>
<h5 id="CheckForTap"><a href="#CheckForTap" class="headerlink" title="CheckForTap"></a>CheckForTap</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckForTap</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">float</span> x;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">float</span> y;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		mPrivateFlags &amp;= ~PFLAG_PREPRESSED;</span><br><span class="line">		setPressed(<span class="keyword">true</span>, x, y);</span><br><span class="line">		checkForLongClick(ViewConfiguration.getTapTimeout());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个任务一旦执行，就说明用户触摸的一个 View 的时间已经到了可以确认为 Tap 的时长了，所以首先要做的就是取消 <code>PFLAG_PREPRESSED</code>状态，并设置 PRESSED 状态，至此整个 View 确实进入到了 PRESSED 状态。然后它会调用<code>checkForLongClick()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkForLongClick</span><span class="params">(<span class="keyword">int</span> delayOffset)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ((mViewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) &#123;</span><br><span class="line">		mHasPerformedLongPress = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (mPendingCheckForLongPress == <span class="keyword">null</span>) &#123;</span><br><span class="line">			mPendingCheckForLongPress = <span class="keyword">new</span> CheckForLongPress();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		mPendingCheckForLongPress.rememberWindowAttachCount();</span><br><span class="line">		postDelayed(mPendingCheckForLongPress,</span><br><span class="line">				ViewConfiguration.getLongPressTimeout() - delayOffset);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的功能一目了然：如果 View 是<code>LONG_CLICKABLE</code>的，就发起一个<code>CheckForLongPress</code>任务。要注意延迟时间：如果是<code>CheckForTap</code>发起的，就需要减去之前等待确认 Tap 动作的时间，如果是 DOWN 事件直接触发的，那就需要等待<code>ViewConfiguration.getLongPressTimeout()</code>时长。</p>
<h5 id="CheckForLongPress"><a href="#CheckForLongPress" class="headerlink" title="CheckForLongPress"></a>CheckForLongPress</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckForLongPress</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> mOriginalWindowAttachCount;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (isPressed() &amp;&amp; (mParent != <span class="keyword">null</span>)</span><br><span class="line">				&amp;&amp; mOriginalWindowAttachCount == mWindowAttachCount) &#123;</span><br><span class="line">			<span class="keyword">if</span> (performLongClick()) &#123;</span><br><span class="line">				mHasPerformedLongPress = <span class="keyword">true</span>; <span class="comment">// 置位</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rememberWindowAttachCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		mOriginalWindowAttachCount = mWindowAttachCount;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法判断如果当前 View 处于 Pressed 状态，那么就执行<code>performLongClick()</code>方法，这个方法会回调设置的<code>OnLongClickListener</code>监听，具体可以查看<code>performLongClick()</code>方法，这个方法如果返回 true，则会设置标志位。一般来说，如果我们设置了<code>OnLongClickListener</code>，这里就该返回 true。</p>
<h4 id="边界问题"><a href="#边界问题" class="headerlink" title="边界问题"></a>边界问题</h4><p>7 处主要处理的是边界问题，如果 View 移出了边界，那么首先要移除<code>CheckForTap</code>任务。根据前面的分析，只有当 View 处于可滚动容器的时候，才会添加这个任务。移出之后查看 View 是否还处于 PFLAG_PRESSED 状态，如果存在，说明 View 是以下两种情况之一：</p>
<ol>
<li>View 的 Down 事件走的是④-⑤路线，并且<code>CheckForTap</code>任务已经执行了，这个时候任务队列中很可能有<code>CheckForLongPress</code>任务；</li>
<li>View 的 Down 事件走的是④-⑥路线，队列中肯定有一个<code>CheckForLongPress</code>任务；</li>
</ol>
<p>因此接着要做的事情就是移除<code>CheckForLongPress</code>任务，并且取消 Pressed 状态。</p>
<h4 id="焦点"><a href="#焦点" class="headerlink" title="焦点"></a>焦点</h4><p>8 处的处理和焦点相关，如果我们没有移出边界，那么很显然此时肯定处于 PRESSED 或者 PFLAG_PREPRESSED 状态。View 此时要尝试去拿一下焦点。默认来说，Touch Mode 下是无法拿到焦点的，因此 <code>focusTaken</code> 肯定为 false。但是如果我们把 View 的 <code>FOCUSABLE_MASK</code> 和 <code>FOCUSABLE_IN_TOUCH_MODE</code> 标志位都设置了（通过代码和XML都可以），那么 View 就可以在 Touch Mode 下获取焦点，也就是说 <code>focusTaken</code> 在第一次 Up 事件的时候，会被置为 true ，而第二次因为 <code>isFocused()</code> 返回 true（第一次Up的时候因为执行<code>requestFocus()</code>会获取焦点，所以第二次就会返回true）而被置为 false。这个务必注意。</p>
<p>9 除首先判断是否执行了 <code>CheckForLongPress</code>，如果没有执行，那么移除任务，判断 View 是否在 Up 处理中获取到了焦点，如果没有，就会执行<code>PerformClick</code>任务，这个任务从名字看就很眼熟，它执行的就是下面这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">boolean</span> result;</span><br><span class="line">	<span class="keyword">final</span> ListenerInfo li = mListenerInfo;</span><br><span class="line">	<span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnClickListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">		playSoundEffect(SoundEffectConstants.CLICK);</span><br><span class="line">		li.mOnClickListener.onClick(<span class="keyword">this</span>);</span><br><span class="line">		result = <span class="keyword">true</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		result = <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是我们经常为 View 设置的点击监听。</p>
<blockquote>
<p><strong>Google 官方不建议设置 <code>FOCUSABLE_MASK</code> 和 <code>FOCUSABLE_IN_TOUCH_MODE</code> 的理由也在这里，10 处很明显的展示了打开这两个标志位的后果：第一次 Click 的时候，<code>View.OnClickListener</code>方法不会被执行</strong>。相关的资料可以看这篇文章：<a href="http://android-developers.blogspot.jp/2008/12/touch-mode.html" target="_blank" rel="noopener">Touch Mode</a>。</p>
</blockquote>
<h2 id="ViewGroup的事件处理"><a href="#ViewGroup的事件处理" class="headerlink" title="ViewGroup的事件处理"></a>ViewGroup的事件处理</h2><p>分析完单个 View 的事件处理流程，接下来就是要分析 ViewGroup 的事件处理流程，首先要明白的事情是 ViewGroup 也是一种 View，因此它和 View 一样，也具备消费事件的能力，所不同的是：ViewGroup 可能拥有很多个子 View，它要决定事件分发的策略以便于事件能够分发到合适的子 View 去处理。因此虽然 ViewGroup 和 View 一样都是从 <code>onTouchEvent</code>方法开始事件处理，但是行为上是完全不一样的。</p>
<h3 id="ViewGroup-的dispatchTouchEvent"><a href="#ViewGroup-的dispatchTouchEvent" class="headerlink" title="ViewGroup 的dispatchTouchEvent"></a>ViewGroup 的<code>dispatchTouchEvent</code></h3><p>相比较于 View 的<code>dispatchTouchEvent</code>方法，ViewGroup 的<code>dispatchTouchEvent</code>方法要复杂的多：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(ev)) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> action = ev.getAction();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 初始化 ViewGroup 的事件处理状态</span></span><br><span class="line">        <span class="comment">// Handle an initial down.</span></span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            <span class="comment">// Throw away all previous state when starting a new touch gesture.</span></span><br><span class="line">            <span class="comment">// The framework may have dropped the up or cancel event for the previous gesture</span></span><br><span class="line">            <span class="comment">// due to an app switch, ANR, or some other state change.</span></span><br><span class="line">            cancelAndClearTouchTargets(ev);</span><br><span class="line">            resetTouchState();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2 判断是否要拦截事件</span></span><br><span class="line">        <span class="comment">// Check for interception.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">                intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">                ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                intercepted = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// There are no touch targets and this action is not an initial down</span></span><br><span class="line">            <span class="comment">// so this view group continues to intercept touches.</span></span><br><span class="line">            intercepted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// @@ 查看事件是否需要取消</span></span><br><span class="line">        <span class="comment">// Check for cancelation.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> canceled = resetCancelNextUpFlag(<span class="keyword">this</span>)</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_CANCEL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update list of touch targets for pointer down, if needed.</span></span><br><span class="line">        <span class="comment">// 3.0 以上，这里默认置位</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != <span class="number">0</span>;</span><br><span class="line">        TouchTarget newTouchTarget = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> alreadyDispatchedToNewTouchTarget = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Down 事件的处理流程</span></span><br><span class="line">        <span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3 如果是 Down 事件或者在允许多指触摸的时候</span></span><br><span class="line">            <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                    || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class="line">                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">                <span class="comment">// 多指触摸</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex(); <span class="comment">// always 0 for down</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> idBitsToAssign = split ? <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex)</span><br><span class="line">                        : TouchTarget.ALL_POINTER_IDS;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Clean up earlier touch targets for this pointer id in case they</span></span><br><span class="line">                <span class="comment">// have become out of sync.</span></span><br><span class="line">                removePointersFromTouchTargets(idBitsToAssign);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">                <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(actionIndex);</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(actionIndex);</span><br><span class="line">                    <span class="comment">// Find a child that can receive the event.</span></span><br><span class="line">                    <span class="comment">// Scan children from front to back.</span></span><br><span class="line">                    <span class="comment">// 4 默认情况下这个列表就是 View 添加的顺序</span></span><br><span class="line">                    <span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildOrderedChildList();</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> customOrder = preorderedList == <span class="keyword">null</span></span><br><span class="line">                            &amp;&amp; isChildrenDrawingOrderEnabled();</span><br><span class="line">                    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">                    <span class="comment">// 5 倒叙遍历所有的子 View，这样最后添加的，在最上面绘制的 View 会首先被分派事件</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> childIndex = customOrder</span><br><span class="line">                                ? getChildDrawingOrder(childrenCount, i) : i;</span><br><span class="line">                        <span class="keyword">final</span> View child = (preorderedList == <span class="keyword">null</span>)</span><br><span class="line">                                ? children[childIndex] : preorderedList.get(childIndex);</span><br><span class="line"></span><br><span class="line">                        ...</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 6 判断 View 能否接受 Touch 事件，并且触摸点是否在本 View 内部</span></span><br><span class="line">                        <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">                                || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                            ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 7 查看目标 View 是否存在在 TargetView 链表中，如果在，则说明已经处理过 Down</span></span><br><span class="line">                        <span class="comment">// 事件，不需要再去处理一次（想象一下两根手指同时触摸一个 View），只需要记录一下第二</span></span><br><span class="line">                        <span class="comment">// 次触摸的 PoniterId</span></span><br><span class="line">                        newTouchTarget = getTouchTarget(child);</span><br><span class="line">                        <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// Child is already receiving touch within its bounds.</span></span><br><span class="line">                            <span class="comment">// Give it the new pointer in addition to the ones it is handling.</span></span><br><span class="line">                            newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        resetCancelNextUpFlag(child);</span><br><span class="line">                        <span class="comment">// 8 分发事件给子 View 或者自己，这个方法会重点分析，它是 ViewGroup 事件处理的核心</span></span><br><span class="line">                        <span class="comment">// 如果返回true，表示事件被成功消费</span></span><br><span class="line">                        <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                            <span class="comment">// Child wants to receive touch within its bounds.</span></span><br><span class="line">                            mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">                            <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">// childIndex points into presorted list, find original index</span></span><br><span class="line">                                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                                        mLastTouchDownIndex = j;</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                mLastTouchDownIndex = childIndex;</span><br><span class="line">                            &#125;</span><br><span class="line">                            mLastTouchDownX = ev.getX();</span><br><span class="line">                            mLastTouchDownY = ev.getY();</span><br><span class="line">                            <span class="comment">// 把 TargetView 添加到链表中去，并且指明它是处理哪些 PointerId 的</span></span><br><span class="line">                            newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                            <span class="comment">// 置位</span></span><br><span class="line">                            alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">                            <span class="comment">// 这个时候一个 Down 事件已经找到目标 View 去消费，后续就不用再继续找了</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// The accessibility focus didn't handle the event, so clear</span></span><br><span class="line">                        <span class="comment">// the flag and do a normal dispatch to all children.</span></span><br><span class="line">                        ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) preorderedList.clear();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 9 如果没找到处理对象，就把这个 PointerId 赋值给最早添加的 TargetView，【Why】</span></span><br><span class="line">                <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Did not find a child to receive the event.</span></span><br><span class="line">                    <span class="comment">// Assign the pointer to the least recently added target.</span></span><br><span class="line">                    newTouchTarget = mFirstTouchTarget;</span><br><span class="line">                    <span class="keyword">while</span> (newTouchTarget.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        newTouchTarget = newTouchTarget.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 10 所有类型事件的处理流程！</span></span><br><span class="line">        <span class="comment">// 这里如果没有找到任何一个目标 View，即这个 ViewGroup 里面的所有</span></span><br><span class="line">        <span class="comment">// View都不消费事件，则调用 dispatchTransformedTouchEvent 处理，这个后面重点说</span></span><br><span class="line">        <span class="comment">// Dispatch to touch targets.</span></span><br><span class="line">        <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No touch targets so treat this as an ordinary view.</span></span><br><span class="line">            handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">                        TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Dispatch to touch targets, excluding the new touch target if we already</span></span><br><span class="line">            <span class="comment">// dispatched to it.  Cancel touch targets if necessary.</span></span><br><span class="line">            TouchTarget predecessor = <span class="keyword">null</span>;</span><br><span class="line">            TouchTarget target = mFirstTouchTarget;</span><br><span class="line">            <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> TouchTarget next = target.next;</span><br><span class="line">                <span class="comment">// 针对 Down 事件，前面已经找到 View 处理过了</span></span><br><span class="line">                <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">                    handled = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 11 判断事件是否要取消，以便于分发正确类型的事件</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class="line">                            || intercepted;</span><br><span class="line">                    <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                            target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                        handled = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果是 CANCEL 事件，就把 TargetView 从链表中删除掉</span></span><br><span class="line">                    <span class="keyword">if</span> (cancelChild) &#123;</span><br><span class="line">                        <span class="comment">// 说明是 TargetView 链表中的第一个</span></span><br><span class="line">                        <span class="keyword">if</span> (predecessor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            mFirstTouchTarget = next;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            predecessor.next = next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        target.recycle();</span><br><span class="line">                        target = next;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 至少循环一次才会赋值</span></span><br><span class="line">                predecessor = target;</span><br><span class="line">                target = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 12 针对 Up 事件做的处理 —— 重置状态</span></span><br><span class="line">        <span class="comment">// Update list of touch targets for pointer up or cancel, if needed.</span></span><br><span class="line">        <span class="keyword">if</span> (canceled</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_UP</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">            resetTouchState();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> idBitsToRemove = <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex);</span><br><span class="line">            removePointersFromTouchTargets(idBitsToRemove);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这么长的代码，只能在代码中进行注释，大概的流程是比较清楚的：</p>
<p>下面还是分小点一一补充。</p>
<h4 id="cancelAndClearTouchTargets事件清理"><a href="#cancelAndClearTouchTargets事件清理" class="headerlink" title="cancelAndClearTouchTargets事件清理"></a><code>cancelAndClearTouchTargets</code>事件清理</h4><p>在 1 处，一旦发现事件类型是 Down 类型，首先要做的就是事件清理，因为 Down 事件是一个事件流的开始，ViewGroup 一旦接收到该事件，则意味着应该初始化状态来准备处理一个新的事件流。我们来看看具体是怎么清理的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cancels and clears all touch targets.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAndClearTouchTargets</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> syntheticEvent = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (event == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            event = MotionEvent.obtain(now, now,</span><br><span class="line">                    MotionEvent.ACTION_CANCEL, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0</span>);</span><br><span class="line">            event.setSource(InputDevice.SOURCE_TOUCHSCREEN);</span><br><span class="line">            syntheticEvent = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (TouchTarget target = mFirstTouchTarget; target != <span class="keyword">null</span>; target = target.next) &#123;</span><br><span class="line">            resetCancelNextUpFlag(target.child);</span><br><span class="line">            dispatchTransformedTouchEvent(event, <span class="keyword">true</span>, target.child, target.pointerIdBits);</span><br><span class="line">        &#125;</span><br><span class="line">        clearTouchTargets();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (syntheticEvent) &#123;</span><br><span class="line">            event.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果传入的 event 为 Null，那么会 Mock 一个 CANCEL 事件出来，否则会使用原 Event，尽量保留原始信息。然后遍历所有的 TargetView，重置状态并分发事件，这分为两步。下面会详细分析。状态重置之后，会调用<code>clearTouchTargets()</code>方法把所有的 TargetView清除掉。这样就完成了初始化的过程，总结一下核心就是两步：</p>
<ol>
<li>之前正在消费事件的View，全部发送一次 CANCEL 事件；</li>
<li>记录消费事件的View链，清空；</li>
</ol>
<h5 id="resetCancelNextUpFlag"><a href="#resetCancelNextUpFlag" class="headerlink" title="resetCancelNextUpFlag"></a><code>resetCancelNextUpFlag</code></h5><p>这个方法在很多地方都被调用，这里统一解释一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Resets the cancel next up flag.</span></span><br><span class="line"><span class="comment"> * Returns true if the flag was previously set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">resetCancelNextUpFlag</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((view.mPrivateFlags &amp; PFLAG_CANCEL_NEXT_UP_EVENT) != <span class="number">0</span>) &#123;</span><br><span class="line">        view.mPrivateFlags &amp;= ~PFLAG_CANCEL_NEXT_UP_EVENT;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是重置一个标志位：<code>PFLAG_CANCEL_NEXT_UP_EVENT</code>。这个标志位是什么意思呢？注释是这样说的：Indicates whether the view is temporarily detached。打开可以猜测一下：如果一个 View 正在从 Window 上 detach（一个中间态），那么这个标志位就会被置位。如果调用该方法的时候，这位被置，则返回true。而这里的清理，只是重置而已，对于是否置位并不关心。</p>
<h5 id="dispatchTransformedTouchEvent"><a href="#dispatchTransformedTouchEvent" class="headerlink" title="dispatchTransformedTouchEvent"></a><code>dispatchTransformedTouchEvent</code></h5><p>这个方法在 8 处和 10 处都出现过，其它的步骤主要是负责定位事件应该传递给什么 View，而这个函数的作用就是做实际分发的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Transforms a motion event into the coordinate space of a particular child view,</span></span><br><span class="line"><span class="comment"> * filters out irrelevant pointer ids, and overrides its action if necessary.</span></span><br><span class="line"><span class="comment"> * If child is null, assumes the MotionEvent will be sent to this ViewGroup instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span></span></span><br><span class="line"><span class="function"><span class="params">        View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注释说的极为清楚，CANCEL 事件是一个特殊事件，重点在于事件类型而非内容</span></span><br><span class="line">    <span class="comment">// Canceling motions is a special case.  We don't need to perform any transformations</span></span><br><span class="line">    <span class="comment">// or filtering.  The important part is the action, not the contents.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldAction = event.getAction();</span><br><span class="line">    <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">        event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// child 如果是Null，就分发事件到父类，也就是调用前面分析的 View 的 dispatchTouchEvent 方法</span></span><br><span class="line">            handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则下发到 child 去处理 CANCEL 事件</span></span><br><span class="line">            handled = child.dispatchTouchEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">        event.setAction(oldAction);</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculate the number of pointers to deliver.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldPointerIdBits = event.getPointerIdBits();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验事件是否合法，如果为 0，说明事件不应该由这个 View 处理</span></span><br><span class="line">    <span class="comment">// If for some reason we ended up in an inconsistent state where it looks like we</span></span><br><span class="line">    <span class="comment">// might produce a motion event with no pointers in it, then drop the event.</span></span><br><span class="line">    <span class="keyword">if</span> (newPointerIdBits == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只要 child 为 null，就会调用父类，也就是 View 的 dispatchTouchEvent 方法</span></span><br><span class="line">    <span class="comment">// If the number of pointers is the same and we don't need to perform any fancy</span></span><br><span class="line">    <span class="comment">// irreversible transformations, then we can reuse the motion event for this</span></span><br><span class="line">    <span class="comment">// dispatch as long as we are careful to revert any changes we make.</span></span><br><span class="line">    <span class="comment">// Otherwise we need to make a copy.</span></span><br><span class="line">    <span class="keyword">final</span> MotionEvent transformedEvent;</span><br><span class="line">    <span class="keyword">if</span> (newPointerIdBits == oldPointerIdBits) &#123;</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span> || child.hasIdentityMatrix()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">                handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> offsetX = mScrollX - child.mLeft;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> offsetY = mScrollY - child.mTop;</span><br><span class="line">                <span class="comment">// 为事件做偏移</span></span><br><span class="line">                event.offsetLocation(offsetX, offsetY);</span><br><span class="line">                <span class="comment">// 分发事件</span></span><br><span class="line">                handled = child.dispatchTouchEvent(event);</span><br><span class="line">                <span class="comment">// 恢复事件</span></span><br><span class="line">                event.offsetLocation(-offsetX, -offsetY);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> handled;</span><br><span class="line">        &#125;</span><br><span class="line">        transformedEvent = MotionEvent.obtain(event);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 分化出一个新的事件</span></span><br><span class="line">        transformedEvent = event.split(newPointerIdBits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perform any necessary transformations and dispatch.</span></span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">        handled = <span class="keyword">super</span>.dispatchTouchEvent(transformedEvent);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> offsetX = mScrollX - child.mLeft;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> offsetY = mScrollY - child.mTop;</span><br><span class="line">        transformedEvent.offsetLocation(offsetX, offsetY);</span><br><span class="line">        <span class="keyword">if</span> (! child.hasIdentityMatrix()) &#123;</span><br><span class="line">            transformedEvent.transform(child.getInverseMatrix());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        handled = child.dispatchTouchEvent(transformedEvent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Done.</span></span><br><span class="line">    transformedEvent.recycle();</span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它其实只做以下几件事情：</p>
<ol>
<li>事件是否是 CANCEL 的，如果是，直接分发即可；</li>
<li>确定分发的事件合法，主要是看 newPointerIdBits 是否为 0，读者要去理解这个方法，需要看一下<code>MotionEvent.getPointerIdBits()</code>方法；</li>
<li>重新计算事件的坐标，并分发，分发的时候判断 child 是否为 null，如果为 null，则分发给 ViewGroup 的父类也就是 View 处理，否则分发给子 View 处理；</li>
</ol>
<h4 id="事件拦截"><a href="#事件拦截" class="headerlink" title="事件拦截"></a>事件拦截</h4><p>2 处的判断看上去可能比较难懂，换一个等价的判断就明白了：<code>actionMasked != MotionEvent.ACTION_DOWN &amp;&amp; mFirstTouchTarget == null</code>。<code>mFirstTouchTarget</code>为 null，也就是说没有找到 View 处理事件，Action 不为 Down，也就是说不是事件流的起始，那这个事件完全就是非法的，不应该传递到这里来，因此肯定不会下发，所以<code>intercepted</code>就置为 true。</p>
<p>if 语句里面的判断和方法调用，就不做解释了。读者去了解一下<code>requestDisallowInterceptTouchEvent()</code>方法和<code>onInterceptTouchEvent()</code>就好，说白了就是 ViewGroup 提供的事件拦截以及禁止事件拦截的两个方法。要注意的是这里方法返回不同的结果对事件流处理造成的影响。</p>
<p>这里接个尾巴，在判断完事件拦截后，@@ 处又调用了一次<code>resetCancelNextUpFlag()</code>方法，这一次它的返回结果就被记录下来了，用于判断事件是否要取消，也就是说我们可以通过这个方法来判断一个 View 是否能合法的接收事件。</p>
<h4 id="多指触摸"><a href="#多指触摸" class="headerlink" title="多指触摸"></a>多指触摸</h4><p>3 处在判断的时候是考虑到了多指触摸的情况的，一个 ViewGroup 里面可能有多个 View，这一个或者多个 View 可以同时被多根手指 Touch，那么在这样的情况下，就需要记录哪个 View 被哪个 Pointer（形象一点可以想象成手指）触摸，这个是通过 TouchTarget 的 pointerIdBits 来记录的，TouchTarget 可以代表着一个触摸对象，它封装了一个 View 以及与触摸相关的信息在内部。</p>
<h4 id="View-是否能接受事件"><a href="#View-是否能接受事件" class="headerlink" title="View 是否能接受事件"></a>View 是否能接受事件</h4><p>6 处判断一个View是否能接受事件，调用了这样一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns true if a child view can receive pointer events.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canViewReceivePointerEvents</span><span class="params">(View child)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE</span><br><span class="line">                || child.getAnimation() != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个判断有依据的是 View 是否可见，或者 View 是否正在执行动画。</p>
<h4 id="关于ACTION-XXXX和ACTION-POINTER-XXXX"><a href="#关于ACTION-XXXX和ACTION-POINTER-XXXX" class="headerlink" title="关于ACTION_XXXX和ACTION_POINTER_XXXX"></a>关于<code>ACTION_XXXX</code>和<code>ACTION_POINTER_XXXX</code></h4><p>XXXX 代表着 DOWN 或者 UP（不存在<code>ACTION_POINTER_MOVE</code>），这里可以从实验得出如下结论：</p>
<ol>
<li>第一个按下去的事件类型是<code>ACTION_DOWN</code>，其余不论按下多少个手指，事件类型都是<code>ACTION_POINTER_DOWN</code>;</li>
<li>不论按下去和抬起来的顺序，最后一个抬起的手指，它触发的事件类型就是<code>ACTION_UP</code>，这个与<code>ACTION_DOWN</code>并不一定发生在同一根手指上；</li>
<li><p>PointerId 可以唯一标记一个手指触摸事件，第一个触摸的手指 ID 为1, 第二个触摸的手指 ID 为2，第三个触摸的手指 ID 为 3，以此类推…因此可以通过下面的方法很方便的将事件发生时手指的触摸情况反映成一个 Bit 组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPointerIdBits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> idBits = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> pointerCount = nativeGetPointerCount(mNativePtr);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pointerCount; i++) &#123;</span><br><span class="line">		idBits |= <span class="number">1</span> &lt;&lt; nativeGetPointerId(mNativePtr, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> idBits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以如果我有四根手指触摸着屏幕，那么通过调用这个方法就可以得到的<code>1111</code>（二进制，后面同含义的数字也是二进制表示），如果我第一个按下的手指抬起，那么计算出来的值就是<code>1110</code>，第四根按下的手指抬起，计算出来的值就是<code>0110</code>，以此类推…因此在 MOVE 中可以通过这种手段确认是哪几根手指处于按下状态。通过以下方法可以获知每一根手指的坐标位置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pointerCount = event.getPointerCount();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pointerCount; i++) &#123;</span><br><span class="line">	<span class="keyword">int</span> id = event.getPointerId(i);</span><br><span class="line">	<span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX(i);</span><br><span class="line">	<span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>相关的还有一个方法是<code>getActionIndex()</code>，这个方法只有在事件类型为<code>ACTION_POINTER_DOWN</code>或者<code>ACTION_POINTER_UP</code>的时候才有意义，其余情况下返回的都是0。详细可见附表数据。</p>
</blockquote>
<p>配合以上几个结论，看 12 处的时候会更加清晰：在<code>ACTION_UP</code>的时候，表示所有手指已经离开 View，所以可以重置状态。而 View 中只会处理<code>ACTION_UP</code>和<code>ACTION_DOWN</code>事件，因此对于 View 来说（这里是狭义的 View，不包括 ViewGroup），只有单指事件。</p>
<h4 id="ACTION-CANCEL事件发生时机"><a href="#ACTION-CANCEL事件发生时机" class="headerlink" title="ACTION_CANCEL事件发生时机"></a><code>ACTION_CANCEL</code>事件发生时机</h4><p>11 处<strong>指明了<code>ACTION_CANCEL</code>事件发生的时机：父 ViewGroup 拦截了子 View 的事件流</strong>。 具体可见<a href="https://developer.android.com/reference/android/view/ViewGroup.html#onInterceptTouchEvent(android.view.MotionEvent" target="_blank" rel="noopener"><code>VierGroup.onInterceptTouchEvent()</code></a>)方法的 API 文档。</p>
<p><strong>其余的点都不是很难理解，第 ⑨ 处留有一个疑问：这里为什么要把 PointerId 记录到第一个添加的 TargetView 中去？。</strong></p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>至此，View 和 ViewGroup 的事件分发处理机制已经解析完毕。</p>
<p>事件被分发到 ViewGroup 之后，会由 ViewGroup 查看哪些子 View 能够接受该事件，判断的初始标准很简单：参考方法<code>canViewReceivePointerEvents()</code>和<code>isTransformedTouchPointInView()</code>，如果找到一个这样的的子 View，尝试调用<code>dispatchTransformedTouchEvent()</code>方法将事件分发给子 View ，如果子 View 处理事件成功（处理过程参考前面的图），则该 View 被加入到 ViewGroup 的 TargetView 链中去，后续的事件会继续分发给它，否则它将不能再接受事件。</p>
<p>如果 ViewGroup 找不到这样一个子 View 进行事件处理，就会尝试调用父类的<code>dispatchTouchEvent()</code>方法处理事件，此时 ViewGroup 把自己当做一个 View 来看待。</p>
<p>以上就是 ViewGroup 进行事件分发 和 View 处理事件的主流程。</p>
<h2 id="附表"><a href="#附表" class="headerlink" title="附表"></a>附表</h2><p>下面是一张三根手指操作 View 的时候，它收到的事件的相关信息打印，打印代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> actionIndex = ev.getActionIndex();</span><br><span class="line">	<span class="keyword">int</span> pointerCount = ev.getPointerCount();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; pointerCount; index++) &#123;</span><br><span class="line">		Log.e(TAG, <span class="string">"PointId: "</span> + ev.getPointerId(index) + <span class="string">" # ActionIndex: "</span> + actionIndex + <span class="string">" # ActionType: "</span> + ev.getActionMasked());</span><br><span class="line">		Log.e(TAG, <span class="string">"X"</span> + index + <span class="string">": "</span> + ev.getX(index) + <span class="string">" # Y"</span> + index + <span class="string">": "</span> + ev.getY(index) + <span class="string">" # PointId: "</span> + ev.getPointerId(actionIndex));</span><br><span class="line">	&#125;</span><br><span class="line">	Log.e(TAG, <span class="string">"======================"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">09-19 10:14:06.045  PointId: 0 # ActionIndex: 0 # ActionType: 0</span><br><span class="line">09-19 10:14:06.045  X0: 224.0 # Y0: 1232.0 # PointId: 0</span><br><span class="line"><span class="number">09</span>-<span class="number">19</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">06.045</span>  ======================</span><br><span class="line">09-19 10:14:06.584  PointId: 0 # ActionIndex: 0 # ActionType: 2</span><br><span class="line">09-19 10:14:06.584  X0: 224.0 # Y0: 1232.0 # PointId: 0</span><br><span class="line"><span class="number">09</span>-<span class="number">19</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">06.584</span>  ======================</span><br><span class="line">09-19 10:14:06.584  PointId: 0 # ActionIndex: 1 # ActionType: 5</span><br><span class="line">09-19 10:14:06.584  X0: 224.0 # Y0: 1232.0 # PointId: 1</span><br><span class="line">09-19 10:14:06.584  PointId: 1 # ActionIndex: 1 # ActionType: 5</span><br><span class="line">09-19 10:14:06.584  X1: 483.0 # Y1: 973.0 # PointId: 1</span><br><span class="line"><span class="number">09</span>-<span class="number">19</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">06.584</span>  ======================</span><br><span class="line">09-19 10:14:06.953  PointId: 0 # ActionIndex: 0 # ActionType: 2</span><br><span class="line">09-19 10:14:06.953  X0: 224.0 # Y0: 1232.0 # PointId: 0</span><br><span class="line">09-19 10:14:06.953  PointId: 1 # ActionIndex: 0 # ActionType: 2</span><br><span class="line">09-19 10:14:06.953  X1: 483.0 # Y1: 973.0 # PointId: 0</span><br><span class="line"><span class="number">09</span>-<span class="number">19</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">06.953</span>  ======================</span><br><span class="line">09-19 10:14:06.954  PointId: 0 # ActionIndex: 2 # ActionType: 5</span><br><span class="line">09-19 10:14:06.954  X0: 224.0 # Y0: 1232.0 # PointId: 2</span><br><span class="line">09-19 10:14:06.954  PointId: 1 # ActionIndex: 2 # ActionType: 5</span><br><span class="line">09-19 10:14:06.954  X1: 483.0 # Y1: 973.0 # PointId: 2</span><br><span class="line">09-19 10:14:06.954  PointId: 2 # ActionIndex: 2 # ActionType: 5</span><br><span class="line">09-19 10:14:06.954  X2: 811.0 # Y2: 1076.0 # PointId: 2</span><br><span class="line"><span class="number">09</span>-<span class="number">19</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">06.954</span>  ======================</span><br><span class="line">09-19 10:14:07.264  PointId: 0 # ActionIndex: 0 # ActionType: 2</span><br><span class="line">09-19 10:14:07.264  X0: 224.0 # Y0: 1232.0 # PointId: 0</span><br><span class="line">09-19 10:14:07.264  PointId: 1 # ActionIndex: 0 # ActionType: 2</span><br><span class="line">09-19 10:14:07.264  X1: 483.0 # Y1: 973.0 # PointId: 0</span><br><span class="line">09-19 10:14:07.264  PointId: 2 # ActionIndex: 0 # ActionType: 2</span><br><span class="line">09-19 10:14:07.264  X2: 809.0 # Y2: 1076.0 # PointId: 0</span><br><span class="line"><span class="number">09</span>-<span class="number">19</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">07.264</span>  ======================</span><br><span class="line">09-19 10:14:07.280  PointId: 0 # ActionIndex: 0 # ActionType: 2</span><br><span class="line">09-19 10:14:07.280  X0: 224.0 # Y0: 1232.0 # PointId: 0</span><br><span class="line">09-19 10:14:07.280  PointId: 1 # ActionIndex: 0 # ActionType: 2</span><br><span class="line">09-19 10:14:07.280  X1: 483.0 # Y1: 973.0 # PointId: 0</span><br><span class="line">09-19 10:14:07.280  PointId: 2 # ActionIndex: 0 # ActionType: 2</span><br><span class="line">09-19 10:14:07.280  X2: 807.0 # Y2: 1076.0 # PointId: 0</span><br><span class="line"><span class="number">09</span>-<span class="number">19</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">07.280</span>  ======================</span><br><span class="line">09-19 10:14:07.297  PointId: 0 # ActionIndex: 0 # ActionType: 2</span><br><span class="line">09-19 10:14:07.297  X0: 224.0 # Y0: 1232.0 # PointId: 0</span><br><span class="line">09-19 10:14:07.297  PointId: 1 # ActionIndex: 0 # ActionType: 2</span><br><span class="line">09-19 10:14:07.297  X1: 483.0 # Y1: 973.0 # PointId: 0</span><br><span class="line">09-19 10:14:07.297  PointId: 2 # ActionIndex: 0 # ActionType: 2</span><br><span class="line">09-19 10:14:07.297  X2: 805.0 # Y2: 1076.0 # PointId: 0</span><br><span class="line"><span class="number">09</span>-<span class="number">19</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">07.297</span>  ======================</span><br><span class="line">09-19 10:14:07.314  PointId: 0 # ActionIndex: 0 # ActionType: 2</span><br><span class="line">09-19 10:14:07.314  X0: 224.0 # Y0: 1232.0 # PointId: 0</span><br><span class="line">09-19 10:14:07.314  PointId: 1 # ActionIndex: 0 # ActionType: 2</span><br><span class="line">09-19 10:14:07.314  X1: 483.0 # Y1: 973.0 # PointId: 0</span><br><span class="line">09-19 10:14:07.314  PointId: 2 # ActionIndex: 0 # ActionType: 2</span><br><span class="line">09-19 10:14:07.314  X2: 803.0 # Y2: 1076.0 # PointId: 0</span><br><span class="line"><span class="number">09</span>-<span class="number">19</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">07.314</span>  ======================</span><br><span class="line">09-19 10:14:07.331  PointId: 0 # ActionIndex: 0 # ActionType: 2</span><br><span class="line">09-19 10:14:07.331  X0: 224.0 # Y0: 1232.0 # PointId: 0</span><br><span class="line">09-19 10:14:07.331  PointId: 1 # ActionIndex: 0 # ActionType: 2</span><br><span class="line">09-19 10:14:07.331  X1: 483.0 # Y1: 973.0 # PointId: 0</span><br><span class="line">09-19 10:14:07.331  PointId: 2 # ActionIndex: 0 # ActionType: 2</span><br><span class="line">09-19 10:14:07.331  X2: 802.0 # Y2: 1076.0 # PointId: 0</span><br><span class="line"><span class="number">09</span>-<span class="number">19</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">07.331</span>  ======================</span><br><span class="line">09-19 10:14:07.405  PointId: 0 # ActionIndex: 1 # ActionType: 6</span><br><span class="line">09-19 10:14:07.405  X0: 224.0 # Y0: 1232.0 # PointId: 1</span><br><span class="line">09-19 10:14:07.405  PointId: 1 # ActionIndex: 1 # ActionType: 6</span><br><span class="line">09-19 10:14:07.406  X1: 483.0 # Y1: 973.0 # PointId: 1</span><br><span class="line">09-19 10:14:07.406  PointId: 2 # ActionIndex: 1 # ActionType: 6</span><br><span class="line">09-19 10:14:07.406  X2: 802.0 # Y2: 1076.0 # PointId: 1</span><br><span class="line"><span class="number">09</span>-<span class="number">19</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">07.406</span>  ======================</span><br><span class="line">09-19 10:14:07.415  PointId: 0 # ActionIndex: 0 # ActionType: 2</span><br><span class="line">09-19 10:14:07.415  X0: 224.0 # Y0: 1232.0 # PointId: 0</span><br><span class="line">09-19 10:14:07.415  PointId: 2 # ActionIndex: 0 # ActionType: 2</span><br><span class="line">09-19 10:14:07.415  X1: 803.0 # Y1: 1076.0 # PointId: 0</span><br><span class="line"><span class="number">09</span>-<span class="number">19</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">07.415</span>  ======================</span><br><span class="line">09-19 10:14:07.421  PointId: 0 # ActionIndex: 0 # ActionType: 6</span><br><span class="line">09-19 10:14:07.421  X0: 224.0 # Y0: 1232.0 # PointId: 0</span><br><span class="line">09-19 10:14:07.421  PointId: 2 # ActionIndex: 0 # ActionType: 6</span><br><span class="line">09-19 10:14:07.421  X1: 803.0 # Y1: 1076.0 # PointId: 0</span><br><span class="line"><span class="number">09</span>-<span class="number">19</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">07.421</span>  ======================</span><br><span class="line">09-19 10:14:07.421  PointId: 2 # ActionIndex: 0 # ActionType: 1</span><br><span class="line">09-19 10:14:07.421  X0: 803.0 # Y0: 1076.0 # PointId: 2</span><br><span class="line"><span class="number">09</span>-<span class="number">19</span> <span class="number">10</span>:<span class="number">14</span>:<span class="number">07.421</span>  ======================</span><br></pre></td></tr></table></figure>
<p>注意：手指抬起的顺序不一致，也会引起一些数据变化，读者要理解，可以自己复制代码做实验。</p>
<blockquote>
<p>1 是<code>ACTION_UP</code>，2 是<code>ACTION_DOWN</code>，5 是<code>ACTION_POINTER_DOWN</code>，6 是<code>ACTION_POINTER_UP</code>。</p>
</blockquote>
</div><div class="tags"><a href="/tags/事件处理/">事件处理</a></div><div class="post-nav"><a href="/2016/09/21/Android-view-display/" class="pre">Android View绘制过程</a><a href="/2016/07/30/ReactiveX/" class="next">ReactiveX 初探</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">59</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactiveX/">ReactiveX</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/后端/">后端</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/影视/">影视</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/电影/">电影</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Gitbook/" style="font-size: 15px;">Gitbook</a> <a href="/tags/Runtime/" style="font-size: 15px;">Runtime</a> <a href="/tags/视图/" style="font-size: 15px;">视图</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/权限/" style="font-size: 15px;">权限</a> <a href="/tags/代码优化/" style="font-size: 15px;">代码优化</a> <a href="/tags/Framework/" style="font-size: 15px;">Framework</a> <a href="/tags/性能优化/" style="font-size: 15px;">性能优化</a> <a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/合集/" style="font-size: 15px;">合集</a> <a href="/tags/ADB/" style="font-size: 15px;">ADB</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/反编译/" style="font-size: 15px;">反编译</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/Gradle/" style="font-size: 15px;">Gradle</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/基础/" style="font-size: 15px;">基础</a> <a href="/tags/效率/" style="font-size: 15px;">效率</a> <a href="/tags/MarkDown/" style="font-size: 15px;">MarkDown</a> <a href="/tags/电影/" style="font-size: 15px;">电影</a> <a href="/tags/Reactive/" style="font-size: 15px;">Reactive</a> <a href="/tags/AIDL/" style="font-size: 15px;">AIDL</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/驱动/" style="font-size: 15px;">驱动</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/日志/" style="font-size: 15px;">日志</a> <a href="/tags/事件/" style="font-size: 15px;">事件</a> <a href="/tags/代码设计/" style="font-size: 15px;">代码设计</a> <a href="/tags/网络/" style="font-size: 15px;">网络</a> <a href="/tags/测试/" style="font-size: 15px;">测试</a> <a href="/tags/Binder/" style="font-size: 15px;">Binder</a> <a href="/tags/Groovy/" style="font-size: 15px;">Groovy</a> <a href="/tags/Loader/" style="font-size: 15px;">Loader</a> <a href="/tags/RAC/" style="font-size: 15px;">RAC</a> <a href="/tags/事件处理/" style="font-size: 15px;">事件处理</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/10/30/AIDL-原理分析/">AIDL 原理分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/30/App-启动过程/">App 启动过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/PMS-解析/">PMS 解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/WMS-解析/">WindowManagerService 解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/AMS-解析/">AMS 解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/10/The-Good-Wife/">The-Good-Wife</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/10/Black-Sails/">黑帆</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/29/hello-world/">Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/23/XCode-8-2-1-ClangFormat-插件安装/">XCode 8.2.1 ClangFormat 插件安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/07/SourceTree-分支图谱/">SourceTree 分支图谱</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">蜗牛壳.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>