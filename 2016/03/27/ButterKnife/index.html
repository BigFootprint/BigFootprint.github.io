<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="李全民的个人博客"><title>ButterKnife 源码分析 | 蜗牛壳</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-65882749-1','auto');ga('send','pageview');</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">ButterKnife 源码分析</h1><a id="logo" href="/.">蜗牛壳</a><p class="description">计算机只有 0 和 1 ，但世界是连续的</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">ButterKnife 源码分析</h1><div class="post-meta">Mar 27, 2016<span> | </span><span class="category"><a href="/categories/Android/">Android</a></span></div><div class="post-content"><h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/logo_butterknife.png" width="188" alt="ButterKnife Logo"></div>

<p><strong>ButterKnife</strong> 是一个注解框架，项目地址: <a href="http://jakewharton.github.io/butterknife/" target="_blank" rel="noopener">ButterKnife</a> 。 简单使用🌰如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Bind</span>(R.id.title) TextView title;</span><br><span class="line">	<span class="meta">@Bind</span>(R.id.subtitle) TextView subtitle;</span><br><span class="line">	<span class="meta">@Bind</span>(R.id.footer) TextView footer;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.simple_activity);</span><br><span class="line">		ButterKnife.bind(<span class="keyword">this</span>);</span><br><span class="line">		<span class="comment">// TODO Use fields...</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@OnClick</span>(R.id.footer)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  		<span class="comment">// TODO submit data to server...</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上这段代码可以代替以下这段代码:<a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(ExampleActivity activity)</span> </span>&#123;</span><br><span class="line">	activity.subtitle = (android.widget.TextView) activity.findViewById(<span class="number">2130968578</span>);</span><br><span class="line">	activity.footer = (android.widget.TextView) activity.findViewById(<span class="number">2130968579</span>);</span><br><span class="line">	activity.title = (android.widget.TextView) activity.findViewById(<span class="number">2130968577</span>);</span><br><span class="line">	</span><br><span class="line">	activity.footer..setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">			submit();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到，使用ButterKnife后可以不用再去写<code>findViewById</code>、<code>setOnClickListener</code>这样重复繁琐代码，通过<code>@Bind</code>、<code>@OnClick</code>注解就可以达到效果，代码简洁不少。</p>
<p>更多的例子和功能可以参见<a href="http://jakewharton.github.io/butterknife/" target="_blank" rel="noopener">官网示例</a>。</p>
<p>本文重点分析两个内容：</p>
<ol>
<li>ButterKnife的注解定义方式；</li>
<li>ButterKnife是如何运用编译时注解来提高效率的（在Android上，反射的效率较低）； </li>
</ol>
<h1 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h1><p>研究ButterKnife要具备一定的注解知识，CodeKK上有篇文章推荐阅读: <a href="http://a.codekk.com/detail/Android/Trinea/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%20Java%20%E6%B3%A8%E8%A7%A3%20Annotation" target="_blank" rel="noopener">《公共技术点之 Java 注解 Annotation》</a>。</p>
<p>关于运行时注解的开发，可以看这篇文章:<a href="http://www.race604.com/annotation-processing/" target="_blank" rel="noopener">Java注解处理器</a>。ButterKnife使用的是<code>com.google.auto.service:auto-service</code>包，通过其<code>AutoService</code>注解来实现编译时注解的开发。</p>
<p>另外也可以关注一下这个项目: <a href="https://bitbucket.org/hvisser/android-apt" target="_blank" rel="noopener">android-apt</a>。</p>
<h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><p>如下是ButterKnife的项目结构:</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/ButterKnife项目.png" width="250" alt="ButterKnife项目"></div>

<p>ButterKnife项目分为四个Module: Module butterknife-annotations中定义的是ButterKnife所支持的注解，butterknife-compiler中主要是编译时注解Processor。butterknife-sample则是一个使用例子。</p>
<p>下面我们就来逐步分析整个注解框架的实现。</p>
<h1 id="注解定义解析"><a href="#注解定义解析" class="headerlink" title="注解定义解析"></a>注解定义解析</h1><p>ButterKnife支持的注解主要分为四类:</p>
<ol>
<li>资源绑定。通过Id引用Array、Bitmap、Bool、Color、Dimen、Drawable、Int、String等几类资源；</li>
<li>事件绑定。包括onCheckedChanged、onClick、onItemClick、onItemLongClick等几种事件监听；</li>
<li>视图绑定。通过id实例化xml中的View；</li>
<li>Mark注解。Unbinder和Optional；</li>
</ol>
<h2 id="资源绑定注解定义"><a href="#资源绑定注解定义" class="headerlink" title="资源绑定注解定义"></a>资源绑定注解定义</h2><p>这类注解都以<code>BindXXX</code>的形式来命名，由于资源注解都只需要指定资源的id，因此定义的形式非常一致。下面以String资源为例，展示一下定义内容:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Bind a field to the specified string resource ID.</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;&lt;code&gt;</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@literal</span> @&#125;BindString(R.string.username_error) String usernameErrorText;</span></span><br><span class="line"><span class="comment"> * &lt;/code&gt;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention</span>(CLASS) <span class="meta">@Target</span>(FIELD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> BindString &#123;</span><br><span class="line">	<span class="comment">/** String resource ID to which the field will be bound. */</span></span><br><span class="line">	<span class="meta">@StringRes</span> <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里还用到了Android提供的资源注解，以保证返回的Id符合特定的资源。注解是编译时注解(CLASS)，适用于属性(FIELD)。</p>
<h2 id="事件绑定注解"><a href="#事件绑定注解" class="headerlink" title="事件绑定注解"></a>事件绑定注解</h2><p>事件绑定注解比较复杂，主要是因为以下三个方面:</p>
<ol>
<li>为View添加监听的方法是不一样的，比如<code>setOnClickListener</code>、<code>addTextChangedListener</code>、<code>setOnFocusChangeListener</code>等，方法名字本身不一致，且无规律可言；</li>
<li>这些方法只能绑定在特定的View上面；</li>
<li>监听需要实现的方法有很大的差别，具体可以参考<code>OnLongClickListener</code>和<code>TextWatcher</code>需要实现的方法的区别；</li>
</ol>
<p>因此在ButterKnife内部专门为此建立两个注解:<code>ListenerClass</code>和<code>ListenerMethod</code>（可以认为是ButterKnife支持事件绑定注解的元注解）。</p>
<h3 id="事件元注解"><a href="#事件元注解" class="headerlink" title="事件元注解"></a>事件元注解</h3><p>首先我们来看一下<code>ListenerMethod</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RUNTIME) <span class="meta">@Target</span>(FIELD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ListenerMethod &#123;</span><br><span class="line">	<span class="comment">/** Name of the listener method for which this annotation applies. */</span></span><br><span class="line">	<span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** List of method parameters. If the type is not a primitive it must be fully-qualified. */</span></span><br><span class="line">	String[] parameters() <span class="keyword">default</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Primitive or fully-qualified return type of the listener method. May also be &#123;<span class="doctag">@code</span> void&#125;. */</span></span><br><span class="line">	<span class="function">String <span class="title">returnType</span><span class="params">()</span> <span class="keyword">default</span> "<span class="keyword">void</span>"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** If &#123;<span class="doctag">@link</span> #returnType()&#125; is not &#123;<span class="doctag">@code</span> void&#125; this value is returned when no binding exists. */</span></span><br><span class="line">	<span class="function">String <span class="title">defaultReturn</span><span class="params">()</span> <span class="keyword">default</span> "<span class="keyword">null</span>"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个注解主要是定义一个方法的签名(方法名字、方法的参数、方法的返回类型)以及默认返回值。</p>
<p>再来看<code>ListenerClass</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RUNTIME) <span class="meta">@Target</span>(ANNOTATION_TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ListenerClass &#123;</span><br><span class="line">	<span class="function">String <span class="title">targetType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Name of the setter method on the &#123;<span class="doctag">@link</span> #targetType() target type&#125; for the listener. */</span></span><br><span class="line">	<span class="function">String <span class="title">setter</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Fully-qualified class name of the listener type. */</span></span><br><span class="line">	<span class="function">String <span class="title">type</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Enum which declares the listener callback methods. Mutually exclusive to &#123;<span class="doctag">@link</span> #method()&#125;. */</span></span><br><span class="line">	Class&lt;? extends Enum&lt;?&gt;&gt; callbacks() <span class="keyword">default</span> NONE.class;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Method data for single-method listener callbacks. Mutually exclusive with &#123;<span class="doctag">@link</span> #callbacks()&#125;</span></span><br><span class="line"><span class="comment">    * and an error to specify more than one value.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	ListenerMethod[] method() <span class="keyword">default</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Default value for &#123;<span class="doctag">@link</span> #callbacks()&#125;. */</span></span><br><span class="line">	<span class="keyword">enum</span> NONE &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个注解主要定义如下内容:</p>
<ol>
<li><strong>setter():</strong> 监听的设置方法全称；</li>
<li><strong>type():</strong> 监听类的类名全称；</li>
<li><strong>method():</strong> 监听类中有哪些方法；</li>
<li><strong>callback():</strong> 当一个监听有多个回调时，指定当前方法在哪个回调中调用，后面有详细阐述；</li>
</ol>
<p>注意，这两个注解都是用来修饰注解的：可以看到<code>@Target</code>都是<code>ANNOTATION_TYPE</code>类型的。</p>
<h3 id="事件注解"><a href="#事件注解" class="headerlink" title="事件注解"></a>事件注解</h3><p>由于事件的复杂性，注解定义本身差距比较大，先看一个简单的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(CLASS)</span><br><span class="line"><span class="meta">@ListenerClass</span>(</span><br><span class="line">    targetType = <span class="string">"android.widget.CompoundButton"</span>,</span><br><span class="line">    setter = <span class="string">"setOnCheckedChangeListener"</span>,</span><br><span class="line">    type = <span class="string">"android.widget.CompoundButton.OnCheckedChangeListener"</span>,</span><br><span class="line">    method = <span class="meta">@ListenerMethod</span>(</span><br><span class="line">        name = <span class="string">"onCheckedChanged"</span>,</span><br><span class="line">        parameters = &#123;</span><br><span class="line">            <span class="string">"android.widget.CompoundButton"</span>,</span><br><span class="line">            <span class="string">"boolean"</span></span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> OnCheckedChanged &#123;</span><br><span class="line">	<span class="comment">/** View IDs to which the method will be bound. */</span></span><br><span class="line">	<span class="meta">@IdRes</span> <span class="keyword">int</span>[] value() <span class="keyword">default</span> &#123; View.NO_ID &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，该注解同样是编译时注解，并且是用于修饰一个方法的。<br>其次，使用“元注解”修饰该注解：该注解是用于为ComPoundButton通过<code>setOnCheckedChangeListener</code>添加<code>OnCheckedChangeListener</code>监听的，该监听有一个需要实现的方法<code>onCheckedChanged</code>，该方法传入一个CompoundButton对象和布尔值作为参数。</p>
<p>最后我们关注一下这个注解本身：它只需要返回设置一组id即可，默认返回的是<code>View.NO_ID</code>。</p>
<p>这样就完成了一个事件注解的定义。这样看上去很抽象，我们看一个官网对<code>OnClick</code>注解的使用例子就清楚了:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OnClick</span>(&#123; R.id.door1, R.id.door2, R.id.door3 &#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pickDoor</span><span class="params">(DoorView door)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (door.hasPrizeBehind()) &#123;</span><br><span class="line">		Toast.makeText(<span class="keyword">this</span>, <span class="string">"You win!"</span>, LENGTH_SHORT).show();</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		Toast.makeText(<span class="keyword">this</span>, <span class="string">"Try again"</span>, LENGTH_SHORT).show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，就是为三个door View添加<code>onClickListener</code>监听。</p>
<p>那么如果一个监听有多个方法需要回调，又应该怎么办呢？比如ViewPager的<code>OnPageChangeListener</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">viewPager.setOnPageChangeListener(<span class="keyword">new</span> ViewPager.OnPageChangeListener() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageScrolled</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">float</span> v, <span class="keyword">int</span> i1)</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageSelected</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageScrollStateChanged</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果像<code>@onClick</code>那样绑定，我怎么知道绑定的是哪个方法呢？也就是说，是在哪个回调里面执行这个方法呢？这个是通过<code>callback</code>来实现的，我们看一下<code>@OnPageChange</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(CLASS)</span><br><span class="line"><span class="meta">@ListenerClass</span>(</span><br><span class="line">    targetType = <span class="string">"android.support.v4.view.ViewPager"</span>,</span><br><span class="line">    setter = <span class="string">"setOnPageChangeListener"</span>,</span><br><span class="line">    type = <span class="string">"android.support.v4.view.ViewPager.OnPageChangeListener"</span>,</span><br><span class="line">    callbacks = OnPageChange.Callback.class</span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> OnPageChange &#123;</span><br><span class="line">	<span class="comment">/** View IDs to which the method will be bound. */</span></span><br><span class="line">	<span class="meta">@IdRes</span> <span class="keyword">int</span>[] value() <span class="keyword">default</span> &#123; View.NO_ID &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Listener callback to which the method will be bound. */</span></span><br><span class="line">	<span class="function">Callback <span class="title">callback</span><span class="params">()</span> <span class="keyword">default</span> Callback.PAGE_SELECTED</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** &#123;<span class="doctag">@code</span> ViewPager.OnPageChangeListener&#125; callback methods. */</span></span><br><span class="line">	<span class="keyword">enum</span> Callback &#123;</span><br><span class="line">		<span class="comment">/** &#123;<span class="doctag">@code</span> onPageSelected(int)&#125; */</span></span><br><span class="line">		<span class="meta">@ListenerMethod</span>(</span><br><span class="line">			name = <span class="string">"onPageSelected"</span>,</span><br><span class="line">			parameters = <span class="string">"int"</span></span><br><span class="line">		PAGE_SELECTED,</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** &#123;<span class="doctag">@code</span> onPageScrolled(int, float, int)&#125; */</span></span><br><span class="line">		<span class="meta">@ListenerMethod</span>(</span><br><span class="line">			name = <span class="string">"onPageScrolled"</span>,</span><br><span class="line">			parameters = &#123;</span><br><span class="line">				<span class="string">"int"</span>,</span><br><span class="line">				<span class="string">"float"</span>,</span><br><span class="line">				<span class="string">"int"</span></span><br><span class="line">			&#125;</span><br><span class="line">		)</span><br><span class="line">		PAGE_SCROLLED,</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** &#123;<span class="doctag">@code</span> onPageScrollStateChanged(int)&#125; */</span></span><br><span class="line">    	<span class="meta">@ListenerMethod</span>(</span><br><span class="line">        	name = <span class="string">"onPageScrollStateChanged"</span>,</span><br><span class="line">        	parameters = <span class="string">"int"</span></span><br><span class="line">    	)</span><br><span class="line">    	PAGE_SCROLL_STATE_CHANGED,</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>callback其实是个枚举值，是一组ListenerMethod，映射到监听类的若干个方法，<code>@OnPageChange</code>注解就定义了三组，callback默认是<code>Callback.PAGE_SELECTED</code>，这个值代表的方法是<code>onPageSelected</code>，即如果按照下面的用法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OnPageChange</span>(R.id.example_pager) <span class="function"><span class="keyword">void</span> <span class="title">onPageSelected</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">	Toast.makeText(<span class="keyword">this</span>, <span class="string">"Selected "</span> + position + <span class="string">"!"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么就是当<code>onPageSelected</code>回调时，该方法会被调用。如果我想绑定到另外一个回调接口里面去，应该怎么办呢？可以如下使用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OnPageChange</span>(value = R.id.example_pager, callback = PAGE_SCROLL_STATE_CHANGED)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onPageStateChanged</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">	Toast.makeText(<span class="keyword">this</span>, <span class="string">"State changed: "</span> + state + <span class="string">"!"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以在<code>onPageScrollStateChanged</code>回调中调用这个方法了。</p>
<h2 id="视图绑定注解"><a href="#视图绑定注解" class="headerlink" title="视图绑定注解"></a>视图绑定注解</h2><p>和资源绑定注解很像，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Bind a field to the view for the specified ID. The view will automatically be cast to the field</span></span><br><span class="line"><span class="comment"> * type.</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;&lt;code&gt;</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@literal</span> @&#125;Bind(R.id.title) TextView title;</span></span><br><span class="line"><span class="comment"> * &lt;/code&gt;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention</span>(CLASS) <span class="meta">@Target</span>(FIELD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Bind &#123;</span><br><span class="line">	<span class="comment">/** View ID to which the field will be bound. */</span></span><br><span class="line">	<span class="meta">@IdRes</span> <span class="keyword">int</span>[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只不过这里返回的是一个int[]数组，因为<code>@Bind</code>实际支持将一组id绑定到一个数组或者List属性上。</p>
<h2 id="其余注解"><a href="#其余注解" class="headerlink" title="其余注解"></a>其余注解</h2><ol>
<li><strong>Unbinder</strong> 这个注解是为了给类生成一个Unbinder实例，这样可以将之前<code>bind</code>的变量全部解绑，后面有例子；</li>
<li><strong>Optional</strong> 可选项，有时候有些View、资源找不到，所以有些注入必须可选，否则就会Crash；</li>
</ol>
<h1 id="注解解析大致过程"><a href="#注解解析大致过程" class="headerlink" title="注解解析大致过程"></a>注解解析大致过程</h1><p>定义注解只是注解框架的一部分，代表着注解框架所支持的功能，解析注解是注解框架的另一个核心部分。下面我们来看看ButterKnife是如何实现编译时注解的。我们就从使用的例子上切入开始分析整个注解的运作过程。</p>
<h2 id="运行时解析"><a href="#运行时解析" class="headerlink" title="运行时解析"></a>运行时解析</h2><p>运行时解析源于ButterKnife的一行代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ButterKnife.bind(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<p>在任何需要使用ButterKnife的类中，这行代码都需要调用。我们看看这个方法做了什么:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(@NonNull Activity target)</span> </span>&#123;</span><br><span class="line">    bind(target, target, Finder.ACTIVITY);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(@NonNull Object target, @NonNull Object source, @NonNull Finder finder)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; targetClass = target.getClass();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">"Looking up view binder for "</span> + targetClass.getName());</span><br><span class="line">        ViewBinder&lt;Object&gt; viewBinder = findViewBinderForClass(targetClass);</span><br><span class="line">        viewBinder.bind(finder, target, source);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to bind views for "</span> + targetClass.getName(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>bind()</code>方法有很多重载方法，但是最终都会调用到方法<code>bind(@NonNull Object target, @NonNull Object source, @NonNull Finder finder)</code>。这个方法接受三个参数，我们关注一下第三个参数<code>Finder</code>，这个其实是一个枚举类，用于编译时生成的代码中，非常重要（后面就可以见到了），它主要的功能如下:<br><strong>为Activity、View、Dialog三种情景提供Context以及findViewById功能，并自带强制转换。</strong></p>
<p>这个方法会对targetClass进行解析，调用的方法是<code>findViewBinderForClass()</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, ViewBinder&lt;Object&gt;&gt; BINDERS = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ViewBinder&lt;Object&gt; NOP_VIEW_BINDER = <span class="keyword">new</span> ViewBinder&lt;Object&gt;() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ViewBinder&lt;Object&gt; <span class="title">findViewBinderForClass</span><span class="params">(Class&lt;?&gt; cls)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">    ViewBinder&lt;Object&gt; viewBinder = BINDERS.get(cls);</span><br><span class="line">    <span class="keyword">if</span> (viewBinder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">"HIT: Cached in view binder map."</span>);</span><br><span class="line">        <span class="keyword">return</span> viewBinder;</span><br><span class="line">    &#125;</span><br><span class="line">    String clsName = cls.getName();</span><br><span class="line">    <span class="keyword">if</span> (clsName.startsWith(<span class="string">"android."</span>) || clsName.startsWith(<span class="string">"java."</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">"MISS: Reached framework class. Abandoning search."</span>);</span><br><span class="line">        <span class="keyword">return</span> NOP_VIEW_BINDER;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class&lt;?&gt; viewBindingClass = Class.forName(clsName + <span class="string">"$$ViewBinder"</span>);</span><br><span class="line">        <span class="comment">//noinspection unchecked</span></span><br><span class="line">        viewBinder = (ViewBinder&lt;Object&gt;) viewBindingClass.newInstance();</span><br><span class="line">        <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">"HIT: Loaded view binder class."</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">"Not found. Trying superclass "</span> + cls.getSuperclass().getName());</span><br><span class="line">        viewBinder = findViewBinderForClass(cls.getSuperclass());</span><br><span class="line">    &#125;</span><br><span class="line">    BINDERS.put(cls, viewBinder);</span><br><span class="line">    <span class="keyword">return</span> viewBinder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里其实是为一个类创建一个ViewBinder<object>对象，并通过BINDERS做出缓存。这里注意一点: 当检测到时android或者java框架库中的类，则立即返回，否则就会默认去读取类中的<code>clsName + &quot;$$ViewBinder&quot;</code>类，并由这个类创建出ViewBinder<object>对象（可以猜测出这个类就是ViewBinder<object>类型的）。</object></object></object></p>
<p>可是我们在使用ButterKnife类的时候，并没有创建这个奇怪的类，那么这个类来自哪里呢？这个下一节再解释，我们继续往下分析，在<code>findViewBinderForClass</code>之后，调用的就是下面的方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">viewBinder.bind(finder, target, source);</span><br></pre></td></tr></table></figure>
<p>ViewBinder只是一个接口，框架里面没有相关实现，根据前面的分析，具体的实现应该在<code>clsName + &quot;$$ViewBinder&quot;</code>类中。</p>
<p>所以，我们去找<code>clsName + &quot;$$ViewBinder&quot;</code>类吧。</p>
<h2 id="编译时注解——代码生成"><a href="#编译时注解——代码生成" class="headerlink" title="编译时注解——代码生成"></a>编译时注解——代码生成</h2><p>研究编译时注解，我们需要找到Processor类，ButterKnife类的Processor类叫做<code>ButterKnifeProcessor</code>，它的<code>process</code>方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env)</span> </span>&#123;</span><br><span class="line">    Map&lt;TypeElement, BindingClass&gt; targetClassMap = findAndParseTargets(env);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;TypeElement, BindingClass&gt; entry : targetClassMap.entrySet()) &#123;</span><br><span class="line">        TypeElement typeElement = entry.getKey();</span><br><span class="line">        BindingClass bindingClass = entry.getValue();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bindingClass.brewJava().writeTo(filer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            error(typeElement, <span class="string">"Unable to write view binder for type %s: %s"</span>, typeElement,</span><br><span class="line">            e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个关键点是调用<code>findAndParseTargets</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Map&lt;TypeElement, BindingClass&gt; <span class="title">findAndParseTargets</span><span class="params">(RoundEnvironment env)</span> </span>&#123;</span><br><span class="line">    Map&lt;TypeElement, BindingClass&gt; targetClassMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    Set&lt;String&gt; erasedTargetNames = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process each @Bind element.</span></span><br><span class="line">    <span class="keyword">for</span> (Element element : env.getElementsAnnotatedWith(Bind.class)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!SuperficialValidation.validateElement(element)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            parseBind(element, targetClassMap, erasedTargetNames);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logParsingError(element, Bind.class, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process each annotation that corresponds to a listener.</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;? extends Annotation&gt; listener : LISTENERS) &#123;</span><br><span class="line">        findAndParseListener(env, listener, targetClassMap, erasedTargetNames);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process each @BindArray element.</span></span><br><span class="line">    <span class="keyword">for</span> (Element element : env.getElementsAnnotatedWith(BindArray.class)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!SuperficialValidation.validateElement(element)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             parseResourceArray(element, targetClassMap, erasedTargetNames);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logParsingError(element, BindArray.class, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process each @BindBitmap element.</span></span><br><span class="line">    <span class="comment">// Process each @BindBool element.</span></span><br><span class="line">    <span class="comment">// Process each @BindColor element.</span></span><br><span class="line">    <span class="comment">// Process each @BindDimen element.</span></span><br><span class="line">    <span class="comment">// Process each @BindDrawable element.</span></span><br><span class="line">    <span class="comment">// Process each @BindInt element.</span></span><br><span class="line">    <span class="comment">// Process each @BindString element.    </span></span><br><span class="line">    <span class="comment">// Process each @Unbinder element.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try to find a parent binder for each.</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;TypeElement, BindingClass&gt; entry : targetClassMap.entrySet()) &#123;</span><br><span class="line">        String parentClassFqcn = findParentFqcn(entry.getKey(), erasedTargetNames);</span><br><span class="line">        <span class="keyword">if</span> (parentClassFqcn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            entry.getValue().setParentViewBinder(parentClassFqcn + BINDING_CLASS_SUFFIX);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">      </span><br><span class="line">     <span class="keyword">return</span> targetClassMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>粗略一看，这个方法就是遍历并且整理所有使用ButterKnife注解的元素，详细暂时略去不表。</p>
<p>继续往下看：在遍历这些元素之后再遍历<code>targetClassMap</code>，然后调用<code>bindingClass.brewJava().writeTo(filer);</code>方法创建文件，这就算生成处理完了，那么到底生成了什么东西呢？</p>
<h3 id="编译时注解运行结果"><a href="#编译时注解运行结果" class="headerlink" title="编译时注解运行结果"></a>编译时注解运行结果</h3><p>这里偷个懒，也是为了更快捷的达到目标：因为有module butterknife-sample，所以ButterKnife可以直接当做应用运行。我们run一下，然后在该下面目录结构下就可以看到一些文件:</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/Butter-Knife生成类.png" height="250" alt="Butter-Knife生成类"></div>

<p>如图，在这里就可以看到运行时注解自动生成的类——类名是以<code>$$ViewBinder</code>结尾的，以<code>SimpleActivity$$ViewBinder</code>为例，它的内容如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleActivity</span>$$<span class="title">ViewBinder</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SimpleActivity</span>&gt; <span class="keyword">implements</span> <span class="title">ViewBinder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> SimpleActivity$$ViewBinder() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(Finder finder, <span class="keyword">final</span> T target, Object source)</span> </span>&#123;</span><br><span class="line">        SimpleActivity$$ViewBinder.Unbinder unbinder = <span class="keyword">new</span> SimpleActivity$$ViewBinder.Unbinder(target);</span><br><span class="line">        View view = (View)finder.findRequiredView(source, <span class="number">2130968576</span>, <span class="string">"field \'title\'"</span>);</span><br><span class="line">        target.title = (TextView)finder.castView(view, <span class="number">2130968576</span>, <span class="string">"field \'title\'"</span>);</span><br><span class="line">        view = (View)finder.findRequiredView(source, <span class="number">2130968577</span>, <span class="string">"field \'subtitle\'"</span>);</span><br><span class="line">        target.subtitle = (TextView)finder.castView(view, <span class="number">2130968577</span>, <span class="string">"field \'subtitle\'"</span>);</span><br><span class="line">        view = (View)finder.findRequiredView(source, <span class="number">2130968578</span>, <span class="string">"field \'hello\', method \'sayHello\', and method \'sayGetOffMe\'"</span>);</span><br><span class="line">        target.hello = (Button)finder.castView(view, <span class="number">2130968578</span>, <span class="string">"field \'hello\'"</span>);</span><br><span class="line">        unbinder.view2130968578 = view;</span><br><span class="line">        view.setOnClickListener(<span class="keyword">new</span> DebouncingOnClickListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doClick</span><span class="params">(View p0)</span> </span>&#123;</span><br><span class="line">                target.sayHello();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        view.setOnLongClickListener(<span class="keyword">new</span> OnLongClickListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onLongClick</span><span class="params">(View p0)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> target.sayGetOffMe();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        view = (View)finder.findRequiredView(source, <span class="number">2130968579</span>, <span class="string">"field \'listOfThings\' and method \'onItemClick\'"</span>);</span><br><span class="line">        target.listOfThings = (ListView)finder.castView(view, <span class="number">2130968579</span>, <span class="string">"field \'listOfThings\'"</span>);</span><br><span class="line">        unbinder.view2130968579 = view;</span><br><span class="line">        ((AdapterView)view).setOnItemClickListener(<span class="keyword">new</span> OnItemClickListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(AdapterView&lt;?&gt; p0, View p1, <span class="keyword">int</span> p2, <span class="keyword">long</span> p3)</span> </span>&#123;</span><br><span class="line">                target.onItemClick(p2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        view = (View)finder.findRequiredView(source, <span class="number">2130968580</span>, <span class="string">"field \'footer\'"</span>);</span><br><span class="line">        target.footer = (TextView)finder.castView(view, <span class="number">2130968580</span>, <span class="string">"field \'footer\'"</span>);</span><br><span class="line">        target.headerViews = Utils.listOf(<span class="keyword">new</span> View[]&#123;(View)finder.findRequiredView(source, <span class="number">2130968576</span>, <span class="string">"field \'headerViews\'"</span>), (View)finder.findRequiredView(source, <span class="number">2130968577</span>, <span class="string">"field \'headerViews\'"</span>), (View)finder.findRequiredView(source, <span class="number">2130968578</span>, <span class="string">"field \'headerViews\'"</span>)&#125;);</span><br><span class="line">        target.unbinder = unbinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Unbinder</span> <span class="keyword">implements</span> <span class="title">butterknife</span>.<span class="title">ButterKnife</span>.<span class="title">Unbinder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> SimpleActivity target;</span><br><span class="line">        View view2130968578;</span><br><span class="line">        View view2130968579;</span><br><span class="line"></span><br><span class="line">        Unbinder(SimpleActivity target) &#123;</span><br><span class="line">            <span class="keyword">this</span>.target = target;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unbind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Bindings already cleared."</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.target.title = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">this</span>.target.subtitle = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">this</span>.view2130968578.setOnClickListener((OnClickListener)<span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">this</span>.view2130968578.setOnLongClickListener((OnLongClickListener)<span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">this</span>.target.hello = <span class="keyword">null</span>;</span><br><span class="line">                ((AdapterView)<span class="keyword">this</span>.view2130968579).setOnItemClickListener((OnItemClickListener)<span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">this</span>.target.listOfThings = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">this</span>.target.footer = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">this</span>.target.headerViews = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">this</span>.target.unbinder = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">this</span>.target = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类就是我们要找的类，也是 <strong>注解解析</strong> 一节中调用<code>Binder.bind()</code>方法时用于绑定的类，注意这个类：它实现了ViewBinder接口。再看一下<code>bind</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(@NonNull Object target, @NonNull Object source, @NonNull Finder finder)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; targetClass = target.getClass();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">"Looking up view binder for "</span> + targetClass.getName());</span><br><span class="line">        ViewBinder&lt;Object&gt; viewBinder = findViewBinderForClass(targetClass);</span><br><span class="line">        viewBinder.bind(finder, target, source);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to bind views for "</span> + targetClass.getName(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>viewBinder.bind(finder, target, source);</code>调用的就是生成类中的<code>bind</code>方法。我们取方法中的一小段来看:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">View view = (View)finder.findRequiredView(source, <span class="number">2130968576</span>, <span class="string">"field \'title\'"</span>);</span><br><span class="line">target.title = (TextView)finder.castView(view, <span class="number">2130968576</span>, <span class="string">"field \'title\'"</span>);</span><br></pre></td></tr></table></figure>
<p>这里就通过finder的<code>findRequiredView</code>和<code>castView</code>两个方法来为target的title属性来赋值了。这里其实略有多余，不需要再添加<code>(TextView)</code>强转，看一下<code>castView</code>方法的实现就好了:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">castView</span><span class="params">(View view, <span class="keyword">int</span> id, String who)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (T) view;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">   		<span class="keyword">if</span> (who == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">		&#125;</span><br><span class="line">      	String name = getResourceEntryName(view, id);</span><br><span class="line">      	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"View '"</span></span><br><span class="line">          + name</span><br><span class="line">          + <span class="string">"' with ID "</span></span><br><span class="line">          + id</span><br><span class="line">          + <span class="string">" for "</span></span><br><span class="line">          + who</span><br><span class="line">          + <span class="string">" was of the wrong type. See cause for more info."</span>, e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里已经使用泛型进行强转了。</p>
<p>到这里，我们大致可以明白ButterKnife的实现原理了:<br><strong>为注解类生成一个对应的ViewBinder类，自动生成<code>findViewById</code>等模板代码，在运行的时候，反射实例化ViewBinder类，调用它的<code>bind()</code>方法完成注解——这里只有在生成ViewBinder对象的时候使用了反射，其余代码均是正常的调用。</strong></p>
<p>从生成的代码里面还可以看到Unbinder这个内部类：生成它是因为SimpleActivity里面有这样的用法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Unbinder</span> ButterKnife.Unbinder unbinder;</span><br></pre></td></tr></table></figure>
<p>在<code>unbinder()</code>方法里面，我们可以看到把注入的内容全部删除了，这也就是<code>@Unbinder</code>注解的使用方法。</p>
<p>好了，到了这里，我们大致能知道ButterKnife是怎么玩的了，但是具体如何生成类这一块还不是很清楚。<strong>下一节我们来重点分析：ButterKnife是如何生成一个类的。</strong></p>
<h1 id="生成类"><a href="#生成类" class="headerlink" title="生成类"></a>生成类</h1><p>讲解这个需要我们基于前面的分析，在<code>findAndParseTargets</code>方法中，有很多的<code>parseXXX</code>方法调用。根据前面的分析，基本可以确定一个注解类XXX会对应生成<code>XXX$$ViewBinder</code>类，那么我们先确定：ButterKnife如何确定需要生成哪些类，属性又是如何规整到这些类里面去的？即：怎么知道生成一个类的所有信息。</p>
<h2 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h2><p>我们来看一个<code>parseResourceInt</code>方法，这是处理所有的Int资源的类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseResourceInt</span><span class="params">(Element element, Map&lt;TypeElement, BindingClass&gt; targetClassMap,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  Set&lt;String&gt; erasedTargetNames)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">boolean</span> hasError = <span class="keyword">false</span>;</span><br><span class="line">	<span class="comment">// A</span></span><br><span class="line">	TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Verify that the target type is int.</span></span><br><span class="line">	<span class="keyword">if</span> (element.asType().getKind() != TypeKind.INT) &#123;</span><br><span class="line">		error(element, <span class="string">"@%s field type must be 'int'. (%s.%s)"</span>, BindInt.class.getSimpleName(),</span><br><span class="line">		enclosingElement.getQualifiedName(), element.getSimpleName());</span><br><span class="line">		hasError = <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Verify common generated code restrictions.</span></span><br><span class="line">	hasError |= isInaccessibleViaGeneratedCode(BindInt.class, <span class="string">"fields"</span>, element);</span><br><span class="line">	hasError |= isBindingInWrongPackage(BindInt.class, element);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (hasError) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Assemble information on the field.</span></span><br><span class="line">	String name = element.getSimpleName().toString();</span><br><span class="line">	<span class="keyword">int</span> id = element.getAnnotation(BindInt.class).value();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// B</span></span><br><span class="line">	BindingClass bindingClass = getOrCreateTargetClass(targetClassMap, enclosingElement);</span><br><span class="line">	FieldResourceBinding binding = <span class="keyword">new</span> FieldResourceBinding(id, name, <span class="string">"getInteger"</span>, <span class="keyword">false</span>);</span><br><span class="line">	bindingClass.addResource(binding);</span><br><span class="line"></span><br><span class="line">	erasedTargetNames.add(enclosingElement.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看A处，这里调用了一个<code>getEnclosingElement()</code>方法，这个方法是干啥的呢？官网文档解释如下:</p>
<blockquote>
<p>返回此元素直接封装（非严格意义上）的元素。 类或接口被认为用于封装它直接声明的字段、方法、构造方法和成员类型。这包括所有（隐式）默认构造方法和枚举类型的隐式 values 和 valueOf 方法。 包封装位于其中的顶层类和接口，但不认为它封装了子包。 当前不认为其他种类的元素封装了任何元素；但是，随着此 API 或编程语言的发展，这种情况可能发生改变。</p>
</blockquote>
<p>从ButterKnife的注解定义来看，注解使用在方法或者属性上面，那么通过这个方法就可以获取到封装这些元素的类。接下来我们看B处，先看一下<code>getOrCreateTargetClass</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BINDING_CLASS_SUFFIX = <span class="string">"$$ViewBinder"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> BindingClass <span class="title">getOrCreateTargetClass</span><span class="params">(Map&lt;TypeElement, BindingClass&gt; targetClassMap, TypeElement enclosingElement)</span> </span>&#123;</span><br><span class="line">	BindingClass bindingClass = targetClassMap.get(enclosingElement);</span><br><span class="line">	<span class="keyword">if</span> (bindingClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">		String targetType = enclosingElement.getQualifiedName().toString();</span><br><span class="line">		String classPackage = getPackageName(enclosingElement);</span><br><span class="line">		String className = getClassName(enclosingElement, classPackage) + BINDING_CLASS_SUFFIX;</span><br><span class="line"></span><br><span class="line">		bindingClass = <span class="keyword">new</span> BindingClass(classPackage, className, targetType);</span><br><span class="line">		targetClassMap.put(enclosingElement, bindingClass);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bindingClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很清楚：这里会往targetClassMap里面存储一个Entry，Key为enclosingElement（即外部类），Value为BindingClass。BindingClass初始化记录了三样东西: 原先的注解类类名、原先的注解类所在包名和要生成的注解类类名（<code>XXX$$ViewBinder</code>）。</p>
<p>我们继续看B处，在获取到这个BindingClass之后，就执行如下代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FieldResourceBinding binding = <span class="keyword">new</span> FieldResourceBinding(id, name, <span class="string">"getInteger"</span>, <span class="keyword">false</span>);</span><br><span class="line">bindingClass.addResource(binding);</span><br></pre></td></tr></table></figure>
<p>这个代码生成一个FieldResourceBinding对象然后添加到BindingClass中。</p>
<p>由此我们可以看到整个解析过程: <strong>遍历所有的注解元素，并通过<code>getEnclosingElement()</code>获取声明这些元素的类，所有需要创建的类信息都维护在<code>targetClassMap</code>Map数据结构中，Key为注解使用类，Value为BindingClass——后续将根据这个BindingClass生成代码。所有的注解元素都将经过解析存储到BindingClass中（类似FieldResourceBinding这样的属性），最终解析完成，所有需要生成的类都可以通过<code>targetClassMap</code>索引到</strong>。</p>
<h2 id="写入过程"><a href="#写入过程" class="headerlink" title="写入过程"></a>写入过程</h2><p>写入过程是这样的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;TypeElement, BindingClass&gt; entry : targetClassMap.entrySet()) &#123;</span><br><span class="line">	TypeElement typeElement = entry.getKey();</span><br><span class="line">	BindingClass bindingClass = entry.getValue();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		bindingClass.brewJava().writeTo(filer);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		error(typeElement, <span class="string">"Unable to write view binder for type %s: %s"</span>, typeElement, e.getMessage());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就是遍历所有的BindingClass，调用<code>brewJava()</code>，这个方法涉及到的知识以及后面<code>writeTo()</code>方法均来自于<a href="https://github.com/square/javapoet" target="_blank" rel="noopener">javapoet项目</a>，这个项目可以很方便的根据一些信息生成一个Java类，此处不赘述。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ButterKnife不但使用方便，而且通过编译时注解，减少了反射的使用，提高了注解解析的效率，确实非常赞。</p>
<p>最后推荐一个Android Studio插件用于生成ButterKnife代码，地址如下: <a href="https://github.com/avast/android-butterknife-zelezny" target="_blank" rel="noopener">android-butterknife-zelezny</a>，可以用于快速生成ButterKnife注解代码。</p>
<p>鉴于某些项目由于方法数问题或者其余原因没有使用ButterKnife，程序员们被逼要写<code>findViewById</code>这样的代码，还得去XML里面翻找id，我基于以上插件，改写了另外一个插件，地址如下：<a href="https://github.com/BigFootprint/AndroidViewGenerator" target="_blank" rel="noopener">AndroidViewGenerator</a>，欢迎使用。</p>
</div><div class="tags"><a href="/tags/源码/">源码</a></div><div class="post-nav"><a href="/2016/04/21/Apk-reverse-engineering/" class="pre">反编译APK</a><a href="/2016/03/24/mvc-mvp-mvvm/" class="next">MVC，MVP，MVVM</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">59</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactiveX/">ReactiveX</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/后端/">后端</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/影视/">影视</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/电影/">电影</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Gitbook/" style="font-size: 15px;">Gitbook</a> <a href="/tags/Runtime/" style="font-size: 15px;">Runtime</a> <a href="/tags/视图/" style="font-size: 15px;">视图</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/权限/" style="font-size: 15px;">权限</a> <a href="/tags/代码优化/" style="font-size: 15px;">代码优化</a> <a href="/tags/Framework/" style="font-size: 15px;">Framework</a> <a href="/tags/性能优化/" style="font-size: 15px;">性能优化</a> <a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/合集/" style="font-size: 15px;">合集</a> <a href="/tags/ADB/" style="font-size: 15px;">ADB</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/反编译/" style="font-size: 15px;">反编译</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/Gradle/" style="font-size: 15px;">Gradle</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/基础/" style="font-size: 15px;">基础</a> <a href="/tags/效率/" style="font-size: 15px;">效率</a> <a href="/tags/MarkDown/" style="font-size: 15px;">MarkDown</a> <a href="/tags/电影/" style="font-size: 15px;">电影</a> <a href="/tags/Reactive/" style="font-size: 15px;">Reactive</a> <a href="/tags/AIDL/" style="font-size: 15px;">AIDL</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/驱动/" style="font-size: 15px;">驱动</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/日志/" style="font-size: 15px;">日志</a> <a href="/tags/事件/" style="font-size: 15px;">事件</a> <a href="/tags/代码设计/" style="font-size: 15px;">代码设计</a> <a href="/tags/网络/" style="font-size: 15px;">网络</a> <a href="/tags/测试/" style="font-size: 15px;">测试</a> <a href="/tags/Binder/" style="font-size: 15px;">Binder</a> <a href="/tags/Groovy/" style="font-size: 15px;">Groovy</a> <a href="/tags/Loader/" style="font-size: 15px;">Loader</a> <a href="/tags/RAC/" style="font-size: 15px;">RAC</a> <a href="/tags/事件处理/" style="font-size: 15px;">事件处理</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/10/30/AIDL-原理分析/">AIDL 原理分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/30/App-启动过程/">App 启动过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/PMS-解析/">PMS 解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/WMS-解析/">WindowManagerService 解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/AMS-解析/">AMS 解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/10/The-Good-Wife/">The-Good-Wife</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/10/Black-Sails/">黑帆</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/29/hello-world/">Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/23/XCode-8-2-1-ClangFormat-插件安装/">XCode 8.2.1 ClangFormat 插件安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/07/SourceTree-分支图谱/">SourceTree 分支图谱</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">蜗牛壳.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>