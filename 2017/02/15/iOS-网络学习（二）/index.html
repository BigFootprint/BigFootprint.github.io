<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="李全民的个人博客"><title>iOS 网络学习（二）—— NSURLSession | 蜗牛壳</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-65882749-1','auto');ga('send','pageview');</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">iOS 网络学习（二）—— NSURLSession</h1><a id="logo" href="/.">蜗牛壳</a><p class="description">计算机只有 0 和 1 ，但世界是连续的</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">iOS 网络学习（二）—— NSURLSession</h1><div class="post-meta">Feb 15, 2017<span> | </span><span class="category"><a href="/categories/iOS/">iOS</a></span></div><div class="post-content"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>2013 年 WWDC 上，Apple 发布了 NSURLConnection 的继任者 <a href="https://developer.apple.com/reference/foundation/urlsession" target="_blank" rel="noopener">NSURLSession</a>，支持 iOS7.0+，而 NSURLCOnnection 在 iOS9 被宣布弃用。</p>
<h2 id="URL-加载系统"><a href="#URL-加载系统" class="headerlink" title="URL 加载系统"></a>URL 加载系统</h2><p>在学习 NSURLSession 之前，有必要先了解一下 URL 加载系统（URL Loading System）。</p>
<blockquote>
<p>这个系统本来应该在 <a href="http://timebridge.space/2017/02/15/iOS-%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="noopener">iOS 网络学习（一）—— URLConnection</a> 提及，但 NSURLConnection 本身比较简单，而且已经被废弃，NSURLSession 将会是后面网络请求的核心，因此在这里系统了解一下。</p>
</blockquote>
<p>URL 加载系统，顾名思义就是根据 URL 从某个地方加载资源，这个“加载”是广义的，既包括从服务端下载资源，也包括上传资源。它支持 http、https、ftp、file、data 资源传输协议以及自定义扩充协议，由一组辅助类以及 Protocol 组成，主要分为五个部分：<a id="more"></a></p>
<ol>
<li>配置管理</li>
<li>缓存管理</li>
<li>cookie 存储</li>
<li>认证和证书</li>
<li>自定义协议支持</li>
</ol>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/NSURLSession-Family.png" height="320" alt="One Piece"></div>

<p>实际上我们平时所说的 NSURLSession 指的就是上面一组类，而并不单单是指 NSURLSession 类本身，下面我们通过对 NSURLSession 用法的学习来了解一下这五个部分。</p>
<blockquote>
<p>图中将 NSURLConnection 也列在其中，它也属于 URL 加载系统的一部分。</p>
</blockquote>
<h2 id="使用-NSURLSession"><a href="#使用-NSURLSession" class="headerlink" title="使用 NSURLSession"></a>使用 NSURLSession</h2><p>NSURLSession 以及相关类为 Http 请求提供了相关接口，为了使用 NSURLSession，需要我们创建一组 session 对象，每一个 session 对象负责执行一组数据传输任务。举个栗子，如果你在开发一个网页浏览器，你可能会为每一个 Tab 或者 Window 创建一个 session，每个 session 会负责一组传输任务，每个任务代表着对一个特定 URL 指向的资源的请求。</p>
<p>和 NSURLConnection 一样，NSURLSession 可以通过 Block 或者 Delegate 来接收处理请求返回的结果数据。Block 被设计为 Delegate 的替换选择，如果一个任务设置了 Block，那么 Delegate 就不会被回调。除此之外，NSURLSession 还提供了取消、暂停、唤醒任务的接口。</p>
<h3 id="URL-Session-相关概念"><a href="#URL-Session-相关概念" class="headerlink" title="URL Session 相关概念"></a>URL Session 相关概念</h3><p>session 中任务的行为取决于三个因素：1）session 的类型（取决于创建时候的配置）；2）任务的类型；3）任务创建的时候应用是否处于前台。</p>
<h4 id="session-类型"><a href="#session-类型" class="headerlink" title="session 类型"></a>session 类型</h4><p>NSURLSession 支持三种类型的 session，由创建时候的配置决定：</p>
<ul>
<li><strong>Default Session</strong> 默认 session 与 Foundation 中其他下载 URL 资源的方法类似，使用基于磁盘的缓存，并将证书存储在 keychain 中；</li>
<li><strong>Ephemeral Session</strong> 这种类型的 session 不会在磁盘上存储任何类型的数据，所有的缓存、证书存储以及其他数据都会被保存在内存中，仅限于当前 session 可用，因此当你的应用关闭这个 session，相关数据会自动被清除；</li>
<li><strong>Background Session</strong> 和 Default Session 类似，但是它是在独立的进程中进行数据传输的，并且还有一些额外的限制，后面会细说。</li>
</ul>
<h4 id="任务类型"><a href="#任务类型" class="headerlink" title="任务类型"></a>任务类型</h4><p>在一个 session 里面，NSURLSession 支持三种类型的任务：数据任务，下载任务和上传任务。</p>
<ul>
<li><strong>数据任务</strong> 使用 NSData 发送和接受数据，适用于比较信息量较少的服务端请求，数据任务可以将服务端返回的数据分批交给应用，又或者在全部接收完成之后通过 Block 一次性返回；</li>
<li><strong>下载任务</strong> 以文件形式接收数据，并且支持当 App 不运行的时候后台下载；</li>
<li><strong>上传任务</strong> 以文件形式发送数据，并且支持当 App 不运行的时候后台上传；</li>
</ul>
<h4 id="后台数据传输考量"><a href="#后台数据传输考量" class="headerlink" title="后台数据传输考量"></a>后台数据传输考量</h4><p>NSURLSession 支持当应用挂起的时候在后台进行数据传输，后台传输仅在使用 Background Session 配置的时候起作用。由于使用 Background Session 的时候下载任务是在独立的进程中进行的，且重启你的 App 有比较大的代价，因此使用这种模式有一些限制：</p>
<p>// TODO</p>
<h4 id="生命周期和-Delegate-交互"><a href="#生命周期和-Delegate-交互" class="headerlink" title="生命周期和 Delegate 交互"></a>生命周期和 Delegate 交互</h4><p>理解这个点取决于你使用 NSURLSession 类来干什么，有可能需要理解 session 生命周期，包括 session 如何与delegate 交互， delegate 接口的调用顺序，服务端重定向资源后会发生什么，当 App 重启一个失败的下载后会发生什么，等等。后面会详述。</p>
<h4 id="NSCoping-行为"><a href="#NSCoping-行为" class="headerlink" title="NSCoping 行为"></a>NSCoping 行为</h4><p>Session 和任务对象遵从 NSCopying 协议，并有如下实现：</p>
<ul>
<li>拷贝 session 和任务对象，会得到相同的对象；</li>
<li>拷贝配置对象，会得到新的对象，可以独立修改；</li>
</ul>
<h3 id="创建并配置-Session"><a href="#创建并配置-Session" class="headerlink" title="创建并配置 Session"></a>创建并配置 Session</h3><p>NSURLSession 提供了丰富的配置项：</p>
<ul>
<li>单个 session 特有的存储配置，包括缓存、cookie、证书，以及协议；</li>
<li>绑定到单个任务或者 session 的身份认证信息；</li>
<li>上传和下载任务，并支持分离数据（文件内容）和元数据（URL 和 设置）；</li>
<li>配置到每个 Host 的最大连接数；</li>
<li>如果整个资源不能在某个时间内被下载下来，那么每个组成资源都会被处罚超时；</li>
<li>支持的 TLS 版本范围设置；</li>
<li>自定义代理字典；</li>
<li>缓存策略；</li>
<li>Http 管道行为控制；</li>
</ul>
<p>因为大部分的配置项都包含在一个单独的配置配置项中，开发者可以重用通用的设置，当一个 session 对象被初始化之后，需要完成：</p>
<ul>
<li>一个控制 session 和 session 内任务行为的配置独享；</li>
<li>一个用于处理加载数据和事件的 delegate，进行服务端身份认证，决定一个资源加载是否需要被转化为下载等工作，这是可选的；</li>
</ul>
<p>如果开发者不提供自定义 delegate， NSURLSession 会使用系统提供的 delegate。但是如果你要进行后台数据传输任务，就必须提供一个自定义的 delegate。</p>
<p>当一个 session 初始化完毕之后，开发者就无法再更改配置对象或者代理了，除非创建一个新的 session。</p>
<p>下面代码展示了如何三种类型的 session：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// Creating session configurations</span><br><span class="line">NSURLSessionConfiguration *defaultConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration];</span><br><span class="line">NSURLSessionConfiguration *ephemeralConfiguration = [NSURLSessionConfiguration ephemeralSessionConfiguration];</span><br><span class="line">NSURLSessionConfiguration *backgroundConfiguration = [NSURLSessionConfiguration backgroundSessionConfigurationWithIdentifier: @&quot;com.myapp.networking.background&quot;];</span><br><span class="line"> </span><br><span class="line">// Configuring caching behavior for the default session</span><br><span class="line">NSString *cachesDirectory = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES).firstObject;</span><br><span class="line">NSString *cachePath = [cachesDirectory stringByAppendingPathComponent:@&quot;MyCache&quot;];</span><br><span class="line"> </span><br><span class="line">/* Note:</span><br><span class="line"> iOS requires the cache path to be</span><br><span class="line"> a path relative to the ~/Library/Caches directory,</span><br><span class="line"> but OS X expects an absolute path.</span><br><span class="line"> */</span><br><span class="line">#if TARGET_OS_OSX</span><br><span class="line">cachePath = [cachePath stringByStandardizingPath];</span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">NSURLCache *cache = [[NSURLCache alloc] initWithMemoryCapacity:16384 diskCapacity:268435456 diskPath:cachePath];</span><br><span class="line">defaultConfiguration.URLCache = cache;</span><br><span class="line">defaultConfiguration.requestCachePolicy = NSURLRequestUseProtocolCachePolicy;</span><br><span class="line"> </span><br><span class="line">// Creating sessions</span><br><span class="line">id &lt;NSURLSessionDelegate&gt; delegate = [[MySessionDelegate alloc] init];</span><br><span class="line">NSOperationQueue *operationQueue = [NSOperationQueue mainQueue];</span><br><span class="line"> </span><br><span class="line">NSURLSession *defaultSession = [NSURLSession sessionWithConfiguration:defaultConfiguration delegate:delegate operationQueue:operationQueue];</span><br><span class="line">NSURLSession *ephemeralSession = [NSURLSession sessionWithConfiguration:ephemeralConfiguration delegate:delegate delegateQueue:operationQueue];</span><br><span class="line">NSURLSession *backgroundSession = [NSURLSession sessionWithConfiguration:backgroundConfiguration delegate:delegate delegateQueue:operationQueue];</span><br></pre></td></tr></table></figure>
<p>除了 Background Session 的配置，开发者可以复用配置对象创建任意的 session（Background session 的配置对象之所以不能复用，是因为如果两个 Background Session 的 identifier 一样，会发生不可预知的行为）。</p>
<p>开发者介意在任何时候修改配置，因为当你创建一个 session 的时候，配置对象就会被深度拷贝，因此修改配置不会影响已经创建的 session。举个栗子，你或许会创建新的 session，并要求只能在链接 wifi 的情况下下载资源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ephemeralConfiguration.allowsCellularAccess = NO;</span><br><span class="line">NSURLSession *ephemeralSessionWiFiOnly = [NSURLSession sessionWithConfiguration:ephemeralConfiguration delegate:delegate delegateQueue:operationQueue];</span><br></pre></td></tr></table></figure>
<h3 id="使用系统提供的-Delegate-拉取资源"><a href="#使用系统提供的-Delegate-拉取资源" class="headerlink" title="使用系统提供的 Delegate 拉取资源"></a>使用系统提供的 Delegate 拉取资源</h3><p>使用 NSURLSession 最直接的方法就是使用系统提供的 Delegate 来请求资源，开发者只需要提供两段代码来实现这种方式的使用：</p>
<ul>
<li>一段代码创建配置对象以及基于配置对象的 session；</li>
<li>在数据全部接收完成后处理数据的 Block；</li>
</ul>
<p>使用系统提供的 Delegate，每个资源请求只需要一行代码就可以搞定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSURLSession *sessionWithoutADelegate = [NSURLSession sessionWithConfiguration:defaultConfiguration];</span><br><span class="line">NSURL *url = [NSURL URLWithString:@&quot;https://www.example.com/&quot;];</span><br><span class="line"> </span><br><span class="line">[[sessionWithoutADelegate dataTaskWithURL:url completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) &#123;</span><br><span class="line">    NSLog(@&quot;Got response %@ with error %@.\n&quot;, response, error);</span><br><span class="line">    NSLog(@&quot;DATA:\n%@\nEND DATA\n&quot;, [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];</span><br><span class="line">&#125;] resume];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>系统提供的 delegate 只定义了有限的网络行为，如果 App 有特殊的需要，比如自定义的认证或者后台下载，这种方式是不合适的。</p>
</blockquote>
<h3 id="使用自定义的-Delegate-拉取数据"><a href="#使用自定义的-Delegate-拉取数据" class="headerlink" title="使用自定义的 Delegate 拉取数据"></a>使用自定义的 Delegate 拉取数据</h3><p>如果你使用自定义的 Delegate 拉取数据，Delegate 必须实现至少如下两个方法：</p>
<ul>
<li><code>URLSession:dataTask:didReceiveData:</code> 会分批吐出服务端返回的数据。</li>
<li><code>URLSession:task:didCompleteWithError:</code> 会告诉 App 数据全部接收完毕。</li>
</ul>
<p>这种情况下，如果 App 需要使用完整的数据，就需要自己存储数据。举个栗子，网页浏览器可能需要渲染当前接收到的数据和之前接收到的数据，因此，它可能需要 <code>appendData:</code> 来不停的将新收到的数据保存下来。</p>
<p>下面的代码展示了如何创建和启动一个数据任务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSURL *url = [NSURL URLWithString: @&quot;https://www.example.com/&quot;];</span><br><span class="line">NSURLSessionDataTask *dataTask = [defaultSession dataTaskWithURL:url];</span><br><span class="line">[dataTask resume];</span><br></pre></td></tr></table></figure>
<h3 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h3><p>文件下载其实和拉取数据类似，使用的时候应该要实现以下 deleggate 方法：</p>
<ul>
<li><p><code>URLSession:downloadTask:didFinishDownloadingToURL:</code> 告知 App 指向下载内容临时存储文件的 URL；</p>
<blockquote>
<p>这个方法返回之前，它必须打开文件读取其中的数据或者将文件移动到一个永久的地址，因为当这个方法返回后，临时文件就会被删除。</p>
</blockquote>
</li>
<li><p><code>URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:</code> 告知 App 下载进度；</p>
</li>
<li><p><code>URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:</code> 告知 App 它成功重启了一个失败的下载；</p>
</li>
<li><p><code>URLSession:task:didCompleteWithError:</code> 告知 App 下载失败了；</p>
</li>
</ul>
<p>如果你在一个 Background Session 中调度下载任务，即使 App 不运行了，下载任务依然会运行；如果是在 Default / Ephemeral Session 中调度下载任务，应用重启之后必须重新开启下载任务。</p>
<p>当从服务端拉取数据的时候，如果用户选择暂停下载，App 可以通过调用<code>cancelByProducingResumeData:</code> 方法来取消任务，之后，App 可以通过将已经下载的数据传递给<code>downloadTaskWithResumeData:</code> 或者 <code>downloadTaskWithResumeData:</code> 方法来创建一个新的下载任务继续下载。</p>
<p>如果数据传输失败，delegate 的 <code>URLSession:task:didCompleteWithError:</code> 方法会被调用。</p>
<p>下面的代码展示了下载一个中等大小文件的过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSURL *url = [NSURL URLWithString:@&quot;https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/ObjC_classic/FoundationObjC.pdf&quot;];</span><br><span class="line">NSURLSessionDownloadTask *downloadTask = [backgroundSession downloadTaskWithURL:url];</span><br><span class="line">[downloadTask resume];</span><br></pre></td></tr></table></figure>
<p>下面是 delegate 实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">      downloadTask:(NSURLSessionDownloadTask *)downloadTask</span><br><span class="line">      didWriteData:(int64_t)bytesWritten</span><br><span class="line"> totalBytesWritten:(int64_t)totalBytesWritten</span><br><span class="line">totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;Session %@ download task %@ wrote an additional %lld bytes (total %lld bytes) out of an expected %lld bytes.\n&quot;, session, downloadTask, bytesWritten, totalBytesWritten, totalBytesExpectedToWrite);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">      downloadTask:(NSURLSessionDownloadTask *)downloadTask</span><br><span class="line"> didResumeAtOffset:(int64_t)fileOffset</span><br><span class="line">expectedTotalBytes:(int64_t)expectedTotalBytes</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;Session %@ download task %@ resumed at offset %lld bytes out of an expected %lld bytes.\n&quot;, session, downloadTask, fileOffset, expectedTotalBytes);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">      downloadTask:(NSURLSessionDownloadTask *)downloadTask</span><br><span class="line">didFinishDownloadingToURL:(NSURL *)location</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;Session %@ download task %@ finished downloading to URL %@\n&quot;, session, downloadTask, location);</span><br><span class="line"> </span><br><span class="line">    // Perform the completion handler for the current session</span><br><span class="line">    self.completionHandlers[session.configuration.identifier]();</span><br><span class="line"> </span><br><span class="line">   // Open the downloaded file for reading</span><br><span class="line">    NSError *readError = nil;</span><br><span class="line">    NSFileHandle *fileHandle = [NSFileHandle fileHandleForReadingFromURL:location error:readError];</span><br><span class="line">    // ...</span><br><span class="line"> </span><br><span class="line">   // Move the file to a new URL</span><br><span class="line">    NSFileManager *fileManager = [NSFileManager defaultManager];</span><br><span class="line">    NSURL *cacheDirectory = [[fileManager URLsForDirectory:NSCachesDirectory inDomains:NSUserDomainMask] firstObject];</span><br><span class="line">    NSError *moveError = nil;</span><br><span class="line">    if ([fileManager moveItemAtURL:location toURL:cacheDirectory error:moveError]) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="上传消息体内容"><a href="#上传消息体内容" class="headerlink" title="上传消息体内容"></a>上传消息体内容</h3><p>App 可以通过三种方式为 HTTP POST 消息提供消息体：NSData、文件或者流。总的来说，你的 App 应该：</p>
<ul>
<li>如果内存中已经存在一个 NSData 对象并且没有理由废弃它（比如内存问题），那么可以直接使用它；</li>
<li>如果上传内容是以文件的形式存在于磁盘上的，或者你是在进行后台传输任务，又或者 App 有必要将数据写到磁盘上来释放那部分数据占用的内存空间，那么使用文件即可；</li>
<li>如果你是从网络上接收数据，那么使用流；</li>
</ul>
<p>不管你选择何种方式上传，如果你的 App 自定义了 session delegate，它都应该实现 <code>URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:</code> 方法来获取上传进度信息；</p>
<p>另外，如果你的 App 是通过流的形式提供消息体的，它必须提供自定义的 session delegate 并实现 <code>URLSession:task:needNewBodyStream:</code> 方法，下面会详细解释。</p>
<h4 id="使用-NSData-上传数据"><a href="#使用-NSData-上传数据" class="headerlink" title="使用 NSData 上传数据"></a>使用 NSData 上传数据</h4><p>使用 NSData 进行上传，App 必须通过调用 <code>uploadTaskWithRequest:fromData:</code> 或者 <code>uploadTaskWithRequest:fromData:completionHandler:</code> 方法来创建上传任务，并在 <code>fromData:</code> 参数中传入数据对象。session 对象会根据 NSData 对象计算 <code>Content-Length</code> Header 的值，服务器需要的其余参数需要开发者手动提供，比如 <code>Content-Type</code>。</p>
<p>下面的代码展示了如何通过 NSData 进行数据上传：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NSURL *textFileURL = [NSURL fileURLWithPath:@&quot;/path/to/file.txt&quot;];</span><br><span class="line">NSData *data = [NSData dataWithContentsOfURL:textFileURL];</span><br><span class="line"> </span><br><span class="line">NSURL *url = [NSURL URLWithString:@&quot;https://www.example.com/&quot;];</span><br><span class="line">NSMutableURLRequest *mutableRequest = [NSMutableURLRequest requestWithURL:url];</span><br><span class="line">mutableRequest.HTTPMethod = @&quot;POST&quot;;</span><br><span class="line">[mutableRequest setValue:[NSString stringWithFormat:@&quot;%lld&quot;, data.length] forHTTPHeaderField:@&quot;Content-Length&quot;];</span><br><span class="line">[mutableRequest setValue:@&quot;text/plain&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];</span><br><span class="line"> </span><br><span class="line">NSURLSessionUploadTask *uploadTask = [defaultSession uploadTaskWithRequest:mutableRequest fromData:data];</span><br><span class="line">[uploadTask resume];</span><br></pre></td></tr></table></figure>
<h4 id="使用文件上传数据"><a href="#使用文件上传数据" class="headerlink" title="使用文件上传数据"></a>使用文件上传数据</h4><p>使用文件上传数据，App 必须通过调用 <code>uploadTaskWithRequest:fromFile:</code> 或者 <code>uploadTaskWithRequest:fromFile:completionHandler:</code> 方法来创建上传任务，并且提供文件的 URL 以供任务读取上传数据。session 对象会根据文件对象计算 <code>Content-Length</code> Header 的值，如果 App 没有设置 <code>Content-Type</code>  Header，session 也会提供一个。</p>
<p>下面的代码展示了如何通过文件进行数据上传：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSURL *textFileURL = [NSURL fileURLWithPath:@&quot;/path/to/file.txt&quot;];</span><br><span class="line"> </span><br><span class="line">NSURL *url = [NSURL URLWithString:@&quot;https://www.example.com/&quot;];</span><br><span class="line">NSMutableURLRequest *mutableRequest = [NSMutableURLRequest requestWithURL:url];</span><br><span class="line">mutableRequest.HTTPMethod = @&quot;POST&quot;;</span><br><span class="line"> </span><br><span class="line">NSURLSessionUploadTask *uploadTask = [defaultSession uploadTaskWithRequest:mutableRequest fromFile:textFileURL];</span><br><span class="line">[uploadTask resume];</span><br></pre></td></tr></table></figure>
<h4 id="使用流上传数据"><a href="#使用流上传数据" class="headerlink" title="使用流上传数据"></a>使用流上传数据</h4><p>使用流上传数据，必须通过调用 <code>uploadTaskWithStreamedRequest:</code> 方法来创建一个上传任务，App 必须为这个方法提供一个上传数据对象的关联流。App 同时必须提供一些服务器需要的 Header 字段，比如 <code>Content-Type</code> 和 <code>Content-Length</code>。</p>
<p>另外，session 如果遇到必须重新尝试一个请求的情况，比如如果身份验证失败，就必须重新读取流，但是流不一定能够倒回去重新读取，这个时候 App 就必须负责重新提供一个新的流。因此，App 需要实现 <code>URLSession:task:needNewBodyStream:</code> 方法，当这个方法被调用的时候，App 应该尽量提供一个新的流，然后以 新的流为参数调用 completion handler block。</p>
<blockquote>
<p>这种技术不能和系统提供的 delegate 兼容。</p>
</blockquote>
<p>下面的代码展示了如何通过流进行数据上传：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NSURL *textFileURL = [NSURL fileURLWithPath:@&quot;/path/to/file.txt&quot;];</span><br><span class="line"> </span><br><span class="line">NSURL *url = [NSURL URLWithString:@&quot;https://www.example.com/&quot;];</span><br><span class="line">NSMutableURLRequest *mutableRequest = [NSMutableURLRequest requestWithURL:url];</span><br><span class="line">mutableRequest.HTTPMethod = @&quot;POST&quot;;</span><br><span class="line">mutableRequest.HTTPBodyStream = [NSInputStream inputStreamWithFileAtPath:textFileURL.path];</span><br><span class="line">[mutableRequest setValue:@&quot;text/plain&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];</span><br><span class="line">[mutableRequest setValue:[NSString stringWithFormat:@&quot;%lld&quot;, data.length] forHTTPHeaderField:@&quot;Content-Type&quot;];</span><br><span class="line"> </span><br><span class="line">NSURLSessionUploadTask *uploadTask = [defaultSession uploadTaskWithStreamedRequest:mutableRequest];</span><br><span class="line">[uploadTask resume];</span><br></pre></td></tr></table></figure>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>URL 加载系统为请求和响应提供了磁盘缓存和内存缓存，这个设计让应用介绍了对网络的依赖，提高了性能。</p>
<h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><p>NSURLRequest 通过设置缓存策略来指定如何使用本地缓存，缓存策略的值是由枚举 <code>NSURLRequestCachePolicy</code> 指定的，包括：<code>NSURLRequestUseProtocolCachePolicy</code>, <code>NSURLRequestReloadIgnoringCacheData</code>, <code>NSURLRequestReturnCacheDataElseLoad</code>, 和 <code>NSURLRequestReturnCacheDataDontLoad</code>。<code>NSURLRequestUseProtocolCachePolicy</code> 是默认的缓存策略，它是根据协议规范实现的； <code>NSURLRequestReloadIgnoringCacheData</code> 表示完全忽略本地缓存；<code>NSURLRequestReturnCacheDataElseLoad</code> 表示只要有缓存，不论是否过期直接使用，没有缓存才从远端加载；<code>NSURLRequestReturnCacheDataDontLoad</code> 表示只从缓存加载数据，也就是离线模式。</p>
<blockquote>
<p>Http 的标准缓存机制可见：<a href="[http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13](http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13">RFC 2616, Section 13</a>)。</p>
</blockquote>
<h3 id="缓存控制"><a href="#缓存控制" class="headerlink" title="缓存控制"></a>缓存控制</h3><p>一般来说，请求会基于缓存策略进行缓存。如果开发者需要更加精细的控制，可以通过实现 delegate 方法来决定每个请求的响应如何进行缓存。对于 NSURLSession 的数据任务和上传任务，需要实现 <code>URLSession:dataTask:willCacheResponse:completionHandler:</code> 方法，这个方法只有在执行数据任务和上传任务的时候才会被调用。下载任务的缓存只能由设置的缓存策略控制。</p>
<p>delegate 方法通过调用 completion handler 来告知 session 应该如何做缓存，通常有以下三种情况：</p>
<ul>
<li>直接返回提供的响应；</li>
<li>修改提供的响应并返回一个新的响应；</li>
<li>返回 nil 拒绝缓存；</li>
</ul>
<p>delegate 方法也可以向 NSCacheURLResponse 对象的 <code>userInfo</code> 字典中插入对象，这些对象也会随着响应一起被缓存。</p>
<p>以下的例子就是拒绝在磁盘上缓存 HTTPS 响应，并且在 userInfo 字典中添加了当前日期：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line"> willCacheResponse:(NSCachedURLResponse *)proposedResponse</span><br><span class="line"> completionHandler:(void (^)(NSCachedURLResponse * __nullable cachedResponse))completionHandler &#123;</span><br><span class="line">    NSCachedURLResponse *newCachedResponse = proposedResponse;</span><br><span class="line">    NSDictionary *newUserInfo;</span><br><span class="line">    newUserInfo = [NSDictionary dictionaryWithObject:[NSDate date]</span><br><span class="line">                                              forKey:@&quot;Cached Date&quot;];</span><br><span class="line">    if ([proposedResponse.response.URL.scheme isEqualToString:@&quot;https&quot;]) &#123;</span><br><span class="line">#if ALLOW_IN_MEMORY_CACHING</span><br><span class="line">        newCachedResponse = [[NSCachedURLResponse alloc]</span><br><span class="line">                             initWithResponse:proposedResponse.response</span><br><span class="line">                             data:proposedResponse.data</span><br><span class="line">                             userInfo:newUserInfo</span><br><span class="line">                             storagePolicy:NSURLCacheStorageAllowedInMemoryOnly];</span><br><span class="line">#else // !ALLOW_IN_MEMORY_CACHING</span><br><span class="line">        newCachedResponse = nil;</span><br><span class="line">#endif // ALLOW_IN_MEMORY_CACHING</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        newCachedResponse = [[NSCachedURLResponse alloc]</span><br><span class="line">                             initWithResponse:[proposedResponse response]</span><br><span class="line">                             data:[proposedResponse data]</span><br><span class="line">                             userInfo:newUserInfo</span><br><span class="line">                             storagePolicy:[proposedResponse storagePolicy]];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    completionHandler(newCachedResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Cookie-存储"><a href="#Cookie-存储" class="headerlink" title="Cookie 存储"></a>Cookie 存储</h2><p>由于 Http 协议无状态的天然特性，客户端通常使用 cookie 来维护状态。URL 加载系统为创建和管理 cookie 提供了接口，并将 cookie 作为请求的一部分发送，会在服务器响应返回的时候接收 cookie。</p>
<p>NSHTTPCookie 类封装了一个 cookie 并对很多的常见 cookie 属性提供了读写方法。NSHTTPCookieStorage 类则提供了所有 App 共享的 NSHTTPCookie 对象的接口。</p>
<blockquote>
<p>注意：iOS 上的应用之间不共享 Cookie。</p>
</blockquote>
<p>NSHTTPCookieStorage 允许 App 指定 Cookie 设置策略，可以设置 Cookie 永久可设置，永久不可设置或者只有来自相同域名的请求才可以设置。</p>
<h2 id="处理身份认证和-TLS-链认证"><a href="#处理身份认证和-TLS-链认证" class="headerlink" title="处理身份认证和 TLS 链认证"></a>处理身份认证和 TLS 链认证</h2><p>如果远程服务返回的状态码要求进行身份认证，又或者认证需要在连接建立的时候进行（比如需要一个 SSL 客户端证书），NSURLSession 会调用一个 delegate 方法：</p>
<p>// TODO</p>
<h2 id="协议支持"><a href="#协议支持" class="headerlink" title="协议支持"></a>协议支持</h2><p>URL 加载系统允许应用扩展协议来支持数据传输。开发者可以继承 NSURLProtocol 协议实现自己的协议类，通过 NSURLProtocol 的类方法 <code>registerClass:</code> 进行注册，当 NSURLSession 对象为一个 NSURLRequest 初始化链接的时候，URL 加载系统会通过 NSURLProtocol 类来倒叙遍历所有的注册协议类，第一个在方法 <code>canInitWithRequest:</code> 中返回 <code>YES</code> 的协议类被用于处请求。</p>
<p>如果你自定义的协议需要在请求或者响应中添加新的属性，可以通过 Caterogry 在 NSURLRequest、NSMutableURLRequest 和 NSURLResponse 类中为这些属性提供读写方法。</p>
<p>URL 加载系统负责在连接建立的时候创建 NSURLProtocol 实例，在请求完成之后释放实例，因此开发者永远不应该自己去创建 NSURLProtocol 的实例。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="处理重定向和其他请求变化"><a href="#处理重定向和其他请求变化" class="headerlink" title="处理重定向和其他请求变化"></a>处理重定向和其他请求变化</h3><p>重定向发生在服务端告诉客户端需要对一个新的  URL 发起请求才能获取资源的时候， NSURLSession 遇到这种情况会通过 delegate 告知 App。为了处理这种情况，delegate 必须实现 <code>URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:</code> 方法，在这个方法里面可以获取到引起重定向的 response，并通过 comletionHandler 返回一个新的请求。delegate 可以做以下事情：</p>
<ul>
<li>简单的返回获取的 request 以允许重定向；</li>
<li>创建一个新的 request 指向一个不同的 URL，并返回 request；</li>
<li>通过返回 nil，拒绝重定向；</li>
</ul>
<p>另外，delegate 可以同时取消重定向和连接，只需要调用 task 对象的 <code>cancel</code> 方法即可。</p>
<p>如果处理请求的 NSURLProtocol 的子类为了标准化请求的格式，更改了 NSRequest 的内容，比如把请求 URL 的地址从 <a href="http://www.apple.com" target="_blank" rel="noopener">http://www.apple.com</a> 改为 <a href="http://www.apple.com/" target="_blank" rel="noopener">http://www.apple.com/</a> ，delegate 也会收到 <code>URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:</code>  消息，在这种特殊的情况下，response 参数会为 nil，delegate 应该直接返回收到的 request 对象。</p>
<p>下面的代码展现了<code>URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:</code> 的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">        task:(NSURLSessionTask *)task</span><br><span class="line">        willPerformHTTPRedirection:(NSHTTPURLResponse *)redirectResponse</span><br><span class="line">        newRequest:(NSURLRequest *)request</span><br><span class="line">        completionHandler:(void (^)(NSURLRequest *))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    NSURLRequest *newRequest = request;</span><br><span class="line">    if (redirectResponse) &#123;</span><br><span class="line">        newRequest = nil;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    completionHandler(newRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码允许请求上因为标准化而发生的任何变化，拒绝了所有服务端的重定向要求。</p>
<h3 id="处理-iOS-后台活动"><a href="#处理-iOS-后台活动" class="headerlink" title="处理 iOS 后台活动"></a>处理 iOS 后台活动</h3><p>如果你使用 NSURLSession，你的 App 会在下载任务完成后自动重新启动，App 的<code>application:handleEventsForBackgroundURLSession:completionHandler:</code> delegate 方法负责重新创建合适的 session，提供 completion handler，并在 session 调用 delegate 的 <code>URLSessionDidFinishEventsForBackgroundURLSession:</code> 方法的时候调用这个 handler。</p>
<p>下面的代码展示了如何在后台创建下载任务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SURL *url = [NSURL URLWithString:@&quot;https://www.example.com/&quot;];</span><br><span class="line"> </span><br><span class="line">NSURLSessionDownloadTask *backgroundDownloadTask = [backgroundSession downloadTaskWithURL:url];</span><br><span class="line">[backgroundDownloadTask resume];</span><br></pre></td></tr></table></figure>
<p>下面的代码展示了 session 的代理方法实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session &#123;</span><br><span class="line">    AppDelegate *appDelegate = (AppDelegate *)[[[UIApplication sharedApplication] delegate];</span><br><span class="line">    if (appDelegate.backgroundSessionCompletionHandler) &#123;</span><br><span class="line">        CompletionHandler completionHandler = appDelegate.backgroundSessionCompletionHandler;</span><br><span class="line">        appDelegate.backgroundSessionCompletionHandler = nil;</span><br><span class="line">        completionHandler();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    NSLog(@&quot;All tasks are finished&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的代码展示了 AppDelegate 的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@interface AppDelegate : UIResponder &lt;UIApplicationDelegate&gt;</span><br><span class="line">@property (strong, nonatomic) UIWindow *window;</span><br><span class="line">@property (copy) CompletionHandler backgroundSessionCompletionHandler;</span><br><span class="line"> </span><br><span class="line">@end</span><br><span class="line"> </span><br><span class="line">@implementation AppDelegate</span><br><span class="line"> </span><br><span class="line">- (void)application:(UIApplication *)application</span><br><span class="line">handleEventsForBackgroundURLSession:(NSString *)identifier</span><br><span class="line">  completionHandler:(void (^)())completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    self.backgroundSessionCompletionHandler = completionHandler;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>【参考资料】</p>
<p>1）<a href="https://objccn.io/issue-5-4/" target="_blank" rel="noopener">从 NSURLConnection 到 NSURLSession</a></p>
<p>2）<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html#//apple_ref/doc/uid/10000165i" target="_blank" rel="noopener">URL Session Programming Guide</a></p>
</div><div class="tags"><a href="/tags/网络/">网络</a></div><div class="post-nav"><a href="/2017/02/15/iOS-网络学习（一）/" class="pre">iOS 网络学习（一）—— URLConnection</a><a href="/2017/02/10/SDWebImage-源码解析/" class="next">SDWebImage 源码解析</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">59</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactiveX/">ReactiveX</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/后端/">后端</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/影视/">影视</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/电影/">电影</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Gitbook/" style="font-size: 15px;">Gitbook</a> <a href="/tags/Runtime/" style="font-size: 15px;">Runtime</a> <a href="/tags/视图/" style="font-size: 15px;">视图</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/权限/" style="font-size: 15px;">权限</a> <a href="/tags/代码优化/" style="font-size: 15px;">代码优化</a> <a href="/tags/Framework/" style="font-size: 15px;">Framework</a> <a href="/tags/性能优化/" style="font-size: 15px;">性能优化</a> <a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/合集/" style="font-size: 15px;">合集</a> <a href="/tags/ADB/" style="font-size: 15px;">ADB</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/反编译/" style="font-size: 15px;">反编译</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/Gradle/" style="font-size: 15px;">Gradle</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/基础/" style="font-size: 15px;">基础</a> <a href="/tags/效率/" style="font-size: 15px;">效率</a> <a href="/tags/MarkDown/" style="font-size: 15px;">MarkDown</a> <a href="/tags/电影/" style="font-size: 15px;">电影</a> <a href="/tags/Reactive/" style="font-size: 15px;">Reactive</a> <a href="/tags/AIDL/" style="font-size: 15px;">AIDL</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/驱动/" style="font-size: 15px;">驱动</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/日志/" style="font-size: 15px;">日志</a> <a href="/tags/事件/" style="font-size: 15px;">事件</a> <a href="/tags/代码设计/" style="font-size: 15px;">代码设计</a> <a href="/tags/网络/" style="font-size: 15px;">网络</a> <a href="/tags/测试/" style="font-size: 15px;">测试</a> <a href="/tags/Binder/" style="font-size: 15px;">Binder</a> <a href="/tags/Groovy/" style="font-size: 15px;">Groovy</a> <a href="/tags/Loader/" style="font-size: 15px;">Loader</a> <a href="/tags/RAC/" style="font-size: 15px;">RAC</a> <a href="/tags/事件处理/" style="font-size: 15px;">事件处理</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/10/30/AIDL-原理分析/">AIDL 原理分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/30/App-启动过程/">App 启动过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/PMS-解析/">PMS 解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/WMS-解析/">WindowManagerService 解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/AMS-解析/">AMS 解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/10/The-Good-Wife/">The-Good-Wife</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/10/Black-Sails/">黑帆</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/29/hello-world/">Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/23/XCode-8-2-1-ClangFormat-插件安装/">XCode 8.2.1 ClangFormat 插件安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/07/SourceTree-分支图谱/">SourceTree 分支图谱</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">蜗牛壳.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>