<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="李全民的个人博客"><title>SDWebImage 源码解析 | 蜗牛壳</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-65882749-1','auto');ga('send','pageview');</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">SDWebImage 源码解析</h1><a id="logo" href="/.">蜗牛壳</a><p class="description">计算机只有 0 和 1 ，但世界是连续的</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">SDWebImage 源码解析</h1><div class="post-meta">Feb 10, 2017<span> | </span><span class="category"><a href="/categories/iOS/">iOS</a></span></div><div class="post-content"><blockquote>
<p>分析版本：3.7.4</p>
</blockquote>
<p><a href="https://github.com/rs/SDWebImage" target="_blank" rel="noopener">SDWebImage</a> 是 iOS 上使用范围最广的网络图片加载库，在 Github 上有高达近 17K 的 Star 数量。它提供的功能主要如下：</p>
<ol>
<li>加载普通图片，包括 png、jpeg、gif、WebP等，支持的组件有 UIImageView、UIButton 和 MKAnnotationView；</li>
<li>为 UIImageVew 加载多帧图片；</li>
<li>预加载图片；</li>
</ol>
<p>使用示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[imageView sd_setImageWithURL:[NSURL URLWithString:@&quot;http://www.domain.com/path/to/image.jpg&quot;]</span><br><span class="line">             placeholderImage:[UIImage imageNamed:@&quot;placeholder.png&quot;]];</span><br></pre></td></tr></table></figure>
<p>简单的情况下只需要告诉它图片的 URL 以及占位图片就可以轻松完成网络图片的加载。知其然更要知其所以然，下面从源码角度分析一下 SDWebImage 是如何完成图片加载的。</p>
<a id="more"></a>
<h2 id="加载流程"><a href="#加载流程" class="headerlink" title="加载流程"></a>加载流程</h2><p>在详细看代码之前，先来看看图片加载的流程（来自项目的 Wiki）：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/SDWebImageSequenceDiagram.png" alt="SDWebImage 图片加载流程图"></div>

<p>文字描述如下：</p>
<ol>
<li>发起图片加载请求；</li>
<li>尝试从缓存中读取图片；</li>
<li>缓存读取成功则返回图片，读取失败则从网络下载；</li>
<li>下载成功后添加到缓存并返回图片；</li>
</ol>
<p>图片加载的流程并不复杂，大部分图片加载库的流程都大同小异，只不过每个库在实现的时候在策略控制以及细节实现上有所差别。在理解大致流程的基础上，下面分析每一步的实现。</p>
<h2 id="任务创建与调度"><a href="#任务创建与调度" class="headerlink" title="任务创建与调度"></a>任务创建与调度</h2><h3 id="任务创建"><a href="#任务创建" class="headerlink" title="任务创建"></a>任务创建</h3><p>我们从上面的示例代码切入，即方法<code>- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder;</code>。这个方法来自于<code>UIImageView+WebCache.h</code>，有很多的重载方法，最终调用到的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionBlock)completedBlock &#123;</span><br><span class="line">    // 1. 取消任务</span><br><span class="line">    [self sd_cancelCurrentImageLoad];</span><br><span class="line">    // 2. 记录要加载的 URL</span><br><span class="line">    objc_setAssociatedObject(self, &amp;imageURLKey, url, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line"></span><br><span class="line">    // 3. 设置占位图</span><br><span class="line">    if (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">            self.image = placeholder;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 4. 如果 URL 存在，则加载图片，否则报错，直接回调</span><br><span class="line">    if (url) &#123;</span><br><span class="line">        // 5. 显示加载菊花</span><br><span class="line">        // check if activityView is enabled or not</span><br><span class="line">        if ([self showActivityIndicatorView]) &#123;</span><br><span class="line">            [self addActivityIndicator];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 6. 创建加载任务</span><br><span class="line">        __weak __typeof(self)wself = self;</span><br><span class="line">        id &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager downloadImageWithURL:url options:options progress:progressBlock completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123;</span><br><span class="line">            [wself removeActivityIndicator];</span><br><span class="line">            if (!wself) return;</span><br><span class="line">            dispatch_main_sync_safe(^&#123;// 调度到主线程</span><br><span class="line">                if (!wself) return;</span><br><span class="line">                // 如果加载选项设置为不自动设置图片，并且有回调 Block，则调用回调 Block</span><br><span class="line">                if (image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage) &amp;&amp; completedBlock)</span><br><span class="line">                &#123;</span><br><span class="line">                    completedBlock(image, error, cacheType, url);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (image) &#123;// 否则直接设置图片</span><br><span class="line">                    wself.image = image;</span><br><span class="line">                    [wself setNeedsLayout];</span><br><span class="line">                &#125; else &#123;// 如果加载失败，在此处设置为占位符（关于 SDWebImageDelayPlaceholder 可以查看该枚举的说明）</span><br><span class="line">                    if ((options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">                        wself.image = placeholder;</span><br><span class="line">                        [wself setNeedsLayout];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // 回调</span><br><span class="line">                if (completedBlock &amp;&amp; finished) &#123;</span><br><span class="line">                    completedBlock(image, error, cacheType, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;];</span><br><span class="line">        // 7. 将该任务记录为 &quot;UIImageViewImageLoad&quot; 对应的任务。一个组件有两种任务，另外一种是 &quot;UIImageViewAnimationImages&quot;</span><br><span class="line">        // 加载的是 Gif 动态图，每种类型的任务同时只能存在一个，该方法调用是会默认检测并取消旧有的任务</span><br><span class="line">        [self sd_setImageLoadOperation:operation forKey:@&quot;UIImageViewImageLoad&quot;];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // URL 非法，直接报错回调</span><br><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">            [self removeActivityIndicator];</span><br><span class="line">            NSError *error = [NSError errorWithDomain:SDWebImageErrorDomain code:-1 userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Trying to load a nil url&quot;&#125;];</span><br><span class="line">            if (completedBlock) &#123;</span><br><span class="line">                completedBlock(nil, error, SDImageCacheTypeNone, url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的主要作用是准备加载环境，创建加载任务。相关注释都已经标记在代码上，下面说一些细节。</p>
<p>首先是<code>dispatch_main_async_safe</code>和<code>dispatch_main_sync_safe</code>两个宏，它们的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#define dispatch_main_sync_safe(block)\</span><br><span class="line">    if ([NSThread isMainThread]) &#123;\</span><br><span class="line">        block();\</span><br><span class="line">    &#125; else &#123;\</span><br><span class="line">        dispatch_sync(dispatch_get_main_queue(), block);\</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#define dispatch_main_async_safe(block)\</span><br><span class="line">    if ([NSThread isMainThread]) &#123;\</span><br><span class="line">        block();\</span><br><span class="line">    &#125; else &#123;\</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), block);\</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这两个宏虽然简化了一些写法，但是定义很糟糕：</p>
<ol>
<li>所谓<code>safe</code>，并不能很明显的看出来，唯一加强安全的地方就是<code>dispatch_main_sync_safe</code>防止了在主线程上调用<code>dispatch_sync(dispatch_get_main_queue(), block)</code>产生死锁，而<code>async</code>完全看不出来；</li>
<li><code>dispatch_main_async_safe</code>如果执行在主线程上，实际是同步的，并不与名字所反映的一样，使用的时候务必要注意；</li>
</ol>
<p>其次是任务的取消。在方法的一开始即 1 处就调用了取消任务的方法，图片加载任务创建的最后，也就是 7 处将任务记录为一个变量，后期会通过这个变量操作任务。<code>sd_setImageLoadOperation</code>方法的调用链如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 来自 UIImageView+WebCache.h</span><br><span class="line">- (void)sd_cancelCurrentImageLoad &#123;</span><br><span class="line">    [self sd_cancelImageLoadOperationWithKey:@&quot;UIImageViewImageLoad&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 来自 UIView+WebCacheOperation.h</span><br><span class="line">- (void)sd_setImageLoadOperation:(id)operation forKey:(NSString *)key &#123;</span><br><span class="line">    [self sd_cancelImageLoadOperationWithKey:key];</span><br><span class="line">    NSMutableDictionary *operationDictionary = [self operationDictionary];</span><br><span class="line">    [operationDictionary setObject:operation forKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 来自 UIView+WebCacheOperation.h</span><br><span class="line">- (void)sd_cancelImageLoadOperationWithKey:(NSString *)key &#123;</span><br><span class="line">    // Cancel in progress downloader from queue</span><br><span class="line">    NSMutableDictionary *operationDictionary = [self operationDictionary];</span><br><span class="line">    id operations = [operationDictionary objectForKey:key];</span><br><span class="line">    if (operations) &#123;</span><br><span class="line">        if ([operations isKindOfClass:[NSArray class]]) &#123;</span><br><span class="line">            for (id &lt;SDWebImageOperation&gt; operation in operations) &#123;</span><br><span class="line">                if (operation) &#123;</span><br><span class="line">                    [operation cancel];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if ([operations conformsToProtocol:@protocol(SDWebImageOperation)])&#123;</span><br><span class="line">            [(id&lt;SDWebImageOperation&gt;) operations cancel];</span><br><span class="line">        &#125;</span><br><span class="line">        [operationDictionary removeObjectForKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 UIView 内部，通过 Category 创建了一个 Dictionary，用于记录当前在该 View 上正在执行的所有任务，在注释 7 处我说了这个 Dictionary 中记录的任务有两种 key：</p>
<ol>
<li><strong>“UIImageViewImageLoad”</strong>对应的是单个<code>SDWebImageOperation</code>，用于下载单张普通图片；</li>
<li><strong>“UIImageViewAnimationImages”</strong>对应的是<code>SDWebImageOperation</code>数组，用于下载一组图片展现帧动画。</li>
</ol>
<p><code>SDWebImageOperation</code>是一个接口，只有一个<code>cancel()</code>方法，取消任务调用它即可。</p>
<blockquote>
<p>要注意的是，在加载任务执行完成之后，并没有主动从字典中删除对应任务。</p>
</blockquote>
<p>最后有一个疑问没有得到解答：下载完成的回调 Block 中为什么要<code>dispatch_main_sync_safe</code>方法进行图片最后的显示处理？这里使用<code>dispatch_main_async_safe</code>明显可以更快地释放加载线程，而且实现效果一致。</p>
<h3 id="加载任务的执行"><a href="#加载任务的执行" class="headerlink" title="加载任务的执行"></a>加载任务的执行</h3><p>注释 6 处已经创建了加载任务，我们来仔细看看加载任务到底做了什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line">// 来自 SDWebImageManager.h</span><br><span class="line">- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url</span><br><span class="line">                                         options:(SDWebImageOptions)options</span><br><span class="line">                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                       completed:(SDWebImageCompletionWithFinishedBlock)completedBlock &#123;</span><br><span class="line">    // 1. 参数检测</span><br><span class="line">    // Invoking this method without a completedBlock is pointless</span><br><span class="line">    NSAssert(completedBlock != nil, @&quot;If you mean to prefetch the image, use -[SDWebImagePrefetcher prefetchURLs] instead&quot;);</span><br><span class="line"></span><br><span class="line">    // Very common mistake is to send the URL using NSString object instead of NSURL. For some strange reason, XCode won&apos;t</span><br><span class="line">    // throw any warning for this type mismatch. Here we failsafe this error by allowing URLs to be passed as NSString.</span><br><span class="line">    if ([url isKindOfClass:NSString.class]) &#123;</span><br><span class="line">        url = [NSURL URLWithString:(NSString *)url];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Prevents app crashing on argument type error like sending NSNull instead of NSURL</span><br><span class="line">    if (![url isKindOfClass:NSURL.class]) &#123;</span><br><span class="line">        url = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2. 创建真正的 Operation</span><br><span class="line">    __block SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new];</span><br><span class="line">    __weak SDWebImageCombinedOperation *weakOperation = operation;</span><br><span class="line"></span><br><span class="line">    // 3. 判断这个 URL 之前有没有加载失败过</span><br><span class="line">    BOOL isFailedUrl = NO;</span><br><span class="line">    @synchronized (self.failedURLs) &#123;</span><br><span class="line">        isFailedUrl = [self.failedURLs containsObject:url];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果 URL 为空，或者这个 URL 加载失败过但是开发者不要求重试失败的 URL，则直接回调</span><br><span class="line">    if (url.absoluteString.length == 0 || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) &#123;</span><br><span class="line">        dispatch_main_sync_safe(^&#123;</span><br><span class="line">            NSError *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil];</span><br><span class="line">            completedBlock(nil, error, SDImageCacheTypeNone, YES, url);</span><br><span class="line">        &#125;);</span><br><span class="line">        return operation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 4. 记录这个 Operation</span><br><span class="line">    @synchronized (self.runningOperations) &#123;</span><br><span class="line">        [self.runningOperations addObject:operation];</span><br><span class="line">    &#125;</span><br><span class="line">    NSString *key = [self cacheKeyForURL:url];</span><br><span class="line"></span><br><span class="line">    // 5. &amp;&amp;&amp; 为任务创建缓存任务，先从磁盘读取任务，根据读取的结果进行操作，根据后面的分析，这个 Block 的执行是在主线程进行的</span><br><span class="line">    operation.cacheOperation = [self.imageCache queryDiskCacheForKey:key done:^(UIImage *image, SDImageCacheType cacheType) &#123;</span><br><span class="line">        if (operation.isCancelled) &#123;</span><br><span class="line">            @synchronized (self.runningOperations) &#123;</span><br><span class="line">                [self.runningOperations removeObject:operation];</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 6. @@@ 如果图片没有从缓存获取到/开发者要求刷新缓存图片（换句话说，获取到的图片不能用，需要下载），并且代理反馈需要根据 URL 下载图片</span><br><span class="line">        if ((!image || options &amp; SDWebImageRefreshCached) &amp;&amp; (![self.delegate respondsToSelector:@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self shouldDownloadImageForURL:url])) &#123;</span><br><span class="line">            // 如果从缓存中获取了图片，但是开发者设置为必须刷新缓存</span><br><span class="line">            if (image &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</span><br><span class="line">                dispatch_main_sync_safe(^&#123;</span><br><span class="line">                    // If image was found in the cache but SDWebImageRefreshCached is provided, notify about the cached image</span><br><span class="line">                    // AND try to re-download it in order to let a chance to NSURLCache to refresh it from server.</span><br><span class="line">                    // 先回调再重新下载</span><br><span class="line">                    completedBlock(image, nil, cacheType, YES, url);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // download if no image or requested to refresh anyway, and download allowed by delegate</span><br><span class="line">            SDWebImageDownloaderOptions downloaderOptions = 0;</span><br><span class="line">            if (options &amp; SDWebImageLowPriority) downloaderOptions |= SDWebImageDownloaderLowPriority;</span><br><span class="line">            if (options &amp; SDWebImageProgressiveDownload) downloaderOptions |= SDWebImageDownloaderProgressiveDownload;</span><br><span class="line">            if (options &amp; SDWebImageRefreshCached) downloaderOptions |= SDWebImageDownloaderUseNSURLCache;</span><br><span class="line">            if (options &amp; SDWebImageContinueInBackground) downloaderOptions |= SDWebImageDownloaderContinueInBackground;</span><br><span class="line">            if (options &amp; SDWebImageHandleCookies) downloaderOptions |= SDWebImageDownloaderHandleCookies;</span><br><span class="line">            if (options &amp; SDWebImageAllowInvalidSSLCertificates) downloaderOptions |= SDWebImageDownloaderAllowInvalidSSLCertificates;</span><br><span class="line">            if (options &amp; SDWebImageHighPriority) downloaderOptions |= SDWebImageDownloaderHighPriority;</span><br><span class="line">            // 如果是设置为刷新缓存并且获取到了图片，则取消渐进式加载，并添加忽略缓存响应选项</span><br><span class="line">            if (image &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</span><br><span class="line">                // force progressive off if image already cached but forced refreshing</span><br><span class="line">                downloaderOptions &amp;= ~SDWebImageDownloaderProgressiveDownload;</span><br><span class="line">                // ignore image read from NSURLCache if image if cached but force refreshing</span><br><span class="line">                downloaderOptions |= SDWebImageDownloaderIgnoreCachedResponse;</span><br><span class="line">            &#125;</span><br><span class="line">            // 7. 创建下载任务</span><br><span class="line">            id &lt;SDWebImageOperation&gt; subOperation = [self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage *downloadedImage, NSData *data, NSError *error, BOOL finished) &#123;</span><br><span class="line">                __strong __typeof(weakOperation) strongOperation = weakOperation;</span><br><span class="line">                if (!strongOperation || strongOperation.isCancelled) &#123; // 如果任务取消</span><br><span class="line">                    // Do nothing if the operation was cancelled</span><br><span class="line">                    // See #699 for more details</span><br><span class="line">                    // if we would call the completedBlock, there could be a race condition between this block and another completedBlock for the same object, so if this one is called second, we will overwrite the new data</span><br><span class="line">                &#125;</span><br><span class="line">                else if (error) &#123; // 如果下载失败</span><br><span class="line">                    dispatch_main_sync_safe(^&#123; </span><br><span class="line">                        if (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</span><br><span class="line">                            completedBlock(nil, error, SDImageCacheTypeNone, finished, url);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    // 如果不是因为以下原因下载失败，则记录为失败的 URL</span><br><span class="line">                    if (   error.code != NSURLErrorNotConnectedToInternet</span><br><span class="line">                        &amp;&amp; error.code != NSURLErrorCancelled</span><br><span class="line">                        &amp;&amp; error.code != NSURLErrorTimedOut</span><br><span class="line">                        &amp;&amp; error.code != NSURLErrorInternationalRoamingOff</span><br><span class="line">                        &amp;&amp; error.code != NSURLErrorDataNotAllowed</span><br><span class="line">                        &amp;&amp; error.code != NSURLErrorCannotFindHost</span><br><span class="line">                        &amp;&amp; error.code != NSURLErrorCannotConnectToHost) &#123;</span><br><span class="line">                        @synchronized (self.failedURLs) &#123;</span><br><span class="line">                            [self.failedURLs addObject:url];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123; // 如果下载成功</span><br><span class="line">                    if ((options &amp; SDWebImageRetryFailed)) &#123;</span><br><span class="line">                        @synchronized (self.failedURLs) &#123;</span><br><span class="line">                            [self.failedURLs removeObject:url];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    // 判断是否要缓存到磁盘上</span><br><span class="line">                    BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);</span><br><span class="line"></span><br><span class="line">                    // 如果要求刷新缓存但是下载图片不存在</span><br><span class="line">                    if (options &amp; SDWebImageRefreshCached &amp;&amp; image &amp;&amp; !downloadedImage) &#123;</span><br><span class="line">                        // Image refresh hit the NSURLCache cache, do not call the completion block</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 如果下载的是多图，进行转换</span><br><span class="line">                    else if (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)]) &#123;</span><br><span class="line">                        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">                            UIImage *transformedImage = [self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url];</span><br><span class="line"></span><br><span class="line">                            if (transformedImage &amp;&amp; finished) &#123;</span><br><span class="line">                                BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage];</span><br><span class="line">                                // 存储图片</span><br><span class="line">                                [self.imageCache storeImage:transformedImage recalculateFromImage:imageWasTransformed imageData:(imageWasTransformed ? nil : data) forKey:key toDisk:cacheOnDisk];</span><br><span class="line">                            &#125;</span><br><span class="line">                            // 回调</span><br><span class="line">                            dispatch_main_sync_safe(^&#123;</span><br><span class="line">                                if (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</span><br><span class="line">                                    completedBlock(transformedImage, nil, SDImageCacheTypeNone, finished, url);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    else &#123; // 如果下载的是普通图片</span><br><span class="line">                        if (downloadedImage &amp;&amp; finished) &#123;</span><br><span class="line">                            // 存储图片</span><br><span class="line">                            [self.imageCache storeImage:downloadedImage recalculateFromImage:NO imageData:data forKey:key toDisk:cacheOnDisk];</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        // 回调</span><br><span class="line">                        dispatch_main_sync_safe(^&#123;</span><br><span class="line">                            if (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</span><br><span class="line">                                completedBlock(downloadedImage, nil, SDImageCacheTypeNone, finished, url);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (finished) &#123;</span><br><span class="line">                    @synchronized (self.runningOperations) &#123;</span><br><span class="line">                        if (strongOperation) &#123;</span><br><span class="line">                            [self.runningOperations removeObject:strongOperation];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">            </span><br><span class="line">            // 取消回调</span><br><span class="line">            operation.cancelBlock = ^&#123;</span><br><span class="line">                [subOperation cancel];</span><br><span class="line">                </span><br><span class="line">                @synchronized (self.runningOperations) &#123;</span><br><span class="line">                    __strong __typeof(weakOperation) strongOperation = weakOperation;</span><br><span class="line">                    if (strongOperation) &#123;</span><br><span class="line">                        [self.runningOperations removeObject:strongOperation];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (image) &#123; // 获取缓存成功</span><br><span class="line">            dispatch_main_sync_safe(^&#123;</span><br><span class="line">                __strong __typeof(weakOperation) strongOperation = weakOperation;</span><br><span class="line">                if (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</span><br><span class="line">                    completedBlock(image, nil, cacheType, YES, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            @synchronized (self.runningOperations) &#123;</span><br><span class="line">                [self.runningOperations removeObject:operation];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123; // 开发者想 “只从缓存获取图片” 失败</span><br><span class="line">            // Image not in cache and download disallowed by delegate</span><br><span class="line">            dispatch_main_sync_safe(^&#123;</span><br><span class="line">                __strong __typeof(weakOperation) strongOperation = weakOperation;</span><br><span class="line">                if (strongOperation &amp;&amp; !weakOperation.isCancelled) &#123;</span><br><span class="line">                    completedBlock(nil, nil, SDImageCacheTypeNone, YES, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            @synchronized (self.runningOperations) &#123;</span><br><span class="line">                [self.runningOperations removeObject:operation];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相关流程关键点都标记在代码中，这边有些地方不能解释的很清楚，比如下载任务回调 Block 中的 finished 参数（7 处）到底指什么？这个参数是从最终的下载任务中传递出来的，后面再解释。要注意的是这个方法包含着图片加载的核心流程：<strong>先尝试从缓存获取（5 处），根据获取结果再决定是否要从网络获取（6 处）。</strong>根据缓存获取结果以及开发者设置的选项，分为三种情况：</p>
<ol>
<li>如果从缓存获取图片失败，或者开发者要求刷新缓存图片，并且根据设置的 delegate 开发者要求重新下载图片（没有设置 delegate 则默认下载），则重新从网络加载图片；</li>
<li>如果从缓存获取图片成功，则直接回调 Block，回传图片；</li>
<li>如果从缓存获取失败，并且根据设置的代理，开发者禁止从网络下载，则直接调用回调 Block；</li>
</ol>
<p>接下来就来详细看看缓存获取和下载流程。</p>
<h4 id="缓存获取"><a href="#缓存获取" class="headerlink" title="缓存获取"></a>缓存获取</h4><p>从缓存获取图片是通过下面方法进行的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// 来自 SDImageCache.h</span><br><span class="line">- (NSOperation *)queryDiskCacheForKey:(NSString *)key done:(SDWebImageQueryCompletedBlock)doneBlock &#123;</span><br><span class="line">    //1. 参数检测</span><br><span class="line">    if (!doneBlock) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!key) &#123;</span><br><span class="line">        doneBlock(nil, SDImageCacheTypeNone);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 2. 首先从内存换取读取</span><br><span class="line">    // First check the in-memory cache...</span><br><span class="line">    UIImage *image = [self imageFromMemoryCacheForKey:key];</span><br><span class="line">    if (image) &#123;</span><br><span class="line">        doneBlock(image, SDImageCacheTypeMemory);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3. 调度到 IO 线程，从磁盘读取</span><br><span class="line">    NSOperation *operation = [NSOperation new];</span><br><span class="line">    dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">        if (operation.isCancelled) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @autoreleasepool &#123;</span><br><span class="line">            UIImage *diskImage = [self diskImageForKey:key];</span><br><span class="line">            if (diskImage &amp;&amp; self.shouldCacheImagesInMemory) &#123;</span><br><span class="line">                NSUInteger cost = SDCacheCostForImage(diskImage);</span><br><span class="line">                [self.memCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                doneBlock(diskImage, SDImageCacheTypeDisk);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SDImageCache 专门负责进行图片缓存，并依赖 AutoPurgeCache 进行内存缓存，它是<strong>单例</strong>的。这里的策略是：</p>
<ol>
<li>首先从内存缓存中读取，读取到则回调返回；</li>
<li>读取不到调度到异步线程从磁盘读取，读取到了则尝试添加到内存缓存；</li>
<li>调度到主线程执行回调 block；</li>
</ol>
<p>AutoPurgeCache 继承于 NSCache，添加了内存回收相关功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@interface AutoPurgeCache : NSCache</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation AutoPurgeCache</span><br><span class="line"></span><br><span class="line">- (id)init</span><br><span class="line">&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(removeAllObjects) name:UIApplicationDidReceiveMemoryWarningNotification object:nil];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    [[NSNotificationCenter defaultCenter] removeObserver:self name:UIApplicationDidReceiveMemoryWarningNotification object:nil];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以在收到 App 内存警告以及被销毁的时候自动释放所有内存缓存的图片。NSCache 本身提供通过数据数量以及数据体积来限制缓存的功能，这部分功能也通过接口暴露给了外部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)setMaxMemoryCost:(NSUInteger)maxMemoryCost &#123;</span><br><span class="line">    self.memCache.totalCostLimit = maxMemoryCost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setMaxMemoryCountLimit:(NSUInteger)maxCountLimit &#123;</span><br><span class="line">    self.memCache.countLimit = maxCountLimit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说我们可以在外部根据 App 实际情况设置内存缓存大小。磁盘缓存的控制清理需要手动调用如下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)cleanDisk &#123;</span><br><span class="line">    [self cleanDiskWithCompletionBlock:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)cleanDiskWithCompletionBlock:(SDWebImageNoParamsBlock)completionBlock &#123;</span><br><span class="line">	// 实际清理操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据代码，实际的清理操作流程与时间和缓存文件大小相关，策略如下：</p>
<ol>
<li>遍历缓存文件夹，先删除过期的文件，期限时长默认设置为一周，即默认删除一周前的文件，时长可设置；</li>
<li>遍历过程中会顺便计算经过 步骤 1 清理之后总的缓存文件大小；</li>
<li>如果开发者设置了缓存文件大小上限，检测剩余缓存文件是否超限，上限值默认为 0，表示未设限制；</li>
<li>如果超限，总体积为 M，则将理想尺寸设置为 M/2，将剩余文件根据修改时间排序，从最旧的文件开始删除，直到体积小于 M/2；</li>
</ol>
<p>相似的还有一个 clear 操作，它会清除所有缓存。</p>
<p>以上就是 SDWebImage 实现的两级缓存，既保证了图片的加载速度，又保证了不会占用太多的设备资源。</p>
<p>回到缓存获取返回处，即前面注释的代码 5 处（读者可以直接搜 “&amp;&amp;&amp;” 跳转）。从缓存返回之后，有两种情况：1）返回的图片对象可用；2）返回的图片对象不可用。不可用的情况同样分为两种：1）缓存未命中，没有获取到缓存图片；2）开发者要求刷新缓存，从缓存中获取的图片必须经过服务端验证。不可用的情况必须向服务端发送请求，这就是注释 7 处（用户可以直接搜 “@@@” 跳转）的目的。</p>
<h4 id="图片下载"><a href="#图片下载" class="headerlink" title="图片下载"></a>图片下载</h4><p>如果从缓存获取的图片不可用，那么就需要从网络进行下载，它调用的是<code>SDWebImageDownloader</code>的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url options:(SDWebImageDownloaderOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageDownloaderCompletedBlock)completedBlock &#123;</span><br><span class="line">    // SDWebImageDownloaderOperation 真正的任务下载类，继承自 NSOperation</span><br><span class="line">    __block SDWebImageDownloaderOperation *operation;</span><br><span class="line">    __weak __typeof(self)wself = self;</span><br><span class="line"></span><br><span class="line">    // 该方法将创建任务下载类实例 &amp; 执行请求</span><br><span class="line">    [self addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^&#123;</span><br><span class="line">        // 执行请求</span><br><span class="line">        ...</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法会调用以下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (void)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock forURL:(NSURL *)url createCallback:(SDWebImageNoParamsBlock)createCallback &#123;</span><br><span class="line">    // The URL will be used as the key to the callbacks dictionary so it cannot be nil. If it is nil immediately call the completed block with no image or data.</span><br><span class="line">    if (url == nil) &#123;</span><br><span class="line">        if (completedBlock != nil) &#123;</span><br><span class="line">            completedBlock(nil, nil, nil, NO);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">	// 经典用法</span><br><span class="line">    dispatch_barrier_sync(self.barrierQueue, ^&#123;</span><br><span class="line">        BOOL first = NO;</span><br><span class="line">        if (!self.URLCallbacks[url]) &#123;</span><br><span class="line">            self.URLCallbacks[url] = [NSMutableArray new];</span><br><span class="line">            first = YES;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Handle single download of simultaneous download request for the same URL</span><br><span class="line">        NSMutableArray *callbacksForURL = self.URLCallbacks[url];</span><br><span class="line">        NSMutableDictionary *callbacks = [NSMutableDictionary new];</span><br><span class="line">        if (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock copy];</span><br><span class="line">        if (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock copy];</span><br><span class="line">        [callbacksForURL addObject:callbacks];</span><br><span class="line">        self.URLCallbacks[url] = callbacksForURL;</span><br><span class="line"></span><br><span class="line">        if (first) &#123;</span><br><span class="line">            createCallback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码比较有趣，首先来了解一下设计场景，SDWebImage 考虑到一个 App 可能同时发起对一张图片的多个请求这种场景，因此当一个图片网络请求执行前，它会先去检测是否已经有一个同样的请求在执行了，如果有，则只是在对应的请求流程上添加回调，而不是直接发起请求。</p>
<p>在<code>SDWebImageDownloader</code>内部，维护着一个称为<code>URLCallbacks</code>的字典，这个字典的 key 就是请求的 URL，value 是一个数组，每一个数组又包含一个字典，这个字段存储着两个 Block，一个是下载进度回调 Block，一个是下载完成回调 Block，数组里面可能有多个元素，每一个元素代表着一组这样的回调。</p>
<p>如果以该 URL 为 key 的回调组不存在，则说明没有它的下载任务存在，这时候这个方法就会回调<code>createCallback</code> Block。这部分代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">// 该方法将创建任务下载类实例 &amp; 执行请求</span><br><span class="line">[self addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^&#123;</span><br><span class="line">    NSTimeInterval timeoutInterval = wself.downloadTimeout;</span><br><span class="line">    if (timeoutInterval == 0.0) &#123;</span><br><span class="line">        timeoutInterval = 15.0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 1. 创建请求 &amp; 设置参数</span><br><span class="line">    // In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise</span><br><span class="line">    NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url cachePolicy:(options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData) timeoutInterval:timeoutInterval];</span><br><span class="line">    request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);</span><br><span class="line">    request.HTTPShouldUsePipelining = YES;</span><br><span class="line">    if (wself.headersFilter) &#123;</span><br><span class="line">        request.allHTTPHeaderFields = wself.headersFilter(url, [wself.HTTPHeaders copy]);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        request.allHTTPHeaderFields = wself.HTTPHeaders;</span><br><span class="line">    &#125;</span><br><span class="line">    // 2. 初始化任务，添加 Block 回调监听</span><br><span class="line">    operation = [[wself.operationClass alloc] initWithRequest:request</span><br><span class="line">                                                      options:options</span><br><span class="line">                                                     progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123;</span><br><span class="line">                                                         SDWebImageDownloader *sself = wself;</span><br><span class="line">                                                         if (!sself) return;</span><br><span class="line">                                                         __block NSArray *callbacksForURL;</span><br><span class="line">                                                         // 回调所有的下载进度监听</span><br><span class="line">                                                         dispatch_sync(sself.barrierQueue, ^&#123;</span><br><span class="line">                                                             callbacksForURL = [sself.URLCallbacks[url] copy];</span><br><span class="line">                                                         &#125;);</span><br><span class="line">                                                         for (NSDictionary *callbacks in callbacksForURL) &#123;</span><br><span class="line">                                                             dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                                                                 SDWebImageDownloaderProgressBlock callback = callbacks[kProgressCallbackKey];</span><br><span class="line">                                                                 if (callback) callback(receivedSize, expectedSize);</span><br><span class="line">                                                             &#125;);</span><br><span class="line">                                                             &#125;</span><br><span class="line">                                                     &#125;</span><br><span class="line">                                                    completed:^(UIImage *image, NSData *data, NSError *error, BOOL finished) &#123;</span><br><span class="line">                                                        SDWebImageDownloader *sself = wself;</span><br><span class="line">                                                        if (!sself) return;</span><br><span class="line">                                                        __block NSArray *callbacksForURL;</span><br><span class="line">                                                        // 回调所有的下载完成监听</span><br><span class="line">                                                        dispatch_barrier_sync(sself.barrierQueue, ^&#123;</span><br><span class="line">                                                            callbacksForURL = [sself.URLCallbacks[url] copy];</span><br><span class="line">                                                            if (finished) &#123;</span><br><span class="line">                                                                [sself.URLCallbacks removeObjectForKey:url]; // 要移除回调监听</span><br><span class="line">                                                            &#125;</span><br><span class="line">                                                        &#125;);</span><br><span class="line">                                                        for (NSDictionary *callbacks in callbacksForURL) &#123;</span><br><span class="line">                                                            SDWebImageDownloaderCompletedBlock callback = callbacks[kCompletedCallbackKey];</span><br><span class="line">                                                            if (callback) callback(image, data, error, finished);</span><br><span class="line">                                                        &#125;</span><br><span class="line">                                                    &#125;</span><br><span class="line">                                                    cancelled:^&#123;</span><br><span class="line">                                                        // 被取消则移除所有的监听</span><br><span class="line">                                                        SDWebImageDownloader *sself = wself;</span><br><span class="line">                                                        if (!sself) return;</span><br><span class="line">                                                        dispatch_barrier_async(sself.barrierQueue, ^&#123;</span><br><span class="line">                                                            [sself.URLCallbacks removeObjectForKey:url];</span><br><span class="line">                                                        &#125;);</span><br><span class="line">                                                    &#125;];</span><br><span class="line">    operation.shouldDecompressImages = wself.shouldDecompressImages;</span><br><span class="line">    </span><br><span class="line">    // 设置认证信息(具体可看 Http StatusCode - 401)</span><br><span class="line">    if (wself.urlCredential) &#123;</span><br><span class="line">        operation.credential = wself.urlCredential;</span><br><span class="line">    &#125; else if (wself.username &amp;&amp; wself.password) &#123;</span><br><span class="line">        operation.credential = [NSURLCredential credentialWithUser:wself.username password:wself.password persistence:NSURLCredentialPersistenceForSession];</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    // 设置优先级</span><br><span class="line">    if (options &amp; SDWebImageDownloaderHighPriority) &#123;</span><br><span class="line">        operation.queuePriority = NSOperationQueuePriorityHigh;</span><br><span class="line">    &#125; else if (options &amp; SDWebImageDownloaderLowPriority) &#123;</span><br><span class="line">        operation.queuePriority = NSOperationQueuePriorityLow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 3. 添加并执行任务</span><br><span class="line">    [wself.downloadQueue addOperation:operation];</span><br><span class="line">    // 模仿实现 LIFO 任务</span><br><span class="line">    if (wself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</span><br><span class="line">        // Emulate LIFO execution order by systematically adding new operations as last operation&apos;s dependency</span><br><span class="line">        [wself.lastAddedOperation addDependency:operation];</span><br><span class="line">        wself.lastAddedOperation = operation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>代码中同样在关键点进行了标注，这里实际只能看到一个发起请求的过程和请求结果的回调，而实际的下载操作在<code>SDWebImageDownloaderOperation</code>类中，这个类是使用 URLConnection  发送请求的，下面一个主题将进行分析。</p>
<p>这里解释一下前面提到的一个参数，即加载完成回调 Block 中的 finish 参数：SDWebImage 可以选择采用渐进式图片加载方式，也就是下载多少显示多少，只需要在下载的时候设置参数 <code>SDWebImageDownloaderProgressiveDownload</code>即可，finish 参数是用于表示下载是否已经完全结束。</p>
<p>另外再关注一下<code>downloadQueue</code>的初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_downloadQueue = [NSOperationQueue new];</span><br><span class="line">_downloadQueue.maxConcurrentOperationCount = 6;</span><br></pre></td></tr></table></figure>
<p>最大线程数设置为 6。也就是最多可以同时进行 6 个下载任务。</p>
<h2 id="下载-amp-解码"><a href="#下载-amp-解码" class="headerlink" title="下载 &amp; 解码"></a>下载 &amp; 解码</h2><p>SDWebImage 下载的真正实现类是<code>SDWebImageDownloaderOperation</code>，这个类继承自<strong>NSOperation</strong>，实现<code>NSURLConnectionDataDelegate</code>协议，将网络下载相关操作和下载图片解码操作封装在内部。</p>
<blockquote>
<p>阅读代码之前最好了解一下如何自定义 NSOperation 和 RunLoop 相关知识。</p>
<p>RunLoop 知识可以参考：<a href="http://blog.ibireme.com/2015/05/18/runloop/#base" target="_blank" rel="noopener">深入理解RunLoop</a></p>
</blockquote>
<h3 id="关键方法start"><a href="#关键方法start" class="headerlink" title="关键方法start"></a>关键方法<code>start</code></h3><p><code>SDWebImageDownloaderOperation</code>的<code>start</code>方法实现大致如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">- (void)start &#123;</span><br><span class="line">    @synchronized (self) &#123;</span><br><span class="line">        if (self.isCancelled) &#123;</span><br><span class="line">            self.finished = YES;</span><br><span class="line">            [self reset];</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ....</span><br><span class="line"></span><br><span class="line">        self.executing = YES;</span><br><span class="line">        self.connection = [[NSURLConnection alloc] initWithRequest:self.request delegate:self startImmediately:NO];</span><br><span class="line">        self.thread = [NSThread currentThread];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [self.connection start];</span><br><span class="line"></span><br><span class="line">    if (self.connection) &#123;// 1. connection 初始化成功</span><br><span class="line">        if (self.progressBlock) &#123;</span><br><span class="line">            self.progressBlock(0, NSURLResponseUnknownLength);</span><br><span class="line">        &#125;</span><br><span class="line">        // 2. 发送通知</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:self];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        // 3. 启动 RunLoop</span><br><span class="line">        if (floor(NSFoundationVersionNumber) &lt;= NSFoundationVersionNumber_iOS_5_1) &#123;</span><br><span class="line">            // Make sure to run the runloop in our background thread so it can process downloaded data</span><br><span class="line">            // Note: we use a timeout to work around an issue with NSURLConnection cancel under iOS 5</span><br><span class="line">            //       not waking up the runloop, leading to dead threads (see https://github.com/rs/SDWebImage/issues/466)</span><br><span class="line">            CFRunLoopRunInMode(kCFRunLoopDefaultMode, 10, false);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            CFRunLoopRun();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 4. 执行取消清理工作</span><br><span class="line">        if (!self.isFinished) &#123;</span><br><span class="line">            [self.connection cancel];</span><br><span class="line">            [self connection:self.connection didFailWithError:[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorTimedOut userInfo:@&#123;NSURLErrorFailingURLErrorKey : self.request.URL&#125;]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123; // 5. connnection 初始化失败</span><br><span class="line">        if (self.completedBlock) &#123;</span><br><span class="line">            self.completedBlock(nil, nil, [NSError errorWithDomain:NSURLErrorDomain code:0 userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Connection can&apos;t be initialized&quot;&#125;], YES);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较难理解的是 RunLoop 的启动。在网上查了一些资料，有的人认为这里启动 RunLoop 是为了保证数据加载的流畅性，在滑动的时候不去加载数据。</p>
<p>但我的理解并不是这样，这个下载任务执行是在异步线程里面，与主线程毫无关系，不存在页面流畅不流畅的问题，如果要做到流畅，也应该是在最后调度到主线程的时候控制。再看注释里面有一句 “Make sure to run the runloop in our background thread so it can process downloaded data”，这句话的意思是说必须要启动 RunLoop 以保证它能够处理下载的数据，而下载的的数据是在 delegate 中进行回调处理的。所以我认为：<strong><code>SDWebImageDownloaderOperation</code>实现了<code>NSURLConnectionDataDelegate</code>协议并把自己设置为 connection 的 delegate，这里之所以启动 RunLoop，是为了保证<code>SDWebImageDownloaderOperation</code>运行在<code>start</code>方法中不退出，从而该对象不会被回收，否则一旦<code>start</code>方法执行完成，connection 就失去代理无法处理数据了。</strong></p>
<h3 id="代理实现"><a href="#代理实现" class="headerlink" title="代理实现"></a>代理实现</h3><p>再来看代理，代理有三个关键时间节点：</p>
<ol>
<li>初次获得响应，也就是连通服务器的时候；</li>
<li>接收数据的过程；</li>
<li>数据接收完成；</li>
</ol>
<p>这部分主要是网络相关的内容，在数据接收上没有什么大问题，关键是看数据的处理。下面一一分析。</p>
<h4 id="连接打通"><a href="#连接打通" class="headerlink" title="连接打通"></a>连接打通</h4><p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response &#123;</span><br><span class="line">    //&apos;304 Not Modified&apos; is an exceptional one</span><br><span class="line">    if (![response respondsToSelector:@selector(statusCode)] || ([((NSHTTPURLResponse *)response) statusCode] &lt; 400 &amp;&amp; [((NSHTTPURLResponse *)response) statusCode] != 304)) &#123;</span><br><span class="line">        NSInteger expected = response.expectedContentLength &gt; 0 ? (NSInteger)response.expectedContentLength : 0;</span><br><span class="line">        self.expectedSize = expected;</span><br><span class="line">        if (self.progressBlock) &#123;</span><br><span class="line">            self.progressBlock(0, expected);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        self.imageData = [[NSMutableData alloc] initWithCapacity:expected];</span><br><span class="line">        self.response = response;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadReceiveResponseNotification object:self];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        NSUInteger code = [((NSHTTPURLResponse *)response) statusCode];</span><br><span class="line">        //This is the case when server returns &apos;304 Not Modified&apos;. It means that remote image is not changed.</span><br><span class="line">        //In case of 304 we need just cancel the operation and return cached image from the cache.</span><br><span class="line">        if (code == 304) &#123;</span><br><span class="line">            [self cancelInternal];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            [self.connection cancel];</span><br><span class="line">        &#125;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:self];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        if (self.completedBlock) &#123;</span><br><span class="line">            self.completedBlock(nil, nil, [NSError errorWithDomain:NSURLErrorDomain code:[((NSHTTPURLResponse *)response) statusCode] userInfo:nil], YES);</span><br><span class="line">        &#125;</span><br><span class="line">        CFRunLoopStop(CFRunLoopGetCurrent());</span><br><span class="line">        [self done];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果响应正常，即 statusCode &lt; 400，并且不是 304，那么正常接收数据，否则 cancel 掉连接。关于 304 的实现，其实并没看太明白。在<code>SDWebImageDownloader.m</code>中初始化下载 request 的时候，有如下注释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise</span><br><span class="line">NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url cachePolicy:(options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData) timeoutInterval:timeoutInterval];</span><br><span class="line">request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);</span><br><span class="line">request.HTTPShouldUsePipelining = YES;</span><br></pre></td></tr></table></figure>
<p>除非开发者手动设置<code>SDWebImageDownloaderUseNSURLCache</code>选项，否则不会使用<code>NSURLRequestUseProtocolCachePolicy</code>缓存策略，否则会直接从服务端加载，系统是不会帮忙做缓存的，而在代码里面是没有看到手动解析保存请求的 Header 的地方的，因此如果不用系统缓存信息，并使用<code>NSURLRequestReloadRevalidatingCacheData</code>缓存策略，那 304 就不可能出现，所以这里 304 到底是什么效果，需要实际调试一把才能弄清楚。</p>
<blockquote>
<p>iOS 缓存可以参考：<a href="http://nshipster.cn/nsurlcache/" target="_blank" rel="noopener">NSURLCache</a></p>
<p>PS：一般图片变化后 URL 都会随之变化，请求图片要求服务端进行缓存验证的情况并不多见。</p>
</blockquote>
<h4 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h4><p>调用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码就不贴出来了，重点在于接收数据的过程中使用 ImageIO 实现渐进式图片加载，关于 ImageIO，可以参考文档 <a href="https://developer.apple.com/library/content/documentation/GraphicsImaging/Conceptual/ImageIOGuide/imageio_basics/ikpg_basics.html" target="_blank" rel="noopener">Image I/O Programming Guide</a>。代码注释作者表明代码是来自网站 <a href="http://www.cocoaintheshell.com/" target="_blank" rel="noopener">http://www.cocoaintheshell.com/</a> 的，但貌似这个网站不存在了。</p>
<p>这段代码有一个小小的细节点需要注意，就是下载下来的图片会通过下面的方法进行拉伸变化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// SDWebImageCompat.m</span><br><span class="line">inline UIImage *SDScaledImageForKey(NSString *key, UIImage *image) &#123;</span><br><span class="line">    if (!image) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if ([image.images count] &gt; 0) &#123;</span><br><span class="line">        NSMutableArray *scaledImages = [NSMutableArray array];</span><br><span class="line"></span><br><span class="line">        for (UIImage *tempImage in image.images) &#123;</span><br><span class="line">            [scaledImages addObject:SDScaledImageForKey(key, tempImage)];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return [UIImage animatedImageWithImages:scaledImages duration:image.duration];</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        if ([[UIScreen mainScreen] respondsToSelector:@selector(scale)]) &#123;</span><br><span class="line">            CGFloat scale = [UIScreen mainScreen].scale;</span><br><span class="line">            if (key.length &gt;= 8) &#123;</span><br><span class="line">                NSRange range = [key rangeOfString:@&quot;@2x.&quot;];</span><br><span class="line">                if (range.location != NSNotFound) &#123;</span><br><span class="line">                    scale = 2.0;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                range = [key rangeOfString:@&quot;@3x.&quot;];</span><br><span class="line">                if (range.location != NSNotFound) &#123;</span><br><span class="line">                    scale = 3.0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            UIImage *scaledImage = [[UIImage alloc] initWithCGImage:image.CGImage scale:scale orientation:image.imageOrientation];</span><br><span class="line">            image = scaledImage;</span><br><span class="line">        &#125;</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即会根据屏幕分辨率以及图片 URL 中的特定字符”@2x.”和”@3x.”来进行图片的比例缩放。</p>
<h4 id="接收完成"><a href="#接收完成" class="headerlink" title="接收完成"></a>接收完成</h4><p>调用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">- (void)connectionDidFinishLoading:(NSURLConnection *)aConnection &#123;</span><br><span class="line">    SDWebImageDownloaderCompletedBlock completionBlock = self.completedBlock;</span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">        // 停掉 Loop</span><br><span class="line">        CFRunLoopStop(CFRunLoopGetCurrent());</span><br><span class="line">        self.thread = nil;</span><br><span class="line">        self.connection = nil;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:self];</span><br><span class="line">            [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadFinishNotification object:self];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 判断响应是否来自缓存</span><br><span class="line">    if (![[NSURLCache sharedURLCache] cachedResponseForRequest:_request]) &#123;</span><br><span class="line">        responseFromCached = NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (completionBlock) &#123;</span><br><span class="line">        // 如果响应是来自缓存，但是开发者又设置了忽略缓存响应的选项，则回调无图片</span><br><span class="line">        if (self.options &amp; SDWebImageDownloaderIgnoreCachedResponse &amp;&amp; responseFromCached) &#123;</span><br><span class="line">            completionBlock(nil, nil, nil, YES);</span><br><span class="line">        &#125; else if (self.imageData) &#123;</span><br><span class="line">            UIImage *image = [UIImage sd_imageWithData:self.imageData];</span><br><span class="line">            NSString *key = [[SDWebImageManager sharedManager] cacheKeyForURL:self.request.URL];</span><br><span class="line">            image = [self scaledImageForKey:key image:image];</span><br><span class="line">            </span><br><span class="line">            // 解码图片</span><br><span class="line">            // Do not force decoding animated GIFs</span><br><span class="line">            if (!image.images) &#123;</span><br><span class="line">                if (self.shouldDecompressImages) &#123;</span><br><span class="line">                    image = [UIImage decodedImageWithImage:image];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (CGSizeEqualToSize(image.size, CGSizeZero)) &#123;</span><br><span class="line">                completionBlock(nil, nil, [NSError errorWithDomain:SDWebImageErrorDomain code:0 userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Downloaded image has 0 pixels&quot;&#125;], YES);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                completionBlock(image, self.imageData, nil, YES);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            completionBlock(nil, nil, [NSError errorWithDomain:SDWebImageErrorDomain code:0 userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Image data is nil&quot;&#125;], YES);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    self.completionBlock = nil;</span><br><span class="line">    [self done];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码本身没有什么难懂的地方，但这里面涉及到一个有用的基本知识——<strong>图片类型判断</strong>，记录如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+ (NSString *)sd_contentTypeForImageData:(NSData *)data &#123;</span><br><span class="line">    uint8_t c;</span><br><span class="line">    [data getBytes:&amp;c length:1];</span><br><span class="line">    switch (c) &#123;</span><br><span class="line">        case 0xFF:</span><br><span class="line">            return @&quot;image/jpeg&quot;;</span><br><span class="line">        case 0x89:</span><br><span class="line">            return @&quot;image/png&quot;;</span><br><span class="line">        case 0x47:</span><br><span class="line">            return @&quot;image/gif&quot;;</span><br><span class="line">        case 0x49:</span><br><span class="line">        case 0x4D:</span><br><span class="line">            return @&quot;image/tiff&quot;;</span><br><span class="line">        case 0x52:</span><br><span class="line">            // R as RIFF for WEBP</span><br><span class="line">            if ([data length] &lt; 12) &#123;</span><br><span class="line">                return nil;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            NSString *testString = [[NSString alloc] initWithData:[data subdataWithRange:NSMakeRange(0, 12)] encoding:NSASCIIStringEncoding];</span><br><span class="line">            if ([testString hasPrefix:@&quot;RIFF&quot;] &amp;&amp; [testString hasSuffix:@&quot;WEBP&quot;]) &#123;</span><br><span class="line">                return @&quot;image/webp&quot;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以前虽然看过一些图片加载库并对比过不同格式的图片的参数，但没有整理过每种图片格式开头的魔法数字，这个函数表达的很清晰，以后如果有相关需求可以拿来直接使用。</p>
<blockquote>
<p>在 SDWebImage 库中，是需要根据不同的类型使用不同的解码方式生成图片的，读者有兴趣也可以看一下这部分代码。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上内容对 SDWebImage 加载图片的细节做了简单的分析描述。下面通过类图来大致整理一下前面提到的函数和功能实现位置（同样来自项目 Wiki）：</p>
<div align="center"><img src="http://7xktd8.com1.z0.glb.clouddn.com/SDWebImage 类关系图.png" alt="SDWebImage SDWebImage 类关系图"></div>

<p>经过前面的分析，可以系统看一下 SDWebImage 的核心模块：</p>
<ol>
<li><strong>UIView 模块</strong> 处于上图的左上角部分，通过 Category 为 UIView、UIImageView 和 UIButton 添加方法，衔接 SDWebImage 的功能；</li>
<li><strong>SDWebImageManager</strong> 处于上图的中心，它是获取图片流程的制定者，负责调度缓存获取和网络下载两种图片获取方式；</li>
<li><strong>SDImageCache</strong> 处于上图左下角，负责图片的内存缓存和磁盘缓存；</li>
<li><strong>下载模块</strong> 处于上图的右边部分，负责图片的下载；</li>
</ol>
<p>以上四个模块配合前面所说的流程，完成图片的加载、解码以及显示。</p>
<p>最后，SDWebImage 是我学习 iOS 以来分析的第一个流行开源库，因为之前研究过 Andorid 上的一些图片加载库，比如 UIL，Picasso 等，因此觉得分析这样一个库会比较得心应手，也相对有个参考，是一个比较好的学习机会，分析完成之后，对于 GCD，NSOperation，Block，RunLoop 等这样的基础概念有了更多的认识，也算达到了我的目的😁。</p>
</div><div class="tags"><a href="/tags/源码/">源码</a></div><div class="post-nav"><a href="/2017/02/15/iOS-网络学习（二）/" class="pre">iOS 网络学习（二）—— NSURLSession</a><a href="/2017/01/17/RAC（二）/" class="next">【译】ReactiveCocoa 入门教程（下半部分）</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">59</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactiveX/">ReactiveX</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/后端/">后端</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/影视/">影视</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/电影/">电影</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Gitbook/" style="font-size: 15px;">Gitbook</a> <a href="/tags/Runtime/" style="font-size: 15px;">Runtime</a> <a href="/tags/视图/" style="font-size: 15px;">视图</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/权限/" style="font-size: 15px;">权限</a> <a href="/tags/代码优化/" style="font-size: 15px;">代码优化</a> <a href="/tags/Framework/" style="font-size: 15px;">Framework</a> <a href="/tags/性能优化/" style="font-size: 15px;">性能优化</a> <a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/合集/" style="font-size: 15px;">合集</a> <a href="/tags/ADB/" style="font-size: 15px;">ADB</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/反编译/" style="font-size: 15px;">反编译</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/Gradle/" style="font-size: 15px;">Gradle</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/基础/" style="font-size: 15px;">基础</a> <a href="/tags/效率/" style="font-size: 15px;">效率</a> <a href="/tags/MarkDown/" style="font-size: 15px;">MarkDown</a> <a href="/tags/电影/" style="font-size: 15px;">电影</a> <a href="/tags/Reactive/" style="font-size: 15px;">Reactive</a> <a href="/tags/AIDL/" style="font-size: 15px;">AIDL</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/驱动/" style="font-size: 15px;">驱动</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/日志/" style="font-size: 15px;">日志</a> <a href="/tags/事件/" style="font-size: 15px;">事件</a> <a href="/tags/代码设计/" style="font-size: 15px;">代码设计</a> <a href="/tags/网络/" style="font-size: 15px;">网络</a> <a href="/tags/测试/" style="font-size: 15px;">测试</a> <a href="/tags/Binder/" style="font-size: 15px;">Binder</a> <a href="/tags/Groovy/" style="font-size: 15px;">Groovy</a> <a href="/tags/Loader/" style="font-size: 15px;">Loader</a> <a href="/tags/RAC/" style="font-size: 15px;">RAC</a> <a href="/tags/事件处理/" style="font-size: 15px;">事件处理</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/10/30/AIDL-原理分析/">AIDL 原理分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/30/App-启动过程/">App 启动过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/PMS-解析/">PMS 解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/WMS-解析/">WindowManagerService 解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/AMS-解析/">AMS 解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/10/The-Good-Wife/">The-Good-Wife</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/10/Black-Sails/">黑帆</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/29/hello-world/">Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/23/XCode-8-2-1-ClangFormat-插件安装/">XCode 8.2.1 ClangFormat 插件安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/07/SourceTree-分支图谱/">SourceTree 分支图谱</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">蜗牛壳.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>