<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="李全民的个人博客"><title>Fragment的事务实现细节分析 | 蜗牛壳</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-65882749-1','auto');ga('send','pageview');</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Fragment的事务实现细节分析</h1><a id="logo" href="/.">蜗牛壳</a><p class="description">计算机只有 0 和 1 ，但世界是连续的</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Fragment的事务实现细节分析</h1><div class="post-meta">Oct 17, 2015<span> | </span><span class="category"><a href="/categories/Android/">Android</a></span></div><div class="post-content"><blockquote>
<p><strong>Note:</strong> 本文适合对 Fragment 的用法比较熟悉的读者。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getSupportFragmentManager().beginTransaction()</span><br><span class="line">	                .add(R.id.container, LCFragment.newInstance(<span class="string">"I am new!"</span>)).addToBackStack(<span class="keyword">null</span>).commit();</span><br></pre></td></tr></table></figure>
<p>对于稍有经验的Android开发者而言，上面的代码都应该很熟悉，通过这段代码我们可以向某个ViewGroup中添加一个Fragment。对于这段代码，我有以下个好奇点: </p>
<ol>
<li>beginTransaction()应该是开启一个事务，这个事务是什么含义?</li>
<li>addToBackStack是将这个变化添加到堆栈中去，我们知道Fragment还可以Pop堆栈，从而恢复回到commit之前的状态，这是如何实现的？</li>
</ol>
<p>本文通过源码分析，解析Fragment的工作原理，顺便解释清楚以上三个问题。<a id="more"></a></p>
<blockquote>
<p><strong>PS:</strong> Fragment是3.0之后才添加的，为了支持3.0之前的应用开发，google提供了support包，本文的源码分析是基于support-v4版本进行的。</p>
</blockquote>
<h2 id="入口函数getSupportFragmentManager"><a href="#入口函数getSupportFragmentManager" class="headerlink" title="入口函数getSupportFragmentManager()"></a>入口函数getSupportFragmentManager()</h2><p>我们操作Fragment都是通过FragmentManager来执行的，在FragmentActivity中找到这个方法的实现，发现它返回的是FragmentManagerImpl的一个实例，我们直接定位到FragmentManager类，FragmentManagerImpl作为它的一个内部类存在。这里就是我们的切入点。</p>
<h3 id="那些带有疑问的函数以及不常见的API"><a href="#那些带有疑问的函数以及不常见的API" class="headerlink" title="那些带有疑问的函数以及不常见的API"></a>那些带有疑问的函数以及不常见的API</h3><ol>
<li><strong>public abstract Fragment findFragmentById(@IdRes int id);</strong><br>读者应该知道两点:1)如果一个Fragment在添加的适合没有指定id，则他的id就等于它的containerId；2）一个ViewGroup可以添加多个Fragment。那么问题来了，这个方法只返回了一个Fragment，在多个Fragment拥有同样的Id的时候，返回的是哪一个？</li>
<li><strong>POP_BACK_STACK_INCLUSIVE</strong><br>这个参数读者可以阅读注释，或者自行查阅相关资料先进行了解，文章后面会讲述。</li>
<li><strong>public abstract void putFragment(Bundle bundle, String key, Fragment fragment);</strong><br>这个函数很少用，其注释中说”Put a reference to a fragment in a Bundle.”，查看Fragment的实现，很容易发现Fragment本身并没有实现Parcelable接口，name它是如何实现将Fragment保存到Bundle的呢?</li>
</ol>
<p>这些问题将在后面的分析中一一解答。</p>
<h2 id="事务函数beginTransaction"><a href="#事务函数beginTransaction" class="headerlink" title="事务函数beginTransaction()"></a>事务函数beginTransaction()</h2><p>从FragmentManagerImpl找到这个函数的实现，返回的是一个BackStackRecord实例。这个类实现了接口FragmentTransaction，查看接口声明，很容易就发现这个接口中的方法就是我们常见的操作Fragment的方法，比如add, remove, 还有很重要的commit()和commitAllowingStateLoss()方法。这个类还实现了Runnable接口，具体作用后面讲述。</p>
<h3 id="BackStackRecord类"><a href="#BackStackRecord类" class="headerlink" title="BackStackRecord类"></a>BackStackRecord类</h3><p>粗略的看一下BackStackRecord类代码的实现，可以很容易发现，它定义了8种操作以及一个Op内部类。</p>
<h4 id="Op类实现"><a href="#Op类实现" class="headerlink" title="Op类实现"></a>Op类实现</h4><p>这个类用于将Add，Remove等这样的方法转换成一个个操作命令：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Op</span> </span>&#123;</span><br><span class="line">	Op next;</span><br><span class="line">	Op prev;</span><br><span class="line">	<span class="keyword">int</span> cmd;</span><br><span class="line">	Fragment fragment;</span><br><span class="line">	<span class="keyword">int</span> enterAnim;</span><br><span class="line">	<span class="keyword">int</span> exitAnim;</span><br><span class="line">	<span class="keyword">int</span> popEnterAnim;</span><br><span class="line">	<span class="keyword">int</span> popExitAnim;</span><br><span class="line">	ArrayList&lt;Fragment&gt; removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从类属性看，可以知道这个类记录了命令类型，以及执行命令时的动画(分为push和pop动画)，以及涉及到的相关的Fragment(比如replace方法，就涉及两个Fragment)，另外从最前面两个属性看，Op将成为一个双向链表的节点：实际上就在这个类声明的下面几行，BackStackRecord就声明了mHead和mTail两个变量，佐证了链表的猜测。</p>
<h4 id="操作方法示例解释"><a href="#操作方法示例解释" class="headerlink" title="操作方法示例解释"></a>操作方法示例解释</h4><p>从定义的命令来看，FragmentManager支持8种操作，我们选择一种简单的看(主要是代码简短，比较好贴)——remove。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FragmentTransaction <span class="title">remove</span><span class="params">(Fragment fragment)</span> </span>&#123;</span><br><span class="line">	Op op = <span class="keyword">new</span> Op();</span><br><span class="line">	op.cmd = OP_REMOVE;</span><br><span class="line">	op.fragment = fragment;</span><br><span class="line">	addOp(op);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码很简单，无需过多解释，我们看一下addOp方法的实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addOp</span><span class="params">(Op op)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">		mHead = mTail = op;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		op.prev = mTail;</span><br><span class="line">		mTail.next = op;</span><br><span class="line">		mTail = op;</span><br><span class="line">	&#125;</span><br><span class="line">	op.enterAnim = mEnterAnim;</span><br><span class="line">	op.exitAnim = mExitAnim;</span><br><span class="line">	op.popEnterAnim = mPopEnterAnim;</span><br><span class="line">	op.popExitAnim = mPopExitAnim;</span><br><span class="line">	mNumOp++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码彻底证明了链表的猜想——新添加的Op被加入了一个链表中。其余的操作也类似，会被转换成一个Op命令，添加到这个列表中。</p>
<h4 id="Commit-方法"><a href="#Commit-方法" class="headerlink" title="Commit()方法"></a><code>Commit()</code>方法</h4><p>commit和commitAllowingStateLoss()两个方法最终都会调用commitInternal方法，只是传入参数不一样，其实现如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">commitInternal</span><span class="params">(<span class="keyword">boolean</span> allowStateLoss)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mCommitted) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"commit already called"</span>);</span><br><span class="line">	mCommitted = <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (mAddToBackStack) &#123;</span><br><span class="line">		mIndex = mManager.allocBackStackIndex(<span class="keyword">this</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		mIndex = -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	mManager.enqueueAction(<span class="keyword">this</span>, allowStateLoss);</span><br><span class="line">	<span class="keyword">return</span> mIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码也很简单，commit之后返回的参数是调用FragmentManager的allocBackStackIndex后返回的值(先不探索，稍等转到FragmentManager后再解释)，之后调用FragmentManager的enqueueAction方法，将自己作为参数传入。从enqueueAction这个方法名字看，很容易就能猜到意思:将自己压入一个队列，做什么呢？等待执行。</p>
<h4 id="run-方法"><a href="#run-方法" class="headerlink" title="run()方法"></a><code>run()</code>方法</h4><p>前面说到BackStackRecord实现了Runnable()接口，作用什么呢？其实这里和线程没有关系，只是为了实现调用类的统一方法来执行一个动作，这个用法和Handler的post(Runnable)方法一样，读者可以先查阅一下FragmentManager的enqueueAction方法签名，它接受的第一个参数就是Runnable，而非BackStackRecord类型。</p>
<p>看一下run方法实现的核心:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Op op = mHead;</span><br><span class="line"><span class="keyword">while</span> (op != <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="keyword">int</span> enterAnim = state != <span class="keyword">null</span> ? <span class="number">0</span> : op.enterAnim;</span><br><span class="line">	<span class="keyword">int</span> exitAnim = state != <span class="keyword">null</span> ? <span class="number">0</span> : op.exitAnim;</span><br><span class="line">	<span class="keyword">switch</span> (op.cmd) &#123;</span><br><span class="line">		<span class="keyword">case</span> OP_ADD: &#123;</span><br><span class="line">			Fragment f = op.fragment;</span><br><span class="line">			f.mNextAnim = enterAnim;</span><br><span class="line">			mManager.addFragment(f, <span class="keyword">false</span>);</span><br><span class="line">			&#125; <span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">//....其余命令</span></span><br><span class="line">		<span class="keyword">default</span>: &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unknown cmd: "</span> + op.cmd);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	op = op.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mAddToBackStack) &#123;<span class="comment">//加入堆栈</span></span><br><span class="line">	mManager.addBackStackState(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是一个典型的链表扫描，这里以OP_ADD命令为例，我们可以看到它最终实现的时候，是调用了FragmentManager的addFragment方法，读者可以查看别的方法，很容易就发现其余的命令实现也是类似。再看方法整体，就是一个遍历扫描链表，执行节点Op的过程。</p>
<p>因此总结如下： <strong>一次beginTransaction()方法会开启一个BackStackRecord实例，后续对Fragment的操作(链式编程)会转化成Op节点以链表形式存储在BackStackRecord中，commit()之后就交给FragmentManager调度执行，而执行的时候，就是遍历链表的Op命令，将命令映射到FragmentManager的函数上，操作Fragment。</strong></p>
<p>读者注意到这个函数的最后三行代码，这里根据mAddToBackStack判断是否将自己添加到BackStack中去，mAddToBackStack什么时候会为true呢？搜索一下代码就会发现:调用addToBackStack之后就会为true。而且很容易得出结论：只要在commit()之前调用就可以，不一定在操作最后调用。但是为了易读，在所有操作之后、commit之前调用比较好。(还有个类似的方法disallowAddToBackStack，一旦调用了这个方法，再掉用addToBackStack就会抛异常)</p>
<p>FragmentManagerImpl中的addBackStackState方法实现如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addBackStackState</span><span class="params">(BackStackRecord state)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mBackStack == <span class="keyword">null</span>) &#123;</span><br><span class="line">		mBackStack = <span class="keyword">new</span> ArrayList&lt;BackStackRecord&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">	mBackStack.add(state);</span><br><span class="line">	reportBackStackChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，所有的事务都被封装为一个BackStackRecord对象存储到”栈”中(此处栈是用List模拟的)。</p>
<h3 id="BackStackRecord的执行"><a href="#BackStackRecord的执行" class="headerlink" title="BackStackRecord的执行"></a>BackStackRecord的执行</h3><p>前面讲到，commit之后，会把BackStackRecord压入到一个队列中去，现在我们来看一下具体的实现方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueueAction</span><span class="params">(Runnable action, <span class="keyword">boolean</span> allowStateLoss)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!allowStateLoss) &#123;</span><br><span class="line">		checkStateLoss();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (mDestroyed || mActivity == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Activity has been destroyed"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (mPendingActions == <span class="keyword">null</span>) &#123;</span><br><span class="line">			mPendingActions = <span class="keyword">new</span> ArrayList&lt;Runnable&gt;();</span><br><span class="line">		&#125;</span><br><span class="line">		mPendingActions.add(action);</span><br><span class="line">		<span class="keyword">if</span> (mPendingActions.size() == <span class="number">1</span>) &#123;</span><br><span class="line">			mActivity.mHandler.removeCallbacks(mExecCommit);</span><br><span class="line">			mActivity.mHandler.post(mExecCommit);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在FragmentManager中有一个List维护着所有待执行的Runnable对象，当然也包含BackStackRecord对象，每次执行enqueueAction，都会往List中加入一个enqueueAction，如果添加之后List的大小为1(表明之前List中是空的)，那么会在主Activity的Handler中发一条全新的mExecCommit命令，这个命令是一个Runnable对象，只执行一个函数：execPendingActions。</p>
<p>这个函数会做什么呢？读者看一下代码(比较长，不贴了)，可以看到以下几个步骤：</p>
<ol>
<li>将List中的Runnable对象都移入mTmpActions数组中，清空List，清空Handler中的mExecCommit命令——表示主线程上完整的对待执行的Runnable对象进行了一次执行操作；</li>
<li>调用每个Runnable对象的run()方法执行(还记得BackStackRecord的run()方法吗？)。</li>
</ol>
<p>逻辑非常简单。这样一次执行完成，就可以完成一次事务提交了。一些方法比如popBackStack都被打上了asynchronous的标记，就是这个原因：它们不是立刻执行的，都是向队列中添加一个Action，等待主线程去调度执行(试想主线程在执行其余的一些操作，则这些事务必须等待它们执行完成之后才有机会执行)。</p>
<p>在FragmentManager中也有一组方法，它们后面跟着Immediate，表明是立即执行的。那是如何做的呢？这涉及到另外一个函数:executePendingTransactions。这个函数其实是直接调用了execPendingActions，而没有经过Handler，因此可以立即执行，开发人员在外部也可以直接调用该函数。正如方法注释中所写的：这个方法只能从主线程调用。</p>
<h2 id="回退——事务出栈"><a href="#回退——事务出栈" class="headerlink" title="回退——事务出栈"></a>回退——事务出栈</h2><p>前面讲述了FragmentManager如何执行事务以及存储事务的。那具体的回退呢？</p>
<h3 id="事务出栈"><a href="#事务出栈" class="headerlink" title="事务出栈"></a>事务出栈</h3><p>FragmentActiivty中写了一个方法，细节如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBackPressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!<span class="keyword">this</span>.mFragments.popBackStackImmediate()) &#123;</span><br><span class="line">		<span class="keyword">this</span>.finish();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>原来回退键默认的行为就是关闭当前界面，这里做了一层拦截：查看popBackStackImmediate方法的返回值。</p>
<h3 id="popBackStackState方法"><a href="#popBackStackState方法" class="headerlink" title="popBackStackState方法"></a>popBackStackState方法</h3><p>popBackStackState方法最终调用了popBackStackState方法，这个方法极为重要，可以从中得出对之前一些参数详细的解释，下面分片段解释：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (name == <span class="keyword">null</span> &amp;&amp; id &lt; <span class="number">0</span> &amp;&amp; (flags &amp; POP_BACK_STACK_INCLUSIVE) == <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="keyword">int</span> last = mBackStack.size() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (last &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">final</span> BackStackRecord bss = mBackStack.remove(last);</span><br><span class="line">	SparseArray&lt;Fragment&gt; firstOutFragments = <span class="keyword">new</span> SparseArray&lt;Fragment&gt;();</span><br><span class="line">	SparseArray&lt;Fragment&gt; lastInFragments = <span class="keyword">new</span> SparseArray&lt;Fragment&gt;();</span><br><span class="line">	bss.calculateBackFragments(firstOutFragments, lastInFragments);</span><br><span class="line">	bss.popFromBackStack(<span class="keyword">true</span>, <span class="keyword">null</span>, firstOutFragments, lastInFragments);</span><br><span class="line">	reportBackStackChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先，执行这个If的条件是name和id值都非法并且Flag POP_BACK_STACK_INCLUSIVE没有被设置才会去执行，即默认行为，是弹出最上层一个。从方法片段可以看出，取出mBackStack中的最后一个事务操作记录，调用calculateBackFragments方法。</p>
<p>calculateBackFragments方法的目的是查看哪些Fragment需要被移除、哪些需要被添加(与之前的Op命令相反，比如之前是Add，现在就应该被计入移除队列)，传入参数是两个SparseArray，执行中涉及到两个函数setLastIn和setFirstOut，这两个方法没有特别的逻辑，就是以containerId为键值将需要添加和移除的fragment保存到SparseArray中。</p>
<blockquote>
<p><strong>Note:</strong> 以containerId为键值会有问题，原因同样是来自于一个container中会存在多个Fragment。比如setFirstOut实现的时时候，会判断f移除队列中是否存在以container为键值的fragment，没有的话才会去移除。这意味着：一次事务回退是不能从一个container中移除两个Fragment的。但是在添加的时候却可以，两相矛盾。<br>不过不用担心回退栈会出现问题，因为实际上并不是通过这两个SparseArray来进行回退的，这个计算结果最终是为了得到transitionStyle和transition，这边是另外一条线，不做细讲。</p>
</blockquote>
<h4 id="popFromBackStack方法实现"><a href="#popFromBackStack方法实现" class="headerlink" title="popFromBackStack方法实现"></a>popFromBackStack方法实现</h4><p>计算好之后，就会调用BackStackRecord的popFromBackStack方法。这个方法前面小半段是计算transitionStyle和transition，后面半段就比较有意思了:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TransitionState <span class="title">popFromBackStack</span><span class="params">(<span class="keyword">boolean</span> doStateMove, TransitionState state,</span></span></span><br><span class="line"><span class="function"><span class="params">	SparseArray&lt;Fragment&gt; firstOutFragments, SparseArray&lt;Fragment&gt; lastInFragments)</span> </span>&#123;</span><br><span class="line">    Op op = mTail;</span><br><span class="line">	<span class="keyword">while</span> (op != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> popEnterAnim = state != <span class="keyword">null</span> ? <span class="number">0</span> : op.popEnterAnim;</span><br><span class="line">		<span class="keyword">int</span> popExitAnim= state != <span class="keyword">null</span> ? <span class="number">0</span> : op.popExitAnim;</span><br><span class="line">		<span class="keyword">switch</span> (op.cmd) &#123;</span><br><span class="line">		<span class="keyword">case</span> OP_ADD: &#123;</span><br><span class="line">			Fragment f = op.fragment;</span><br><span class="line">			f.mNextAnim = popExitAnim;</span><br><span class="line">			mManager.removeFragment(f,</span><br><span class="line">			FragmentManagerImpl.reverseTransit(transition), transitionStyle);</span><br><span class="line">			&#125; <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> OP_REMOVE: &#123;</span><br><span class="line">			Fragment f = op.fragment;</span><br><span class="line">			f.mNextAnim = popEnterAnim;</span><br><span class="line">			mManager.addFragment(f, <span class="keyword">false</span>);</span><br><span class="line">			&#125; <span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">//....</span></span><br><span class="line">		<span class="keyword">default</span>: &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unknown cmd: "</span> + op.cmd);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		op = op.prev;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (mIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		mManager.freeBackStackIndex(mIndex);</span><br><span class="line">		mIndex = -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码倒叙遍历之前的Op链表，以相反的方式执行Op链表。之前说到BackStackRecord中定义了8中Fragment操作，这8种操作都有互逆性，比如OP_ADD和OP_REMOVE就是相反的，OP_HIDE和OP_SHOW也是相反的，而OP_REPLACE则是一个OP_ADD和一组OP_REMOVE的组合。因此从这个方法的实现看，其实就是一个逆过程，比如之前的Op命令执行的是OP_ADD，这里只需要将这个Op中记录的Fragment移除就好了。通过这种方式，总能顺利的回退栈。</p>
<h4 id="popBackStackState方法后半段"><a href="#popBackStackState方法后半段" class="headerlink" title="popBackStackState方法后半段"></a>popBackStackState方法后半段</h4><p>继续回到popBackStackState方法，前面只讲了一半，还有一个If分支没有讲述，执行条件是：name或者id不为null其中一个有效或者设置了Flag POP_BACK_STACK_INCLUSIVE。这里可以看到程序是如何解释POP_BACK_STACK_INCLUSIVE这个Flag的，具体细节不解释，总结一下就是：对于popBackStack方法，如果int(flag)为POP_BACK_STACK_INCLUSIVE，则在这个name或者id标识的BackStackRecord以上的BackStackRecord包括自身都会被弹出，否则，自身不会被弹出，只有该Fragment以上的Fragemnt会被弹出。</p>
<p>name的含义很清楚，因为addToBackStack就要求传入一个String，但是id呢？这里可以看到一行代码:<br><strong>if (id &gt;= 0 &amp;&amp; id == bss.mIndex)</strong><br>是的，mIndex其实是BackStackRecord在栈中的位置！那么这个mIndex是在什么时候生成的呢？我们回退到commitInternal中，可以在这个方法实现中找到，在提交一个事务的时候，如果需要添加到事务回退栈，则会调用FragmentManager的allocBackStackIndex方法去分配一个Index。这个方法的实现也比较有意思。为了防止读者分心，此处不拓展讲述，读者只需要知道mIndex是BackStackRecord在栈中的位置就好。</p>
<p>因此，我们向事务栈中添加事务的时候，可以指定一个String作为此次添加的标记，当我们回退的时候，我们可以通过这个标记指定回退到某个历史状态，或者，直接通过位置去指定。</p>
<p>id是唯一的，一个位置上只能存储一个BackStackRecord，但是name却不唯一，多个BackStackRecord可以指定同一个BackStackRecord，如果我指定一个name去弹出，会发生什么呢？弹出栈的时候，首先找到name或者id匹配的那个BackStackRecord，如果没有找到，就直接返回，不进行退出操作。如果找到了，并且设置了POP_BACK_STACK_INCLUSIVE，会继续向下搜索，直到最后一个name或者id匹配的BackStackRecord才会结束。接下去后面的处理就和之前的类似了。</p>
<p>以上，是事务回退时的逻辑。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述，现在可以解答一开始提出的问题。第3个问题则在前面已经详细描述。</p>
<p>第1个问题：Fragment的事务和数据库中的事务是两个概念。虽然实际上它也是多个原子操作(Op)的组合，但是并不存在其中一个Op失败之后，回退其余Op的控制保证，这个事务目的是为了组合一堆零散的操作，以便于在一次提交中完成复杂的Fragment切换。而对于数据库而言，事务失败之后是需要回退到执行之前的样子的，Fragment的事务失败可以认为界面退出，它没有持久化保存任何数据，也没有后续的操作会受此次事务失败的影响，因此不需要做出保证。</p>
<p>关于Fragment的事务，还有一些细节没有去解读，但是大致的逻辑在此。读者如有补充，欢迎回复，如发现疑问，欢迎斧正。</p>
</div><div class="tags"><a href="/tags/源码/">源码</a></div><div class="post-nav"><a href="/2015/10/17/Volley-za-tan/" class="pre">Volley杂谈</a><a href="/2015/10/17/Android-de-shu-ju-hui-fu-er/" class="next">Android的数据恢复(二)</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">59</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactiveX/">ReactiveX</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/后端/">后端</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/影视/">影视</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/电影/">电影</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Gitbook/" style="font-size: 15px;">Gitbook</a> <a href="/tags/Runtime/" style="font-size: 15px;">Runtime</a> <a href="/tags/视图/" style="font-size: 15px;">视图</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/权限/" style="font-size: 15px;">权限</a> <a href="/tags/代码优化/" style="font-size: 15px;">代码优化</a> <a href="/tags/Framework/" style="font-size: 15px;">Framework</a> <a href="/tags/性能优化/" style="font-size: 15px;">性能优化</a> <a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/合集/" style="font-size: 15px;">合集</a> <a href="/tags/ADB/" style="font-size: 15px;">ADB</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/反编译/" style="font-size: 15px;">反编译</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/Gradle/" style="font-size: 15px;">Gradle</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/基础/" style="font-size: 15px;">基础</a> <a href="/tags/效率/" style="font-size: 15px;">效率</a> <a href="/tags/MarkDown/" style="font-size: 15px;">MarkDown</a> <a href="/tags/电影/" style="font-size: 15px;">电影</a> <a href="/tags/Reactive/" style="font-size: 15px;">Reactive</a> <a href="/tags/AIDL/" style="font-size: 15px;">AIDL</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/驱动/" style="font-size: 15px;">驱动</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/日志/" style="font-size: 15px;">日志</a> <a href="/tags/事件/" style="font-size: 15px;">事件</a> <a href="/tags/代码设计/" style="font-size: 15px;">代码设计</a> <a href="/tags/网络/" style="font-size: 15px;">网络</a> <a href="/tags/测试/" style="font-size: 15px;">测试</a> <a href="/tags/Binder/" style="font-size: 15px;">Binder</a> <a href="/tags/Groovy/" style="font-size: 15px;">Groovy</a> <a href="/tags/Loader/" style="font-size: 15px;">Loader</a> <a href="/tags/RAC/" style="font-size: 15px;">RAC</a> <a href="/tags/事件处理/" style="font-size: 15px;">事件处理</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/10/30/AIDL-原理分析/">AIDL 原理分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/30/App-启动过程/">App 启动过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/PMS-解析/">PMS 解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/WMS-解析/">WindowManagerService 解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/AMS-解析/">AMS 解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/10/The-Good-Wife/">The-Good-Wife</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/10/Black-Sails/">黑帆</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/29/hello-world/">Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/23/XCode-8-2-1-ClangFormat-插件安装/">XCode 8.2.1 ClangFormat 插件安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/07/SourceTree-分支图谱/">SourceTree 分支图谱</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">蜗牛壳.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>