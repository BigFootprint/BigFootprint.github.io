<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="李全民的个人博客"><title>Android的数据恢复(二) | 蜗牛壳</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-65882749-1','auto');ga('send','pageview');</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android的数据恢复(二)</h1><a id="logo" href="/.">蜗牛壳</a><p class="description">计算机只有 0 和 1 ，但世界是连续的</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android的数据恢复(二)</h1><div class="post-meta">Oct 17, 2015<span> | </span><span class="category"><a href="/categories/Android/">Android</a></span></div><div class="post-content"><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在Android上，会有以下原因导致需要保存和恢复当前页面的数据：  </p>
<ol>
<li>一个Activity退到后台：比如跳转到另外一个Activity，或者按Home键退到后端;</li>
<li>系统配置变化，如：屏幕旋转(在用户意识里只是屏幕旋转，实际上Activity是被杀掉后重建);</li>
</ol>
<p>第一种情况只有在内存不足，后台Activity确实被系统回收掉的时候才会进行数据恢复，如果Activity正常存在于内存中，则不需要数据恢复，但一定会做数据保存。第二种情况是因为在用户眼里只是界面旋转了一下，而实际上Activity是被销毁重建的，这个时候做数据恢复是合理而且应当的。<a id="more"></a></p>
<h2 id="数据如何保存"><a href="#数据如何保存" class="headerlink" title="数据如何保存"></a>数据如何保存</h2><p>一般来说，我们通过三个方法进行Activity的数据恢复与保存，分别如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span>  </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span>  </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRestoreInstanceState</span><span class="params">(Bundle savedInstanceState)</span></span></span><br></pre></td></tr></table></figure></p>
<p>我们通过第一个方法的outState参数保存数据，后面两个方法的savedInstanceState参数获取保存的数据。onRestoreInstanceState方法在onStart后面onResume前面执行。</p>
<p>关于以上两点，开发者官网上都有比较完善的描述，读者可以仔细阅读：<a href="http://developer.android.com/training/basics/activity-lifecycle/recreating.html" target="_blank" rel="noopener">【原文链接】</a></p>
<p>这一部分稍有经验的开发者都比较熟悉，本文重点讲述的是<strong>View如何去保存恢复数据</strong>。</p>
<h2 id="View状态如何保存"><a href="#View状态如何保存" class="headerlink" title="View状态如何保存"></a>View状态如何保存</h2><p>一个Activity展示给用户的除了数据，就是View，所以当我们做恢复的时候，不仅需要恢复重要数据，也需要尽可能的恢复View的状态。</p>
<p>日常开发中我们一般是通过onSaveInstanceState去保存View的状态(比如EditTex的输入内容)，恢复的时候将数据读出设置到View中去，但这种方式粗暴有用但不优雅，举个🌰：我封装了一个CustomView，其中包含着一个EditText，如果按照前面的方式去做恢复则EditText一定要暴露给外部，否则Activity就不能获取并设置值，这破坏了组件的封装性。</p>
<p>其实Android内部是有一套View状态保存和恢复机制的，不需要通过Activity的生命周期方法去实现。阅读官方文档的读者可以注意一点，文中提到了EditText状态的保存条件：需要有一个唯一的id。这是为什么呢？</p>
<p>下面我们来详细看一下View的数据保存机制，从中找出回答前面问题的答案。</p>
<blockquote>
<p>【Note】建议打开Android Studio，下面的代码片段比较多，直接阅读源码对照阅读比较容易理解。</p>
</blockquote>
<h3 id="Activity的onSaveInstanceState-方法"><a href="#Activity的onSaveInstanceState-方法" class="headerlink" title="Activity的onSaveInstanceState()方法"></a>Activity的onSaveInstanceState()方法</h3><p>View说到底是属于Activity的，onSaveInstanceState是整个Activity保存数据的出发点，我们从这里入手:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</span><br><span class="line">	outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState());</span><br><span class="line">	Parcelable p = mFragments.saveAllState();</span><br><span class="line">	<span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">		outState.putParcelable(FRAGMENTS_TAG, p);</span><br><span class="line">	&#125;</span><br><span class="line">	getApplication().dispatchActivitySaveInstanceState(<span class="keyword">this</span>, outState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如代码所示，第二行将整个Window的状态保存在一个Bundle中，将值保存到ontState中去，看上去很有可能与View相关，我们继续往下走。</p>
<p>3-6行则是触发Fragment数据保存的（下一篇博文主题）。关于Windnow的解释，可以查看这篇博客：<a href="http://www.cnblogs.com/lqminn/archive/2013/05/01/3050776.html" target="_blank" rel="noopener">【Android】Android界面从里至外浅析（一）</a></p>
<h3 id="Window的saveHierarchyState-方法"><a href="#Window的saveHierarchyState-方法" class="headerlink" title="Window的saveHierarchyState()方法"></a>Window的saveHierarchyState()方法</h3><p>了解之后，我们定位到PhoneWindow中的saveHierarchyState方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Bundle <span class="title">saveHierarchyState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Bundle outState = <span class="keyword">new</span> Bundle();</span><br><span class="line">	<span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line"> 		<span class="keyword">return</span> outState;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	SparseArray&lt;Parcelable&gt; states = <span class="keyword">new</span> SparseArray&lt;Parcelable&gt;();</span><br><span class="line"> 	mContentParent.saveHierarchyState(states);</span><br><span class="line"> 	outState.putSparseParcelableArray(VIEWS_TAG, states);</span><br><span class="line"> 	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此处省略了部分代码。我们看到，这个方法触发了mContentParent的saveHierarchyState的方法。mContentParent又是何方神圣？查看其声明发现：它是一个ViewGroup。比对<a href="http://www.cnblogs.com/lqminn/archive/2013/05/01/3050776.html" target="_blank" rel="noopener">【Android】Android界面从里至外浅析（一）</a>中的图，这个mContentParent又在什么位置呢？读者可以阅读一下PhoneWindow里面的setContentView方法，其实这个mContentParent就是图中DecorView下的LinearLayout，即我们setContentView的父容器。</p>
<p>然后我们看到方法声明了一个SparseArray对象，存储的是Parcelable，这个SparseArray对象被传递给了ViewGroup的saveHierarchyState方法，之后这个SparseArray对象又被存储到了outBundle中去了，那么问题就在于saveHierarchyState这个方法到底做了什么？</p>
<h3 id="ViewGroup的saveHierarchyState-方法"><a href="#ViewGroup的saveHierarchyState-方法" class="headerlink" title="ViewGroup的saveHierarchyState()方法"></a>ViewGroup的saveHierarchyState()方法</h3><p>标题虽然是ViewGroup的saveHierarchyState()方法，但ViewGroup本身其实并没有saveHierarchyState方法，这个方法继承于它的父类——View。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveHierarchyState</span><span class="params">(SparseArray&lt;Parcelable&gt; container)</span> </span>&#123;</span><br><span class="line">	dispatchSaveInstanceState(container);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchSaveInstanceState</span><span class="params">(SparseArray&lt;Parcelable&gt; container)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mID != NO_ID &amp;&amp; (mViewFlags &amp; SAVE_DISABLED_MASK) == <span class="number">0</span>) &#123;</span><br><span class="line">		mPrivateFlags &amp;= ~PFLAG_SAVE_STATE_CALLED;</span><br><span class="line">		Parcelable state = onSaveInstanceState();</span><br><span class="line">		<span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_SAVE_STATE_CALLED) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Derived class did not call super.onSaveInstanceState()"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (state != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// Log.i("View", "Freezing #" + Integer.toHexString(mID)</span></span><br><span class="line">			<span class="comment">// + ": " + state);</span></span><br><span class="line">			container.put(mID, state);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，在这个方法中，它调用了dispatchSaveInstanceState方法，而这个方法则调用本身的onSaveInstanceState方法获取一个Parcelable对象，通过View的id将这个对象存储到SparseArray里面去了。而ViewGroup里面重写了dispatchSaveInstanceState方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchSaveInstanceState</span><span class="params">(SparseArray&lt;Parcelable&gt; container)</span></span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.dispatchSaveInstanceState(container);</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> count = mChildrenCount;</span><br><span class="line">	<span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">		View c = children[i];</span><br><span class="line">		<span class="keyword">if</span> ((c.mViewFlags &amp; PARENT_SAVE_DISABLED_MASK) != PARENT_SAVE_DISABLED) &#123;</span><br><span class="line">			c.dispatchSaveInstanceState(container);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码很好理解：它不但保存自己的状态，还遍历所有的子View，调用他们的dispatchSaveInstanceState方法去保存数据。</p>
<h3 id="View数据保存总结"><a href="#View数据保存总结" class="headerlink" title="View数据保存总结"></a>View数据保存总结</h3><p>综上，View本身的数据保存机制是这样的: <strong>Activity会触发根ViewGroup将该命令传达给所有的子View，同时传递一个SparseArray给它们。View调用自己的onSaveInstanceState()将自己的状态以<id, state="">方式存储到SparseArray中去，最终SparseArray会被保存到outState中。</id,></strong></p>
<p>现在解答前面说到的一个问题：id唯一的必要性。平时编码中id仅用于定位View，所以如果能实现这个功能，即使Id重复也没有关系。但是在保存状态的时候，因为Key就是id，如果id重复，那会怎么样呢？保存的时候数据会被覆盖，恢复的时候相同id的View会被以同样的数据恢复，很多人都遇到这样的问题，原因就在于此。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>这里通过以TextView为🌰看一下实际的情况:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Parcelable <span class="title">onSaveInstanceState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Parcelable superState = <span class="keyword">super</span>.onSaveInstanceState();</span><br><span class="line">	<span class="comment">// Save state if we are forced to</span></span><br><span class="line">	<span class="keyword">boolean</span> save = mFreezesText;</span><br><span class="line">	<span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (mText != <span class="keyword">null</span>) &#123;</span><br><span class="line">		start = getSelectionStart();</span><br><span class="line">		end = getSelectionEnd();</span><br><span class="line">		<span class="keyword">if</span> (start &gt;= <span class="number">0</span> || end &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">// Or save state if there is a selection</span></span><br><span class="line">			save = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (save) &#123;</span><br><span class="line">		SavedState ss = <span class="keyword">new</span> SavedState(superState);</span><br><span class="line">		<span class="comment">// XXX Should also save the current scroll position!</span></span><br><span class="line">		ss.selStart = start;</span><br><span class="line">		ss.selEnd = end;</span><br><span class="line">		<span class="keyword">if</span> (mText <span class="keyword">instanceof</span> Spanned) &#123;</span><br><span class="line">			Spannable sp = <span class="keyword">new</span> SpannableStringBuilder(mText);</span><br><span class="line">			<span class="keyword">if</span> (mEditor != <span class="keyword">null</span>) &#123;</span><br><span class="line">				removeMisspelledSpans(sp);</span><br><span class="line">				sp.removeSpan(mEditor.mSuggestionRangeSpan);</span><br><span class="line">			&#125;</span><br><span class="line">			ss.text = sp;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			ss.text = mText.toString();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (isFocused() &amp;&amp; start &gt;= <span class="number">0</span> &amp;&amp; end &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			ss.frozenWithFocus = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ss.error = getError();</span><br><span class="line">		<span class="keyword">return</span> ss;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> superState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如代码所示，TextView就通过这个方法保存了它显示的text，不过开发者可以通过设置mFreezesText控制否要保存。读者有兴趣还可以去看看ScrollView这个方法的实现。</p>
<p>##总结<br><strong>数据恢复的过程和数据保存的流程类似，此处略去不表。</strong></p>
<p>从开发经验来看，Android上回收资源发生的比较频繁，做好状态保存恢复工作对于提升用户体验有很大帮助。文章主要阐述了View状态保存恢复的过程，有助于开发者更好的利用该机制: </p>
<ol>
<li>注意id问题——粗暴的方式问题也不大，但是如果粗暴已经引起了设计或者实现问题，可以考虑View的内建机制，出现问题的时候，id的重复也可以作为一个考虑方向;</li>
<li>如果想写一个CustomView并且想保存状态，可以通过重载onSaveInstanceState()方法实现，恢复也有响应的方式，简单优雅且不依赖于使用者;</li>
</ol>
</div><div class="tags"><a href="/tags/源码/">源码</a></div><div class="post-nav"><a href="/2015/10/17/Movie/" class="pre">那些年计划看的电影</a><a href="/2015/10/17/Volley-za-tan/" class="next">Volley杂谈</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">59</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactiveX/">ReactiveX</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/后端/">后端</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/影视/">影视</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/电影/">电影</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Gitbook/" style="font-size: 15px;">Gitbook</a> <a href="/tags/Runtime/" style="font-size: 15px;">Runtime</a> <a href="/tags/视图/" style="font-size: 15px;">视图</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/权限/" style="font-size: 15px;">权限</a> <a href="/tags/代码优化/" style="font-size: 15px;">代码优化</a> <a href="/tags/Framework/" style="font-size: 15px;">Framework</a> <a href="/tags/性能优化/" style="font-size: 15px;">性能优化</a> <a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/合集/" style="font-size: 15px;">合集</a> <a href="/tags/ADB/" style="font-size: 15px;">ADB</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/反编译/" style="font-size: 15px;">反编译</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/Gradle/" style="font-size: 15px;">Gradle</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/基础/" style="font-size: 15px;">基础</a> <a href="/tags/效率/" style="font-size: 15px;">效率</a> <a href="/tags/MarkDown/" style="font-size: 15px;">MarkDown</a> <a href="/tags/电影/" style="font-size: 15px;">电影</a> <a href="/tags/Reactive/" style="font-size: 15px;">Reactive</a> <a href="/tags/AIDL/" style="font-size: 15px;">AIDL</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/驱动/" style="font-size: 15px;">驱动</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/日志/" style="font-size: 15px;">日志</a> <a href="/tags/事件/" style="font-size: 15px;">事件</a> <a href="/tags/代码设计/" style="font-size: 15px;">代码设计</a> <a href="/tags/网络/" style="font-size: 15px;">网络</a> <a href="/tags/测试/" style="font-size: 15px;">测试</a> <a href="/tags/Binder/" style="font-size: 15px;">Binder</a> <a href="/tags/Groovy/" style="font-size: 15px;">Groovy</a> <a href="/tags/Loader/" style="font-size: 15px;">Loader</a> <a href="/tags/RAC/" style="font-size: 15px;">RAC</a> <a href="/tags/事件处理/" style="font-size: 15px;">事件处理</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/10/30/AIDL-原理分析/">AIDL 原理分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/30/App-启动过程/">App 启动过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/PMS-解析/">PMS 解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/WMS-解析/">WindowManagerService 解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/AMS-解析/">AMS 解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/10/The-Good-Wife/">The-Good-Wife</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/10/Black-Sails/">黑帆</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/29/hello-world/">Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/23/XCode-8-2-1-ClangFormat-插件安装/">XCode 8.2.1 ClangFormat 插件安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/07/SourceTree-分支图谱/">SourceTree 分支图谱</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">蜗牛壳.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>