<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="李全民的个人博客"><title>Loader &amp; LoaderManager源码分析 | 蜗牛壳</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-65882749-1','auto');ga('send','pageview');</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Loader &amp; LoaderManager源码分析</h1><a id="logo" href="/.">蜗牛壳</a><p class="description">计算机只有 0 和 1 ，但世界是连续的</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Loader &amp; LoaderManager源码分析</h1><div class="post-meta">Dec 17, 2015<span> | </span><span class="category"><a href="/categories/Android/">Android</a></span></div><div class="post-content"><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>【环境】代码分析基于 supportv4包。</p>
<h2 id="Loader的介绍和使用"><a href="#Loader的介绍和使用" class="headerlink" title="Loader的介绍和使用"></a>Loader的介绍和使用</h2><p>加载器: 用于在Activity和Fragment中异步加载数据，它有以下特性:</p>
<ol>
<li><strong>异步数据管理</strong> 除了可以异步加载数据，还能在数据源更新的时候通知上层;</li>
<li><strong>生命周期管理</strong> 和Activity、Fragment的生命周期绑定，在Activity的配置变化的时候仍然能够继续在后台运行;</li>
<li><strong>缓存数据</strong> 如果有异步数据无法分发，它可以缓存数据直到有接收者出现，比如在Activity重建期间;</li>
<li><strong>防止内存泄露</strong> 不会影响Context对象的回收，因为它只依赖于Application Context;</li>
</ol>
<p>详细介绍和用法可以看<a href="http://developer.android.com/intl/zh-cn/guide/components/loaders.html" target="_blank" rel="noopener">官网文档</a>。<a id="more"></a></p>
<blockquote>
<p>开发官网已经逐步国际化了，现在能看中文版啦，唯一要求就是翻·个·墙。</p>
</blockquote>
<h2 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h2><p>我们从使用代码切入，调用一个Loader只需要如下代码即可:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数的具体类型见下面的方法</span></span><br><span class="line">getLoaderManager().initLoader(<span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<p>我们来看一下initLoader（位于LoaderManagerImpl中）:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;D&gt; <span class="function">Loader&lt;D&gt; <span class="title">initLoader</span><span class="params">(<span class="keyword">int</span> id, Bundle args, LoaderManager.LoaderCallbacks&lt;D&gt; callback)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mCreatingLoader) &#123;<span class="comment">//表示正在创建中</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Called while creating a loader"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	LoaderInfo info = mLoaders.get(id);</span><br><span class="line">        </span><br><span class="line">	<span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"initLoader in "</span> + <span class="keyword">this</span> + <span class="string">": args="</span> + args);</span><br><span class="line">	<span class="keyword">if</span> (info == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// Loader doesn't already exist; create.</span></span><br><span class="line">		info = createAndInstallLoader(id, args,  (LoaderManager.LoaderCallbacks&lt;Object&gt;)callback);</span><br><span class="line">		<span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"  Created new loader "</span> + info);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"  Re-using existing loader "</span> + info);</span><br><span class="line">		info.mCallbacks = (LoaderManager.LoaderCallbacks&lt;Object&gt;)callback;</span><br><span class="line">	&#125;</span><br><span class="line">   <span class="comment">//这个点要额外注意: 这里就是从已经存在的Loader中获取数据，比如Activity配置变化的时候——实现了前面说的第三点特性，数据缓存。</span></span><br><span class="line">	<span class="keyword">if</span> (info.mHaveData &amp;&amp; mStarted) &#123;</span><br><span class="line">		<span class="comment">// If the loader has already generated its data, report it now.</span></span><br><span class="line">		info.callOnLoadFinished(info.mLoader, info.mData);</span><br><span class="line">	&#125;</span><br><span class="line">        </span><br><span class="line">	<span class="keyword">return</span> (Loader&lt;D&gt;)info.mLoader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先看一下mLoaders变量:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> SparseArrayCompat&lt;LoaderInfo&gt; mLoaders = <span class="keyword">new</span> SparseArrayCompat&lt;LoaderInfo&gt;();</span><br></pre></td></tr></table></figure>
<p>它是一个从id到LoaderInfo的映射，从代码可以看出，如果没有对应的LoaderInfo，就createAndInstallLoader，否则，更新一下callback。如果LoadInfo记录这个Loader已经启动运行并且保存了之前的数据，那么直接调用回调函数，调用的是LoadInfo的callOnLoadFinished方法。最后返回创建出来的Loader。很明显重点在于createAndInstallLoader方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> LoaderInfo <span class="title">createAndInstallLoader</span><span class="params">(<span class="keyword">int</span> id, Bundle args, LoaderManager.LoaderCallbacks&lt;Object&gt; callback)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		mCreatingLoader = <span class="keyword">true</span>;<span class="comment">//1. 设置标志</span></span><br><span class="line">		LoaderInfo info = createLoader(id, args, callback);<span class="comment">//2. 创建</span></span><br><span class="line">		installLoader(info);<span class="comment">//3. install</span></span><br><span class="line">		<span class="keyword">return</span> info;</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		mCreatingLoader = <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里设置了一个标志位mCreatingLoader，表示正在创建Loader，整个过程分为create和install两步。</p>
<h3 id="Loader的create过程"><a href="#Loader的create过程" class="headerlink" title="Loader的create过程"></a>Loader的create过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> LoaderInfo <span class="title">createLoader</span><span class="params">(<span class="keyword">int</span> id, Bundle args, LoaderManager.LoaderCallbacks&lt;Object&gt; callback)</span> </span>&#123;</span><br><span class="line">	LoaderInfo info = <span class="keyword">new</span> LoaderInfo(id, args, callback);</span><br><span class="line">	Loader&lt;Object&gt; loader = callback.onCreateLoader(id, args);</span><br><span class="line">	info.mLoader = loader;</span><br><span class="line">	<span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建过程很简单，创建一个LoaderInfo，从回调的onCreateLoader中获取对应的Loader，再将Loader设置到LoaderInfo中，这样LoaderInfo将保存着有关Loader的所有信息：id，args以及Loader本身。</p>
<h3 id="Loader的install过程"><a href="#Loader的install过程" class="headerlink" title="Loader的install过程"></a>Loader的install过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">installLoader</span><span class="params">(LoaderInfo info)</span> </span>&#123;</span><br><span class="line">	mLoaders.put(info.mId, info);</span><br><span class="line">	<span class="keyword">if</span> (mStarted) &#123;</span><br><span class="line">		<span class="comment">// The activity will start all existing loaders in it's onStart(),</span></span><br><span class="line">		<span class="comment">// so only start them here if we're past that point of the activitiy's</span></span><br><span class="line">		<span class="comment">// life cycle</span></span><br><span class="line">		info.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先将LoaderInfo保存到mLoaders中，如果已经start过了，就调用LoaderInfo的start方法。注意方法内部这段注释：<strong>Activity在onStart()方法中会启动所有的loaders，所以只有在onStart()之后还没有启动的Loader才会在这里启动</strong>。</p>
<p>从官网例子中可以看到，我们只需要调用initLoader方法即可，并不需要手动启动加载过程，再加上上面的注释，我们可以猜测: Loader的数据加载是由Activity/Fragment的生命周期方法启动的，下面就来分析一下。</p>
<h3 id="Loader的启动过程"><a href="#Loader的启动过程" class="headerlink" title="Loader的启动过程"></a>Loader的启动过程</h3><p>在supportv4的FragmentActivity中，查看其onStart方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.onStart();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="comment">//最后三行代码</span></span><br><span class="line">	mFragments.doLoaderStart();</span><br><span class="line"></span><br><span class="line">	mFragments.dispatchStart();</span><br><span class="line">	mFragments.reportLoaderStart();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mFragments是FragmentManager类型，这里就调用了它的doLoaderStart()方法——这里表明：<strong>为了Loader在Activity和Fragment中都能使用，同时逻辑一致，Loader是通过FragmentManager进行管理的，Activity只是引用了FragmentManager的实例。</strong></p>
<blockquote>
<p>【特别注意】这里还调用了一个和Loader相关的方法:reportLoaderStart。这个方法后面讲retain的时候会用到，暂时不用关注。</p>
</blockquote>
<p>我们来看一下FragmentManager的doLoaderStart()方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doLoaderStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mLoadersStarted) &#123;<span class="comment">//只能Start一次</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mLoadersStarted = <span class="keyword">true</span>;<span class="comment">//标记开始</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mLoaderManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">		mLoaderManager.doStart();</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mCheckedForLoaderManager) &#123;</span><br><span class="line">		mLoaderManager = getLoaderManager(<span class="string">"(root)"</span>, mLoadersStarted, <span class="keyword">false</span>);</span><br><span class="line">		<span class="comment">// the returned loader manager may be a new one, so we have to start it</span></span><br><span class="line">		<span class="keyword">if</span> ((mLoaderManager != <span class="keyword">null</span>) &amp;&amp; (!mLoaderManager.mStarted)) &#123;</span><br><span class="line">			mLoaderManager.doStart();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	mCheckedForLoaderManager = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会初始化LoaderManager，并调用它的doStart()方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Starting in "</span> + <span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">if</span> (mStarted) &#123;</span><br><span class="line">		RuntimeException e = <span class="keyword">new</span> RuntimeException(<span class="string">"here"</span>);</span><br><span class="line">		e.fillInStackTrace();</span><br><span class="line">		Log.w(TAG, <span class="string">"Called doStart when already started: "</span> + <span class="keyword">this</span>, e);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//start之后就会设置标志位，还记得前面LoaderManager.installLoader方法对这个参数的使用么？</span></span><br><span class="line">	mStarted = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Call out to sub classes so they can start their loaders</span></span><br><span class="line">	<span class="comment">// Let the existing loaders know that we want to be notified when a load is complete</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = mLoaders.size()-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		mLoaders.valueAt(i).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里又看到了mStarted标志位，很明显，一个LoaderManager启动两次是会打印异常信息的(不会crash)。然后遍历mLoaders中的所有的LoaderInfo，调用start()方法启动。</p>
<h3 id="又见start-方法"><a href="#又见start-方法" class="headerlink" title="又见start()方法"></a>又见start()方法</h3><p>前面的分析中，不论Loader是在Activity的onStrat()方法之前还是之后调用的，最终启动都是调用的Loader的start()方法。下面我们来看LoaderInfo的start()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//A</span></span><br><span class="line">	<span class="keyword">if</span> (mRetaining &amp;&amp; mRetainingStarted) &#123;</span><br><span class="line">		<span class="comment">// Our owner is started, but we were being retained from a</span></span><br><span class="line">		<span class="comment">// previous instance in the started state...  so there is really</span></span><br><span class="line">		<span class="comment">// nothing to do here, since the loaders are still started.</span></span><br><span class="line">		mStarted = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//B</span></span><br><span class="line">	<span class="keyword">if</span> (mStarted) &#123;</span><br><span class="line">		<span class="comment">// If loader already started, don't restart.</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mStarted = <span class="keyword">true</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"  Starting: "</span> + <span class="keyword">this</span>);</span><br><span class="line">	<span class="comment">//Loader为Null则尝试去创建Loader</span></span><br><span class="line">	<span class="keyword">if</span> (mLoader == <span class="keyword">null</span> &amp;&amp; mCallbacks != <span class="keyword">null</span>) &#123;</span><br><span class="line">		mLoader = mCallbacks.onCreateLoader(mId, mArgs);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (mLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (mLoader.getClass().isMemberClass() &amp;&amp; !Modifier.isStatic(mLoader.getClass().getModifiers())) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Object returned from onCreateLoader must not be a non-static inner member class: "</span></span><br><span class="line">                            + mLoader);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!mListenerRegistered) &#123;</span><br><span class="line">			mLoader.registerListener(mId, <span class="keyword">this</span>);</span><br><span class="line">			mLoader.registerOnLoadCanceledListener(<span class="keyword">this</span>);</span><br><span class="line">			mListenerRegistered = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		mLoader.startLoading();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里在进入正常流程之前会做两个判断：</p>
<p><strong>A处</strong>  如果一个LoaderInfo已经被retain过，且retain之前已经start了，则标记一下mStarted为true，直接返回(<strong>关于retain的含义，见后面的解释，这里不需要纠结，知道有这个条件判断就好</strong>)；<br><strong>B处</strong>  如果Loader已经启动了，不需要打断或者做别的处理，直接返回；  </p>
<p><strong>如果Loader是成员类，并且不是static的，则会抛出异常（这里会直接抛异常，比handler更加严厉）。</strong>之后在Loader上注册监听，这两个监听是OnLoadCompleteListener和OnLoadCanceledListener(注: LoaderInfo类实现了这两个接口)，分别监听加载完成和加载取消两个事件。最后调用Loader的startLoading方法开始加载。</p>
<h3 id="Loader的load过程"><a href="#Loader的load过程" class="headerlink" title="Loader的load过程"></a>Loader的load过程</h3><p>Loader的startLoading方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startLoading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	mStarted = <span class="keyword">true</span>;</span><br><span class="line">	mReset = <span class="keyword">false</span>;</span><br><span class="line">	mAbandoned = <span class="keyword">false</span>;</span><br><span class="line">	onStartLoading();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Subclasses must implement this to take care of loading their data,</span></span><br><span class="line"><span class="comment"> * as per &#123;<span class="doctag">@link</span> #startLoading()&#125;.  This is not called by clients directly,</span></span><br><span class="line"><span class="comment"> * but as a result of a call to &#123;<span class="doctag">@link</span> #startLoading()&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStartLoading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码，设置flag之后，startLoading就调用了onStartLoading方法，根据注释，子类必须实现这个方法来加载数据。Loader本身是一个接近接口的具体类，实际的代码量很少，读者可以去看它的源码，与前面提到的异步过程没有关系，这是一个很原始的类，实际使用的时候，比较常用的类是<strong>AsyncTaskLoader</strong>，它的源码分析见另外一篇文章。</p>
<p>OK，到这里，Loader的初始化和启动加载过程已经讲完了。我们只需要在onStartLoading()中加载数据即可。先不要好奇数据怎么抛到调用层，前面说了，因为Loader很原始，方法之间的关系没有建立，这块需要去AsyncTaskLoader中体现。</p>
<h2 id="Loader的停止过程"><a href="#Loader的停止过程" class="headerlink" title="Loader的停止过程"></a>Loader的停止过程</h2><p>有了上述创建启动过程，分析停止过程的切入点就比较好找了。根据经验，在Activity的onStart()方法有创建方法，则在对应的onStop()方法中应该就停止方法。onStop()方法比较绕，但是追踪一下不难发现最终会调用到这个方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onReallyStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	mFragments.doLoaderStop(mRetaining);</span><br><span class="line">	mFragments.dispatchReallyStop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就调用了FragmentController的doLoaderStop方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doLoaderStop</span><span class="params">(<span class="keyword">boolean</span> retain)</span> </span>&#123;</span><br><span class="line">	mRetainLoaders = retain;</span><br><span class="line">	<span class="keyword">if</span> (mLoaderManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!mLoadersStarted) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	mLoadersStarted = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (retain) &#123;</span><br><span class="line">		mLoaderManager.doRetain();</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		mLoaderManager.doStop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里在LoaderManager不为null且已经启动的情况下，根据retain判断决定调用LoaderManager的方法。</p>
<h3 id="Loader的retain过程"><a href="#Loader的retain过程" class="headerlink" title="Loader的retain过程"></a>Loader的retain过程</h3><p>retain是从外部传出来的，Activity正常stop的时候，这个值为false，但是下面情况是true的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">onRetainNonConfigurationInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mStopped) &#123;</span><br><span class="line">		doReallyStop(<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//·····</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此比如转屏的时候，我们只是做retain，而不是stop。LoaderInfo的retain方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">retain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"  Retaining: "</span> + <span class="keyword">this</span>);</span><br><span class="line">	mRetaining = <span class="keyword">true</span>;</span><br><span class="line">	mRetainingStarted = mStarted;</span><br><span class="line">	mStarted = <span class="keyword">false</span>;</span><br><span class="line">	mCallbacks = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边只是这是一些标志位。并且将<strong>mCallbacks设置为Null</strong>(防止内存泄露)。这边涉及到两个flag——mRetainingStarted和mStarted。前面start()的时候用到了这两个参数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mRetaining &amp;&amp; mRetainingStarted) &#123;</span><br><span class="line">	mStarted = <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详细的retain情况后面补充介绍，了解主流程的话到这里就基本可以了。</p>
<h3 id="Loader的stop过程"><a href="#Loader的stop过程" class="headerlink" title="Loader的stop过程"></a>Loader的stop过程</h3><p>LoaderManager的doStop方法是这样的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Stopping in "</span> + <span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">if</span> (!mStarted) &#123;</span><br><span class="line">		RuntimeException e = <span class="keyword">new</span> RuntimeException(<span class="string">"here"</span>);</span><br><span class="line">		e.fillInStackTrace();</span><br><span class="line">		Log.w(TAG, <span class="string">"Called doStop when not started: "</span> + <span class="keyword">this</span>, e);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = mLoaders.size()-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		mLoaders.valueAt(i).stop();</span><br><span class="line">	&#125;</span><br><span class="line">	mStarted = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有start的时候，是不允许执行stop的，会打印异常信息(同样不会引起crash)。否则遍历所有的LoaderInfo，调用stop()方法，也就是执行下面的方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"  Stopping: "</span> + <span class="keyword">this</span>);</span><br><span class="line">	mStarted = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (!mRetaining) &#123;</span><br><span class="line">		<span class="keyword">if</span> (mLoader != <span class="keyword">null</span> &amp;&amp; mListenerRegistered) &#123;</span><br><span class="line">			<span class="comment">// Let the loader know we're done with it</span></span><br><span class="line">			mListenerRegistered = <span class="keyword">false</span>;</span><br><span class="line">			mLoader.unregisterListener(<span class="keyword">this</span>);</span><br><span class="line">			mLoader.unregisterOnLoadCanceledListener(<span class="keyword">this</span>);</span><br><span class="line">			mLoader.stopLoading();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在没有retain的情况下，主要是取消监听并且调用Loader的stopLoading方法，注意这边调用stopLoading的条件是很苛刻的(PS: 这边这个写法可能有些问题，注册动作和stop不应该有这么强的关系)。Loader里面的stop方法很简单:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopLoading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	mStarted = <span class="keyword">false</span>;</span><br><span class="line">	onStopLoading();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Subclasses must implement this to take care of stopping their loader,</span></span><br><span class="line"><span class="comment"> * as per &#123;<span class="doctag">@link</span> #stopLoading()&#125;.  This is not called by clients directly,</span></span><br><span class="line"><span class="comment"> * but as a result of a call to &#123;<span class="doctag">@link</span> #stopLoading()&#125;.</span></span><br><span class="line"><span class="comment"> * This will always be called from the process's main thread.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStopLoading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和startLoading()很像，同样子类需要去覆盖实现onStopLoading完成加载。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="Loader的retain过程-1"><a href="#Loader的retain过程-1" class="headerlink" title="Loader的retain过程"></a>Loader的retain过程</h3><p>前面说start的时候，留了一个和retain有关的方法:reportLoaderStart，我们看一下这个方法在做什么。这个方法最终会调用FragmentHostCallback的reportLoaderStart方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reportLoaderStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mAllLoaderManagers != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> N = mAllLoaderManagers.size();</span><br><span class="line">		LoaderManagerImpl loaders[] = <span class="keyword">new</span> LoaderManagerImpl[N];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=N-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">			loaders[i] = (LoaderManagerImpl) mAllLoaderManagers.valueAt(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">			LoaderManagerImpl lm = loaders[i];</span><br><span class="line">			lm.finishRetain();</span><br><span class="line">			lm.doReportStart();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里涉及到mAllLoaderManagers变量，它的声明是这样的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The loader managers for individual fragments [i.e. Fragment#getLoaderManager()] */</span></span><br><span class="line"><span class="keyword">private</span> SimpleArrayMap&lt;String, LoaderManager&gt; mAllLoaderManagers;</span><br></pre></td></tr></table></figure>
<p>是一个从String到LoaderManager的映射，另外从变量名称可以看出，这里应该集合了属于Activity的所有的LoaderManager。搜索它被使用的地方可以看到:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LoaderManagerImpl <span class="title">getLoaderManager</span><span class="params">(String who, <span class="keyword">boolean</span> started, <span class="keyword">boolean</span> create)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mAllLoaderManagers == <span class="keyword">null</span>) &#123;</span><br><span class="line">		mAllLoaderManagers = <span class="keyword">new</span> SimpleArrayMap&lt;String, LoaderManager&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">	LoaderManagerImpl lm = (LoaderManagerImpl) mAllLoaderManagers.get(who);</span><br><span class="line">	<span class="keyword">if</span> (lm == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (create) &#123;</span><br><span class="line">			lm = <span class="keyword">new</span> LoaderManagerImpl(who, <span class="keyword">this</span>, started);</span><br><span class="line">			mAllLoaderManagers.put(who, lm);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		lm.updateHostController(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> lm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是以一种putIfAbsent的方式在创建LoaderManagerImpl，这个方法是包内可见的，我在FragmentActivity和Fragment中getSupportLoaderManager方法和getLoaderManager方法，发现最终都是调用到这个方法获取属于Activity/Fragment的LoaderManager。读者细心的话，应该在doLoaderStart中就注意到它了:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mLoaderManager = getLoaderManager(<span class="string">"(root)"</span>, mLoadersStarted, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>
<p>而在Fragment中，这个方法调用的地方就更多了，比如onStart()中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	mCalled = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!mLoadersStarted) &#123;</span><br><span class="line">		mLoadersStarted = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (!mCheckedForLoaderManager) &#123;</span><br><span class="line">			mCheckedForLoaderManager = <span class="keyword">true</span>;</span><br><span class="line">			mLoaderManager = mHost.getLoaderManager(mWho, mLoadersStarted, <span class="keyword">false</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (mLoaderManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">			mLoaderManager.doStart();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而mWho的设置是这样的，其实可以认为是Fragment的一个Tag:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setIndex</span><span class="params">(<span class="keyword">int</span> index, Fragment parent)</span> </span>&#123;</span><br><span class="line">	mIndex = index;</span><br><span class="line">	<span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">		mWho = parent.mWho + <span class="string">":"</span> + mIndex;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		mWho = <span class="string">"android:fragment:"</span> + mIndex;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再往上就不追溯了，总之每一个Fragment自身都会有一个独有的mWho，而这个参数又被用来标识一个LoaderManager。因此这里不难猜测出Loader和Fragment、Activity的关系:</p>
<p><strong>在一个Activity中，可以有N个Fragment，Activity和每一个Fragment都有自己的LoaderManager，其中Activity是以(root)标记的(为什么root是Activity的？可以从FragmentActivity的onStart方法看到，是先调用doLoaderStart，不管onStart之前是否调用了getLoaderManager，这里都会建立一个root为标记的LoaderManager，这个LoaderManager就是属于Activity的)，Fragment则是以自己的mWho属性标记的，它们都被记录在FragmentHostCallback的mAllLoaderManagers属性中(这个属性被FragmentHostCallback引用，FragmentHostCallback属性被FragmentController引用，FragmentController又被FragmentActivity引用)。</strong></p>
<p>试想一下一个Fragment被移除的过程？所有在它内部被创建的Loader都会被销毁掉，而不会影响到其余的Loader。</p>
<p>上面解释了一下所有的LoaderManager都被mAllLoaderManagers变量使用一个String索引着。我们回到前面reportLoaderStart的代码，再贴一下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reportLoaderStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mAllLoaderManagers != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> N = mAllLoaderManagers.size();</span><br><span class="line">		LoaderManagerImpl loaders[] = <span class="keyword">new</span> LoaderManagerImpl[N];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=N-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">			loaders[i] = (LoaderManagerImpl) mAllLoaderManagers.valueAt(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">			LoaderManagerImpl lm = loaders[i];</span><br><span class="line">			lm.finishRetain();</span><br><span class="line">			lm.doReportStart();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里遍历所有的LoaderManager的实例，调用他们的finishRetain和doReportStart方法。LoaderManager再将这些分发到响应的Loader中去。LoaderInfo中两个方法的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finishRetain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mRetaining) &#123;</span><br><span class="line">		<span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"  Finished Retaining: "</span> + <span class="keyword">this</span>);</span><br><span class="line">		mRetaining = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (mStarted != mRetainingStarted) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!mStarted) &#123;</span><br><span class="line">				<span class="comment">// This loader was retained in a started state, but</span></span><br><span class="line">				<span class="comment">// at the end of retaining everything our owner is</span></span><br><span class="line">				<span class="comment">// no longer started...  so make it stop.</span></span><br><span class="line">				stop();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mStarted &amp;&amp; mHaveData &amp;&amp; !mReportNextStart) &#123;</span><br><span class="line">		<span class="comment">// This loader has retained its data, either completely across</span></span><br><span class="line">		<span class="comment">// a configuration change or just whatever the last data set</span></span><br><span class="line">		<span class="comment">// was after being restarted from a stop, and now at the point of</span></span><br><span class="line"> 		<span class="comment">// finishing the retain we find we remain started, have</span></span><br><span class="line">		<span class="comment">// our data, and the owner has a new callback...  so</span></span><br><span class="line">		<span class="comment">// let's deliver the data now.</span></span><br><span class="line">		callOnLoadFinished(mLoader, mData);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reportStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mStarted) &#123;</span><br><span class="line">		<span class="keyword">if</span> (mReportNextStart) &#123;</span><br><span class="line">			mReportNextStart = <span class="keyword">false</span>;</span><br><span class="line">			<span class="keyword">if</span> (mHaveData) &#123;</span><br><span class="line">				callOnLoadFinished(mLoader, mData);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>finishRetain的时候，如果之前retain了，则停止掉(mRetaining置为true)。接下来的判断比较难以理解。首先明确一下mStarted和mRetainingStarted的含义: mStarted标记的是当前Loader是否start的状态，而mRetainingStarted标记的是Loader在retain之前的start状态。所以这个判断的含义是，如果当前的start状态和retain之前的start状态不一致，且当前的状态是未启动的，换句话说，之前是启动的，retain恢复之后又不启动了，那么可以认为这个Loader不再被需要了，因此直接stop掉——读者应当注意FragmentActivity.onStart()方法里面doLoaderStart()和reportLoaderStart()方法的调用顺序，是先全部启动Loader，再report的。</p>
<p>之后，如果Loader已经开始了，数据也有了，而且callback已经被更新了(环境重建)，那么我们就可以调用callOnLoadFinished分发数据了。reportStart类似。</p>
<blockquote>
<p>补充：从代码看，当Fragment的performDestroyView方法被调用，即Fragment被销毁的时候，所有属于它的LoaderInfo的mReportNextStart都会被标为true，reportStart()之后都会被标为false，当然初始化的时候也是false。</p>
</blockquote>
<p>callOnLoadFinished代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callOnLoadFinished</span><span class="params">(Loader&lt;Object&gt; loader, Object data)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mCallbacks != <span class="keyword">null</span>) &#123;</span><br><span class="line">		String lastBecause = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (mHost != <span class="keyword">null</span>) &#123;</span><br><span class="line">			lastBecause = mHost.mFragmentManager.mNoTransactionsBecause;</span><br><span class="line">			mHost.mFragmentManager.mNoTransactionsBecause = <span class="string">"onLoadFinished"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"  onLoadFinished in "</span> + loader + <span class="string">": "</span> + loader.dataToString(data));</span><br><span class="line">			<span class="comment">//分发数据</span></span><br><span class="line"> 			mCallbacks.onLoadFinished(loader, data);</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (mHost != <span class="keyword">null</span>) &#123;</span><br><span class="line">				mHost.mFragmentManager.mNoTransactionsBecause = lastBecause;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		mDeliveredData = <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果mCallbacks不为null，那么调用它的onLoadFinished分发数据。</p>
<h3 id="Loader的Restart过程"><a href="#Loader的Restart过程" class="headerlink" title="Loader的Restart过程"></a>Loader的Restart过程</h3><p>Loader的restart过程是通过<code>LoaderManager.restartLoader()</code>方法实现的。方法注释中说，重新创建一个ID指向的Loader，如果这个ID已经有绑定的Loader，那么这个Loader会被cancel、stop或者destroy，然后使用新的arguments创建一个Loader。这就是它与<code>LoaderManager.initLoader()</code>方法的区别——<strong>不存在重用</strong>。</p>
<p>因此，如果在组件的生命周期之间使用缓存数据(即数据不会变化)，则应该使用<code>LoaderManager.initLoader()</code>，如果可能变化，则应该使用<code>LoaderManager.restartLoader()</code>方法。</p>
<p>Restart过程从<code>LoaderManager.restartLoader()</code>方法切入即可，基于前面的解释，看懂这个方法并不困难，其中可以看到一些重要的方法是如何调用的，比如：LoaderCallbacks的<code>onLoaderReset()</code>方法，Loader的<code>onAbandon()</code>方法。请读者自行解析。</p>
<h2 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h2><ol>
<li>可以通过<code>Loader.forceLoad()</code>方法强制重新加载数据，数据加载完成会调用<code>onLoadFinished()</code>回调，也可以调用<code>Loader.cancelLoad()</code>取消回调，将不会受到任何回调;</li>
<li>在Activity、Fragment销毁的时候或者手动调用了<code>LoaderManager.destroyLoader(id)</code>方法的时候，Loader会被销毁，回调方法<code>onLoaderReset(Loader)</code>会被调用，表示数据失效，需要重置;</li>
<li>前面说了Loader可以监测数据的变化，但有时候数据变化过快，导致UI持续刷新，可以通过如下方法降低刷新频率: <code>setUpdateThrottle(long delayMs)</code>;</li>
</ol>
<p>Loader数据加载相关方法执行流程如下:<br><img src="http://7xktd8.com1.z0.glb.clouddn.com/Loader数据加载.png" alt="Loader数据加载"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上解析了Loader是如何初始化并启动的，整个数据的加载和停止又是如何绑定到Activity和Fragment的生命周期的。</p>
<p>然而Loader本身的用处并不大，因为Loader本身没有任何的异步调度，直接使用Loader进行开发显得太过原始，开发中一般会使用<strong>AsyncTaskLoader</strong>。AsyncTaskLoader结合了<a href="http://www.muzileecoding.com/androidsource/Android-AsyncTask.html" target="_blank" rel="noopener">AsyncTask</a>和Loader的机制，将数据加载方到了异步任务中(源码里是通过LoadTask实现的)，并重新声明了一些回调函数，有力的支持了Activity和Fragment的异步加载数据任务。</p>
<blockquote>
<p><strong>AsyncTaskLoader</strong>并不依赖于平台的AsyncTask，因为平台的AsyncTask并行或者串行执行任务是随着平台版本变化的。</p>
<p><strong>AsyncTaskLoader</strong>会尽可能的减少任务的数量，如果我们调用<code>forceLoader()</code>方法，前面的相同任务会被取消掉，是不会有任何回调的。</p>
</blockquote>
<p>对于数据库查询，Loader还有一个子类叫做：CursorLoader，读者有兴趣也可以去看一下。</p>
<h3 id="自定义Loader"><a href="#自定义Loader" class="headerlink" title="自定义Loader"></a>自定义Loader</h3><p>如总结所说，Loader本身的功能很弱，虽然有AsyncTaskLoader和CursorLoader等具体类支持，但是开发者仍可能有需求需要自定义一个Loader，这时候参考实现如下特性:</p>
<ol>
<li>Loader的生命周期;</li>
<li>后台数据加载;</li>
<li>数据管理;</li>
<li>发送缓存结果;</li>
</ol>
<p>Loader的生命周期方法轮转如下:</p>
<p><img src="http://7xktd8.com1.z0.glb.clouddn.com/Loader状态.png" alt="Loader状态"><br>这其中涉及到一些重要方法的实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startLoading</span><span class="params">()</span> -&gt; <span class="keyword">void</span> <span class="title">onStartLoading</span><span class="params">()</span> <span class="keyword">void</span> <span class="title">stopLoading</span><span class="params">()</span> -&gt; <span class="keyword">void</span> <span class="title">onStopLoading</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> -&gt; <span class="keyword">void</span> <span class="title">onReset</span><span class="params">()</span><span class="keyword">void</span> <span class="title">abandon</span><span class="params">()</span> -&gt; <span class="keyword">void</span> <span class="title">onAbandon</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<p>以及<code>forceLoad ()</code>方法的实现，这些方法在Loader类中都有详细的注释，具体实现可以参考注释以及AsyncTaskLoader的实现。</p>
<h3 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h3><p>监控数据变化的方式: </p>
<ol>
<li>使用Java的Observable和Observer;</li>
<li>广播告知;</li>
<li>FileObserver——监控一个路径上的文件变化;</li>
</ol>
<blockquote>
<p>PS: 自定义的时候可以仔细研究一下AsyncTaskLoader的实现。</p>
</blockquote>
</div><div class="tags"><a href="/tags/源码/">源码</a><a href="/tags/Loader/">Loader</a></div><div class="post-nav"><a href="/2016/01/29/Groovy-install-and-ide-plugin/" class="pre">Groovy 安装和 Eclipse 插件安装</a><a href="/2015/12/14/Android-adapt-ued-mark-convert/" class="next">Android适配之UED标注转换</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">59</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactiveX/">ReactiveX</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/后端/">后端</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/影视/">影视</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/电影/">电影</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Gitbook/" style="font-size: 15px;">Gitbook</a> <a href="/tags/Runtime/" style="font-size: 15px;">Runtime</a> <a href="/tags/视图/" style="font-size: 15px;">视图</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/权限/" style="font-size: 15px;">权限</a> <a href="/tags/代码优化/" style="font-size: 15px;">代码优化</a> <a href="/tags/Framework/" style="font-size: 15px;">Framework</a> <a href="/tags/性能优化/" style="font-size: 15px;">性能优化</a> <a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/合集/" style="font-size: 15px;">合集</a> <a href="/tags/ADB/" style="font-size: 15px;">ADB</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/反编译/" style="font-size: 15px;">反编译</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/Gradle/" style="font-size: 15px;">Gradle</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/基础/" style="font-size: 15px;">基础</a> <a href="/tags/效率/" style="font-size: 15px;">效率</a> <a href="/tags/MarkDown/" style="font-size: 15px;">MarkDown</a> <a href="/tags/电影/" style="font-size: 15px;">电影</a> <a href="/tags/Reactive/" style="font-size: 15px;">Reactive</a> <a href="/tags/AIDL/" style="font-size: 15px;">AIDL</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/驱动/" style="font-size: 15px;">驱动</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/日志/" style="font-size: 15px;">日志</a> <a href="/tags/事件/" style="font-size: 15px;">事件</a> <a href="/tags/代码设计/" style="font-size: 15px;">代码设计</a> <a href="/tags/网络/" style="font-size: 15px;">网络</a> <a href="/tags/测试/" style="font-size: 15px;">测试</a> <a href="/tags/Binder/" style="font-size: 15px;">Binder</a> <a href="/tags/Groovy/" style="font-size: 15px;">Groovy</a> <a href="/tags/Loader/" style="font-size: 15px;">Loader</a> <a href="/tags/RAC/" style="font-size: 15px;">RAC</a> <a href="/tags/事件处理/" style="font-size: 15px;">事件处理</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/10/30/AIDL-原理分析/">AIDL 原理分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/30/App-启动过程/">App 启动过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/PMS-解析/">PMS 解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/WMS-解析/">WindowManagerService 解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/AMS-解析/">AMS 解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/10/The-Good-Wife/">The-Good-Wife</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/10/Black-Sails/">黑帆</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/29/hello-world/">Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/23/XCode-8-2-1-ClangFormat-插件安装/">XCode 8.2.1 ClangFormat 插件安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/07/SourceTree-分支图谱/">SourceTree 分支图谱</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">蜗牛壳.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>