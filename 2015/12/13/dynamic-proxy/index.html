<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="李全民的个人博客"><title>Java动态代理实现 | 蜗牛壳</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-65882749-1','auto');ga('send','pageview');</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java动态代理实现</h1><a id="logo" href="/.">蜗牛壳</a><p class="description">计算机只有 0 和 1 ，但世界是连续的</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java动态代理实现</h1><div class="post-meta">Dec 13, 2015<span> | </span><span class="category"><a href="/categories/Java/">Java</a></span></div><div class="post-content"><p>本文整理自《Thinking In Java》和 IBM 技术博客<a href="https://www.ibm.com/developerworks/cn/java/j-lo-proxy1/" target="_blank" rel="noopener">Java 动态代理机制分析及扩展</a>，对动态类的生成部分做了补充。<a id="more"></a></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>例子来自《Thinking In Java》。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodSelector</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> Object proxied;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">MethodSelector</span><span class="params">(Object proxied)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.proxied = proxied;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(method.getName().equals(<span class="string">"interesting"</span>))</span><br><span class="line">               print(<span class="string">"Proxy detected the interesting method"</span>);</span><br><span class="line">          <span class="keyword">return</span> method.invoke(proxied, args);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SomeMethods</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">boring1</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">boring2</span><span class="params">()</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">interesting</span><span class="params">(String arg)</span></span>;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">boring3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Implementation</span> <span class="keyword">implements</span> <span class="title">SomeMethods</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">boring1</span><span class="params">()</span> </span>&#123; print(<span class="string">"boring1"</span>); &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">boring2</span><span class="params">()</span> </span>&#123; print(<span class="string">"boring2"</span>); &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interesting</span><span class="params">(String arg)</span> </span>&#123;</span><br><span class="line">          print(<span class="string">"interesting "</span> + arg);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">boring3</span><span class="params">()</span> </span>&#123; print(<span class="string">"boring3"</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelectingMethods</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          SomeMethods proxy= (SomeMethods)Proxy.newProxyInstance(</span><br><span class="line">               SomeMethods.class.getClassLoader(),</span><br><span class="line">               <span class="keyword">new</span> Class[]&#123; SomeMethods.class &#125;,</span><br><span class="line">               <span class="keyword">new</span> MethodSelector(<span class="keyword">new</span> Implementation()));</span><br><span class="line">          proxy.boring1();</span><br><span class="line">          proxy.boring2();</span><br><span class="line">          proxy.interesting(<span class="string">"bonobo"</span>);</span><br><span class="line">          proxy.boring3();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">boring1</span><br><span class="line">boring2</span><br><span class="line">Proxy detected the interesting method</span><br><span class="line">interesting bonobo</span><br></pre></td></tr></table></figure>
<p>它的使用非常简单，重点就在于InvocationHandler的实现。这里可以对方法的调用做出转发，很像APO？</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="分析前提"><a href="#分析前提" class="headerlink" title="分析前提"></a>分析前提</h3><p>【环境】JDK 1.6<br>【代码】<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b27/java/lang/reflect/Proxy.java#Proxy.newProxyInstance%28java.lang.ClassLoader%2Cjava.lang.Class%5B%5D%2Cjava.lang.reflect.InvocationHandler%29" target="_blank" rel="noopener">Proxy.java</a></p>
<h3 id="代理机制及其特点"><a href="#代理机制及其特点" class="headerlink" title="代理机制及其特点"></a>代理机制及其特点</h3><p>首先让我们来了解一下如何使用 Java 动态代理。具体有如下四步骤：</p>
<ol>
<li>通过实现 InvocationHandler 接口创建自己的调用处理器；</li>
<li>通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类；</li>
<li>通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型；</li>
<li>通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入；</li>
</ol>
<p>而实际使用的时候，我们只需要做如下两步:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InvocationHandlerImpl 实现了 InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发</span></span><br><span class="line">InvocationHandler handler = <span class="keyword">new</span> InvocationHandlerImpl(..); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 Proxy 直接创建动态代理类实例</span></span><br><span class="line">Interface proxy = (Interface)Proxy.newProxyInstance( classLoader, <span class="keyword">new</span> Class[] &#123; Interface.class &#125;, handler );</span><br></pre></td></tr></table></figure>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 映射表：用于维护类装载器对象到其对应的代理类缓存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map loaderToCache = <span class="keyword">new</span> WeakHashMap(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记：用于标记一个动态代理类正在被创建中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Object pendingGenerationMarker = <span class="keyword">new</span> Object(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步表：记录已经被创建的动态代理类类型，主要被方法 isProxyClass 进行相关的判断</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map proxyClasses = Collections.synchronizedMap(<span class="keyword">new</span> WeakHashMap()); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 关联的调用处理器引用</span></span><br><span class="line"><span class="keyword">protected</span> InvocationHandler h;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理类实例化构建参数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Class[] constructorParams =</span><br><span class="line">        &#123; InvocationHandler.class &#125;;</span><br></pre></td></tr></table></figure>
<p>由变量可以猜测，代理的创建过程中是使用了很多的缓存的。</p>
<h3 id="静态构造方法"><a href="#静态构造方法" class="headerlink" title="静态构造方法"></a>静态构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, </span></span></span><br><span class="line"><span class="function"><span class="params">            Class&lt;?&gt;[] interfaces, </span></span></span><br><span class="line"><span class="function"><span class="params">            InvocationHandler h)</span> </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IllegalArgumentException </span>&#123; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查 h 不为空，否则抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (h == <span class="keyword">null</span>) &#123; </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得与制定类装载器和一组接口相关的代理类类型对象</span></span><br><span class="line">    Class cl = getProxyClass(loader, interfaces); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过反射获取构造函数对象并生成代理类实例</span></span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        Constructor cons = cl.getConstructor(constructorParams); </span><br><span class="line">        <span class="keyword">return</span> (Object) cons.newInstance(<span class="keyword">new</span> Object[] &#123; h &#125;); </span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString()); </span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString()); </span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException e) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString()); </span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString()); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法很简单，主要是调用getProxyClass方法获取一个cl，然后通过反射创建出代理类的实例。很明显，核心在于getProxyClass到底做了什么？</p>
<h3 id="getProxyClass方法"><a href="#getProxyClass方法" class="headerlink" title="getProxyClass方法"></a>getProxyClass方法</h3><p>这个方法比较长，分为四个主体部分:</p>
<p>【1】对这组接口进行一定程度的安全检查，包括检查接口类对象是否对类装载器可见并且与类装载器所能识别的接口类对象是完全相同的，还会检查确保是 interface 类型而不是 class 类型。这个步骤通过一个循环来完成，检查通过后将会得到一个包含所有接口名称的字符串数组，记为 String[] interfaceNames。总体上这部分实现比较直观，所以略去大部分代码，仅保留留如何判断某类或接口是否对特定类装载器可见的相关代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    <span class="comment">// 指定接口名字、类装载器对象，同时制定 initializeBoolean 为 false 表示无须初始化类</span></span><br><span class="line">    <span class="comment">// 如果方法返回正常这表示可见，否则会抛出 ClassNotFoundException 异常表示不可见</span></span><br><span class="line">    interfaceClass = Class.forName(interfaceName, <span class="keyword">false</span>, loader); </span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的目的是保证代理类创建的时候，和它所有需要代理的接口都在一个ClassLoader上可见。并且禁止传入类（后面解释），禁止重复传入。</p>
<p>【2】从 loaderToCache 映射表中获取以类装载器对象为关键字所对应的缓存表，如果不存在就创建一个新的缓存表并更新到 loaderToCache。缓存表是一个 HashMap 实例，正常情况下它将存放键值对（接口名字列表，动态生成的代理类的类对象引用）。当代理类正在被创建时它会临时保存（接口名字列表，pendingGenerationMarker）。标记 pendingGenerationMarke (其实是一个对象)的作用是通知后续的同类请求（接口数组相同且组内接口排列顺序也相同）代理类正在被创建，请保持等待直至创建完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 以接口名字列表作为关键字获得对应 cache 值</span></span><br><span class="line">    Object value = cache.get(key); </span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Reference) &#123; </span><br><span class="line">        proxyClass = (Class) ((Reference) value).get(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (proxyClass != <span class="keyword">null</span>) &#123; </span><br><span class="line">        <span class="comment">// 如果已经创建，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> proxyClass; </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value == pendingGenerationMarker) &#123; </span><br><span class="line">        <span class="comment">// 代理类正在被创建，保持等待</span></span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            cache.wait(); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 等待被唤醒，继续循环并通过二次检查以确保创建完成，否则重新等待</span></span><br><span class="line">        <span class="keyword">continue</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// 标记代理类正在被创建</span></span><br><span class="line">        cache.put(key, pendingGenerationMarker); </span><br><span class="line">        <span class="comment">// break 跳出循环已进入创建过程</span></span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<p>【3】动态创建代理类的类对象。首先是确定代理类所在的包，其原则如前所述，如果都为 public 接口，则包名为空字符串表示顶层包；如果所有非 public 接口(package可见)都在同一个包，则包名与这些接口的包名相同；如果有多个非 public 接口且不同包，则抛异常终止代理类的生成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">String proxyPkg = <span class="keyword">null</span>;     <span class="comment">// package to define proxy class in</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Record the package of a non-public proxy interface so that the</span></span><br><span class="line"><span class="comment">	 * proxy class will be defined in the same package.  Verify that</span></span><br><span class="line"><span class="comment">	 * all non-public proxy interfaces are in the same package.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interfaces.length; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> flags = interfaces[i].getModifiers();</span><br><span class="line">		<span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">			String name = interfaces[i].getName();</span><br><span class="line">			<span class="keyword">int</span> n = name.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">			String pkg = ((n == -<span class="number">1</span>) ? <span class="string">""</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span><br><span class="line">			<span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">				proxyPkg = pkg;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"non-public interfaces from different packages"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;     <span class="comment">// if no non-public proxy interfaces,</span></span><br><span class="line">		proxyPkg = <span class="string">""</span>;          <span class="comment">// use the unnamed package</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>确定了包后，就开始生成代理类的类名，同样如前所述按格式“$ProxyN”生成。类名也确定了，接下来就是见证奇迹的发生 —— 动态生成代理类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Choose a name for the proxy class to generate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">long</span> num;</span><br><span class="line"><span class="keyword">synchronized</span> (nextUniqueNumberLock) &#123;</span><br><span class="line">	num = nextUniqueNumber++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Verify that the class loader hasn't already</span></span><br><span class="line"><span class="comment"> * defined a class with the chosen name.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Generate the specified proxy class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	proxyClass = defineClass0(loader, proxyName,</span><br><span class="line">	proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment"> 	 * A ClassFormatError here means that (barring bugs in the</span></span><br><span class="line"><span class="comment"> 	 * proxy class generation code) there was some other</span></span><br><span class="line"><span class="comment"> 	 * invalid aspect of the arguments supplied to the proxy</span></span><br><span class="line"><span class="comment"> 	 * class creation (such as virtual machine limitations</span></span><br><span class="line"><span class="comment"> 	 * exceeded).</span></span><br><span class="line"><span class="comment">  	 */</span></span><br><span class="line"> 	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里通过proxyPkg + proxyClassNamePrefix + num拼接出代理类的名字，一般proxyPkg为空，proxyClassNamePrefix是一个final字符串”$Proxy”，num则是一个递增数字，可以看做是创建的第N个代理类。最后调用ProxyGenerator的generateProxyClass生成代理类的byte[]数组，以一个native方法defineClass0生成最终的代理类class对象。</p>
<p>【4】代码生成过程进入结尾部分，根据结果更新缓存表，如果成功则将代理类的类对象引用更新进缓存表，否则清楚缓存表中对应关键值，最后唤醒所有可能的正在等待的线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We must clean up the "pending generation" state of the proxy</span></span><br><span class="line"><span class="comment"> * class cache entry somehow.  If a proxy class was successfully</span></span><br><span class="line"><span class="comment"> * generated, store it in the cache (with a weak reference);</span></span><br><span class="line"><span class="comment"> * otherwise, remove the reserved entry.  In all cases, notify</span></span><br><span class="line"><span class="comment"> * all waiters on reserved entries in this cache.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">synchronized</span> (cache) &#123;</span><br><span class="line">	<span class="keyword">if</span> (proxyClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">		cache.put(key, <span class="keyword">new</span> WeakReference(proxyClass));</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		cache.remove(key);</span><br><span class="line">	&#125;</span><br><span class="line">	cache.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上四步展现了创建一个代理类的主体，到现在只剩下ProxyGenerator未描述了。<br>在IBM的原博客中说:</p>
<blockquote>
<p>当你尝试去探索这个类时，你所能获得的信息仅仅是它位于并未公开的 sun.misc 包，有若干常量、变量和方法以完成这个神奇的代码生成的过程，但是 sun 并没有提供源代码以供研读。</p>
</blockquote>
<p>但是到我写这篇博客的时候，ProxyGenerator.java已经可以看到了，可以在这里<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b27/sun/misc/ProxyGenerator.java#ProxyGenerator" target="_blank" rel="noopener">下载</a>。</p>
<h2 id="ProxyGenerator类"><a href="#ProxyGenerator类" class="headerlink" title="ProxyGenerator类"></a>ProxyGenerator类</h2><h3 id="generateProxyClass方法"><a href="#generateProxyClass方法" class="headerlink" title="generateProxyClass方法"></a>generateProxyClass方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] generateProxyClass(<span class="keyword">final</span> String name, Class[] interfaces) &#123;</span><br><span class="line">ProxyGenerator gen = <span class="keyword">new</span> ProxyGenerator(name, interfaces);</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span>[] classFile = gen.generateClassFile();</span><br><span class="line"><span class="comment">//...省略，这里是将byte持久化。</span></span><br></pre></td></tr></table></figure>
<p>继续追踪generateClassFile方法。</p>
<h3 id="generateClassFile方法"><a href="#generateClassFile方法" class="headerlink" title="generateClassFile方法"></a>generateClassFile方法</h3><p>从方法名字可以猜出，这个方法用于生成一个Class对象。这个方法也非常长，分为3步。</p>
<p>【1】收集创建Class对象的所有方法，并创建对应的ProxyMethod对象，以便于后面生成代理代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">addProxyMethod(hashCodeMethod, Object.class);</span><br><span class="line">addProxyMethod(equalsMethod, Object.class);</span><br><span class="line">addProxyMethod(toStringMethod, Object.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interfaces.length; i++) &#123;</span><br><span class="line">	Method[] methods = interfaces[i].getMethods();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; methods.length; j++) &#123;</span><br><span class="line">		addProxyMethod(methods[j], interfaces[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) &#123;</span><br><span class="line">	checkReturnTypes(sigmethods);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加了Object的基础方法和接口的所有方法。在添加方法的时候，会生成一个由方法名字+参数作为Key，List<proxymethod>作为值的map，添加完成后会做一次check，即checkReturnTypes。关于这个方法，注释如下：</proxymethod></p>
<blockquote>
<p>For a given set of proxy methods with the same signature, check that their return types are compatible according to the Proxy specification. Specifically, if there is more than one such method, then all of the return types must be reference types, and there must be one return type that is assignable to each of the rest of them.</p>
</blockquote>
<p>【2】收集产生类所需要的所有的MethodInfo和FieldInfo对象<br>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">methods.add(generateConstructor());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) &#123;</span><br><span class="line">	<span class="keyword">for</span> (ProxyMethod pm : sigmethods) &#123;</span><br><span class="line">		<span class="comment">// add static field for method's Method object</span></span><br><span class="line">		fields.add(<span class="keyword">new</span> FieldInfo(pm.methodFieldName,</span><br><span class="line">			<span class="string">"Ljava/lang/reflect/Method;"</span>,</span><br><span class="line">			ACC_PRIVATE | ACC_STATIC));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// generate code for proxy method and add it</span></span><br><span class="line">		methods.add(pm.generateMethod());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以看到，method中嗨添加了构造函数和静态初始化函数。</p>
<p>【3】写入最终的类文件<br>接下去代码的含义是：按照Java类文件编译后的格式，创建一个类出来。我们看一下重点(注意，下面贴的代码在原代码中不是连贯的，为了方便，特意截取几行展示)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** name of the superclass of proxy classes */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String superclassName = <span class="string">"java/lang/reflect/Proxy"</span>;</span><br><span class="line">    </span><br><span class="line">dout.writeInt(<span class="number">0xCAFEBABE</span>);</span><br><span class="line">dout.writeShort(cp.getClass(superclassName));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (MethodInfo m : methods) &#123;</span><br><span class="line">	m.write(dout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写入的第一个内容就是<strong>dout.writeInt(0xCAFEBABE);</strong>，而0xCAFEBABE就是标记 java class 文件的魔数。之后会写入superclassName，而这个类就是java/lang/reflect/Proxy，即Proxy类，所以所有自动生成的代理类都是Proxy的子类，这也就解释了为什么自动生成的代理类不能代理一个具体类，而只能代理一个接口：Java中没有多继承，后面会有更直接的证据。之后就是写入方法。写入方法这一块比较复杂，我们来采取一些特殊措施看看具体生成的文件是什么。接着最前面的使用例子，我们在main函数中写入如下代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Implementation implementation = <span class="keyword">new</span> Implementation();</span><br><span class="line">Class[] interfaces = implementation.getClass().getInterfaces();</span><br><span class="line"><span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(<span class="string">"MethodSelector"</span>, interfaces);</span><br><span class="line">File f = <span class="keyword">new</span> File(<span class="string">"/Users/muzileecoding/Desktop/MethodSelector.class"</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(f);</span><br><span class="line">	fos.write(proxyClassFile);</span><br><span class="line">	fos.flush();</span><br><span class="line">	fos.close();;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行之后就可以在相应的文件夹下面获取到MethodSelector.class文件，将文件反编译（拖入IDE打开即可），下面是完整的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.footprint.reflection.SomeMethods;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodSelector</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">SomeMethods</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m6;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m5;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MethodSelector</span><span class="params">(InvocationHandler var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ((Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;)).booleanValue();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">boring2</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m4, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">boring3</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m6, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">interesting</span><span class="params">(String var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m5, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ((Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>)).intValue();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">boring1</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, <span class="keyword">new</span> Class[]&#123;Class.forName(<span class="string">"java.lang.Object"</span>)&#125;);</span><br><span class="line">            m4 = Class.forName(<span class="string">"com.footprint.reflection.SomeMethods"</span>).getMethod(<span class="string">"boring2"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">            m6 = Class.forName(<span class="string">"com.footprint.reflection.SomeMethods"</span>).getMethod(<span class="string">"boring3"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">            m5 = Class.forName(<span class="string">"com.footprint.reflection.SomeMethods"</span>).getMethod(<span class="string">"interesting"</span>, <span class="keyword">new</span> Class[]&#123;Class.forName(<span class="string">"java.lang.String"</span>)&#125;);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">            m3 = Class.forName(<span class="string">"com.footprint.reflection.SomeMethods"</span>).getMethod(<span class="string">"boring1"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个就是最终写出的java动态代理类：</p>
<ol>
<li>动态生成类的时候生成了一个只需要InvocationHandler实例作为参数的构造函数的，结合前面创建出动态代理文件之后创建动态代理实例的反射代码，这里不难理解；</li>
<li>所有的方法体都变成了<strong>super.h.invoke(this, m4, (Object[])null);</strong>这样的调用，而m4代表着接口中的一个方法，从这里可以知道，实际生成的动态代理类，调用了我们创建代理时传入的InvocationHandler实例，并且将我们的返回结果直接返回，这就是动态代理的本质；</li>
</ol>
<p>至此，我们传入的三个参数如何转化为最终的动态代理类，已经比较清楚了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>动态代理的原理实际上就是：</strong>根据我们要代理的接口，在接口加载的ClassLoader上动态生成一个动态代理类（这个类原来不存在），动态代理类需要我们传入的InvocationHandler作为构造参数，这个代理类中会有所有我们需要代理的接口的方法实现，而这个实现，就是简单的调用我们传入的InvocationHandler的invoke方法。所以如果这样写:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object o, Method method, Object[] objects)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> method.invoke(o, objects);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就会造成循环调用，导致栈溢出。</p>
<p>Proxy.newProxyInstance方法的返回值只能强转为它代理的其中一个接口，原因很简单，因为生成的类签名是这样的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodSelector</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">SomeMethods</span></span></span><br></pre></td></tr></table></figure>
<p>以上两个点要注意一下。</p>
<p>最后，正如 IBM 博客中所说，也如前面分析的，Java自带的动态代理是不能实现代理实体类或者抽象类的，这一点美中不足，这意味着我一旦要代理一个类，就必须抽象出响应的方法。但实际上，应该有随意代理一个类的成熟实现了，因为AOP的实现就依赖于此。So:</p>
<blockquote>
<p>不完美并不等于不伟大，伟大是一种本质，Java 动态代理就是佐例。  </p>
<p>——<a href="https://www.ibm.com/developerworks/cn/java/j-lo-proxy1/" target="_blank" rel="noopener">Java 动态代理机制分析及扩展</a></p>
</blockquote>
</div><div class="tags"><a href="/tags/源码/">源码</a></div><div class="post-nav"><a href="/2015/12/14/Android-adapt-ued-mark-convert/" class="pre">Android适配之UED标注转换</a><a href="/2015/12/05/mars-jiu-yuan/" class="next">观影《火星救援》</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">59</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReactiveX/">ReactiveX</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/后端/">后端</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/影视/">影视</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/电影/">电影</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Gitbook/" style="font-size: 15px;">Gitbook</a> <a href="/tags/Runtime/" style="font-size: 15px;">Runtime</a> <a href="/tags/视图/" style="font-size: 15px;">视图</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/权限/" style="font-size: 15px;">权限</a> <a href="/tags/代码优化/" style="font-size: 15px;">代码优化</a> <a href="/tags/Framework/" style="font-size: 15px;">Framework</a> <a href="/tags/性能优化/" style="font-size: 15px;">性能优化</a> <a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/合集/" style="font-size: 15px;">合集</a> <a href="/tags/ADB/" style="font-size: 15px;">ADB</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/反编译/" style="font-size: 15px;">反编译</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/Gradle/" style="font-size: 15px;">Gradle</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/基础/" style="font-size: 15px;">基础</a> <a href="/tags/效率/" style="font-size: 15px;">效率</a> <a href="/tags/MarkDown/" style="font-size: 15px;">MarkDown</a> <a href="/tags/电影/" style="font-size: 15px;">电影</a> <a href="/tags/Reactive/" style="font-size: 15px;">Reactive</a> <a href="/tags/AIDL/" style="font-size: 15px;">AIDL</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/驱动/" style="font-size: 15px;">驱动</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/日志/" style="font-size: 15px;">日志</a> <a href="/tags/事件/" style="font-size: 15px;">事件</a> <a href="/tags/代码设计/" style="font-size: 15px;">代码设计</a> <a href="/tags/网络/" style="font-size: 15px;">网络</a> <a href="/tags/测试/" style="font-size: 15px;">测试</a> <a href="/tags/Binder/" style="font-size: 15px;">Binder</a> <a href="/tags/Groovy/" style="font-size: 15px;">Groovy</a> <a href="/tags/Loader/" style="font-size: 15px;">Loader</a> <a href="/tags/RAC/" style="font-size: 15px;">RAC</a> <a href="/tags/事件处理/" style="font-size: 15px;">事件处理</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/10/30/AIDL-原理分析/">AIDL 原理分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/30/App-启动过程/">App 启动过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/PMS-解析/">PMS 解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/WMS-解析/">WindowManagerService 解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/29/AMS-解析/">AMS 解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/10/The-Good-Wife/">The-Good-Wife</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/10/Black-Sails/">黑帆</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/29/hello-world/">Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/23/XCode-8-2-1-ClangFormat-插件安装/">XCode 8.2.1 ClangFormat 插件安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/07/SourceTree-分支图谱/">SourceTree 分支图谱</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">蜗牛壳.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>